{"version":3,"sources":["main.min.js","wst.js","d3.cloud.js","toggle.js","carousel.js","faq.js","image-carousel.js","message-count.js","visualizations.js","word-cloud.js","main.js"],"names":["isLocalhost","Boolean","window","location","hostname","match","navigator","protocol","serviceWorker","register","then","registration","onupdatefound","controller","installingWorker","installing","onstatechange","state","Error","e","console","error","_typeof","Symbol","iterator","obj","constructor","prototype","cloud","place","board","tag","bounds","dxdy","dx","dy","startX","x","y","size","startY","maxDelta","Math","sqrt","s","spiral","dt","random","t","min","x0","y0","x1","y1","cloudCollide","collideRects","last","sprite","w","width","sw","lx","sx","msx","h","j","i","text","cloudText","font","cloudFont","fontSize","cloudFontSize","fontStyle","cloudFontNormal","fontWeight","rotate","cloudRotate","padding","cloudPadding","archimedeanSpiral","words","timeInterval","Infinity","event","d3","dispatch","timer","start","step","d","Date","n","data","cloudSprite","hasText","tags","push","word","cloudBounds","stop","end","zeroArray","length","map","call","this","style","weight","sort","a","b","clearInterval","setInterval","arguments","functor","spirals","rebind","value","di","c","clearRect","cw","ratio","ch","maxh","save","measureText","sr","sin","cloudRadians","cr","cos","wcr","wsr","hcr","hsr","max","abs","translate","fillText","lineWidth","strokeText","restore","height","xoff","yoff","pixels","getImageData","w32","seen","seenRow","k","m","slice","b0","b1","rectangularSpiral","sign","canvas","PI","document","createElement","getContext","Canvas","archimedean","rectangular","fillStyle","strokeStyle","textAlign","module","exports","layout","toggle","NodeList","forEach","display","hide","show","_typeof2","f","define","amd","g","global","self","Carousel","r","o","u","require","code","l","1","process","__filename","amdefine","requireFn","trimDots","ary","part","splice","normalize","name","baseName","baseParts","charAt","split","concat","join","makeNormalize","relName","makeLoad","id","load","loaderCache","fromText","runFactory","deps","factory","result","uri","makeRequire","alreadyCalled","depName","apply","undefined","Array","isArray","defineCache","stringRequire","path","systemRequire","relId","amdRequire","callback","nextTick","toUrl","filePath","indexOf","dirname","filename","prefix","plugin","index","originalId","hasOwnProperty","substring","_process","2","throwFirstError","pendingErrors","shift","asap","task","rawTask","freeTasks","pop","RawTask","rawAsap","requestErrorThrow","makeRequestCallFromTimer","onerror","./raw","3","queue","requestFlush","flushing","flush","currentIndex","capacity","scan","newLength","makeRequestCallFromMutationObserver","observer","BrowserMutationObserver","node","createTextNode","observe","characterData","handleTimer","clearTimeout","timeoutHandle","intervalHandle","setTimeout","scope","MutationObserver","WebKitMutationObserver","4","ES6Promise","objectOrFunction","isFunction","setScheduler","scheduleFn","customSchedulerFn","setAsap","asapFn","useNextTick","useVertxTimer","vertxNext","useSetTimeout","useMutationObserver","iterations","useMessageChannel","channel","MessageChannel","port1","onmessage","port2","postMessage","globalSetTimeout","len","arg","attemptVertx","vertx","runOnLoop","runOnContext","onFulfillment","onRejection","_arguments","parent","child","noop","PROMISE_ID","makePromise","_state","invokeCallback","_result","subscribe","resolve","object","Constructor","promise","_resolve","selfFulfillment","TypeError","cannotReturnOwn","getThen","GET_THEN_ERROR","tryThen","fulfillmentHandler","rejectionHandler","handleForeignThenable","thenable","sealed","fulfill","reason","_reject","_label","handleOwnThenable","FULFILLED","REJECTED","handleMaybeThenable","maybeThenable","then$$","publishRejection","_onerror","publish","PENDING","_subscribers","subscribers","settled","detail","ErrorObject","tryCatch","TRY_CATCH_ERROR","hasCallback","succeeded","failed","initializePromise","resolver","nextId","Enumerator","input","_instanceConstructor","_input","_remaining","_enumerate","validationError","all","entries","race","reject","_","needsResolver","needsNew","Promise","polyfill","local","Function","P","promiseToString","Object","toString","cast","_isArray","scheduleFlush","browserWindow","browserGlobal","isNode","isWorker","Uint8ClampedArray","importScripts","_eachEntry","entry","resolve$$","_then","_settledAt","_willSettleAt","enumerator","_setScheduler","_setAsap","_asap","catch","5","_interopRequireDefault","__esModule","default","create","hb","_create","compile","options","_handlebarsCompilerCompiler","precompile","AST","_handlebarsCompilerAst2","Compiler","JavaScriptCompiler","_handlebarsCompilerJavascriptCompiler2","Parser","_handlebarsCompilerBase","parser","parse","_handlebarsRuntime","_handlebarsRuntime2","_handlebarsCompilerAst","_handlebarsCompilerJavascriptCompiler","_handlebarsCompilerVisitor","_handlebarsCompilerVisitor2","_handlebarsNoConflict","_handlebarsNoConflict2","inst","Visitor","./handlebars.runtime","./handlebars/compiler/ast","./handlebars/compiler/base","./handlebars/compiler/compiler","./handlebars/compiler/javascript-compiler","./handlebars/compiler/visitor","./handlebars/no-conflict","6","_interopRequireWildcard","newObj","key","base","HandlebarsEnvironment","Utils","extend","SafeString","_handlebarsSafeString2","Exception","_handlebarsException2","escapeExpression","VM","runtime","template","spec","_handlebarsBase","_handlebarsSafeString","_handlebarsException","_handlebarsUtils","./handlebars/base","./handlebars/exception","./handlebars/runtime","./handlebars/safe-string","./handlebars/utils","7","helpers","partials","decorators","_helpers","registerDefaultHelpers","_decorators","registerDefaultDecorators","_utils","_exception","_exception2","_logger","_logger2","VERSION","COMPILER_REVISION","REVISION_CHANGES","objectType","logger","log","registerHelper","fn","unregisterHelper","registerPartial","partial","unregisterPartial","registerDecorator","unregisterDecorator","createFrame","./decorators","./exception","./helpers","./logger","./utils","8","helperExpression","type","params","hash","scopedId","test","original","simpleId","parts","depth","9","_parser2","yy","locInfo","SourceLocation","srcName","strip","_whitespaceControl2","accept","_parser","_whitespaceControl","Helpers","../utils","./parser","./whitespace-control","10","castChunk","chunk","codeGen","loc","ret","wrap","CodeGen","srcFile","source","SourceNode","SourceMap","err","line","column","chunks","src","add","prepend","toStringWithSourceMap","isEmpty","unshift","merge","empty","each","iter","currentLocation","functionCall","generateList","quotedString","str","replace","objectLiteral","pairs","generateArray","source-map","11","env","compat","useDepths","ast","environment","compileInput","templateSpec","context","execOptions","compiled","_setup","setupOptions","_child","blockParams","depths","argEquals","transformLiteralToPath","sexpr","literal","_ast","_ast2","compiler","equals","other","opcodes","opcode","otherOpcode","args","children","guid","program","sourceNode","stringParams","trackIds","knownHelpers","helperMissing","blockHelperMissing","if","unless","with","lookup","_name","compileProgram","childCompiler","usePartial","Program","body","bodyLength","isSimple","BlockStatement","block","inverse","classifySexpr","helperSexpr","simpleSexpr","ambiguousSexpr","DecoratorBlock","decorator","setupFullMustacheParams","useDecorators","PartialStatement","explicitPartialContext","partialName","isDynamic","indent","preventIndent","PartialBlockStatement","partialBlock","MustacheStatement","mustache","SubExpression","escaped","noEscape","Decorator","ContentStatement","content","CommentStatement","isBlock","strict","knownHelpersOnly","falsy","PathExpression","addDepth","scoped","blockParamId","blockParamIndex","StringLiteral","string","NumberLiteral","number","BooleanLiteral","bool","UndefinedLiteral","NullLiteral","Hash","pushParam","isBlockParam","isHelper","isEligible","_name2","pushParams","val","blockParamChild","omitEmpty","param","../exception","./ast","12","validateClose","open","close","errorNode","first_line","first_column","last_line","last_column","token","substr","stripFlags","stripComment","comment","preparePath","dig","depthString","isLiteral","separator","prepareMustache","escapeFlag","prepareRawBlock","openRawBlock","contents","openStrip","inverseStrip","closeStrip","prepareBlock","openBlock","inverseAndProgram","inverted","chain","prepareProgram","statements","firstLoc","lastLoc","preparePartialBlock","13","Literal","strictLookup","requireTerminal","stack","popStack","nameLookup","aliasable","_base","_codeGen","_codeGen2","isValidJavaScriptVariableName","JSON","stringify","depthedLookup","compilerInfo","revision","versions","appendToBuffer","explicit","initializeBuffer","asObject","isChild","programs","environments","preamble","stackSlot","stackVars","aliases","registers","list","hashes","compileStack","inlineStack","compileChildren","useBlockParams","pushSource","createFunctionContext","main","main_d","_context","useData","compilerOptions","file","destName","lastContext","varDeclarations","locals","aliasCount","alias","referenceCount","mergeSource","appendOnly","forceBuffer","appendFirst","sourceSeen","bufferStart","bufferEnd","blockValue","contextName","setupHelperArgs","blockName","ambiguousBlockValue","flushInline","current","topStack","lastHelper","appendContent","pendingContent","pendingLocation","append","isInline","replaceStack","appendEscaped","pushContext","pushStackLiteral","lookupOnContext","resolvePath","lookupBlockParam","lookupData","_this","assumeObjects","resolvePossibleLambda","pushStringParam","pushString","emptyHash","pushHash","values","types","contexts","ids","popHash","pushLiteral","pushProgram","programExpression","paramSize","foundDecorator","invokeHelper","nonHelper","helper","setupHelper","simple","callParams","invokeKnownHelper","invokeAmbiguous","helperCall","useRegister","helperName","paramsInit","invokePartial","setupParams","assignToHash","pushId","existing","matchExistingProgram","programParams","expr","item","createdStack","usedLiteral","top","incrStack","topStackName","wrapped","inline","blockHelper","foundHelper","callContext","objectArgs","hashIds","hashTypes","hashContexts","reservedWords","compilerWords","RESERVED_WORDS","../base","./code-gen","14","handlebars","trace","symbols_","root","EOF","program_repetition0","statement","rawBlock","COMMENT","CONTENT","rawBlock_repetition_plus0","END_RAW_BLOCK","OPEN_RAW_BLOCK","openRawBlock_repetition0","openRawBlock_option0","CLOSE_RAW_BLOCK","block_option0","closeBlock","openInverse","block_option1","OPEN_BLOCK","openBlock_repetition0","openBlock_option0","openBlock_option1","CLOSE","OPEN_INVERSE","openInverse_repetition0","openInverse_option0","openInverse_option1","openInverseChain","OPEN_INVERSE_CHAIN","openInverseChain_repetition0","openInverseChain_option0","openInverseChain_option1","INVERSE","inverseChain","inverseChain_option0","OPEN_ENDBLOCK","OPEN","mustache_repetition0","mustache_option0","OPEN_UNESCAPED","mustache_repetition1","mustache_option1","CLOSE_UNESCAPED","OPEN_PARTIAL","partial_repetition0","partial_option0","openPartialBlock","OPEN_PARTIAL_BLOCK","openPartialBlock_repetition0","openPartialBlock_option0","OPEN_SEXPR","sexpr_repetition0","sexpr_option0","CLOSE_SEXPR","hash_repetition_plus0","hashSegment","ID","EQUALS","OPEN_BLOCK_PARAMS","blockParams_repetition_plus0","CLOSE_BLOCK_PARAMS","dataName","STRING","NUMBER","BOOLEAN","UNDEFINED","NULL","DATA","pathSegments","SEP","$accept","$end","terminals_","15","18","19","23","29","33","34","39","44","47","48","51","54","55","60","65","68","72","73","75","77","80","81","82","83","84","85","87","productions_","performAction","yytext","yyleng","yylineno","yystate","$$","_$","$0","$","chained","Number","table","16","24","27","59","20","78","79","86","17","56","64","49","52","25","38","43","45","28","57","26","30","35","21","61","50","63","69","70","71","53","58","66","31","36","22","62","46","40","67","32","74","37","41","76","42","defaultActions","91","102","105","111","112","117","120","123","124","136","137","parseError","lex","lexer","vstack","lstack","recovering","setInput","yylloc","yyloc","ranges","symbol","preErrorSymbol","action","p","newState","expected","yyval","errStr","showPosition","range","_more","_less","done","matched","conditionStack","offset","lines","unput","oldLines","more","less","pastInput","past","upcomingInput","next","pre","tempMatch","rules","_currentRules","flex","matches","begin","condition","popState","conditions","topState","pushState","yy_","$avoiding_name_collisions","YY_START","mu","inclusive","emu","com","raw","INITIAL","print","PrintVisitor","_visitor","_visitor2","pad","out","paramStrings","joinedPairs","HashPair","pair","./visitor","parents","visitSubExpression","acceptRequired","acceptArray","acceptKey","visitBlock","visitPartial","mutating","array","WhitespaceControl","isPrevWhitespace","isRoot","prev","sibling","isNextWhitespace","omitRight","multiple","rightStripped","omitLeft","leftStripped","doStandalone","ignoreStandalone","isRootSeen","_isPrevWhitespace","_isNextWhitespace","openStandalone","closeStandalone","inlineStandalone","exec","firstInverse","lastInverse","instance","_decoratorsInline2","_decoratorsInline","./decorators/inline","props","container","message","tmp","idx","errorProps","captureStackTrace","lineNumber","defineProperty","nop","_helpersBlockHelperMissing2","_helpersEach2","_helpersHelperMissing2","_helpersIf2","_helpersLog2","_helpersLookup2","_helpersWith2","_helpersBlockHelperMissing","_helpersEach","_helpersHelperMissing","_helpersIf","_helpersLog","_helpersLookup","_helpersWith","./helpers/block-helper-missing","./helpers/each","./helpers/helper-missing","./helpers/if","./helpers/log","./helpers/lookup","./helpers/with","contextPath","appendContextPath","execIteration","field","first","priorKey","conditional","includeZero","level","methodMap","lookupLevel","levelMap","toLowerCase","parseInt","method","_len","_key","Handlebars","$Handlebars","noConflict","checkRevision","compilerRevision","currentRevision","runtimeVersions","compilerVersions","invokePartialWrapper","resolvePartial","initData","executeDecorators","lambda","declaredBlockParams","programWrapper","wrapProgram","_parent","common","isTop","prog","currentDepths","./base","toHTML","escapeChar","chr","escape","possible","badChars","frame","&","<",">","\"","'","`","=","extension","fs","templateString","readFileSync","printer","extensions","../dist/cjs/handlebars","../dist/cjs/handlebars/compiler/printer","./dist/cjs/handlebars.runtime","_classCallCheck","_createClass","defineProperties","target","descriptor","enumerable","configurable","writable","protoProps","staticProps","ensurePathArray","paths","ResourceManager","_head","getElementsByTagName","_cssPaths","_scriptMaps","_dataPromises","script","loadPromises","createScriptElement","setAttribute","addEventListener","appendChild","bind","querySelectorAll","removeChild","url","reqOptions","cacheId","cache","fetch","el","hbsData","isHandlebarFile","frags","ext","resp","innerHTML","unloadCss","getOwnPropertyNames","unloadScript","es6-promise","whatwg-fetch","_resourceManagerJs","_resourceManagerJs2","getCssPropUnitMap","v","trim","num","unit","convertCssTimeValueToMilliseconds","getJsPropName","cssProp","letter","toUpperCase","traverseEachParent","startEl","parentNode","predicate","className","Module","defaultOptions","loadedClass","activeClass","disabledClass","errorClass","styles","requestOptions","onLoad","onShow","onHide","onEnable","onDisable","onError","_handleElementInitialState","subModules","active","loaded","_elChildren","loadStatus","view","getStyles","fetchData","getTemplate","nodes","frag","createDocumentFragment","classList","cssUrl","loadCss","_isHTMLTemplate","tpl","importNode","childNodes","HTMLElement","_ret","tempDiv","loadTemplate","html","HTMLTemplateElement","errored","waitForTransition","remove","disabled","contains","_origDisabled","disable","_origError","_this2","duration","getTransitionDuration","delayProp","getCssComputedProperty","durationProp","times","delay","highest","prop","getComputedStyle","getPropertyValue","startTarget","_this3","destroy","_resetElementInitialState","handlebars/runtime","resource-manager-js","./lib","ex","LAST_ERROR","IS_ERROR","tryCallOne","tryCallTwo","_45","_81","_65","_54","doResolve","safeThen","onFulfilled","onRejected","res","handle","Handler","deferred","_10","handleResolved","cb","newValue","finale","_97","_61","asap/raw","./core.js","valuePromise","TRUE","FALSE","ZERO","EMPTYSTRING","arr","remaining","./done.js","./es6-extensions.js","./finally.js","./node-extensions.js","./synchronous.js","denodeifyWithCount","argumentCount","callbackFn","denodeifyWithoutCount","fnLength","denodeify","nodeify","ctx","enableSynchronous","isPending","getState","isFulfilled","isRejected","getValue","getReason","disableSynchronous","SourceMapGenerator","SourceMapConsumer","./source-map/source-map-consumer","./source-map/source-map-generator","./source-map/source-node","ArraySet","_array","_set","util","fromArray","aArray","aAllowDuplicates","set","aStr","isDuplicate","has","toSetString","at","aIdx","toArray","./util","toVLQSigned","aValue","fromVLQSigned","isNegative","shifted","base64","VLQ_BASE_SHIFT","VLQ_BASE","VLQ_BASE_MASK","VLQ_CONTINUATION_BIT","encode","digit","encoded","vlq","decode","aIndex","aOutParam","continuation","strLen","charCodeAt","rest","./base64","intToCharMap","aNumber","charCode","bigA","bigZ","littleA","littleZ","zero","nine","plus","slash","littleOffset","numberOffset","recursiveSearch","aLow","aHigh","aNeedle","aHaystack","aCompare","aBias","mid","floor","cmp","LEAST_UPPER_BOUND","GREATEST_LOWER_BOUND","search","generatedPositionAfter","mappingA","mappingB","lineA","generatedLine","lineB","columnA","generatedColumn","columnB","compareByGeneratedPositionsInflated","MappingList","_sorted","_last","unsortedForEach","aCallback","aThisArg","aMapping","swap","temp","randomIntInRange","low","high","round","doQuickSort","comparator","pivotIndex","pivot","q","quickSort","aSourceMap","sourceMap","sections","IndexedSourceMapConsumer","BasicSourceMapConsumer","version","getArg","sources","names","sourceRoot","sourcesContent","mappings","_version","_names","_sources","_mappings","Mapping","originalLine","originalColumn","lastOffset","_sections","offsetLine","offsetColumn","generatedOffset","consumer","binarySearch","base64VLQ","fromSourceMap","__generatedMappings","get","_parseMappings","__originalMappings","_charIsMappingSeparator","aSourceRoot","GENERATED_ORDER","ORIGINAL_ORDER","eachMapping","aContext","aOrder","order","_generatedMappings","_originalMappings","mapping","allGeneratedPositionsFor","aArgs","needle","relative","_findMapping","compareByOriginalPositions","lastColumn","smc","_sourceRoot","_generateSourcesContent","_file","generatedMappings","destGeneratedMappings","destOriginalMappings","srcMapping","destMapping","segment","previousGeneratedColumn","previousOriginalLine","previousOriginalColumn","previousSource","previousName","cachedSegments","originalMappings","compareByGeneratedPositionsDeflated","aMappings","aLineName","aColumnName","aComparator","computeColumnSpans","nextMapping","lastGeneratedColumn","originalPositionFor","hasContentsOfAllSources","some","sc","sourceContentFor","aSource","nullOnMissing","urlParse","fileUriAbsPath","scheme","generatedPositionFor","sectionIndex","section","bias","every","generatedPosition","sectionMappings","adjustedMapping","./array-set","./base64-vlq","./binary-search","./quick-sort","_skipValidation","_sourcesContents","aSourceMapConsumer","generator","newMapping","generated","addMapping","sourceFile","setSourceContent","_validateMapping","aSourceFile","aSourceContent","keys","applySourceMap","aSourceMapPath","newSources","newNames","aGenerated","aOriginal","aName","_serializeMappings","previousGeneratedLine","aSources","toJSON","./mapping-list","aLine","aColumn","aChunks","sourceContents","isSourceNode","REGEX_NEWLINE","NEWLINE_CODE","fromStringWithSourceMap","aGeneratedCode","aRelativePath","addMappingWithCode","remainingLines","shiftNextLine","lineContents","newLine","lastGeneratedLine","lastMapping","nextLine","aChunk","walk","aFn","aSep","newChildren","replaceRight","aPattern","aReplacement","lastChild","walkSourceContents","fromSetString","sourceMappingActive","lastOriginalSource","lastOriginalLine","lastOriginalColumn","lastOriginalName","sourceContent","./source-map-generator","aDefaultValue","aUrl","urlRegexp","auth","host","port","urlGenerate","aParsedUrl","aPath","isAbsolute","up","aRoot","aPathUrl","aRootUrl","dataUrlRegexp","joined","lastIndexOf","onlyCompareOriginal","onlyCompareGenerated","strcmp","aStr1","aStr2","normalizeName","String","normalizeValue","iteratorFor","items","support","iterable","Headers","headers","consumed","bodyUsed","fileReaderReady","reader","onload","readBlobAsArrayBuffer","blob","FileReader","readAsArrayBuffer","readBlobAsText","readAsText","readArrayBufferAsText","buf","Uint8Array","chars","fromCharCode","bufferClone","byteLength","buffer","Body","_initBody","_bodyInit","_bodyText","Blob","isPrototypeOf","_bodyBlob","formData","FormData","_bodyFormData","searchParams","URLSearchParams","arrayBuffer","isDataView","_bodyArrayBuffer","ArrayBuffer","isArrayBufferView","rejected","json","normalizeMethod","upcased","methods","Request","credentials","mode","referrer","form","bytes","decodeURIComponent","parseHeaders","rawHeaders","Response","bodyInit","status","ok","statusText","viewClasses","DataView","isView","getAll","thisArg","clone","response","redirectStatuses","redirect","RangeError","init","request","xhr","XMLHttpRequest","getAllResponseHeaders","responseURL","responseText","ontimeout","withCredentials","responseType","setRequestHeader","send","_extends","assign","CarouselArrows","leftArrow","rightArrow","panels","arrowDisabledClass","onLeftArrowClick","onRightArrowClick","initialIndex","arrows","_leftArrowEventListener","_rightArrowEventListener","panelIndex","currentItemNum","maxItems","minItems","enable","disableRightArrow","enableLeftArrow","disableLeftArrow","enableRightArrow","isDisabled","removeEventListener","_possibleConstructorReturn","ReferenceError","_inherits","subClass","superClass","setPrototypeOf","__proto__","_get","property","receiver","desc","getOwnPropertyDescriptor","getPrototypeOf","getter","_promise","_promise2","_moduleJs","_moduleJs2","CarouselPanel","_Module","lazyLoadAttr","assetLoadedClass","_loadableImages","imgEl","_loadImage","tagName","getAttribute","img","module-js","_carouselPanel","_carouselPanel2","CarouselPanels","panelActiveClass","panelLoadedClass","onChange","panelBackClass","panelForwardClass","_panelModules","_setupPanelModules","panel","modules","errorMsg","maxIndex","minIndex","prevIndex","getCurrentIndex","_updatePanels","_currentIndex","toIndex","fromIndex","fromPanel","toPanel","rangePanels","toAdd","toRemove","panelModule","./carousel-panel","CarouselThumbs","thumbnails","thumbnailActiveTriggerEvent","thumbnailActiveClass","_thumbnailEventListener","onThumbnailEvent","setup","thumbs","triggerThumbsEventListener","_thumbnailArr","currentTarget","goTo","thumbnailCount","count","_carouselThumbs","_carouselThumbs2","_carouselPanels","_carouselPanels2","_carouselArrows","_carouselArrows2","assetLoadingClass","autoLoadAssets","onPanelChange","arrowActiveClass","_checkForInitErrors","_setupPanels","_setupThumbs","_setupArrows","onThumbnailChange","internalOptions","panelCount","warn","update","./carousel-arrows","./carousel-panels","./carousel-thumbs","normalizeArray","allowAboveRoot","filter","xs","splitPathRe","splitPath","resolvedPath","resolvedAbsolute","cwd","trailingSlash","from","to","fromParts","toParts","samePartsLength","outputParts","sep","delimiter","dir","basename","extname","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","cleanUpNextTick","draining","currentQueue","queueIndex","drainQueue","timeout","run","Item","title","browser","argv","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","chdir","umask","renderFAQ","bootstrapTemplate","domNode","addQuestion","question","answer","appendTo","_thisQuestion","_question","cloneNode","_destination","getElementsByClassName","_section","_subsection","sectionTitle","faq","_thisSection","image","_thisDestination","subsectionTitle","questions","subsection","_thisSubsection","bindFAQ","select","allElements","cursor","stopPropagation","renderCarousel","fail","incrementValue","intVal","difference","currentVal","ceil","updateDisplay","messageDiv","MESSAGE_URL","getElementById","getMessageCount","loadDashboard","reload","DASHBOARD_URL","reflowDashboard","adjustHeight","viz","offsetWidth","getQuotes","quotes","initializeD3","svg","attr","cloudHeight","setSVGWidth","wordCloudDiv","skipRedraw","cloudWidth","doViz","lastWords","selectAll","vis","maxscale","scale","linear","domain","sizeScale","draw","enter","quoteDiv","CLOUD_HEIGHT","bootstrapWordCloud","issue","attachHamburger","element","scrollToTop","scrollTo","preventDefault","resizeTimer","outerWidth","newEvent","Event","originalEvent","dispatchEvent"],"mappings":"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","file":"main.min.js","sourcesContent":["'use strict'; /*\n               *\n               *  Web Starter Kit\n               *  Copyright 2015 Google Inc. All rights reserved.\n               *\n               *  Licensed under the Apache License, Version 2.0 (the \"License\");\n               *  you may not use this file except in compliance with the License.\n               *  You may obtain a copy of the License at\n               *\n               *    https://www.apache.org/licenses/LICENSE-2.0\n               *\n               *  Unless required by applicable law or agreed to in writing, software\n               *  distributed under the License is distributed on an \"AS IS\" BASIS,\n               *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n               *  See the License for the specific language governing permissions and\n               *  limitations under the License\n               *\n               */\n\n(function () {\n  'use strict';\n\n  // Check to make sure service workers are supported in the current browser,\n  // and that the current page is accessed from a secure origin. Using a\n  // service worker from an insecure origin will trigger JS console errors. See\n  // http://www.chromium.org/Home/chromium-security/prefer-secure-origins-for-powerful-new-features\n  var isLocalhost = Boolean(window.location.hostname === 'localhost' ||\n  // [::1] is the IPv6 localhost address.\n  window.location.hostname === '[::1]' ||\n  // 127.0.0.1/8 is considered localhost for IPv4.\n  window.location.hostname.match(\n  /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));\n\n\n\n  if ('serviceWorker' in navigator && (\n  window.location.protocol === 'https:' || isLocalhost)) {\n    navigator.serviceWorker.register('service-worker.js').\n    then(function (registration) {\n      // updatefound is fired if service-worker.js changes.\n      registration.onupdatefound = function () {\n        // updatefound is also fired the very first time the SW is installed,\n        // and there's no need to prompt for a reload at that point.\n        // So check here to see if the page is already controlled,\n        // i.e. whether there's an existing service worker.\n        if (navigator.serviceWorker.controller) {(function () {\n            // The updatefound event implies that registration.installing is set:\n            // https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#service-worker-container-updatefound-event\n            var installingWorker = registration.installing;\n\n            installingWorker.onstatechange = function () {\n              switch (installingWorker.state) {\n                case 'installed':\n                  // At this point, the old content will have been purged and the\n                  // fresh content will have been added to the cache.\n                  // It's the perfect time to display a \"New content is\n                  // available; please refresh.\" message in the page's interface.\n                  break;\n\n                case 'redundant':\n                  throw new Error('The installing ' +\n                  'service worker became redundant.');\n\n                default:\n                // Ignore\n              }\n            };})();\n        }\n      };\n    }).catch(function (e) {\n      console.error('Error during service worker registration:', e);\n    });\n  }\n\n  // Your custom JavaScript goes here\n})();\n//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndzdC5qcyJdLCJuYW1lcyI6WyJpc0xvY2FsaG9zdCIsIkJvb2xlYW4iLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhvc3RuYW1lIiwibWF0Y2giLCJuYXZpZ2F0b3IiLCJwcm90b2NvbCIsInNlcnZpY2VXb3JrZXIiLCJyZWdpc3RlciIsInRoZW4iLCJyZWdpc3RyYXRpb24iLCJvbnVwZGF0ZWZvdW5kIiwiY29udHJvbGxlciIsImluc3RhbGxpbmdXb3JrZXIiLCJpbnN0YWxsaW5nIiwib25zdGF0ZWNoYW5nZSIsInN0YXRlIiwiRXJyb3IiLCJjYXRjaCIsImUiLCJjb25zb2xlIiwiZXJyb3IiXSwibWFwcGluZ3MiOiJjQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBLENBQUMsWUFBVztBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUEsY0FBY0MsUUFBUUMsT0FBT0MsUUFBUCxDQUFnQkMsUUFBaEIsS0FBNkIsV0FBN0I7QUFDeEI7QUFDQUYsU0FBT0MsUUFBUCxDQUFnQkMsUUFBaEIsS0FBNkIsT0FGTDtBQUd4QjtBQUNBRixTQUFPQyxRQUFQLENBQWdCQyxRQUFoQixDQUF5QkMsS0FBekI7QUFDRSwwREFERixDQUpnQixDQUFwQjs7OztBQVNBLE1BQUksbUJBQW1CQyxTQUFuQjtBQUNDSixTQUFPQyxRQUFQLENBQWdCSSxRQUFoQixLQUE2QixRQUE3QixJQUF5Q1AsV0FEMUMsQ0FBSixFQUM0RDtBQUMxRE0sY0FBVUUsYUFBVixDQUF3QkMsUUFBeEIsQ0FBaUMsbUJBQWpDO0FBQ0NDLFFBREQsQ0FDTSxVQUFTQyxZQUFULEVBQXVCO0FBQzNCO0FBQ0FBLG1CQUFhQyxhQUFiLEdBQTZCLFlBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJTixVQUFVRSxhQUFWLENBQXdCSyxVQUE1QixFQUF3QztBQUN0QztBQUNBO0FBQ0EsZ0JBQU1DLG1CQUFtQkgsYUFBYUksVUFBdEM7O0FBRUFELDZCQUFpQkUsYUFBakIsR0FBaUMsWUFBVztBQUMxQyxzQkFBUUYsaUJBQWlCRyxLQUF6QjtBQUNFLHFCQUFLLFdBQUw7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVGLHFCQUFLLFdBQUw7QUFDRSx3QkFBTSxJQUFJQyxLQUFKLENBQVU7QUFDQSxvREFEVixDQUFOOztBQUdGO0FBQ0U7QUFiSjtBQWVELGFBaEJELENBTHNDO0FBc0J2QztBQUNGLE9BNUJEO0FBNkJELEtBaENELEVBZ0NHQyxLQWhDSCxDQWdDUyxVQUFTQyxDQUFULEVBQVk7QUFDbkJDLGNBQVFDLEtBQVIsQ0FBYywyQ0FBZCxFQUEyREYsQ0FBM0Q7QUFDRCxLQWxDRDtBQW1DRDs7QUFFRDtBQUNELENBeEREIiwiZmlsZSI6IndzdC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKlxuICogIFdlYiBTdGFydGVyIEtpdFxuICogIENvcHlyaWdodCAyMDE1IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2VcbiAqXG4gKi9cblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQ2hlY2sgdG8gbWFrZSBzdXJlIHNlcnZpY2Ugd29ya2VycyBhcmUgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGJyb3dzZXIsXG4gIC8vIGFuZCB0aGF0IHRoZSBjdXJyZW50IHBhZ2UgaXMgYWNjZXNzZWQgZnJvbSBhIHNlY3VyZSBvcmlnaW4uIFVzaW5nIGFcbiAgLy8gc2VydmljZSB3b3JrZXIgZnJvbSBhbiBpbnNlY3VyZSBvcmlnaW4gd2lsbCB0cmlnZ2VyIEpTIGNvbnNvbGUgZXJyb3JzLiBTZWVcbiAgLy8gaHR0cDovL3d3dy5jaHJvbWl1bS5vcmcvSG9tZS9jaHJvbWl1bS1zZWN1cml0eS9wcmVmZXItc2VjdXJlLW9yaWdpbnMtZm9yLXBvd2VyZnVsLW5ldy1mZWF0dXJlc1xuICBjb25zdCBpc0xvY2FsaG9zdCA9IEJvb2xlYW4od2luZG93LmxvY2F0aW9uLmhvc3RuYW1lID09PSAnbG9jYWxob3N0JyB8fFxuICAgICAgLy8gWzo6MV0gaXMgdGhlIElQdjYgbG9jYWxob3N0IGFkZHJlc3MuXG4gICAgICB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgPT09ICdbOjoxXScgfHxcbiAgICAgIC8vIDEyNy4wLjAuMS84IGlzIGNvbnNpZGVyZWQgbG9jYWxob3N0IGZvciBJUHY0LlxuICAgICAgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lLm1hdGNoKFxuICAgICAgICAvXjEyNyg/OlxcLig/OjI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPykpezN9JC9cbiAgICAgIClcbiAgICApO1xuXG4gIGlmICgnc2VydmljZVdvcmtlcicgaW4gbmF2aWdhdG9yICYmXG4gICAgICAod2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHM6JyB8fCBpc0xvY2FsaG9zdCkpIHtcbiAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5yZWdpc3Rlcignc2VydmljZS13b3JrZXIuanMnKVxuICAgIC50aGVuKGZ1bmN0aW9uKHJlZ2lzdHJhdGlvbikge1xuICAgICAgLy8gdXBkYXRlZm91bmQgaXMgZmlyZWQgaWYgc2VydmljZS13b3JrZXIuanMgY2hhbmdlcy5cbiAgICAgIHJlZ2lzdHJhdGlvbi5vbnVwZGF0ZWZvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHVwZGF0ZWZvdW5kIGlzIGFsc28gZmlyZWQgdGhlIHZlcnkgZmlyc3QgdGltZSB0aGUgU1cgaXMgaW5zdGFsbGVkLFxuICAgICAgICAvLyBhbmQgdGhlcmUncyBubyBuZWVkIHRvIHByb21wdCBmb3IgYSByZWxvYWQgYXQgdGhhdCBwb2ludC5cbiAgICAgICAgLy8gU28gY2hlY2sgaGVyZSB0byBzZWUgaWYgdGhlIHBhZ2UgaXMgYWxyZWFkeSBjb250cm9sbGVkLFxuICAgICAgICAvLyBpLmUuIHdoZXRoZXIgdGhlcmUncyBhbiBleGlzdGluZyBzZXJ2aWNlIHdvcmtlci5cbiAgICAgICAgaWYgKG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAvLyBUaGUgdXBkYXRlZm91bmQgZXZlbnQgaW1wbGllcyB0aGF0IHJlZ2lzdHJhdGlvbi5pbnN0YWxsaW5nIGlzIHNldDpcbiAgICAgICAgICAvLyBodHRwczovL3NsaWdodGx5b2ZmLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyL3NwZWMvc2VydmljZV93b3JrZXIvaW5kZXguaHRtbCNzZXJ2aWNlLXdvcmtlci1jb250YWluZXItdXBkYXRlZm91bmQtZXZlbnRcbiAgICAgICAgICBjb25zdCBpbnN0YWxsaW5nV29ya2VyID0gcmVnaXN0cmF0aW9uLmluc3RhbGxpbmc7XG5cbiAgICAgICAgICBpbnN0YWxsaW5nV29ya2VyLm9uc3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaW5zdGFsbGluZ1dvcmtlci5zdGF0ZSkge1xuICAgICAgICAgICAgICBjYXNlICdpbnN0YWxsZWQnOlxuICAgICAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSBvbGQgY29udGVudCB3aWxsIGhhdmUgYmVlbiBwdXJnZWQgYW5kIHRoZVxuICAgICAgICAgICAgICAgIC8vIGZyZXNoIGNvbnRlbnQgd2lsbCBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgIC8vIEl0J3MgdGhlIHBlcmZlY3QgdGltZSB0byBkaXNwbGF5IGEgXCJOZXcgY29udGVudCBpc1xuICAgICAgICAgICAgICAgIC8vIGF2YWlsYWJsZTsgcGxlYXNlIHJlZnJlc2guXCIgbWVzc2FnZSBpbiB0aGUgcGFnZSdzIGludGVyZmFjZS5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlICdyZWR1bmRhbnQnOlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGluc3RhbGxpbmcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzZXJ2aWNlIHdvcmtlciBiZWNhbWUgcmVkdW5kYW50LicpO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbihlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkdXJpbmcgc2VydmljZSB3b3JrZXIgcmVnaXN0cmF0aW9uOicsIGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gWW91ciBjdXN0b20gSmF2YVNjcmlwdCBnb2VzIGhlcmVcbn0pKCk7XG4iXX0=\n\n\"use strict\";var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {return typeof obj;} : function (obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;}; // Word cloud layout by Jason Davies, http://www.jasondavies.com/word-cloud/\n// Algorithm due to Jonathan Feinberg, http://static.mrfeinberg.com/bv_ch03.pdf\n(function () {\n  function cloud() {\n    var size = [256, 256],\n    text = cloudText,\n    font = cloudFont,\n    fontSize = cloudFontSize,\n    fontStyle = cloudFontNormal,\n    fontWeight = cloudFontNormal,\n    rotate = cloudRotate,\n    padding = cloudPadding,\n    spiral = archimedeanSpiral,\n    words = [],\n    timeInterval = Infinity,\n    event = d3.dispatch(\"word\", \"end\"),\n    timer = null,\n    cloud = {};\n\n    cloud.start = function () {\n      var board = zeroArray((size[0] >> 5) * size[1]),\n      bounds = null,\n      n = words.length,\n      i = -1,\n      tags = [],\n      data = words.map(function (d, i) {\n        d.text = text.call(this, d, i);\n        d.font = font.call(this, d, i);\n        d.style = fontStyle.call(this, d, i);\n        d.weight = fontWeight.call(this, d, i);\n        d.rotate = rotate.call(this, d, i);\n        d.size = ~~fontSize.call(this, d, i);\n        d.padding = padding.call(this, d, i);\n        return d;\n      }).sort(function (a, b) {return b.size - a.size;});\n\n      if (timer) clearInterval(timer);\n      timer = setInterval(step, 0);\n      step();\n\n      return cloud;\n\n      function step() {\n        var start = +new Date(),\n        d;\n        while (+new Date() - start < timeInterval && ++i < n && timer) {\n          d = data[i];\n          d.x = size[0] * (Math.random() + .5) >> 1;\n          d.y = size[1] * (Math.random() + .5) >> 1;\n          cloudSprite(d, data, i);\n          if (d.hasText && place(board, d, bounds)) {\n            tags.push(d);\n            event.word(d);\n            if (bounds) cloudBounds(bounds, d);else\n            bounds = [{ x: d.x + d.x0, y: d.y + d.y0 }, { x: d.x + d.x1, y: d.y + d.y1 }];\n            // Temporary hack\n            d.x -= size[0] >> 1;\n            d.y -= size[1] >> 1;\n          }\n        }\n        if (i >= n) {\n          cloud.stop();\n          event.end(tags, bounds);\n        }\n      }\n    };\n\n    cloud.stop = function () {\n      if (timer) {\n        clearInterval(timer);\n        timer = null;\n      }\n      return cloud;\n    };\n\n    cloud.timeInterval = function (x) {\n      if (!arguments.length) return timeInterval;\n      timeInterval = x == null ? Infinity : x;\n      return cloud;\n    };\n\n    function place(board, tag, bounds) {\n      var perimeter = [{ x: 0, y: 0 }, { x: size[0], y: size[1] }],\n      startX = tag.x,\n      startY = tag.y,\n      maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),\n      s = spiral(size),\n      dt = Math.random() < .5 ? 1 : -1,\n      t = -dt,\n      dxdy,\n      dx,\n      dy;\n\n      while (dxdy = s(t += dt)) {\n        dx = ~~dxdy[0];\n        dy = ~~dxdy[1];\n\n        if (Math.min(dx, dy) > maxDelta) break;\n\n        tag.x = startX + dx;\n        tag.y = startY + dy;\n\n        if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 ||\n        tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue;\n        // TODO only check for collisions within current bounds.\n        if (!bounds || !cloudCollide(tag, board, size[0])) {\n          if (!bounds || collideRects(tag, bounds)) {\n            var sprite = tag.sprite,\n            w = tag.width >> 5,\n            sw = size[0] >> 5,\n            lx = tag.x - (w << 4),\n            sx = lx & 0x7f,\n            msx = 32 - sx,\n            h = tag.y1 - tag.y0,\n            x = (tag.y + tag.y0) * sw + (lx >> 5),\n            last;\n            for (var j = 0; j < h; j++) {\n              last = 0;\n              for (var i = 0; i <= w; i++) {\n                board[x + i] |= last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);\n              }\n              x += sw;\n            }\n            delete tag.sprite;\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    cloud.words = function (x) {\n      if (!arguments.length) return words;\n      words = x;\n      return cloud;\n    };\n\n    cloud.size = function (x) {\n      if (!arguments.length) return size;\n      size = [+x[0], +x[1]];\n      return cloud;\n    };\n\n    cloud.font = function (x) {\n      if (!arguments.length) return font;\n      font = d3.functor(x);\n      return cloud;\n    };\n\n    cloud.fontStyle = function (x) {\n      if (!arguments.length) return fontStyle;\n      fontStyle = d3.functor(x);\n      return cloud;\n    };\n\n    cloud.fontWeight = function (x) {\n      if (!arguments.length) return fontWeight;\n      fontWeight = d3.functor(x);\n      return cloud;\n    };\n\n    cloud.rotate = function (x) {\n      if (!arguments.length) return rotate;\n      rotate = d3.functor(x);\n      return cloud;\n    };\n\n    cloud.text = function (x) {\n      if (!arguments.length) return text;\n      text = d3.functor(x);\n      return cloud;\n    };\n\n    cloud.spiral = function (x) {\n      if (!arguments.length) return spiral;\n      spiral = spirals[x + \"\"] || x;\n      return cloud;\n    };\n\n    cloud.fontSize = function (x) {\n      if (!arguments.length) return fontSize;\n      fontSize = d3.functor(x);\n      return cloud;\n    };\n\n    cloud.padding = function (x) {\n      if (!arguments.length) return padding;\n      padding = d3.functor(x);\n      return cloud;\n    };\n\n    return d3.rebind(cloud, event, \"on\");\n  }\n\n  function cloudText(d) {\n    return d.text;\n  }\n\n  function cloudFont() {\n    return \"serif\";\n  }\n\n  function cloudFontNormal() {\n    return \"normal\";\n  }\n\n  function cloudFontSize(d) {\n    return Math.sqrt(d.value);\n  }\n\n  function cloudRotate() {\n    return (~~(Math.random() * 6) - 3) * 30;\n  }\n\n  function cloudPadding() {\n    return 1;\n  }\n\n  // Fetches a monochrome sprite bitmap for the specified text.\n  // Load in batches for speed.\n  function cloudSprite(d, data, di) {\n    if (d.sprite) return;\n    c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);\n    var x = 0,\n    y = 0,\n    maxh = 0,\n    n = data.length;\n    --di;\n    while (++di < n) {\n      d = data[di];\n      c.save();\n      c.font = d.style + \" \" + d.weight + \" \" + ~~((d.size + 1) / ratio) + \"px \" + d.font;\n      var w = c.measureText(d.text + \"m\").width * ratio,\n      h = d.size << 1;\n      if (d.rotate) {\n        var sr = Math.sin(d.rotate * cloudRadians),\n        cr = Math.cos(d.rotate * cloudRadians),\n        wcr = w * cr,\n        wsr = w * sr,\n        hcr = h * cr,\n        hsr = h * sr;\n        w = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f >> 5 << 5;\n        h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));\n      } else {\n        w = w + 0x1f >> 5 << 5;\n      }\n      if (h > maxh) maxh = h;\n      if (x + w >= cw << 5) {\n        x = 0;\n        y += maxh;\n        maxh = 0;\n      }\n      if (y + h >= ch) break;\n      c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);\n      if (d.rotate) c.rotate(d.rotate * cloudRadians);\n      c.fillText(d.text, 0, 0);\n      if (d.padding) c.lineWidth = 2 * d.padding, c.strokeText(d.text, 0, 0);\n      c.restore();\n      d.width = w;\n      d.height = h;\n      d.xoff = x;\n      d.yoff = y;\n      d.x1 = w >> 1;\n      d.y1 = h >> 1;\n      d.x0 = -d.x1;\n      d.y0 = -d.y1;\n      d.hasText = true;\n      x += w;\n    }\n    var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,\n    sprite = [];\n    while (--di >= 0) {\n      d = data[di];\n      if (!d.hasText) continue;\n      var w = d.width,\n      w32 = w >> 5,\n      h = d.y1 - d.y0;\n      // Zero the buffer\n      for (var i = 0; i < h * w32; i++) {sprite[i] = 0;}\n      x = d.xoff;\n      if (x == null) return;\n      y = d.yoff;\n      var seen = 0,\n      seenRow = -1;\n      for (var j = 0; j < h; j++) {\n        for (var i = 0; i < w; i++) {\n          var k = w32 * j + (i >> 5),\n          m = pixels[(y + j) * (cw << 5) + (x + i) << 2] ? 1 << 31 - i % 32 : 0;\n          sprite[k] |= m;\n          seen |= m;\n        }\n        if (seen) seenRow = j;else\n        {\n          d.y0++;\n          h--;\n          j--;\n          y++;\n        }\n      }\n      d.y1 = d.y0 + seenRow;\n      d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);\n    }\n  }\n\n  // Use mask-based collision detection.\n  function cloudCollide(tag, board, sw) {\n    sw >>= 5;\n    var sprite = tag.sprite,\n    w = tag.width >> 5,\n    lx = tag.x - (w << 4),\n    sx = lx & 0x7f,\n    msx = 32 - sx,\n    h = tag.y1 - tag.y0,\n    x = (tag.y + tag.y0) * sw + (lx >> 5),\n    last;\n    for (var j = 0; j < h; j++) {\n      last = 0;\n      for (var i = 0; i <= w; i++) {\n        if ((last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)) &\n        board[x + i]) return true;\n      }\n      x += sw;\n    }\n    return false;\n  }\n\n  function cloudBounds(bounds, d) {\n    var b0 = bounds[0],\n    b1 = bounds[1];\n    if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;\n    if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;\n    if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;\n    if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;\n  }\n\n  function collideRects(a, b) {\n    return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;\n  }\n\n  function archimedeanSpiral(size) {\n    var e = size[0] / size[1];\n    return function (t) {\n      return [e * (t *= .1) * Math.cos(t), t * Math.sin(t)];\n    };\n  }\n\n  function rectangularSpiral(size) {\n    var dy = 4,\n    dx = dy * size[0] / size[1],\n    x = 0,\n    y = 0;\n    return function (t) {\n      var sign = t < 0 ? -1 : 1;\n      // See triangular numbers: T_n = n * (n + 1) / 2.\n      switch (Math.sqrt(1 + 4 * sign * t) - sign & 3) {\n        case 0:x += dx;break;\n        case 1:y += dy;break;\n        case 2:x -= dx;break;\n        default:y -= dy;break;}\n\n      return [x, y];\n    };\n  }\n\n  // TODO reuse arrays?\n  function zeroArray(n) {\n    var a = [],\n    i = -1;\n    while (++i < n) {a[i] = 0;}\n    return a;\n  }\n\n  var cloudRadians = Math.PI / 180,\n  cw = 1 << 11 >> 5,\n  ch = 1 << 11,\n  canvas,\n  ratio = 1;\n\n  if (typeof document !== \"undefined\") {\n    canvas = document.createElement(\"canvas\");\n    canvas.width = 1;\n    canvas.height = 1;\n    ratio = Math.sqrt(canvas.getContext(\"2d\").getImageData(0, 0, 1, 1).data.length >> 2);\n    canvas.width = (cw << 5) / ratio;\n    canvas.height = ch / ratio;\n  } else {\n    // Attempt to use node-canvas.\n    canvas = new Canvas(cw << 5, ch);\n  }\n\n  var c = canvas.getContext(\"2d\"),\n  spirals = {\n    archimedean: archimedeanSpiral,\n    rectangular: rectangularSpiral };\n\n  c.fillStyle = c.strokeStyle = \"red\";\n  c.textAlign = \"center\";\n\n  if ((typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) === \"object\" && module.exports) module.exports = cloud;else\n  (d3.layout || (d3.layout = {})).cloud = cloud;\n})();\n//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQzLmNsb3VkLmpzIl0sIm5hbWVzIjpbImNsb3VkIiwic2l6ZSIsInRleHQiLCJjbG91ZFRleHQiLCJmb250IiwiY2xvdWRGb250IiwiZm9udFNpemUiLCJjbG91ZEZvbnRTaXplIiwiZm9udFN0eWxlIiwiY2xvdWRGb250Tm9ybWFsIiwiZm9udFdlaWdodCIsInJvdGF0ZSIsImNsb3VkUm90YXRlIiwicGFkZGluZyIsImNsb3VkUGFkZGluZyIsInNwaXJhbCIsImFyY2hpbWVkZWFuU3BpcmFsIiwid29yZHMiLCJ0aW1lSW50ZXJ2YWwiLCJJbmZpbml0eSIsImV2ZW50IiwiZDMiLCJkaXNwYXRjaCIsInRpbWVyIiwic3RhcnQiLCJib2FyZCIsInplcm9BcnJheSIsImJvdW5kcyIsIm4iLCJsZW5ndGgiLCJpIiwidGFncyIsImRhdGEiLCJtYXAiLCJkIiwiY2FsbCIsInN0eWxlIiwid2VpZ2h0Iiwic29ydCIsImEiLCJiIiwiY2xlYXJJbnRlcnZhbCIsInNldEludGVydmFsIiwic3RlcCIsIkRhdGUiLCJ4IiwiTWF0aCIsInJhbmRvbSIsInkiLCJjbG91ZFNwcml0ZSIsImhhc1RleHQiLCJwbGFjZSIsInB1c2giLCJ3b3JkIiwiY2xvdWRCb3VuZHMiLCJ4MCIsInkwIiwieDEiLCJ5MSIsInN0b3AiLCJlbmQiLCJhcmd1bWVudHMiLCJ0YWciLCJwZXJpbWV0ZXIiLCJzdGFydFgiLCJzdGFydFkiLCJtYXhEZWx0YSIsInNxcnQiLCJzIiwiZHQiLCJ0IiwiZHhkeSIsImR4IiwiZHkiLCJtaW4iLCJjbG91ZENvbGxpZGUiLCJjb2xsaWRlUmVjdHMiLCJzcHJpdGUiLCJ3Iiwid2lkdGgiLCJzdyIsImx4Iiwic3giLCJtc3giLCJoIiwibGFzdCIsImoiLCJmdW5jdG9yIiwic3BpcmFscyIsInJlYmluZCIsInZhbHVlIiwiZGkiLCJjIiwiY2xlYXJSZWN0IiwiY3ciLCJyYXRpbyIsImNoIiwibWF4aCIsInNhdmUiLCJtZWFzdXJlVGV4dCIsInNyIiwic2luIiwiY2xvdWRSYWRpYW5zIiwiY3IiLCJjb3MiLCJ3Y3IiLCJ3c3IiLCJoY3IiLCJoc3IiLCJtYXgiLCJhYnMiLCJ0cmFuc2xhdGUiLCJmaWxsVGV4dCIsImxpbmVXaWR0aCIsInN0cm9rZVRleHQiLCJyZXN0b3JlIiwiaGVpZ2h0IiwieG9mZiIsInlvZmYiLCJwaXhlbHMiLCJnZXRJbWFnZURhdGEiLCJ3MzIiLCJzZWVuIiwic2VlblJvdyIsImsiLCJtIiwic2xpY2UiLCJiMCIsImIxIiwiZSIsInJlY3Rhbmd1bGFyU3BpcmFsIiwic2lnbiIsIlBJIiwiY2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiZ2V0Q29udGV4dCIsIkNhbnZhcyIsImFyY2hpbWVkZWFuIiwicmVjdGFuZ3VsYXIiLCJmaWxsU3R5bGUiLCJzdHJva2VTdHlsZSIsInRleHRBbGlnbiIsIm1vZHVsZSIsImV4cG9ydHMiLCJsYXlvdXQiXSwibWFwcGluZ3MiOiJ1UkFBQTtBQUNBO0FBQ0EsQ0FBQyxZQUFXO0FBQ1YsV0FBU0EsS0FBVCxHQUFpQjtBQUNmLFFBQUlDLE9BQU8sQ0FBQyxHQUFELEVBQU0sR0FBTixDQUFYO0FBQ0lDLFdBQU9DLFNBRFg7QUFFSUMsV0FBT0MsU0FGWDtBQUdJQyxlQUFXQyxhQUhmO0FBSUlDLGdCQUFZQyxlQUpoQjtBQUtJQyxpQkFBYUQsZUFMakI7QUFNSUUsYUFBU0MsV0FOYjtBQU9JQyxjQUFVQyxZQVBkO0FBUUlDLGFBQVNDLGlCQVJiO0FBU0lDLFlBQVEsRUFUWjtBQVVJQyxtQkFBZUMsUUFWbkI7QUFXSUMsWUFBUUMsR0FBR0MsUUFBSCxDQUFZLE1BQVosRUFBb0IsS0FBcEIsQ0FYWjtBQVlJQyxZQUFRLElBWlo7QUFhSXZCLFlBQVEsRUFiWjs7QUFlQUEsVUFBTXdCLEtBQU4sR0FBYyxZQUFXO0FBQ3ZCLFVBQUlDLFFBQVFDLFVBQVUsQ0FBQ3pCLEtBQUssQ0FBTCxLQUFXLENBQVosSUFBaUJBLEtBQUssQ0FBTCxDQUEzQixDQUFaO0FBQ0kwQixlQUFTLElBRGI7QUFFSUMsVUFBSVgsTUFB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LElBQWdFLENBQTFFLENBQVI7QUFDQXdHLFdBQU90RCxLQUFQLEdBQWUsQ0FBQ2UsTUFBTSxDQUFQLElBQVlDLEtBQTNCO0FBQ0FzQyxXQUFPakIsTUFBUCxHQUFnQnBCLEtBQUtELEtBQXJCO0FBQ0QsR0FQRCxNQU9PO0FBQ0w7QUFDQXNDLGFBQVMsSUFBSUksTUFBSixDQUFXM0MsTUFBTSxDQUFqQixFQUFvQkUsRUFBcEIsQ0FBVDtBQUNEOztBQUVELE1BQUlKLElBQUl5QyxPQUFPRyxVQUFQLENBQWtCLElBQWxCLENBQVI7QUFDSWhELFlBQVU7QUFDUmtELGlCQUFhMUgsaUJBREw7QUFFUjJILGlCQUFhVCxpQkFGTCxFQURkOztBQUtBdEMsSUFBRWdELFNBQUYsR0FBY2hELEVBQUVpRCxXQUFGLEdBQWdCLEtBQTlCO0FBQ0FqRCxJQUFFa0QsU0FBRixHQUFjLFFBQWQ7O0FBRUEsTUFBSSxRQUFPQyxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQWxCLElBQThCQSxPQUFPQyxPQUF6QyxFQUFrREQsT0FBT0MsT0FBUCxHQUFpQmhKLEtBQWpCLENBQWxEO0FBQ0ssR0FBQ3FCLEdBQUc0SCxNQUFILEtBQWM1SCxHQUFHNEgsTUFBSCxHQUFZLEVBQTFCLENBQUQsRUFBZ0NqSixLQUFoQyxHQUF3Q0EsS0FBeEM7QUFDTixDQTlZRCIsImZpbGUiOiJkMy5jbG91ZC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFdvcmQgY2xvdWQgbGF5b3V0IGJ5IEphc29uIERhdmllcywgaHR0cDovL3d3dy5qYXNvbmRhdmllcy5jb20vd29yZC1jbG91ZC9cbi8vIEFsZ29yaXRobSBkdWUgdG8gSm9uYXRoYW4gRmVpbmJlcmcsIGh0dHA6Ly9zdGF0aWMubXJmZWluYmVyZy5jb20vYnZfY2gwMy5wZGZcbihmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gY2xvdWQoKSB7XG4gICAgdmFyIHNpemUgPSBbMjU2LCAyNTZdLFxuICAgICAgICB0ZXh0ID0gY2xvdWRUZXh0LFxuICAgICAgICBmb250ID0gY2xvdWRGb250LFxuICAgICAgICBmb250U2l6ZSA9IGNsb3VkRm9udFNpemUsXG4gICAgICAgIGZvbnRTdHlsZSA9IGNsb3VkRm9udE5vcm1hbCxcbiAgICAgICAgZm9udFdlaWdodCA9IGNsb3VkRm9udE5vcm1hbCxcbiAgICAgICAgcm90YXRlID0gY2xvdWRSb3RhdGUsXG4gICAgICAgIHBhZGRpbmcgPSBjbG91ZFBhZGRpbmcsXG4gICAgICAgIHNwaXJhbCA9IGFyY2hpbWVkZWFuU3BpcmFsLFxuICAgICAgICB3b3JkcyA9IFtdLFxuICAgICAgICB0aW1lSW50ZXJ2YWwgPSBJbmZpbml0eSxcbiAgICAgICAgZXZlbnQgPSBkMy5kaXNwYXRjaChcIndvcmRcIiwgXCJlbmRcIiksXG4gICAgICAgIHRpbWVyID0gbnVsbCxcbiAgICAgICAgY2xvdWQgPSB7fTtcblxuICAgIGNsb3VkLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYm9hcmQgPSB6ZXJvQXJyYXkoKHNpemVbMF0gPj4gNSkgKiBzaXplWzFdKSxcbiAgICAgICAgICBib3VuZHMgPSBudWxsLFxuICAgICAgICAgIG4gPSB3b3Jkcy5sZW5ndGgsXG4gICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgIHRhZ3MgPSBbXSxcbiAgICAgICAgICBkYXRhID0gd29yZHMubWFwKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgIGQudGV4dCA9IHRleHQuY2FsbCh0aGlzLCBkLCBpKTtcbiAgICAgICAgICAgIGQuZm9udCA9IGZvbnQuY2FsbCh0aGlzLCBkLCBpKTtcbiAgICAgICAgICAgIGQuc3R5bGUgPSBmb250U3R5bGUuY2FsbCh0aGlzLCBkLCBpKTtcbiAgICAgICAgICAgIGQud2VpZ2h0ID0gZm9udFdlaWdodC5jYWxsKHRoaXMsIGQsIGkpO1xuICAgICAgICAgICAgZC5yb3RhdGUgPSByb3RhdGUuY2FsbCh0aGlzLCBkLCBpKTtcbiAgICAgICAgICAgIGQuc2l6ZSA9IH5+Zm9udFNpemUuY2FsbCh0aGlzLCBkLCBpKTtcbiAgICAgICAgICAgIGQucGFkZGluZyA9IHBhZGRpbmcuY2FsbCh0aGlzLCBkLCBpKTtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgIH0pLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYi5zaXplIC0gYS5zaXplOyB9KTtcblxuICAgICAgaWYgKHRpbWVyKSBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgICAgIHRpbWVyID0gc2V0SW50ZXJ2YWwoc3RlcCwgMCk7XG4gICAgICBzdGVwKCk7XG5cbiAgICAgIHJldHVybiBjbG91ZDtcblxuICAgICAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gK25ldyBEYXRlLFxuICAgICAgICAgICAgZDtcbiAgICAgICAgd2hpbGUgKCtuZXcgRGF0ZSAtIHN0YXJ0IDwgdGltZUludGVydmFsICYmICsraSA8IG4gJiYgdGltZXIpIHtcbiAgICAgICAgICBkID0gZGF0YVtpXTtcbiAgICAgICAgICBkLnggPSAoc2l6ZVswXSAqIChNYXRoLnJhbmRvbSgpICsgLjUpKSA+PiAxO1xuICAgICAgICAgIGQueSA9IChzaXplWzFdICogKE1hdGgucmFuZG9tKCkgKyAuNSkpID4+IDE7XG4gICAgICAgICAgY2xvdWRTcHJpdGUoZCwgZGF0YSwgaSk7XG4gICAgICAgICAgaWYgKGQuaGFzVGV4dCAmJiBwbGFjZShib2FyZCwgZCwgYm91bmRzKSkge1xuICAgICAgICAgICAgdGFncy5wdXNoKGQpO1xuICAgICAgICAgICAgZXZlbnQud29yZChkKTtcbiAgICAgICAgICAgIGlmIChib3VuZHMpIGNsb3VkQm91bmRzKGJvdW5kcywgZCk7XG4gICAgICAgICAgICBlbHNlIGJvdW5kcyA9IFt7eDogZC54ICsgZC54MCwgeTogZC55ICsgZC55MH0sIHt4OiBkLnggKyBkLngxLCB5OiBkLnkgKyBkLnkxfV07XG4gICAgICAgICAgICAvLyBUZW1wb3JhcnkgaGFja1xuICAgICAgICAgICAgZC54IC09IHNpemVbMF0gPj4gMTtcbiAgICAgICAgICAgIGQueSAtPSBzaXplWzFdID4+IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpID49IG4pIHtcbiAgICAgICAgICBjbG91ZC5zdG9wKCk7XG4gICAgICAgICAgZXZlbnQuZW5kKHRhZ3MsIGJvdW5kcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjbG91ZC5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbG91ZDtcbiAgICB9O1xuXG4gICAgY2xvdWQudGltZUludGVydmFsID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGltZUludGVydmFsO1xuICAgICAgdGltZUludGVydmFsID0geCA9PSBudWxsID8gSW5maW5pdHkgOiB4O1xuICAgICAgcmV0dXJuIGNsb3VkO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwbGFjZShib2FyZCwgdGFnLCBib3VuZHMpIHtcbiAgICAgIHZhciBwZXJpbWV0ZXIgPSBbe3g6IDAsIHk6IDB9LCB7eDogc2l6ZVswXSwgeTogc2l6ZVsxXX1dLFxuICAgICAgICAgIHN0YXJ0WCA9IHRhZy54LFxuICAgICAgICAgIHN0YXJ0WSA9IHRhZy55LFxuICAgICAgICAgIG1heERlbHRhID0gTWF0aC5zcXJ0KHNpemVbMF0gKiBzaXplWzBdICsgc2l6ZVsxXSAqIHNpemVbMV0pLFxuICAgICAgICAgIHMgPSBzcGlyYWwoc2l6ZSksXG4gICAgICAgICAgZHQgPSBNYXRoLnJhbmRvbSgpIDwgLjUgPyAxIDogLTEsXG4gICAgICAgICAgdCA9IC1kdCxcbiAgICAgICAgICBkeGR5LFxuICAgICAgICAgIGR4LFxuICAgICAgICAgIGR5O1xuXG4gICAgICB3aGlsZSAoZHhkeSA9IHModCArPSBkdCkpIHtcbiAgICAgICAgZHggPSB+fmR4ZHlbMF07XG4gICAgICAgIGR5ID0gfn5keGR5WzFdO1xuXG4gICAgICAgIGlmIChNYXRoLm1pbihkeCwgZHkpID4gbWF4RGVsdGEpIGJyZWFrO1xuXG4gICAgICAgIHRhZy54ID0gc3RhcnRYICsgZHg7XG4gICAgICAgIHRhZy55ID0gc3RhcnRZICsgZHk7XG5cbiAgICAgICAgaWYgKHRhZy54ICsgdGFnLngwIDwgMCB8fCB0YWcueSArIHRhZy55MCA8IDAgfHxcbiAgICAgICAgICAgIHRhZy54ICsgdGFnLngxID4gc2l6ZVswXSB8fCB0YWcueSArIHRhZy55MSA+IHNpemVbMV0pIGNvbnRpbnVlO1xuICAgICAgICAvLyBUT0RPIG9ubHkgY2hlY2sgZm9yIGNvbGxpc2lvbnMgd2l0aGluIGN1cnJlbnQgYm91bmRzLlxuICAgICAgICBpZiAoIWJvdW5kcyB8fCAhY2xvdWRDb2xsaWRlKHRhZywgYm9hcmQsIHNpemVbMF0pKSB7XG4gICAgICAgICAgaWYgKCFib3VuZHMgfHwgY29sbGlkZVJlY3RzKHRhZywgYm91bmRzKSkge1xuICAgICAgICAgICAgdmFyIHNwcml0ZSA9IHRhZy5zcHJpdGUsXG4gICAgICAgICAgICAgICAgdyA9IHRhZy53aWR0aCA+PiA1LFxuICAgICAgICAgICAgICAgIHN3ID0gc2l6ZVswXSA+PiA1LFxuICAgICAgICAgICAgICAgIGx4ID0gdGFnLnggLSAodyA8PCA0KSxcbiAgICAgICAgICAgICAgICBzeCA9IGx4ICYgMHg3ZixcbiAgICAgICAgICAgICAgICBtc3ggPSAzMiAtIHN4LFxuICAgICAgICAgICAgICAgIGggPSB0YWcueTEgLSB0YWcueTAsXG4gICAgICAgICAgICAgICAgeCA9ICh0YWcueSArIHRhZy55MCkgKiBzdyArIChseCA+PiA1KSxcbiAgICAgICAgICAgICAgICBsYXN0O1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoOyBqKyspIHtcbiAgICAgICAgICAgICAgbGFzdCA9IDA7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHc7IGkrKykge1xuICAgICAgICAgICAgICAgIGJvYXJkW3ggKyBpXSB8PSAobGFzdCA8PCBtc3gpIHwgKGkgPCB3ID8gKGxhc3QgPSBzcHJpdGVbaiAqIHcgKyBpXSkgPj4+IHN4IDogMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgeCArPSBzdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSB0YWcuc3ByaXRlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY2xvdWQud29yZHMgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB3b3JkcztcbiAgICAgIHdvcmRzID0geDtcbiAgICAgIHJldHVybiBjbG91ZDtcbiAgICB9O1xuXG4gICAgY2xvdWQuc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNpemU7XG4gICAgICBzaXplID0gWyt4WzBdLCAreFsxXV07XG4gICAgICByZXR1cm4gY2xvdWQ7XG4gICAgfTtcblxuICAgIGNsb3VkLmZvbnQgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBmb250O1xuICAgICAgZm9udCA9IGQzLmZ1bmN0b3IoeCk7XG4gICAgICByZXR1cm4gY2xvdWQ7XG4gICAgfTtcblxuICAgIGNsb3VkLmZvbnRTdHlsZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGZvbnRTdHlsZTtcbiAgICAgIGZvbnRTdHlsZSA9IGQzLmZ1bmN0b3IoeCk7XG4gICAgICByZXR1cm4gY2xvdWQ7XG4gICAgfTtcblxuICAgIGNsb3VkLmZvbnRXZWlnaHQgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBmb250V2VpZ2h0O1xuICAgICAgZm9udFdlaWdodCA9IGQzLmZ1bmN0b3IoeCk7XG4gICAgICByZXR1cm4gY2xvdWQ7XG4gICAgfTtcblxuICAgIGNsb3VkLnJvdGF0ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJvdGF0ZTtcbiAgICAgIHJvdGF0ZSA9IGQzLmZ1bmN0b3IoeCk7XG4gICAgICByZXR1cm4gY2xvdWQ7XG4gICAgfTtcblxuICAgIGNsb3VkLnRleHQgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0ZXh0O1xuICAgICAgdGV4dCA9IGQzLmZ1bmN0b3IoeCk7XG4gICAgICByZXR1cm4gY2xvdWQ7XG4gICAgfTtcblxuICAgIGNsb3VkLnNwaXJhbCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNwaXJhbDtcbiAgICAgIHNwaXJhbCA9IHNwaXJhbHNbeCArIFwiXCJdIHx8IHg7XG4gICAgICByZXR1cm4gY2xvdWQ7XG4gICAgfTtcblxuICAgIGNsb3VkLmZvbnRTaXplID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZm9udFNpemU7XG4gICAgICBmb250U2l6ZSA9IGQzLmZ1bmN0b3IoeCk7XG4gICAgICByZXR1cm4gY2xvdWQ7XG4gICAgfTtcblxuICAgIGNsb3VkLnBhZGRpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwYWRkaW5nO1xuICAgICAgcGFkZGluZyA9IGQzLmZ1bmN0b3IoeCk7XG4gICAgICByZXR1cm4gY2xvdWQ7XG4gICAgfTtcblxuICAgIHJldHVybiBkMy5yZWJpbmQoY2xvdWQsIGV2ZW50LCBcIm9uXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xvdWRUZXh0KGQpIHtcbiAgICByZXR1cm4gZC50ZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gY2xvdWRGb250KCkge1xuICAgIHJldHVybiBcInNlcmlmXCI7XG4gIH1cblxuICBmdW5jdGlvbiBjbG91ZEZvbnROb3JtYWwoKSB7XG4gICAgcmV0dXJuIFwibm9ybWFsXCI7XG4gIH1cblxuICBmdW5jdGlvbiBjbG91ZEZvbnRTaXplKGQpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KGQudmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xvdWRSb3RhdGUoKSB7XG4gICAgcmV0dXJuICh+fihNYXRoLnJhbmRvbSgpICogNikgLSAzKSAqIDMwO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xvdWRQYWRkaW5nKCkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLy8gRmV0Y2hlcyBhIG1vbm9jaHJvbWUgc3ByaXRlIGJpdG1hcCBmb3IgdGhlIHNwZWNpZmllZCB0ZXh0LlxuICAvLyBMb2FkIGluIGJhdGNoZXMgZm9yIHNwZWVkLlxuICBmdW5jdGlvbiBjbG91ZFNwcml0ZShkLCBkYXRhLCBkaSkge1xuICAgIGlmIChkLnNwcml0ZSkgcmV0dXJuO1xuICAgIGMuY2xlYXJSZWN0KDAsIDAsIChjdyA8PCA1KSAvIHJhdGlvLCBjaCAvIHJhdGlvKTtcbiAgICB2YXIgeCA9IDAsXG4gICAgICAgIHkgPSAwLFxuICAgICAgICBtYXhoID0gMCxcbiAgICAgICAgbiA9IGRhdGEubGVuZ3RoO1xuICAgIC0tZGk7XG4gICAgd2hpbGUgKCsrZGkgPCBuKSB7XG4gICAgICBkID0gZGF0YVtkaV07XG4gICAgICBjLnNhdmUoKTtcbiAgICAgIGMuZm9udCA9IGQuc3R5bGUgKyBcIiBcIiArIGQud2VpZ2h0ICsgXCIgXCIgKyB+figoZC5zaXplICsgMSkgLyByYXRpbykgKyBcInB4IFwiICsgZC5mb250O1xuICAgICAgdmFyIHcgPSBjLm1lYXN1cmVUZXh0KGQudGV4dCArIFwibVwiKS53aWR0aCAqIHJhdGlvLFxuICAgICAgICAgIGggPSBkLnNpemUgPDwgMTtcbiAgICAgIGlmIChkLnJvdGF0ZSkge1xuICAgICAgICB2YXIgc3IgPSBNYXRoLnNpbihkLnJvdGF0ZSAqIGNsb3VkUmFkaWFucyksXG4gICAgICAgICAgICBjciA9IE1hdGguY29zKGQucm90YXRlICogY2xvdWRSYWRpYW5zKSxcbiAgICAgICAgICAgIHdjciA9IHcgKiBjcixcbiAgICAgICAgICAgIHdzciA9IHcgKiBzcixcbiAgICAgICAgICAgIGhjciA9IGggKiBjcixcbiAgICAgICAgICAgIGhzciA9IGggKiBzcjtcbiAgICAgICAgdyA9IChNYXRoLm1heChNYXRoLmFicyh3Y3IgKyBoc3IpLCBNYXRoLmFicyh3Y3IgLSBoc3IpKSArIDB4MWYpID4+IDUgPDwgNTtcbiAgICAgICAgaCA9IH5+TWF0aC5tYXgoTWF0aC5hYnMod3NyICsgaGNyKSwgTWF0aC5hYnMod3NyIC0gaGNyKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3ID0gKHcgKyAweDFmKSA+PiA1IDw8IDU7XG4gICAgICB9XG4gICAgICBpZiAoaCA+IG1heGgpIG1heGggPSBoO1xuICAgICAgaWYgKHggKyB3ID49IChjdyA8PCA1KSkge1xuICAgICAgICB4ID0gMDtcbiAgICAgICAgeSArPSBtYXhoO1xuICAgICAgICBtYXhoID0gMDtcbiAgICAgIH1cbiAgICAgIGlmICh5ICsgaCA+PSBjaCkgYnJlYWs7XG4gICAgICBjLnRyYW5zbGF0ZSgoeCArICh3ID4+IDEpKSAvIHJhdGlvLCAoeSArIChoID4+IDEpKSAvIHJhdGlvKTtcbiAgICAgIGlmIChkLnJvdGF0ZSkgYy5yb3RhdGUoZC5yb3RhdGUgKiBjbG91ZFJhZGlhbnMpO1xuICAgICAgYy5maWxsVGV4dChkLnRleHQsIDAsIDApO1xuICAgICAgaWYgKGQucGFkZGluZykgYy5saW5lV2lkdGggPSAyICogZC5wYWRkaW5nLCBjLnN0cm9rZVRleHQoZC50ZXh0LCAwLCAwKTtcbiAgICAgIGMucmVzdG9yZSgpO1xuICAgICAgZC53aWR0aCA9IHc7XG4gICAgICBkLmhlaWdodCA9IGg7XG4gICAgICBkLnhvZmYgPSB4O1xuICAgICAgZC55b2ZmID0geTtcbiAgICAgIGQueDEgPSB3ID4+IDE7XG4gICAgICBkLnkxID0gaCA+PiAxO1xuICAgICAgZC54MCA9IC1kLngxO1xuICAgICAgZC55MCA9IC1kLnkxO1xuICAgICAgZC5oYXNUZXh0ID0gdHJ1ZTtcbiAgICAgIHggKz0gdztcbiAgICB9XG4gICAgdmFyIHBpeGVscyA9IGMuZ2V0SW1hZ2VEYXRhKDAsIDAsIChjdyA8PCA1KSAvIHJhdGlvLCBjaCAvIHJhdGlvKS5kYXRhLFxuICAgICAgICBzcHJpdGUgPSBbXTtcbiAgICB3aGlsZSAoLS1kaSA+PSAwKSB7XG4gICAgICBkID0gZGF0YVtkaV07XG4gICAgICBpZiAoIWQuaGFzVGV4dCkgY29udGludWU7XG4gICAgICB2YXIgdyA9IGQud2lkdGgsXG4gICAgICAgICAgdzMyID0gdyA+PiA1LFxuICAgICAgICAgIGggPSBkLnkxIC0gZC55MDtcbiAgICAgIC8vIFplcm8gdGhlIGJ1ZmZlclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoICogdzMyOyBpKyspIHNwcml0ZVtpXSA9IDA7XG4gICAgICB4ID0gZC54b2ZmO1xuICAgICAgaWYgKHggPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgeSA9IGQueW9mZjtcbiAgICAgIHZhciBzZWVuID0gMCxcbiAgICAgICAgICBzZWVuUm93ID0gLTE7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGg7IGorKykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHc7IGkrKykge1xuICAgICAgICAgIHZhciBrID0gdzMyICogaiArIChpID4+IDUpLFxuICAgICAgICAgICAgICBtID0gcGl4ZWxzWygoeSArIGopICogKGN3IDw8IDUpICsgKHggKyBpKSkgPDwgMl0gPyAxIDw8ICgzMSAtIChpICUgMzIpKSA6IDA7XG4gICAgICAgICAgc3ByaXRlW2tdIHw9IG07XG4gICAgICAgICAgc2VlbiB8PSBtO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWVuKSBzZWVuUm93ID0gajtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZC55MCsrO1xuICAgICAgICAgIGgtLTtcbiAgICAgICAgICBqLS07XG4gICAgICAgICAgeSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkLnkxID0gZC55MCArIHNlZW5Sb3c7XG4gICAgICBkLnNwcml0ZSA9IHNwcml0ZS5zbGljZSgwLCAoZC55MSAtIGQueTApICogdzMyKTtcbiAgICB9XG4gIH1cblxuICAvLyBVc2UgbWFzay1iYXNlZCBjb2xsaXNpb24gZGV0ZWN0aW9uLlxuICBmdW5jdGlvbiBjbG91ZENvbGxpZGUodGFnLCBib2FyZCwgc3cpIHtcbiAgICBzdyA+Pj0gNTtcbiAgICB2YXIgc3ByaXRlID0gdGFnLnNwcml0ZSxcbiAgICAgICAgdyA9IHRhZy53aWR0aCA+PiA1LFxuICAgICAgICBseCA9IHRhZy54IC0gKHcgPDwgNCksXG4gICAgICAgIHN4ID0gbHggJiAweDdmLFxuICAgICAgICBtc3ggPSAzMiAtIHN4LFxuICAgICAgICBoID0gdGFnLnkxIC0gdGFnLnkwLFxuICAgICAgICB4ID0gKHRhZy55ICsgdGFnLnkwKSAqIHN3ICsgKGx4ID4+IDUpLFxuICAgICAgICBsYXN0O1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgaDsgaisrKSB7XG4gICAgICBsYXN0ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHc7IGkrKykge1xuICAgICAgICBpZiAoKChsYXN0IDw8IG1zeCkgfCAoaSA8IHcgPyAobGFzdCA9IHNwcml0ZVtqICogdyArIGldKSA+Pj4gc3ggOiAwKSlcbiAgICAgICAgICAgICYgYm9hcmRbeCArIGldKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHggKz0gc3c7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3VkQm91bmRzKGJvdW5kcywgZCkge1xuICAgIHZhciBiMCA9IGJvdW5kc1swXSxcbiAgICAgICAgYjEgPSBib3VuZHNbMV07XG4gICAgaWYgKGQueCArIGQueDAgPCBiMC54KSBiMC54ID0gZC54ICsgZC54MDtcbiAgICBpZiAoZC55ICsgZC55MCA8IGIwLnkpIGIwLnkgPSBkLnkgKyBkLnkwO1xuICAgIGlmIChkLnggKyBkLngxID4gYjEueCkgYjEueCA9IGQueCArIGQueDE7XG4gICAgaWYgKGQueSArIGQueTEgPiBiMS55KSBiMS55ID0gZC55ICsgZC55MTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbGxpZGVSZWN0cyhhLCBiKSB7XG4gICAgcmV0dXJuIGEueCArIGEueDEgPiBiWzBdLnggJiYgYS54ICsgYS54MCA8IGJbMV0ueCAmJiBhLnkgKyBhLnkxID4gYlswXS55ICYmIGEueSArIGEueTAgPCBiWzFdLnk7XG4gIH1cblxuICBmdW5jdGlvbiBhcmNoaW1lZGVhblNwaXJhbChzaXplKSB7XG4gICAgdmFyIGUgPSBzaXplWzBdIC8gc2l6ZVsxXTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIFtlICogKHQgKj0gLjEpICogTWF0aC5jb3ModCksIHQgKiBNYXRoLnNpbih0KV07XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY3Rhbmd1bGFyU3BpcmFsKHNpemUpIHtcbiAgICB2YXIgZHkgPSA0LFxuICAgICAgICBkeCA9IGR5ICogc2l6ZVswXSAvIHNpemVbMV0sXG4gICAgICAgIHggPSAwLFxuICAgICAgICB5ID0gMDtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgdmFyIHNpZ24gPSB0IDwgMCA/IC0xIDogMTtcbiAgICAgIC8vIFNlZSB0cmlhbmd1bGFyIG51bWJlcnM6IFRfbiA9IG4gKiAobiArIDEpIC8gMi5cbiAgICAgIHN3aXRjaCAoKE1hdGguc3FydCgxICsgNCAqIHNpZ24gKiB0KSAtIHNpZ24pICYgMykge1xuICAgICAgICBjYXNlIDA6ICB4ICs9IGR4OyBicmVhaztcbiAgICAgICAgY2FzZSAxOiAgeSArPSBkeTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogIHggLT0gZHg7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiB5IC09IGR5OyBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfTtcbiAgfVxuXG4gIC8vIFRPRE8gcmV1c2UgYXJyYXlzP1xuICBmdW5jdGlvbiB6ZXJvQXJyYXkobikge1xuICAgIHZhciBhID0gW10sXG4gICAgICAgIGkgPSAtMTtcbiAgICB3aGlsZSAoKytpIDwgbikgYVtpXSA9IDA7XG4gICAgcmV0dXJuIGE7XG4gIH1cblxuICB2YXIgY2xvdWRSYWRpYW5zID0gTWF0aC5QSSAvIDE4MCxcbiAgICAgIGN3ID0gMSA8PCAxMSA+PiA1LFxuICAgICAgY2ggPSAxIDw8IDExLFxuICAgICAgY2FudmFzLFxuICAgICAgcmF0aW8gPSAxO1xuXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IDE7XG4gICAgY2FudmFzLmhlaWdodCA9IDE7XG4gICAgcmF0aW8gPSBNYXRoLnNxcnQoY2FudmFzLmdldENvbnRleHQoXCIyZFwiKS5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YS5sZW5ndGggPj4gMik7XG4gICAgY2FudmFzLndpZHRoID0gKGN3IDw8IDUpIC8gcmF0aW87XG4gICAgY2FudmFzLmhlaWdodCA9IGNoIC8gcmF0aW87XG4gIH0gZWxzZSB7XG4gICAgLy8gQXR0ZW1wdCB0byB1c2Ugbm9kZS1jYW52YXMuXG4gICAgY2FudmFzID0gbmV3IENhbnZhcyhjdyA8PCA1LCBjaCk7XG4gIH1cblxuICB2YXIgYyA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiksXG4gICAgICBzcGlyYWxzID0ge1xuICAgICAgICBhcmNoaW1lZGVhbjogYXJjaGltZWRlYW5TcGlyYWwsXG4gICAgICAgIHJlY3Rhbmd1bGFyOiByZWN0YW5ndWxhclNwaXJhbFxuICAgICAgfTtcbiAgYy5maWxsU3R5bGUgPSBjLnN0cm9rZVN0eWxlID0gXCJyZWRcIjtcbiAgYy50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuXG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIG1vZHVsZS5leHBvcnRzKSBtb2R1bGUuZXhwb3J0cyA9IGNsb3VkO1xuICBlbHNlIChkMy5sYXlvdXQgfHwgKGQzLmxheW91dCA9IHt9KSkuY2xvdWQgPSBjbG91ZDtcbn0pKCk7Il19\n\n'use strict'; /* eslint-env browser */\n/**\n                                        * Toggle the display of an element.\n                                        *\n                                        * @param  {element} e The element to toggle.\n                                        *\n                                        * @return {element}   The element that was toggled.\n                                        */\nwindow.toggle = function (e) {\n  if (e instanceof NodeList) {\n    e.forEach(toggle);\n    return e;\n  }\n\n  if (e.style.display === 'inherit') {\n    return hide(e);\n  }\n\n  return show(e);\n};\n\n/**\n    * Hide an element or elements.\n    *\n    * @param  {element|NodeList} e The element(s) to hide\n    *\n    * @return {element} The element hidden\n    */\nwindow.hide = function (e) {\n  if (e instanceof NodeList) {\n    e.forEach(hide);\n  } else {\n    e.style.display = 'none';\n  }\n\n  return e;\n};\n\n/**\n    * Unhide an element.\n    *\n    * @param  {element} e The element to unhide.\n    *\n    * @return {element} The element unhidden\n    */\nwindow.show = function (e) {\n  if (e instanceof NodeList) {\n    e.forEach(hide);\n  } else {\n    e.style.display = 'inherit';\n  }\n\n  return e;\n};\n//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRvZ2dsZS5qcyJdLCJuYW1lcyI6WyJ3aW5kb3ciLCJ0b2dnbGUiLCJlIiwiTm9kZUxpc3QiLCJmb3JFYWNoIiwic3R5bGUiLCJkaXNwbGF5IiwiaGlkZSIsInNob3ciXSwibWFwcGluZ3MiOiJjQUFBO0FBQ0E7Ozs7Ozs7QUFPQUEsT0FBT0MsTUFBUCxHQUFnQixVQUFTQyxDQUFULEVBQVk7QUFDMUIsTUFBSUEsYUFBYUMsUUFBakIsRUFBMkI7QUFDekJELE1BQUVFLE9BQUYsQ0FBVUgsTUFBVjtBQUNBLFdBQU9DLENBQVA7QUFDRDs7QUFFRCxNQUFJQSxFQUFFRyxLQUFGLENBQVFDLE9BQVIsS0FBb0IsU0FBeEIsRUFBbUM7QUFDakMsV0FBT0MsS0FBS0wsQ0FBTCxDQUFQO0FBQ0Q7O0FBRUQsU0FBT00sS0FBS04sQ0FBTCxDQUFQO0FBQ0QsQ0FYRDs7QUFhQTs7Ozs7OztBQU9BRixPQUFPTyxJQUFQLEdBQWMsVUFBU0wsQ0FBVCxFQUFZO0FBQ3hCLE1BQUlBLGFBQWFDLFFBQWpCLEVBQTJCO0FBQ3pCRCxNQUFFRSxPQUFGLENBQVVHLElBQVY7QUFDRCxHQUZELE1BRU87QUFDTEwsTUFBRUcsS0FBRixDQUFRQyxPQUFSLEdBQWtCLE1BQWxCO0FBQ0Q7O0FBRUQsU0FBT0osQ0FBUDtBQUNELENBUkQ7O0FBVUE7Ozs7Ozs7QUFPQUYsT0FBT1EsSUFBUCxHQUFjLFVBQVNOLENBQVQsRUFBWTtBQUN4QixNQUFJQSxhQUFhQyxRQUFqQixFQUEyQjtBQUN6QkQsTUFBRUUsT0FBRixDQUFVRyxJQUFWO0FBQ0QsR0FGRCxNQUVPO0FBQ0xMLE1BQUVHLEtBQUYsQ0FBUUMsT0FBUixHQUFrQixTQUFsQjtBQUNEOztBQUVELFNBQU9KLENBQVA7QUFDRCxDQVJEIiwiZmlsZSI6InRvZ2dsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuLyoqXG4gKiBUb2dnbGUgdGhlIGRpc3BsYXkgb2YgYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gIHtlbGVtZW50fSBlIFRoZSBlbGVtZW50IHRvIHRvZ2dsZS5cbiAqXG4gKiBAcmV0dXJuIHtlbGVtZW50fSAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIHRvZ2dsZWQuXG4gKi9cbndpbmRvdy50b2dnbGUgPSBmdW5jdGlvbihlKSB7XG4gIGlmIChlIGluc3RhbmNlb2YgTm9kZUxpc3QpIHtcbiAgICBlLmZvckVhY2godG9nZ2xlKTtcbiAgICByZXR1cm4gZTtcbiAgfVxuXG4gIGlmIChlLnN0eWxlLmRpc3BsYXkgPT09ICdpbmhlcml0Jykge1xuICAgIHJldHVybiBoaWRlKGUpO1xuICB9XG5cbiAgcmV0dXJuIHNob3coZSk7XG59XG5cbi8qKlxuICogSGlkZSBhbiBlbGVtZW50IG9yIGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSAge2VsZW1lbnR8Tm9kZUxpc3R9IGUgVGhlIGVsZW1lbnQocykgdG8gaGlkZVxuICpcbiAqIEByZXR1cm4ge2VsZW1lbnR9IFRoZSBlbGVtZW50IGhpZGRlblxuICovXG53aW5kb3cuaGlkZSA9IGZ1bmN0aW9uKGUpIHtcbiAgaWYgKGUgaW5zdGFuY2VvZiBOb2RlTGlzdCkge1xuICAgIGUuZm9yRWFjaChoaWRlKTtcbiAgfSBlbHNlIHtcbiAgICBlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH1cblxuICByZXR1cm4gZTtcbn1cblxuLyoqXG4gKiBVbmhpZGUgYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gIHtlbGVtZW50fSBlIFRoZSBlbGVtZW50IHRvIHVuaGlkZS5cbiAqXG4gKiBAcmV0dXJuIHtlbGVtZW50fSBUaGUgZWxlbWVudCB1bmhpZGRlblxuICovXG53aW5kb3cuc2hvdyA9IGZ1bmN0aW9uKGUpIHtcbiAgaWYgKGUgaW5zdGFuY2VvZiBOb2RlTGlzdCkge1xuICAgIGUuZm9yRWFjaChoaWRlKTtcbiAgfSBlbHNlIHtcbiAgICBlLnN0eWxlLmRpc3BsYXkgPSAnaW5oZXJpdCc7XG4gIH1cblxuICByZXR1cm4gZTtcbn1cbiJdfQ==\n\n\"use strict\";var _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {return typeof obj;} : function (obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;}; /** \n                                                                                                                                                                                                                                                                                        * carousel-js - v3.1.1.\n                                                                                                                                                                                                                                                                                        * git://github.com/mkay581/carousel-js.git\n                                                                                                                                                                                                                                                                                        * Copyright 2016 Mark Kennedy. Licensed MIT.\n                                                                                                                                                                                                                                                                                        */\n\n(function (f) {if ((typeof exports === \"undefined\" ? \"undefined\" : _typeof2(exports)) === \"object\" && typeof module !== \"undefined\") {module.exports = f();} else if (typeof define === \"function\" && define.amd) {define([], f);} else {var g;if (typeof window !== \"undefined\") {g = window;} else if (typeof global !== \"undefined\") {g = global;} else if (typeof self !== \"undefined\") {g = self;} else {g = this;}g.Carousel = f();}})(function () {var define, module, exports;return function e(t, n, r) {function s(o, u) {if (!n[o]) {if (!t[o]) {var a = typeof require == \"function\" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error(\"Cannot find module '\" + o + \"'\");throw f.code = \"MODULE_NOT_FOUND\", f;}var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {var n = t[o][1][e];return s(n ? n : e);}, l, l.exports, e, t, n, r);}return n[o].exports;}var i = typeof require == \"function\" && require;for (var o = 0; o < r.length; o++) {s(r[o]);}return s;}({ 1: [function (require, module, exports) {\n      (function (process, __filename) {\n        /** vim: et:ts=4:sw=4:sts=4\n                                        * @license amdefine 1.0.1 Copyright (c) 2011-2016, The Dojo Foundation All Rights Reserved.\n                                        * Available via the MIT or new BSD license.\n                                        * see: http://github.com/jrburke/amdefine for details\n                                        */\n\n        /*jslint node: true */\n        /*global module, process */\n        'use strict';\n\n        /**\n                       * Creates a define for node.\n                       * @param {Object} module the \"module\" object that is defined by Node for the\n                       * current module.\n                       * @param {Function} [requireFn]. Node's require function for the current module.\n                       * It only needs to be passed in Node versions before 0.5, when module.require\n                       * did not exist.\n                       * @returns {Function} a define function that is usable for the current node\n                       * module.\n                       */\n        function amdefine(module, requireFn) {\n          'use strict';\n          var defineCache = {},\n          loaderCache = {},\n          alreadyCalled = false,\n          path = require('path'),\n          makeRequire,_stringRequire;\n\n          /**\n                                       * Trims the . and .. from an array of path segments.\n                                       * It will keep a leading path segment if a .. will become\n                                       * the first path segment, to help with module name lookups,\n                                       * which act like paths, but can be remapped. But the end result,\n                                       * all paths that use this function should look normalized.\n                                       * NOTE: this method MODIFIES the input array.\n                                       * @param {Array} ary the array of path segments.\n                                       */\n          function trimDots(ary) {\n            var i, part;\n            for (i = 0; ary[i]; i += 1) {\n              part = ary[i];\n              if (part === '.') {\n                ary.splice(i, 1);\n                i -= 1;\n              } else if (part === '..') {\n                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {\n                  //End of the line. Keep at least one non-dot\n                  //path segment at the front so it can be mapped\n                  //correctly to disk. Otherwise, there is likely\n                  //no path mapping for a path starting with '..'.\n                  //This can still fail, but catches the most reasonable\n                  //uses of ..\n                  break;\n                } else if (i > 0) {\n                  ary.splice(i - 1, 2);\n                  i -= 2;\n                }\n              }\n            }\n          }\n\n          function normalize(name, baseName) {\n            var baseParts;\n\n            //Adjust any relative paths.\n            if (name && name.charAt(0) === '.') {\n              //If have a base name, try to normalize against it,\n              //otherwise, assume it is a top-level require that will\n              //be relative to baseUrl in the end.\n              if (baseName) {\n                baseParts = baseName.split('/');\n                baseParts = baseParts.slice(0, baseParts.length - 1);\n                baseParts = baseParts.concat(name.split('/'));\n                trimDots(baseParts);\n                name = baseParts.join('/');\n              }\n            }\n\n            return name;\n          }\n\n          /**\n             * Create the normalize() function passed to a loader plugin's\n             * normalize method.\n             */\n          function makeNormalize(relName) {\n            return function (name) {\n              return normalize(name, relName);\n            };\n          }\n\n          function makeLoad(id) {\n            function load(value) {\n              loaderCache[id] = value;\n            }\n\n            load.fromText = function (id, text) {\n              //This one is difficult because the text can/probably uses\n              //define, and any relative paths and requires should be relative\n              //to that id was it would be found on disk. But this would require\n              //bootstrapping a module/require fairly deeply from node core.\n              //Not sure how best to go about that yet.\n              throw new Error('amdefine does not implement load.fromText');\n            };\n\n            return load;\n          }\n\n          makeRequire = function makeRequire(systemRequire, exports, module, relId) {\n            function amdRequire(deps, callback) {\n              if (typeof deps === 'string') {\n                //Synchronous, single module require('')\n                return _stringRequire(systemRequire, exports, module, deps, relId);\n              } else {\n                //Array of dependencies with a callback.\n\n                //Convert the dependencies to modules.\n                deps = deps.map(function (depName) {\n                  return _stringRequire(systemRequire, exports, module, depName, relId);\n                });\n\n                //Wait for next tick to call back the require call.\n                if (callback) {\n                  process.nextTick(function () {\n                    callback.apply(null, deps);\n                  });\n                }\n              }\n            }\n\n            amdRequire.toUrl = function (filePath) {\n              if (filePath.indexOf('.') === 0) {\n                return normalize(filePath, path.dirname(module.filename));\n              } else {\n                return filePath;\n              }\n            };\n\n            return amdRequire;\n          };\n\n          //Favor explicit value, passed in if the module wants to support Node 0.4.\n          requireFn = requireFn || function req() {\n            return module.require.apply(module, arguments);\n          };\n\n          function runFactory(id, deps, factory) {\n            var r, e, m, result;\n\n            if (id) {\n              e = loaderCache[id] = {};\n              m = {\n                id: id,\n                uri: __filename,\n                exports: e };\n\n              r = makeRequire(requireFn, e, m, id);\n            } else {\n              //Only support one define call per file\n              if (alreadyCalled) {\n                throw new Error('amdefine with no module ID cannot be called more than once per file.');\n              }\n              alreadyCalled = true;\n\n              //Use the real variables from node\n              //Use module.exports for exports, since\n              //the exports in here is amdefine exports.\n              e = module.exports;\n              m = module;\n              r = makeRequire(requireFn, e, m, module.id);\n            }\n\n            //If there are dependencies, they are strings, so need\n            //to convert them to dependency values.\n            if (deps) {\n              deps = deps.map(function (depName) {\n                return r(depName);\n              });\n            }\n\n            //Call the factory with the right dependencies.\n            if (typeof factory === 'function') {\n              result = factory.apply(m.exports, deps);\n            } else {\n              result = factory;\n            }\n\n            if (result !== undefined) {\n              m.exports = result;\n              if (id) {\n                loaderCache[id] = m.exports;\n              }\n            }\n          }\n\n          _stringRequire = function stringRequire(systemRequire, exports, module, id, relId) {\n            //Split the ID by a ! so that\n            var index = id.indexOf('!'),\n            originalId = id,\n            prefix,plugin;\n\n            if (index === -1) {\n              id = normalize(id, relId);\n\n              //Straight module lookup. If it is one of the special dependencies,\n              //deal with it, otherwise, delegate to node.\n              if (id === 'require') {\n                return makeRequire(systemRequire, exports, module, relId);\n              } else if (id === 'exports') {\n                return exports;\n              } else if (id === 'module') {\n                return module;\n              } else if (loaderCache.hasOwnProperty(id)) {\n                return loaderCache[id];\n              } else if (defineCache[id]) {\n                runFactory.apply(null, defineCache[id]);\n                return loaderCache[id];\n              } else {\n                if (systemRequire) {\n                  return systemRequire(originalId);\n                } else {\n                  throw new Error('No module with ID: ' + id);\n                }\n              }\n            } else {\n              //There is a plugin in play.\n              prefix = id.substring(0, index);\n              id = id.substring(index + 1, id.length);\n\n              plugin = _stringRequire(systemRequire, exports, module, prefix, relId);\n\n              if (plugin.normalize) {\n                id = plugin.normalize(id, makeNormalize(relId));\n              } else {\n                //Normalize the ID normally.\n                id = normalize(id, relId);\n              }\n\n              if (loaderCache[id]) {\n                return loaderCache[id];\n              } else {\n                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});\n\n                return loaderCache[id];\n              }\n            }\n          };\n\n          //Create a define function specific to the module asking for amdefine.\n          function define(id, deps, factory) {\n            if (Array.isArray(id)) {\n              factory = deps;\n              deps = id;\n              id = undefined;\n            } else if (typeof id !== 'string') {\n              factory = id;\n              id = deps = undefined;\n            }\n\n            if (deps && !Array.isArray(deps)) {\n              factory = deps;\n              deps = undefined;\n            }\n\n            if (!deps) {\n              deps = ['require', 'exports', 'module'];\n            }\n\n            //Set up properties for this module. If an ID, then use\n            //internal cache. If no ID, then use the external variables\n            //for this node module.\n            if (id) {\n              //Put the module in deep freeze until there is a\n              //require call for it.\n              defineCache[id] = [id, deps, factory];\n            } else {\n              runFactory(id, deps, factory);\n            }\n          }\n\n          //define.require, which has access to all the values in the\n          //cache. Useful for AMD modules that all have IDs in the file,\n          //but need to finally export a value to node based on one of those\n          //IDs.\n          define.require = function (id) {\n            if (loaderCache[id]) {\n              return loaderCache[id];\n            }\n\n            if (defineCache[id]) {\n              runFactory.apply(null, defineCache[id]);\n              return loaderCache[id];\n            }\n          };\n\n          define.amd = {};\n\n          return define;\n        }\n\n        module.exports = amdefine;\n\n      }).call(this, require('_process'), \"/node_modules/amdefine/amdefine.js\");\n    }, { \"_process\": 65, \"path\": 64 }], 2: [function (require, module, exports) {\n      \"use strict\";\n\n      // rawAsap provides everything we need except exception management.\n      var rawAsap = require(\"./raw\");\n      // RawTasks are recycled to reduce GC churn.\n      var freeTasks = [];\n      // We queue errors to ensure they are thrown in right order (FIFO).\n      // Array-as-queue is good enough here, since we are just dealing with exceptions.\n      var pendingErrors = [];\n      var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);\n\n      function throwFirstError() {\n        if (pendingErrors.length) {\n          throw pendingErrors.shift();\n        }\n      }\n\n      /**\n         * Calls a task as soon as possible after returning, in its own event, with priority\n         * over other events like animation, reflow, and repaint. An error thrown from an\n         * event will not interrupt, nor even substantially slow down the processing of\n         * other events, but will be rather postponed to a lower priority event.\n         * @param {{call}} task A callable object, typically a function that takes no\n         * arguments.\n         */\n      module.exports = asap;\n      function asap(task) {\n        var rawTask;\n        if (freeTasks.length) {\n          rawTask = freeTasks.pop();\n        } else {\n          rawTask = new RawTask();\n        }\n        rawTask.task = task;\n        rawAsap(rawTask);\n      }\n\n      // We wrap tasks with recyclable task objects.  A task object implements\n      // `call`, just like a function.\n      function RawTask() {\n        this.task = null;\n      }\n\n      // The sole purpose of wrapping the task is to catch the exception and recycle\n      // the task object after its single use.\n      RawTask.prototype.call = function () {\n        try {\n          this.task.call();\n        } catch (error) {\n          if (asap.onerror) {\n            // This hook exists purely for testing purposes.\n            // Its name will be periodically randomized to break any code that\n            // depends on its existence.\n            asap.onerror(error);\n          } else {\n            // In a web browser, exceptions are not fatal. However, to avoid\n            // slowing down the queue of pending tasks, we rethrow the error in a\n            // lower priority turn.\n            pendingErrors.push(error);\n            requestErrorThrow();\n          }\n        } finally {\n          this.task = null;\n          freeTasks[freeTasks.length] = this;\n        }\n      };\n\n    }, { \"./raw\": 3 }], 3: [function (require, module, exports) {\n      (function (global) {\n        \"use strict\";\n\n        // Use the fastest means possible to execute a task in its own turn, with\n        // priority over other events including IO, animation, reflow, and redraw\n        // events in browsers.\n        //\n        // An exception thrown by a task will permanently interrupt the processing of\n        // subsequent tasks. The higher level `asap` function ensures that if an\n        // exception is thrown by a task, that the task queue will continue flushing as\n        // soon as possible, but if you use `rawAsap` directly, you are responsible to\n        // either ensure that no exceptions are thrown from your task, or to manually\n        // call `rawAsap.requestFlush` if an exception is thrown.\n        module.exports = rawAsap;\n        function rawAsap(task) {\n          if (!queue.length) {\n            requestFlush();\n            flushing = true;\n          }\n          // Equivalent to push, but avoids a function call.\n          queue[queue.length] = task;\n        }\n\n        var queue = [];\n        // Once a flush has been requested, no further calls to `requestFlush` are\n        // necessary until the next `flush` completes.\n        var flushing = false;\n        // `requestFlush` is an implementation-specific method that attempts to kick\n        // off a `flush` event as quickly as possible. `flush` will attempt to exhaust\n        // the event queue before yielding to the browser's own event loop.\n        var requestFlush;\n        // The position of the next task to execute in the task queue. This is\n        // preserved between calls to `flush` so that it can be resumed if\n        // a task throws an exception.\n        var index = 0;\n        // If a task schedules additional tasks recursively, the task queue can grow\n        // unbounded. To prevent memory exhaustion, the task queue will periodically\n        // truncate already-completed tasks.\n        var capacity = 1024;\n\n        // The flush function processes all tasks that have been scheduled with\n        // `rawAsap` unless and until one of those tasks throws an exception.\n        // If a task throws an exception, `flush` ensures that its state will remain\n        // consistent and will resume where it left off when called again.\n        // However, `flush` does not make any arrangements to be called again if an\n        // exception is thrown.\n        function flush() {\n          while (index < queue.length) {\n            var currentIndex = index;\n            // Advance the index before calling the task. This ensures that we will\n            // begin flushing on the next task the task throws an error.\n            index = index + 1;\n            queue[currentIndex].call();\n            // Prevent leaking memory for long chains of recursive calls to `asap`.\n            // If we call `asap` within tasks scheduled by `asap`, the queue will\n            // grow, but to avoid an O(n) walk for every task we execute, we don't\n            // shift tasks off the queue after they have been executed.\n            // Instead, we periodically shift 1024 tasks off the queue.\n            if (index > capacity) {\n              // Manually shift all values starting at the index back to the\n              // beginning of the queue.\n              for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n              }\n              queue.length -= index;\n              index = 0;\n            }\n          }\n          queue.length = 0;\n          index = 0;\n          flushing = false;\n        }\n\n        // `requestFlush` is implemented using a strategy based on data collected from\n        // every available SauceLabs Selenium web driver worker at time of writing.\n        // https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\n        // Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n        // have WebKitMutationObserver but not un-prefixed MutationObserver.\n        // Must use `global` or `self` instead of `window` to work in both frames and web\n        // workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n\n        /* globals self */\n        var scope = typeof global !== \"undefined\" ? global : self;\n        var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;\n\n        // MutationObservers are desirable because they have high priority and work\n        // reliably everywhere they are implemented.\n        // They are implemented in all modern browsers.\n        //\n        // - Android 4-4.3\n        // - Chrome 26-34\n        // - Firefox 14-29\n        // - Internet Explorer 11\n        // - iPad Safari 6-7.1\n        // - iPhone Safari 7-7.1\n        // - Safari 6-7\n        if (typeof BrowserMutationObserver === \"function\") {\n          requestFlush = makeRequestCallFromMutationObserver(flush);\n\n          // MessageChannels are desirable because they give direct access to the HTML\n          // task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n          // 11-12, and in web workers in many engines.\n          // Although message channels yield to any queued rendering and IO tasks, they\n          // would be better than imposing the 4ms delay of timers.\n          // However, they do not work reliably in Internet Explorer or Safari.\n\n          // Internet Explorer 10 is the only browser that has setImmediate but does\n          // not have MutationObservers.\n          // Although setImmediate yields to the browser's renderer, it would be\n          // preferrable to falling back to setTimeout since it does not have\n          // the minimum 4ms penalty.\n          // Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n          // Desktop to a lesser extent) that renders both setImmediate and\n          // MessageChannel useless for the purposes of ASAP.\n          // https://github.com/kriskowal/q/issues/396\n\n          // Timers are implemented universally.\n          // We fall back to timers in workers in most engines, and in foreground\n          // contexts in the following browsers.\n          // However, note that even this simple case requires nuances to operate in a\n          // broad spectrum of browsers.\n          //\n          // - Firefox 3-13\n          // - Internet Explorer 6-9\n          // - iPad Safari 4.3\n          // - Lynx 2.8.7\n        } else {\n          requestFlush = makeRequestCallFromTimer(flush);\n        }\n\n        // `requestFlush` requests that the high priority event queue be flushed as\n        // soon as possible.\n        // This is useful to prevent an error thrown in a task from stalling the event\n        // queue if the exception handled by Node.js’s\n        // `process.on(\"uncaughtException\")` or by a domain.\n        rawAsap.requestFlush = requestFlush;\n\n        // To request a high priority event, we induce a mutation observer by toggling\n        // the text of a text node between \"1\" and \"-1\".\n        function makeRequestCallFromMutationObserver(callback) {\n          var toggle = 1;\n          var observer = new BrowserMutationObserver(callback);\n          var node = document.createTextNode(\"\");\n          observer.observe(node, { characterData: true });\n          return function requestCall() {\n            toggle = -toggle;\n            node.data = toggle;\n          };\n        }\n\n        // The message channel technique was discovered by Malte Ubl and was the\n        // original foundation for this library.\n        // http://www.nonblocking.io/2011/06/windownexttick.html\n\n        // Safari 6.0.5 (at least) intermittently fails to create message ports on a\n        // page's first load. Thankfully, this version of Safari supports\n        // MutationObservers, so we don't need to fall back in that case.\n\n        // function makeRequestCallFromMessageChannel(callback) {\n        //     var channel = new MessageChannel();\n        //     channel.port1.onmessage = callback;\n        //     return function requestCall() {\n        //         channel.port2.postMessage(0);\n        //     };\n        // }\n\n        // For reasons explained above, we are also unable to use `setImmediate`\n        // under any circumstances.\n        // Even if we were, there is another bug in Internet Explorer 10.\n        // It is not sufficient to assign `setImmediate` to `requestFlush` because\n        // `setImmediate` must be called *by name* and therefore must be wrapped in a\n        // closure.\n        // Never forget.\n\n        // function makeRequestCallFromSetImmediate(callback) {\n        //     return function requestCall() {\n        //         setImmediate(callback);\n        //     };\n        // }\n\n        // Safari 6.0 has a problem where timers will get lost while the user is\n        // scrolling. This problem does not impact ASAP because Safari 6.0 supports\n        // mutation observers, so that implementation is used instead.\n        // However, if we ever elect to use timers in Safari, the prevalent work-around\n        // is to add a scroll event listener that calls for a flush.\n\n        // `setTimeout` does not call the passed callback if the delay is less than\n        // approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n        // even then.\n\n        function makeRequestCallFromTimer(callback) {\n          return function requestCall() {\n            // We dispatch a timeout with a specified delay of 0 for engines that\n            // can reliably accommodate that request. This will usually be snapped\n            // to a 4 milisecond delay, but once we're flushing, there's no delay\n            // between events.\n            var timeoutHandle = setTimeout(handleTimer, 0);\n            // However, since this timer gets frequently dropped in Firefox\n            // workers, we enlist an interval handle that will try to fire\n            // an event 20 times per second until it succeeds.\n            var intervalHandle = setInterval(handleTimer, 50);\n\n            function handleTimer() {\n              // Whichever timer succeeds will cancel both timers and\n              // execute the callback.\n              clearTimeout(timeoutHandle);\n              clearInterval(intervalHandle);\n              callback();\n            }\n          };\n        }\n\n        // This is for `asap.js` only.\n        // Its name will be periodically randomized to break any code that depends on\n        // its existence.\n        rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;\n\n        // ASAP was originally a nextTick shim included in Q. This was factored out\n        // into this ASAP package. It was later adapted to RSVP which made further\n        // amendments. These decisions, particularly to marginalize MessageChannel and\n        // to capture the MutationObserver implementation in a closure, were integrated\n        // back into ASAP proper.\n        // https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n\n      }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {}], 4: [function (require, module, exports) {\n      (function (process, global) {\n        /*!\n                                    * @overview es6-promise - a tiny implementation of Promises/A+.\n                                    * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n                                    * @license   Licensed under MIT license\n                                    *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE\n                                    * @version   4.0.5\n                                    */\n\n        (function (global, factory) {\n          (typeof exports === \"undefined\" ? \"undefined\" : _typeof2(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n          typeof define === 'function' && define.amd ? define(factory) :\n          global.ES6Promise = factory();\n        })(this, function () {'use strict';\n\n          function objectOrFunction(x) {\n            return typeof x === 'function' || (typeof x === \"undefined\" ? \"undefined\" : _typeof2(x)) === 'object' && x !== null;\n          }\n\n          function isFunction(x) {\n            return typeof x === 'function';\n          }\n\n          var _isArray = undefined;\n          if (!Array.isArray) {\n            _isArray = function _isArray(x) {\n              return Object.prototype.toString.call(x) === '[object Array]';\n            };\n          } else {\n            _isArray = Array.isArray;\n          }\n\n          var isArray = _isArray;\n\n          var len = 0;\n          var vertxNext = undefined;\n          var customSchedulerFn = undefined;\n\n          var asap = function asap(callback, arg) {\n            queue[len] = callback;\n            queue[len + 1] = arg;\n            len += 2;\n            if (len === 2) {\n              // If len is 2, that means that we need to schedule an async flush.\n              // If additional callbacks are queued before the queue is flushed, they\n              // will be processed by this flush that we are scheduling.\n              if (customSchedulerFn) {\n                customSchedulerFn(flush);\n              } else {\n                scheduleFlush();\n              }\n            }\n          };\n\n          function setScheduler(scheduleFn) {\n            customSchedulerFn = scheduleFn;\n          }\n\n          function setAsap(asapFn) {\n            asap = asapFn;\n          }\n\n          var browserWindow = typeof window !== 'undefined' ? window : undefined;\n          var browserGlobal = browserWindow || {};\n          var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\n          var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n          // test for web worker but not in IE10\n          var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';\n\n          // node\n          function useNextTick() {\n            // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n            // see https://github.com/cujojs/when/issues/410 for details\n            return function () {\n              return process.nextTick(flush);\n            };\n          }\n\n          // vertx\n          function useVertxTimer() {\n            if (typeof vertxNext !== 'undefined') {\n              return function () {\n                vertxNext(flush);\n              };\n            }\n\n            return useSetTimeout();\n          }\n\n          function useMutationObserver() {\n            var iterations = 0;\n            var observer = new BrowserMutationObserver(flush);\n            var node = document.createTextNode('');\n            observer.observe(node, { characterData: true });\n\n            return function () {\n              node.data = iterations = ++iterations % 2;\n            };\n          }\n\n          // web worker\n          function useMessageChannel() {\n            var channel = new MessageChannel();\n            channel.port1.onmessage = flush;\n            return function () {\n              return channel.port2.postMessage(0);\n            };\n          }\n\n          function useSetTimeout() {\n            // Store setTimeout reference so es6-promise will be unaffected by\n            // other code modifying setTimeout (like sinon.useFakeTimers())\n            var globalSetTimeout = setTimeout;\n            return function () {\n              return globalSetTimeout(flush, 1);\n            };\n          }\n\n          var queue = new Array(1000);\n          function flush() {\n            for (var i = 0; i < len; i += 2) {\n              var callback = queue[i];\n              var arg = queue[i + 1];\n\n              callback(arg);\n\n              queue[i] = undefined;\n              queue[i + 1] = undefined;\n            }\n\n            len = 0;\n          }\n\n          function attemptVertx() {\n            try {\n              var r = require;\n              var vertx = r('vertx');\n              vertxNext = vertx.runOnLoop || vertx.runOnContext;\n              return useVertxTimer();\n            } catch (e) {\n              return useSetTimeout();\n            }\n          }\n\n          var scheduleFlush = undefined;\n          // Decide what async method to use to triggering processing of queued callbacks:\n          if (isNode) {\n            scheduleFlush = useNextTick();\n          } else if (BrowserMutationObserver) {\n            scheduleFlush = useMutationObserver();\n          } else if (isWorker) {\n            scheduleFlush = useMessageChannel();\n          } else if (browserWindow === undefined && typeof require === 'function') {\n            scheduleFlush = attemptVertx();\n          } else {\n            scheduleFlush = useSetTimeout();\n          }\n\n          function then(onFulfillment, onRejection) {\n            var _arguments = arguments;\n\n            var parent = this;\n\n            var child = new this.constructor(noop);\n\n            if (child[PROMISE_ID] === undefined) {\n              makePromise(child);\n            }\n\n            var _state = parent._state;\n\n            if (_state) {\n              (function () {\n                var callback = _arguments[_state - 1];\n                asap(function () {\n                  return invokeCallback(_state, child, callback, parent._result);\n                });\n              })();\n            } else {\n              subscribe(parent, child, onFulfillment, onRejection);\n            }\n\n            return child;\n          }\n\n          /**\n              `Promise.resolve` returns a promise that will become resolved with the\n              passed `value`. It is shorthand for the following:\n            \n              ```javascript\n              let promise = new Promise(function(resolve, reject){\n                resolve(1);\n              });\n            \n              promise.then(function(value){\n                // value === 1\n              });\n              ```\n            \n              Instead of writing the above, your code now simply becomes the following:\n            \n              ```javascript\n              let promise = Promise.resolve(1);\n            \n              promise.then(function(value){\n                // value === 1\n              });\n              ```\n            \n              @method resolve\n              @static\n              @param {Any} value value that the returned promise will be resolved with\n              Useful for tooling.\n              @return {Promise} a promise that will become fulfilled with the given\n              `value`\n            */\n          function resolve(object) {\n            /*jshint validthis:true */\n            var Constructor = this;\n\n            if (object && (typeof object === \"undefined\" ? \"undefined\" : _typeof2(object)) === 'object' && object.constructor === Constructor) {\n              return object;\n            }\n\n            var promise = new Constructor(noop);\n            _resolve(promise, object);\n            return promise;\n          }\n\n          var PROMISE_ID = Math.random().toString(36).substring(16);\n\n          function noop() {}\n\n          var PENDING = void 0;\n          var FULFILLED = 1;\n          var REJECTED = 2;\n\n          var GET_THEN_ERROR = new ErrorObject();\n\n          function selfFulfillment() {\n            return new TypeError(\"You cannot resolve a promise with itself\");\n          }\n\n          function cannotReturnOwn() {\n            return new TypeError('A promises callback cannot return that same promise.');\n          }\n\n          function getThen(promise) {\n            try {\n              return promise.then;\n            } catch (error) {\n              GET_THEN_ERROR.error = error;\n              return GET_THEN_ERROR;\n            }\n          }\n\n          function tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n            try {\n              then.call(value, fulfillmentHandler, rejectionHandler);\n            } catch (e) {\n              return e;\n            }\n          }\n\n          function handleForeignThenable(promise, thenable, then) {\n            asap(function (promise) {\n              var sealed = false;\n              var error = tryThen(then, thenable, function (value) {\n                if (sealed) {\n                  return;\n                }\n                sealed = true;\n                if (thenable !== value) {\n                  _resolve(promise, value);\n                } else {\n                  fulfill(promise, value);\n                }\n              }, function (reason) {\n                if (sealed) {\n                  return;\n                }\n                sealed = true;\n\n                _reject(promise, reason);\n              }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n              if (!sealed && error) {\n                sealed = true;\n                _reject(promise, error);\n              }\n            }, promise);\n          }\n\n          function handleOwnThenable(promise, thenable) {\n            if (thenable._state === FULFILLED) {\n              fulfill(promise, thenable._result);\n            } else if (thenable._state === REJECTED) {\n              _reject(promise, thenable._result);\n            } else {\n              subscribe(thenable, undefined, function (value) {\n                return _resolve(promise, value);\n              }, function (reason) {\n                return _reject(promise, reason);\n              });\n            }\n          }\n\n          function handleMaybeThenable(promise, maybeThenable, then$$) {\n            if (maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve) {\n              handleOwnThenable(promise, maybeThenable);\n            } else {\n              if (then$$ === GET_THEN_ERROR) {\n                _reject(promise, GET_THEN_ERROR.error);\n              } else if (then$$ === undefined) {\n                fulfill(promise, maybeThenable);\n              } else if (isFunction(then$$)) {\n                handleForeignThenable(promise, maybeThenable, then$$);\n              } else {\n                fulfill(promise, maybeThenable);\n              }\n            }\n          }\n\n          function _resolve(promise, value) {\n            if (promise === value) {\n              _reject(promise, selfFulfillment());\n            } else if (objectOrFunction(value)) {\n              handleMaybeThenable(promise, value, getThen(value));\n            } else {\n              fulfill(promise, value);\n            }\n          }\n\n          function publishRejection(promise) {\n            if (promise._onerror) {\n              promise._onerror(promise._result);\n            }\n\n            publish(promise);\n          }\n\n          function fulfill(promise, value) {\n            if (promise._state !== PENDING) {\n              return;\n            }\n\n            promise._result = value;\n            promise._state = FULFILLED;\n\n            if (promise._subscribers.length !== 0) {\n              asap(publish, promise);\n            }\n          }\n\n          function _reject(promise, reason) {\n            if (promise._state !== PENDING) {\n              return;\n            }\n            promise._state = REJECTED;\n            promise._result = reason;\n\n            asap(publishRejection, promise);\n          }\n\n          function subscribe(parent, child, onFulfillment, onRejection) {\n            var _subscribers = parent._subscribers;\n            var length = _subscribers.length;\n\n            parent._onerror = null;\n\n            _subscribers[length] = child;\n            _subscribers[length + FULFILLED] = onFulfillment;\n            _subscribers[length + REJECTED] = onRejection;\n\n            if (length === 0 && parent._state) {\n              asap(publish, parent);\n            }\n          }\n\n          function publish(promise) {\n            var subscribers = promise._subscribers;\n            var settled = promise._state;\n\n            if (subscribers.length === 0) {\n              return;\n            }\n\n            var child = undefined,\n            callback = undefined,\n            detail = promise._result;\n\n            for (var i = 0; i < subscribers.length; i += 3) {\n              child = subscribers[i];\n              callback = subscribers[i + settled];\n\n              if (child) {\n                invokeCallback(settled, child, callback, detail);\n              } else {\n                callback(detail);\n              }\n            }\n\n            promise._subscribers.length = 0;\n          }\n\n          function ErrorObject() {\n            this.error = null;\n          }\n\n          var TRY_CATCH_ERROR = new ErrorObject();\n\n          function tryCatch(callback, detail) {\n            try {\n              return callback(detail);\n            } catch (e) {\n              TRY_CATCH_ERROR.error = e;\n              return TRY_CATCH_ERROR;\n            }\n          }\n\n          function invokeCallback(settled, promise, callback, detail) {\n            var hasCallback = isFunction(callback),\n            value = undefined,\n            error = undefined,\n            succeeded = undefined,\n            failed = undefined;\n\n            if (hasCallback) {\n              value = tryCatch(callback, detail);\n\n              if (value === TRY_CATCH_ERROR) {\n                failed = true;\n                error = value.error;\n                value = null;\n              } else {\n                succeeded = true;\n              }\n\n              if (promise === value) {\n                _reject(promise, cannotReturnOwn());\n                return;\n              }\n            } else {\n              value = detail;\n              succeeded = true;\n            }\n\n            if (promise._state !== PENDING) {\n              // noop\n            } else if (hasCallback && succeeded) {\n              _resolve(promise, value);\n            } else if (failed) {\n              _reject(promise, error);\n            } else if (settled === FULFILLED) {\n              fulfill(promise, value);\n            } else if (settled === REJECTED) {\n              _reject(promise, value);\n            }\n          }\n\n          function initializePromise(promise, resolver) {\n            try {\n              resolver(function resolvePromise(value) {\n                _resolve(promise, value);\n              }, function rejectPromise(reason) {\n                _reject(promise, reason);\n              });\n            } catch (e) {\n              _reject(promise, e);\n            }\n          }\n\n          var id = 0;\n          function nextId() {\n            return id++;\n          }\n\n          function makePromise(promise) {\n            promise[PROMISE_ID] = id++;\n            promise._state = undefined;\n            promise._result = undefined;\n            promise._subscribers = [];\n          }\n\n          function Enumerator(Constructor, input) {\n            this._instanceConstructor = Constructor;\n            this.promise = new Constructor(noop);\n\n            if (!this.promise[PROMISE_ID]) {\n              makePromise(this.promise);\n            }\n\n            if (isArray(input)) {\n              this._input = input;\n              this.length = input.length;\n              this._remaining = input.length;\n\n              this._result = new Array(this.length);\n\n              if (this.length === 0) {\n                fulfill(this.promise, this._result);\n              } else {\n                this.length = this.length || 0;\n                this._enumerate();\n                if (this._remaining === 0) {\n                  fulfill(this.promise, this._result);\n                }\n              }\n            } else {\n              _reject(this.promise, validationError());\n            }\n          }\n\n          function validationError() {\n            return new Error('Array Methods must be provided an Array');\n          };\n\n          Enumerator.prototype._enumerate = function () {\n            var length = this.length;\n            var _input = this._input;\n\n            for (var i = 0; this._state === PENDING && i < length; i++) {\n              this._eachEntry(_input[i], i);\n            }\n          };\n\n          Enumerator.prototype._eachEntry = function (entry, i) {\n            var c = this._instanceConstructor;\n            var resolve$$ = c.resolve;\n\n            if (resolve$$ === resolve) {\n              var _then = getThen(entry);\n\n              if (_then === then && entry._state !== PENDING) {\n                this._settledAt(entry._state, i, entry._result);\n              } else if (typeof _then !== 'function') {\n                this._remaining--;\n                this._result[i] = entry;\n              } else if (c === Promise) {\n                var promise = new c(noop);\n                handleMaybeThenable(promise, entry, _then);\n                this._willSettleAt(promise, i);\n              } else {\n                this._willSettleAt(new c(function (resolve$$) {\n                  return resolve$$(entry);\n                }), i);\n              }\n            } else {\n              this._willSettleAt(resolve$$(entry), i);\n            }\n          };\n\n          Enumerator.prototype._settledAt = function (state, i, value) {\n            var promise = this.promise;\n\n            if (promise._state === PENDING) {\n              this._remaining--;\n\n              if (state === REJECTED) {\n                _reject(promise, value);\n              } else {\n                this._result[i] = value;\n              }\n            }\n\n            if (this._remaining === 0) {\n              fulfill(promise, this._result);\n            }\n          };\n\n          Enumerator.prototype._willSettleAt = function (promise, i) {\n            var enumerator = this;\n\n            subscribe(promise, undefined, function (value) {\n              return enumerator._settledAt(FULFILLED, i, value);\n            }, function (reason) {\n              return enumerator._settledAt(REJECTED, i, reason);\n            });\n          };\n\n          /**\n               `Promise.all` accepts an array of promises, and returns a new promise which\n               is fulfilled with an array of fulfillment values for the passed promises, or\n               rejected with the reason of the first passed promise to be rejected. It casts all\n               elements of the passed iterable to promises as it runs this algorithm.\n             \n               Example:\n             \n               ```javascript\n               let promise1 = resolve(1);\n               let promise2 = resolve(2);\n               let promise3 = resolve(3);\n               let promises = [ promise1, promise2, promise3 ];\n             \n               Promise.all(promises).then(function(array){\n                 // The array here would be [ 1, 2, 3 ];\n               });\n               ```\n             \n               If any of the `promises` given to `all` are rejected, the first promise\n               that is rejected will be given as an argument to the returned promises's\n               rejection handler. For example:\n             \n               Example:\n             \n               ```javascript\n               let promise1 = resolve(1);\n               let promise2 = reject(new Error(\"2\"));\n               let promise3 = reject(new Error(\"3\"));\n               let promises = [ promise1, promise2, promise3 ];\n             \n               Promise.all(promises).then(function(array){\n                 // Code here never runs because there are rejected promises!\n               }, function(error) {\n                 // error.message === \"2\"\n               });\n               ```\n             \n               @method all\n               @static\n               @param {Array} entries array of promises\n               @param {String} label optional string for labeling the promise.\n               Useful for tooling.\n               @return {Promise} promise that is fulfilled when all `promises` have been\n               fulfilled, or rejected if any of them become rejected.\n               @static\n             */\n          function all(entries) {\n            return new Enumerator(this, entries).promise;\n          }\n\n          /**\n              `Promise.race` returns a new promise which is settled in the same way as the\n              first passed promise to settle.\n            \n              Example:\n            \n              ```javascript\n              let promise1 = new Promise(function(resolve, reject){\n                setTimeout(function(){\n                  resolve('promise 1');\n                }, 200);\n              });\n            \n              let promise2 = new Promise(function(resolve, reject){\n                setTimeout(function(){\n                  resolve('promise 2');\n                }, 100);\n              });\n            \n              Promise.race([promise1, promise2]).then(function(result){\n                // result === 'promise 2' because it was resolved before promise1\n                // was resolved.\n              });\n              ```\n            \n              `Promise.race` is deterministic in that only the state of the first\n              settled promise matters. For example, even if other promises given to the\n              `promises` array argument are resolved, but the first settled promise has\n              become rejected before the other promises became fulfilled, the returned\n              promise will become rejected:\n            \n              ```javascript\n              let promise1 = new Promise(function(resolve, reject){\n                setTimeout(function(){\n                  resolve('promise 1');\n                }, 200);\n              });\n            \n              let promise2 = new Promise(function(resolve, reject){\n                setTimeout(function(){\n                  reject(new Error('promise 2'));\n                }, 100);\n              });\n            \n              Promise.race([promise1, promise2]).then(function(result){\n                // Code here never runs\n              }, function(reason){\n                // reason.message === 'promise 2' because promise 2 became rejected before\n                // promise 1 became fulfilled\n              });\n              ```\n            \n              An example real-world use case is implementing timeouts:\n            \n              ```javascript\n              Promise.race([ajax('foo.json'), timeout(5000)])\n              ```\n            \n              @method race\n              @static\n              @param {Array} promises array of promises to observe\n              Useful for tooling.\n              @return {Promise} a promise which settles in the same way as the first passed\n              promise to settle.\n            */\n          function race(entries) {\n            /*jshint validthis:true */\n            var Constructor = this;\n\n            if (!isArray(entries)) {\n              return new Constructor(function (_, reject) {\n                return reject(new TypeError('You must pass an array to race.'));\n              });\n            } else {\n              return new Constructor(function (resolve, reject) {\n                var length = entries.length;\n                for (var i = 0; i < length; i++) {\n                  Constructor.resolve(entries[i]).then(resolve, reject);\n                }\n              });\n            }\n          }\n\n          /**\n              `Promise.reject` returns a promise rejected with the passed `reason`.\n              It is shorthand for the following:\n            \n              ```javascript\n              let promise = new Promise(function(resolve, reject){\n                reject(new Error('WHOOPS'));\n              });\n            \n              promise.then(function(value){\n                // Code here doesn't run because the promise is rejected!\n              }, function(reason){\n                // reason.message === 'WHOOPS'\n              });\n              ```\n            \n              Instead of writing the above, your code now simply becomes the following:\n            \n              ```javascript\n              let promise = Promise.reject(new Error('WHOOPS'));\n            \n              promise.then(function(value){\n                // Code here doesn't run because the promise is rejected!\n              }, function(reason){\n                // reason.message === 'WHOOPS'\n              });\n              ```\n            \n              @method reject\n              @static\n              @param {Any} reason value that the returned promise will be rejected with.\n              Useful for tooling.\n              @return {Promise} a promise rejected with the given `reason`.\n            */\n          function reject(reason) {\n            /*jshint validthis:true */\n            var Constructor = this;\n            var promise = new Constructor(noop);\n            _reject(promise, reason);\n            return promise;\n          }\n\n          function needsResolver() {\n            throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n          }\n\n          function needsNew() {\n            throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n          }\n\n          /**\n              Promise objects represent the eventual result of an asynchronous operation. The\n              primary way of interacting with a promise is through its `then` method, which\n              registers callbacks to receive either a promise's eventual value or the reason\n              why the promise cannot be fulfilled.\n            \n              Terminology\n              -----------\n            \n              - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n              - `thenable` is an object or function that defines a `then` method.\n              - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n              - `exception` is a value that is thrown using the throw statement.\n              - `reason` is a value that indicates why a promise was rejected.\n              - `settled` the final resting state of a promise, fulfilled or rejected.\n            \n              A promise can be in one of three states: pending, fulfilled, or rejected.\n            \n              Promises that are fulfilled have a fulfillment value and are in the fulfilled\n              state.  Promises that are rejected have a rejection reason and are in the\n              rejected state.  A fulfillment value is never a thenable.\n            \n              Promises can also be said to *resolve* a value.  If this value is also a\n              promise, then the original promise's settled state will match the value's\n              settled state.  So a promise that *resolves* a promise that rejects will\n              itself reject, and a promise that *resolves* a promise that fulfills will\n              itself fulfill.\n            \n            \n              Basic Usage:\n              ------------\n            \n              ```js\n              let promise = new Promise(function(resolve, reject) {\n                // on success\n                resolve(value);\n            \n                // on failure\n                reject(reason);\n              });\n            \n              promise.then(function(value) {\n                // on fulfillment\n              }, function(reason) {\n                // on rejection\n              });\n              ```\n            \n              Advanced Usage:\n              ---------------\n            \n              Promises shine when abstracting away asynchronous interactions such as\n              `XMLHttpRequest`s.\n            \n              ```js\n              function getJSON(url) {\n                return new Promise(function(resolve, reject){\n                  let xhr = new XMLHttpRequest();\n            \n                  xhr.open('GET', url);\n                  xhr.onreadystatechange = handler;\n                  xhr.responseType = 'json';\n                  xhr.setRequestHeader('Accept', 'application/json');\n                  xhr.send();\n            \n                  function handler() {\n                    if (this.readyState === this.DONE) {\n                      if (this.status === 200) {\n                        resolve(this.response);\n                      } else {\n                        reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n                      }\n                    }\n                  };\n                });\n              }\n            \n              getJSON('/posts.json').then(function(json) {\n                // on fulfillment\n              }, function(reason) {\n                // on rejection\n              });\n              ```\n            \n              Unlike callbacks, promises are great composable primitives.\n            \n              ```js\n              Promise.all([\n                getJSON('/posts'),\n                getJSON('/comments')\n              ]).then(function(values){\n                values[0] // => postsJSON\n                values[1] // => commentsJSON\n            \n                return values;\n              });\n              ```\n            \n              @class Promise\n              @param {function} resolver\n              Useful for tooling.\n              @constructor\n            */\n          function Promise(resolver) {\n            this[PROMISE_ID] = nextId();\n            this._result = this._state = undefined;\n            this._subscribers = [];\n\n            if (noop !== resolver) {\n              typeof resolver !== 'function' && needsResolver();\n              this instanceof Promise ? initializePromise(this, resolver) : needsNew();\n            }\n          }\n\n          Promise.all = all;\n          Promise.race = race;\n          Promise.resolve = resolve;\n          Promise.reject = reject;\n          Promise._setScheduler = setScheduler;\n          Promise._setAsap = setAsap;\n          Promise._asap = asap;\n\n          Promise.prototype = {\n            constructor: Promise,\n\n            /**\n                                    The primary way of interacting with a promise is through its `then` method,\n                                    which registers callbacks to receive either a promise's eventual value or the\n                                    reason why the promise cannot be fulfilled.\n                                  \n                                    ```js\n                                    findUser().then(function(user){\n                                      // user is available\n                                    }, function(reason){\n                                      // user is unavailable, and you are given the reason why\n                                    });\n                                    ```\n                                  \n                                    Chaining\n                                    --------\n                                  \n                                    The return value of `then` is itself a promise.  This second, 'downstream'\n                                    promise is resolved with the return value of the first promise's fulfillment\n                                    or rejection handler, or rejected if the handler throws an exception.\n                                  \n                                    ```js\n                                    findUser().then(function (user) {\n                                      return user.name;\n                                    }, function (reason) {\n                                      return 'default name';\n                                    }).then(function (userName) {\n                                      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n                                      // will be `'default name'`\n                                    });\n                                  \n                                    findUser().then(function (user) {\n                                      throw new Error('Found user, but still unhappy');\n                                    }, function (reason) {\n                                      throw new Error('`findUser` rejected and we're unhappy');\n                                    }).then(function (value) {\n                                      // never reached\n                                    }, function (reason) {\n                                      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n                                      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n                                    });\n                                    ```\n                                    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n                                  \n                                    ```js\n                                    findUser().then(function (user) {\n                                      throw new PedagogicalException('Upstream error');\n                                    }).then(function (value) {\n                                      // never reached\n                                    }).then(function (value) {\n                                      // never reached\n                                    }, function (reason) {\n                                      // The `PedgagocialException` is propagated all the way down to here\n                                    });\n                                    ```\n                                  \n                                    Assimilation\n                                    ------------\n                                  \n                                    Sometimes the value you want to propagate to a downstream promise can only be\n                                    retrieved asynchronously. This can be achieved by returning a promise in the\n                                    fulfillment or rejection handler. The downstream promise will then be pending\n                                    until the returned promise is settled. This is called *assimilation*.\n                                  \n                                    ```js\n                                    findUser().then(function (user) {\n                                      return findCommentsByAuthor(user);\n                                    }).then(function (comments) {\n                                      // The user's comments are now available\n                                    });\n                                    ```\n                                  \n                                    If the assimliated promise rejects, then the downstream promise will also reject.\n                                  \n                                    ```js\n                                    findUser().then(function (user) {\n                                      return findCommentsByAuthor(user);\n                                    }).then(function (comments) {\n                                      // If `findCommentsByAuthor` fulfills, we'll have the value here\n                                    }, function (reason) {\n                                      // If `findCommentsByAuthor` rejects, we'll have the reason here\n                                    });\n                                    ```\n                                  \n                                    Simple Example\n                                    --------------\n                                  \n                                    Synchronous Example\n                                  \n                                    ```javascript\n                                    let result;\n                                  \n                                    try {\n                                      result = findResult();\n                                      // success\n                                    } catch(reason) {\n                                      // failure\n                                    }\n                                    ```\n                                  \n                                    Errback Example\n                                  \n                                    ```js\n                                    findResult(function(result, err){\n                                      if (err) {\n                                        // failure\n                                      } else {\n                                        // success\n                                      }\n                                    });\n                                    ```\n                                  \n                                    Promise Example;\n                                  \n                                    ```javascript\n                                    findResult().then(function(result){\n                                      // success\n                                    }, function(reason){\n                                      // failure\n                                    });\n                                    ```\n                                  \n                                    Advanced Example\n                                    --------------\n                                  \n                                    Synchronous Example\n                                  \n                                    ```javascript\n                                    let author, books;\n                                  \n                                    try {\n                                      author = findAuthor();\n                                      books  = findBooksByAuthor(author);\n                                      // success\n                                    } catch(reason) {\n                                      // failure\n                                    }\n                                    ```\n                                  \n                                    Errback Example\n                                  \n                                    ```js\n                                  \n                                    function foundBooks(books) {\n                                  \n                                    }\n                                  \n                                    function failure(reason) {\n                                  \n                                    }\n                                  \n                                    findAuthor(function(author, err){\n                                      if (err) {\n                                        failure(err);\n                                        // failure\n                                      } else {\n                                        try {\n                                          findBoooksByAuthor(author, function(books, err) {\n                                            if (err) {\n                                              failure(err);\n                                            } else {\n                                              try {\n                                                foundBooks(books);\n                                              } catch(reason) {\n                                                failure(reason);\n                                              }\n                                            }\n                                          });\n                                        } catch(error) {\n                                          failure(err);\n                                        }\n                                        // success\n                                      }\n                                    });\n                                    ```\n                                  \n                                    Promise Example;\n                                  \n                                    ```javascript\n                                    findAuthor().\n                                      then(findBooksByAuthor).\n                                      then(function(books){\n                                        // found books\n                                    }).catch(function(reason){\n                                      // something went wrong\n                                    });\n                                    ```\n                                  \n                                    @method then\n                                    @param {Function} onFulfilled\n                                    @param {Function} onRejected\n                                    Useful for tooling.\n                                    @return {Promise}\n                                  */\n            then: then,\n\n            /**\n                          `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n                          as the catch block of a try/catch statement.\n                        \n                          ```js\n                          function findAuthor(){\n                            throw new Error('couldn't find that author');\n                          }\n                        \n                          // synchronous\n                          try {\n                            findAuthor();\n                          } catch(reason) {\n                            // something went wrong\n                          }\n                        \n                          // async with promises\n                          findAuthor().catch(function(reason){\n                            // something went wrong\n                          });\n                          ```\n                        \n                          @method catch\n                          @param {Function} onRejection\n                          Useful for tooling.\n                          @return {Promise}\n                        */\n            'catch': function _catch(onRejection) {\n              return this.then(null, onRejection);\n            } };\n\n\n          function polyfill() {\n            var local = undefined;\n\n            if (typeof global !== 'undefined') {\n              local = global;\n            } else if (typeof self !== 'undefined') {\n              local = self;\n            } else {\n              try {\n                local = Function('return this')();\n              } catch (e) {\n                throw new Error('polyfill failed because global object is unavailable in this environment');\n              }\n            }\n\n            var P = local.Promise;\n\n            if (P) {\n              var promiseToString = null;\n              try {\n                promiseToString = Object.prototype.toString.call(P.resolve());\n              } catch (e) {\n                // silently ignored\n              }\n\n              if (promiseToString === '[object Promise]' && !P.cast) {\n                return;\n              }\n            }\n\n            local.Promise = Promise;\n          }\n\n          // Strange compat..\n          Promise.polyfill = polyfill;\n          Promise.Promise = Promise;\n\n          return Promise;\n\n        });\n\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, { \"_process\": 65 }], 5: [function (require, module, exports) {\n      'use strict';\n\n      exports.__esModule = true;\n      // istanbul ignore next\n\n      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { 'default': obj };}\n\n      var _handlebarsRuntime = require('./handlebars.runtime');\n\n      var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);\n\n      // Compiler imports\n\n      var _handlebarsCompilerAst = require('./handlebars/compiler/ast');\n\n      var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);\n\n      var _handlebarsCompilerBase = require('./handlebars/compiler/base');\n\n      var _handlebarsCompilerCompiler = require('./handlebars/compiler/compiler');\n\n      var _handlebarsCompilerJavascriptCompiler = require('./handlebars/compiler/javascript-compiler');\n\n      var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);\n\n      var _handlebarsCompilerVisitor = require('./handlebars/compiler/visitor');\n\n      var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);\n\n      var _handlebarsNoConflict = require('./handlebars/no-conflict');\n\n      var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);\n\n      var _create = _handlebarsRuntime2['default'].create;\n      function create() {\n        var hb = _create();\n\n        hb.compile = function (input, options) {\n          return _handlebarsCompilerCompiler.compile(input, options, hb);\n        };\n        hb.precompile = function (input, options) {\n          return _handlebarsCompilerCompiler.precompile(input, options, hb);\n        };\n\n        hb.AST = _handlebarsCompilerAst2['default'];\n        hb.Compiler = _handlebarsCompilerCompiler.Compiler;\n        hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2['default'];\n        hb.Parser = _handlebarsCompilerBase.parser;\n        hb.parse = _handlebarsCompilerBase.parse;\n\n        return hb;\n      }\n\n      var inst = create();\n      inst.create = create;\n\n      _handlebarsNoConflict2['default'](inst);\n\n      inst.Visitor = _handlebarsCompilerVisitor2['default'];\n\n      inst['default'] = inst;\n\n      exports['default'] = inst;\n      module.exports = exports['default'];\n\n\n    }, { \"./handlebars.runtime\": 6, \"./handlebars/compiler/ast\": 8, \"./handlebars/compiler/base\": 9, \"./handlebars/compiler/compiler\": 11, \"./handlebars/compiler/javascript-compiler\": 13, \"./handlebars/compiler/visitor\": 16, \"./handlebars/no-conflict\": 30 }], 6: [function (require, module, exports) {\n      'use strict';\n\n      exports.__esModule = true;\n      // istanbul ignore next\n\n      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { 'default': obj };}\n\n      // istanbul ignore next\n\n      function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;} else {var newObj = {};if (obj != null) {for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];}}newObj['default'] = obj;return newObj;}}\n\n      var _handlebarsBase = require('./handlebars/base');\n\n      var base = _interopRequireWildcard(_handlebarsBase);\n\n      // Each of these augment the Handlebars object. No need to setup here.\n      // (This is done to easily share code between commonjs and browse envs)\n\n      var _handlebarsSafeString = require('./handlebars/safe-string');\n\n      var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);\n\n      var _handlebarsException = require('./handlebars/exception');\n\n      var _handlebarsException2 = _interopRequireDefault(_handlebarsException);\n\n      var _handlebarsUtils = require('./handlebars/utils');\n\n      var Utils = _interopRequireWildcard(_handlebarsUtils);\n\n      var _handlebarsRuntime = require('./handlebars/runtime');\n\n      var runtime = _interopRequireWildcard(_handlebarsRuntime);\n\n      var _handlebarsNoConflict = require('./handlebars/no-conflict');\n\n      var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);\n\n      // For compatibility and usage outside of module systems, make the Handlebars object a namespace\n      function create() {\n        var hb = new base.HandlebarsEnvironment();\n\n        Utils.extend(hb, base);\n        hb.SafeString = _handlebarsSafeString2['default'];\n        hb.Exception = _handlebarsException2['default'];\n        hb.Utils = Utils;\n        hb.escapeExpression = Utils.escapeExpression;\n\n        hb.VM = runtime;\n        hb.template = function (spec) {\n          return runtime.template(spec, hb);\n        };\n\n        return hb;\n      }\n\n      var inst = create();\n      inst.create = create;\n\n      _handlebarsNoConflict2['default'](inst);\n\n      inst['default'] = inst;\n\n      exports['default'] = inst;\n      module.exports = exports['default'];\n\n\n    }, { \"./handlebars/base\": 7, \"./handlebars/exception\": 20, \"./handlebars/no-conflict\": 30, \"./handlebars/runtime\": 31, \"./handlebars/safe-string\": 32, \"./handlebars/utils\": 33 }], 7: [function (require, module, exports) {\n      'use strict';\n\n      exports.__esModule = true;\n      exports.HandlebarsEnvironment = HandlebarsEnvironment;\n      // istanbul ignore next\n\n      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { 'default': obj };}\n\n      var _utils = require('./utils');\n\n      var _exception = require('./exception');\n\n      var _exception2 = _interopRequireDefault(_exception);\n\n      var _helpers = require('./helpers');\n\n      var _decorators = require('./decorators');\n\n      var _logger = require('./logger');\n\n      var _logger2 = _interopRequireDefault(_logger);\n\n      var VERSION = '4.0.5';\n      exports.VERSION = VERSION;\n      var COMPILER_REVISION = 7;\n\n      exports.COMPILER_REVISION = COMPILER_REVISION;\n      var REVISION_CHANGES = {\n        1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it\n        2: '== 1.0.0-rc.3',\n        3: '== 1.0.0-rc.4',\n        4: '== 1.x.x',\n        5: '== 2.0.0-alpha.x',\n        6: '>= 2.0.0-beta.1',\n        7: '>= 4.0.0' };\n\n\n      exports.REVISION_CHANGES = REVISION_CHANGES;\n      var objectType = '[object Object]';\n\n      function HandlebarsEnvironment(helpers, partials, decorators) {\n        this.helpers = helpers || {};\n        this.partials = partials || {};\n        this.decorators = decorators || {};\n\n        _helpers.registerDefaultHelpers(this);\n        _decorators.registerDefaultDecorators(this);\n      }\n\n      HandlebarsEnvironment.prototype = {\n        constructor: HandlebarsEnvironment,\n\n        logger: _logger2['default'],\n        log: _logger2['default'].log,\n\n        registerHelper: function registerHelper(name, fn) {\n          if (_utils.toString.call(name) === objectType) {\n            if (fn) {\n              throw new _exception2['default']('Arg not supported with multiple helpers');\n            }\n            _utils.extend(this.helpers, name);\n          } else {\n            this.helpers[name] = fn;\n          }\n        },\n        unregisterHelper: function unregisterHelper(name) {\n          delete this.helpers[name];\n        },\n\n        registerPartial: function registerPartial(name, partial) {\n          if (_utils.toString.call(name) === objectType) {\n            _utils.extend(this.partials, name);\n          } else {\n            if (typeof partial === 'undefined') {\n              throw new _exception2['default']('Attempting to register a partial called \"' + name + '\" as undefined');\n            }\n            this.partials[name] = partial;\n          }\n        },\n        unregisterPartial: function unregisterPartial(name) {\n          delete this.partials[name];\n        },\n\n        registerDecorator: function registerDecorator(name, fn) {\n          if (_utils.toString.call(name) === objectType) {\n            if (fn) {\n              throw new _exception2['default']('Arg not supported with multiple decorators');\n            }\n            _utils.extend(this.decorators, name);\n          } else {\n            this.decorators[name] = fn;\n          }\n        },\n        unregisterDecorator: function unregisterDecorator(name) {\n          delete this.decorators[name];\n        } };\n\n\n      var log = _logger2['default'].log;\n\n      exports.log = log;\n      exports.createFrame = _utils.createFrame;\n      exports.logger = _logger2['default'];\n\n\n    }, { \"./decorators\": 18, \"./exception\": 20, \"./helpers\": 21, \"./logger\": 29, \"./utils\": 33 }], 8: [function (require, module, exports) {\n      'use strict';\n\n      exports.__esModule = true;\n      var AST = {\n        // Public API used to evaluate derived attributes regarding AST nodes\n        helpers: {\n          // a mustache is definitely a helper if:\n          // * it is an eligible helper, and\n          // * it has at least one parameter or hash segment\n          helperExpression: function helperExpression(node) {\n            return node.type === 'SubExpression' || (node.type === 'MustacheStatement' || node.type === 'BlockStatement') && !!(node.params && node.params.length || node.hash);\n          },\n\n          scopedId: function scopedId(path) {\n            return (/^\\.|this\\b/.test(path.original));\n\n          },\n\n          // an ID is simple if it only has one part, and that part is not\n          // `..` or `this`.\n          simpleId: function simpleId(path) {\n            return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;\n          } } };\n\n\n\n      // Must be exported as an object rather than the root of the module as the jison lexer\n      // must modify the object to operate properly.\n      exports['default'] = AST;\n      module.exports = exports['default'];\n\n\n    }, {}], 9: [function (require, module, exports) {\n      'use strict';\n\n      exports.__esModule = true;\n      exports.parse = parse;\n      // istanbul ignore next\n\n      function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;} else {var newObj = {};if (obj != null) {for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];}}newObj['default'] = obj;return newObj;}}\n\n      // istanbul ignore next\n\n      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { 'default': obj };}\n\n      var _parser = require('./parser');\n\n      var _parser2 = _interopRequireDefault(_parser);\n\n      var _whitespaceControl = require('./whitespace-control');\n\n      var _whitespaceControl2 = _interopRequireDefault(_whitespaceControl);\n\n      var _helpers = require('./helpers');\n\n      var Helpers = _interopRequireWildcard(_helpers);\n\n      var _utils = require('../utils');\n\n      exports.parser = _parser2['default'];\n\n      var yy = {};\n      _utils.extend(yy, Helpers);\n\n      function parse(input, options) {\n        // Just return if an already-compiled AST was passed in.\n        if (input.type === 'Program') {\n          return input;\n        }\n\n        _parser2['default'].yy = yy;\n\n        // Altering the shared object here, but this is ok as parser is a sync operation\n        yy.locInfo = function (locInfo) {\n          return new yy.SourceLocation(options && options.srcName, locInfo);\n        };\n\n        var strip = new _whitespaceControl2['default'](options);\n        return strip.accept(_parser2['default'].parse(input));\n      }\n\n\n    }, { \"../utils\": 33, \"./helpers\": 12, \"./parser\": 14, \"./whitespace-control\": 17 }], 10: [function (require, module, exports) {\n      /* global define */\n      'use strict';\n\n      exports.__esModule = true;\n\n      var _utils = require('../utils');\n\n      var SourceNode = undefined;\n\n      try {\n        /* istanbul ignore next */\n        if (typeof define !== 'function' || !define.amd) {\n          // We don't support this in AMD environments. For these environments, we asusme that\n          // they are running on the browser and thus have no need for the source-map library.\n          var SourceMap = require('source-map');\n          SourceNode = SourceMap.SourceNode;\n        }\n      } catch (err) {}\n      /* NOP */\n\n      /* istanbul ignore if: tested but not covered in istanbul due to dist build  */\n      if (!SourceNode) {\n        SourceNode = function SourceNode(line, column, srcFile, chunks) {\n          this.src = '';\n          if (chunks) {\n            this.add(chunks);\n          }\n        };\n        /* istanbul ignore next */\n        SourceNode.prototype = {\n          add: function add(chunks) {\n            if (_utils.isArray(chunks)) {\n              chunks = chunks.join('');\n            }\n            this.src += chunks;\n          },\n          prepend: function prepend(chunks) {\n            if (_utils.isArray(chunks)) {\n              chunks = chunks.join('');\n            }\n            this.src = chunks + this.src;\n          },\n          toStringWithSourceMap: function toStringWithSourceMap() {\n            return { code: this.toString() };\n          },\n          toString: function toString() {\n            return this.src;\n          } };\n\n      }\n\n      function castChunk(chunk, codeGen, loc) {\n        if (_utils.isArray(chunk)) {\n          var ret = [];\n\n          for (var i = 0, len = chunk.length; i < len; i++) {\n            ret.push(codeGen.wrap(chunk[i], loc));\n          }\n          return ret;\n        } else if (typeof chunk === 'boolean' || typeof chunk === 'number') {\n          // Handle primitives that the SourceNode will throw up on\n          return chunk + '';\n        }\n        return chunk;\n      }\n\n      function CodeGen(srcFile) {\n        this.srcFile = srcFile;\n        this.source = [];\n      }\n\n      CodeGen.prototype = {\n        isEmpty: function isEmpty() {\n          return !this.source.length;\n        },\n        prepend: function prepend(source, loc) {\n          this.source.unshift(this.wrap(source, loc));\n        },\n        push: function push(source, loc) {\n          this.source.push(this.wrap(source, loc));\n        },\n\n        merge: function merge() {\n          var source = this.empty();\n          this.each(function (line) {\n            source.add(['  ', line, '\\n']);\n          });\n          return source;\n        },\n\n        each: function each(iter) {\n          for (var i = 0, len = this.source.length; i < len; i++) {\n            iter(this.source[i]);\n          }\n        },\n\n        empty: function empty() {\n          var loc = this.currentLocation || { start: {} };\n          return new SourceNode(loc.start.line, loc.start.column, this.srcFile);\n        },\n        wrap: function wrap(chunk) {\n          var loc = arguments.length <= 1 || arguments[1] === undefined ? this.currentLocation || { start: {} } : arguments[1];\n\n          if (chunk instanceof SourceNode) {\n            return chunk;\n          }\n\n          chunk = castChunk(chunk, this, loc);\n\n          return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);\n        },\n\n        functionCall: function functionCall(fn, type, params) {\n          params = this.generateList(params);\n          return this.wrap([fn, type ? '.' + type + '(' : '(', params, ')']);\n        },\n\n        quotedString: function quotedString(str) {\n          return '\"' + (str + '').replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r').replace(/\\u2028/g, \"\\\\u2028\") // Per Ecma-262 7.3 + 7.8.4\n          .replace(/\\u2029/g, \"\\\\u2029\") + '\"';\n        },\n\n        objectLiteral: function objectLiteral(obj) {\n          var pairs = [];\n\n          for (var key in obj) {\n            if (obj.hasOwnProperty(key)) {\n              var value = castChunk(obj[key], this);\n              if (value !== 'undefined') {\n                pairs.push([this.quotedString(key), ':', value]);\n              }\n            }\n          }\n\n          var ret = this.generateList(pairs);\n          ret.prepend('{');\n          ret.add('}');\n          return ret;\n        },\n\n        generateList: function generateList(entries) {\n          var ret = this.empty();\n\n          for (var i = 0, len = entries.length; i < len; i++) {\n            if (i) {\n              ret.add(',');\n            }\n\n            ret.add(castChunk(entries[i], this));\n          }\n\n          return ret;\n        },\n\n        generateArray: function generateArray(entries) {\n          var ret = this.generateList(entries);\n          ret.prepend('[');\n          ret.add(']');\n\n          return ret;\n        } };\n\n\n      exports['default'] = CodeGen;\n      module.exports = exports['default'];\n\n\n    }, { \"../utils\": 33, \"source-map\": 46 }], 11: [function (require, module, exports) {\n      /* eslint-disable new-cap */\n\n      'use strict';\n\n      exports.__esModule = true;\n      exports.Compiler = Compiler;\n      exports.precompile = precompile;\n      exports.compile = compile;\n      // istanbul ignore next\n\n      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { 'default': obj };}\n\n      var _exception = require('../exception');\n\n      var _exception2 = _interopRequireDefault(_exception);\n\n      var _utils = require('../utils');\n\n      var _ast = require('./ast');\n\n      var _ast2 = _interopRequireDefault(_ast);\n\n      var slice = [].slice;\n\n      function Compiler() {}\n\n      // the foundHelper register will disambiguate helper lookup from finding a\n      // function in a context. This is necessary for mustache compatibility, which\n      // requires that context functions in blocks are evaluated by blockHelperMissing,\n      // and then proceed as if the resulting value was provided to blockHelperMissing.\n\n      Compiler.prototype = {\n        compiler: Compiler,\n\n        equals: function equals(other) {\n          var len = this.opcodes.length;\n          if (other.opcodes.length !== len) {\n            return false;\n          }\n\n          for (var i = 0; i < len; i++) {\n            var opcode = this.opcodes[i],\n            otherOpcode = other.opcodes[i];\n            if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {\n              return false;\n            }\n          }\n\n          // We know that length is the same between the two arrays because they are directly tied\n          // to the opcode behavior above.\n          len = this.children.length;\n          for (var i = 0; i < len; i++) {\n            if (!this.children[i].equals(other.children[i])) {\n              return false;\n            }\n          }\n\n          return true;\n        },\n\n        guid: 0,\n\n        compile: function compile(program, options) {\n          this.sourceNode = [];\n          this.opcodes = [];\n          this.children = [];\n          this.options = options;\n          this.stringParams = options.stringParams;\n          this.trackIds = options.trackIds;\n\n          options.blockParams = options.blockParams || [];\n\n          // These changes will propagate to the other compiler components\n          var knownHelpers = options.knownHelpers;\n          options.knownHelpers = {\n            'helperMissing': true,\n            'blockHelperMissing': true,\n            'each': true,\n            'if': true,\n            'unless': true,\n            'with': true,\n            'log': true,\n            'lookup': true };\n\n          if (knownHelpers) {\n            for (var _name in knownHelpers) {\n              /* istanbul ignore else */\n              if (_name in knownHelpers) {\n                options.knownHelpers[_name] = knownHelpers[_name];\n              }\n            }\n          }\n\n          return this.accept(program);\n        },\n\n        compileProgram: function compileProgram(program) {\n          var childCompiler = new this.compiler(),\n          // eslint-disable-line new-cap\n          result = childCompiler.compile(program, this.options),\n          guid = this.guid++;\n\n          this.usePartial = this.usePartial || result.usePartial;\n\n          this.children[guid] = result;\n          this.useDepths = this.useDepths || result.useDepths;\n\n          return guid;\n        },\n\n        accept: function accept(node) {\n          /* istanbul ignore next: Sanity code */\n          if (!this[node.type]) {\n            throw new _exception2['default']('Unknown type: ' + node.type, node);\n          }\n\n          this.sourceNode.unshift(node);\n          var ret = this[node.type](node);\n          this.sourceNode.shift();\n          return ret;\n        },\n\n        Program: function Program(program) {\n          this.options.blockParams.unshift(program.blockParams);\n\n          var body = program.body,\n          bodyLength = body.length;\n          for (var i = 0; i < bodyLength; i++) {\n            this.accept(body[i]);\n          }\n\n          this.options.blockParams.shift();\n\n          this.isSimple = bodyLength === 1;\n          this.blockParams = program.blockParams ? program.blockParams.length : 0;\n\n          return this;\n        },\n\n        BlockStatement: function BlockStatement(block) {\n          transformLiteralToPath(block);\n\n          var program = block.program,\n          inverse = block.inverse;\n\n          program = program && this.compileProgram(program);\n          inverse = inverse && this.compileProgram(inverse);\n\n          var type = this.classifySexpr(block);\n\n          if (type === 'helper') {\n            this.helperSexpr(block, program, inverse);\n          } else if (type === 'simple') {\n            this.simpleSexpr(block);\n\n            // now that the simple mustache is resolved, we need to\n            // evaluate it by executing `blockHelperMissing`\n            this.opcode('pushProgram', program);\n            this.opcode('pushProgram', inverse);\n            this.opcode('emptyHash');\n            this.opcode('blockValue', block.path.original);\n          } else {\n            this.ambiguousSexpr(block, program, inverse);\n\n            // now that the simple mustache is resolved, we need to\n            // evaluate it by executing `blockHelperMissing`\n            this.opcode('pushProgram', program);\n            this.opcode('pushProgram', inverse);\n            this.opcode('emptyHash');\n            this.opcode('ambiguousBlockValue');\n          }\n\n          this.opcode('append');\n        },\n\n        DecoratorBlock: function DecoratorBlock(decorator) {\n          var program = decorator.program && this.compileProgram(decorator.program);\n          var params = this.setupFullMustacheParams(decorator, program, undefined),\n          path = decorator.path;\n\n          this.useDecorators = true;\n          this.opcode('registerDecorator', params.length, path.original);\n        },\n\n        PartialStatement: function PartialStatement(partial) {\n          this.usePartial = true;\n\n          var program = partial.program;\n          if (program) {\n            program = this.compileProgram(partial.program);\n          }\n\n          var params = partial.params;\n          if (params.length > 1) {\n            throw new _exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);\n          } else if (!params.length) {\n            if (this.options.explicitPartialContext) {\n              this.opcode('pushLiteral', 'undefined');\n            } else {\n              params.push({ type: 'PathExpression', parts: [], depth: 0 });\n            }\n          }\n\n          var partialName = partial.name.original,\n          isDynamic = partial.name.type === 'SubExpression';\n          if (isDynamic) {\n            this.accept(partial.name);\n          }\n\n          this.setupFullMustacheParams(partial, program, undefined, true);\n\n          var indent = partial.indent || '';\n          if (this.options.preventIndent && indent) {\n            this.opcode('appendContent', indent);\n            indent = '';\n          }\n\n          this.opcode('invokePartial', isDynamic, partialName, indent);\n          this.opcode('append');\n        },\n        PartialBlockStatement: function PartialBlockStatement(partialBlock) {\n          this.PartialStatement(partialBlock);\n        },\n\n        MustacheStatement: function MustacheStatement(mustache) {\n          this.SubExpression(mustache);\n\n          if (mustache.escaped && !this.options.noEscape) {\n            this.opcode('appendEscaped');\n          } else {\n            this.opcode('append');\n          }\n        },\n        Decorator: function Decorator(decorator) {\n          this.DecoratorBlock(decorator);\n        },\n\n        ContentStatement: function ContentStatement(content) {\n          if (content.value) {\n            this.opcode('appendContent', content.value);\n          }\n        },\n\n        CommentStatement: function CommentStatement() {},\n\n        SubExpression: function SubExpression(sexpr) {\n          transformLiteralToPath(sexpr);\n          var type = this.classifySexpr(sexpr);\n\n          if (type === 'simple') {\n            this.simpleSexpr(sexpr);\n          } else if (type === 'helper') {\n            this.helperSexpr(sexpr);\n          } else {\n            this.ambiguousSexpr(sexpr);\n          }\n        },\n        ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {\n          var path = sexpr.path,\n          name = path.parts[0],\n          isBlock = program != null || inverse != null;\n\n          this.opcode('getContext', path.depth);\n\n          this.opcode('pushProgram', program);\n          this.opcode('pushProgram', inverse);\n\n          path.strict = true;\n          this.accept(path);\n\n          this.opcode('invokeAmbiguous', name, isBlock);\n        },\n\n        simpleSexpr: function simpleSexpr(sexpr) {\n          var path = sexpr.path;\n          path.strict = true;\n          this.accept(path);\n          this.opcode('resolvePossibleLambda');\n        },\n\n        helperSexpr: function helperSexpr(sexpr, program, inverse) {\n          var params = this.setupFullMustacheParams(sexpr, program, inverse),\n          path = sexpr.path,\n          name = path.parts[0];\n\n          if (this.options.knownHelpers[name]) {\n            this.opcode('invokeKnownHelper', params.length, name);\n          } else if (this.options.knownHelpersOnly) {\n            throw new _exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);\n          } else {\n            path.strict = true;\n            path.falsy = true;\n\n            this.accept(path);\n            this.opcode('invokeHelper', params.length, path.original, _ast2['default'].helpers.simpleId(path));\n          }\n        },\n\n        PathExpression: function PathExpression(path) {\n          this.addDepth(path.depth);\n          this.opcode('getContext', path.depth);\n\n          var name = path.parts[0],\n          scoped = _ast2['default'].helpers.scopedId(path),\n          blockParamId = !path.depth && !scoped && this.blockParamIndex(name);\n\n          if (blockParamId) {\n            this.opcode('lookupBlockParam', blockParamId, path.parts);\n          } else if (!name) {\n            // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`\n            this.opcode('pushContext');\n          } else if (path.data) {\n            this.options.data = true;\n            this.opcode('lookupData', path.depth, path.parts, path.strict);\n          } else {\n            this.opcode('lookupOnContext', path.parts, path.falsy, path.strict, scoped);\n          }\n        },\n\n        StringLiteral: function StringLiteral(string) {\n          this.opcode('pushString', string.value);\n        },\n\n        NumberLiteral: function NumberLiteral(number) {\n          this.opcode('pushLiteral', number.value);\n        },\n\n        BooleanLiteral: function BooleanLiteral(bool) {\n          this.opcode('pushLiteral', bool.value);\n        },\n\n        UndefinedLiteral: function UndefinedLiteral() {\n          this.opcode('pushLiteral', 'undefined');\n        },\n\n        NullLiteral: function NullLiteral() {\n          this.opcode('pushLiteral', 'null');\n        },\n\n        Hash: function Hash(hash) {\n          var pairs = hash.pairs,\n          i = 0,\n          l = pairs.length;\n\n          this.opcode('pushHash');\n\n          for (; i < l; i++) {\n            this.pushParam(pairs[i].value);\n          }\n          while (i--) {\n            this.opcode('assignToHash', pairs[i].key);\n          }\n          this.opcode('popHash');\n        },\n\n        // HELPERS\n        opcode: function opcode(name) {\n          this.opcodes.push({ opcode: name, args: slice.call(arguments, 1), loc: this.sourceNode[0].loc });\n        },\n\n        addDepth: function addDepth(depth) {\n          if (!depth) {\n            return;\n          }\n\n          this.useDepths = true;\n        },\n\n        classifySexpr: function classifySexpr(sexpr) {\n          var isSimple = _ast2['default'].helpers.simpleId(sexpr.path);\n\n          var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);\n\n          // a mustache is an eligible helper if:\n          // * its id is simple (a single part, not `this` or `..`)\n          var isHelper = !isBlockParam && _ast2['default'].helpers.helperExpression(sexpr);\n\n          // if a mustache is an eligible helper but not a definite\n          // helper, it is ambiguous, and will be resolved in a later\n          // pass or at runtime.\n          var isEligible = !isBlockParam && (isHelper || isSimple);\n\n          // if ambiguous, we can possibly resolve the ambiguity now\n          // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.\n          if (isEligible && !isHelper) {\n            var _name2 = sexpr.path.parts[0],\n            options = this.options;\n\n            if (options.knownHelpers[_name2]) {\n              isHelper = true;\n            } else if (options.knownHelpersOnly) {\n              isEligible = false;\n            }\n          }\n\n          if (isHelper) {\n            return 'helper';\n          } else if (isEligible) {\n            return 'ambiguous';\n          } else {\n            return 'simple';\n          }\n        },\n\n        pushParams: function pushParams(params) {\n          for (var i = 0, l = params.length; i < l; i++) {\n            this.pushParam(params[i]);\n          }\n        },\n\n        pushParam: function pushParam(val) {\n          var value = val.value != null ? val.value : val.original || '';\n\n          if (this.stringParams) {\n            if (value.replace) {\n              value = value.replace(/^(\\.?\\.\\/)*/g, '').replace(/\\//g, '.');\n            }\n\n            if (val.depth) {\n              this.addDepth(val.depth);\n            }\n            this.opcode('getContext', val.depth || 0);\n            this.opcode('pushStringParam', value, val.type);\n\n            if (val.type === 'SubExpression') {\n              // SubExpressions get evaluated and passed in\n              // in string params mode.\n              this.accept(val);\n            }\n          } else {\n            if (this.trackIds) {\n              var blockParamIndex = undefined;\n              if (val.parts && !_ast2['default'].helpers.scopedId(val) && !val.depth) {\n                blockParamIndex = this.blockParamIndex(val.parts[0]);\n              }\n              if (blockParamIndex) {\n                var blockParamChild = val.parts.slice(1).join('.');\n                this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);\n              } else {\n                value = val.original || value;\n                if (value.replace) {\n                  value = value.replace(/^this(?:\\.|$)/, '').replace(/^\\.\\//, '').replace(/^\\.$/, '');\n                }\n\n                this.opcode('pushId', val.type, value);\n              }\n            }\n            this.accept(val);\n          }\n        },\n\n        setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {\n          var params = sexpr.params;\n          this.pushParams(params);\n\n          this.opcode('pushProgram', program);\n          this.opcode('pushProgram', inverse);\n\n          if (sexpr.hash) {\n            this.accept(sexpr.hash);\n          } else {\n            this.opcode('emptyHash', omitEmpty);\n          }\n\n          return params;\n        },\n\n        blockParamIndex: function blockParamIndex(name) {\n          for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {\n            var blockParams = this.options.blockParams[depth],\n            param = blockParams && _utils.indexOf(blockParams, name);\n            if (blockParams && param >= 0) {\n              return [depth, param];\n            }\n          }\n        } };\n\n\n      function precompile(input, options, env) {\n        if (input == null || typeof input !== 'string' && input.type !== 'Program') {\n          throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);\n        }\n\n        options = options || {};\n        if (!('data' in options)) {\n          options.data = true;\n        }\n        if (options.compat) {\n          options.useDepths = true;\n        }\n\n        var ast = env.parse(input, options),\n        environment = new env.Compiler().compile(ast, options);\n        return new env.JavaScriptCompiler().compile(environment, options);\n      }\n\n      function compile(input, options, env) {\n        if (options === undefined) options = {};\n\n        if (input == null || typeof input !== 'string' && input.type !== 'Program') {\n          throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);\n        }\n\n        if (!('data' in options)) {\n          options.data = true;\n        }\n        if (options.compat) {\n          options.useDepths = true;\n        }\n\n        var compiled = undefined;\n\n        function compileInput() {\n          var ast = env.parse(input, options),\n          environment = new env.Compiler().compile(ast, options),\n          templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);\n          return env.template(templateSpec);\n        }\n\n        // Template is only compiled on first use and cached after that point.\n        function ret(context, execOptions) {\n          if (!compiled) {\n            compiled = compileInput();\n          }\n          return compiled.call(this, context, execOptions);\n        }\n        ret._setup = function (setupOptions) {\n          if (!compiled) {\n            compiled = compileInput();\n          }\n          return compiled._setup(setupOptions);\n        };\n        ret._child = function (i, data, blockParams, depths) {\n          if (!compiled) {\n            compiled = compileInput();\n          }\n          return compiled._child(i, data, blockParams, depths);\n        };\n        return ret;\n      }\n\n      function argEquals(a, b) {\n        if (a === b) {\n          return true;\n        }\n\n        if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {\n          for (var i = 0; i < a.length; i++) {\n            if (!argEquals(a[i], b[i])) {\n              return false;\n            }\n          }\n          return true;\n        }\n      }\n\n      function transformLiteralToPath(sexpr) {\n        if (!sexpr.path.parts) {\n          var literal = sexpr.path;\n          // Casting to string here to make false and 0 literal values play nicely with the rest\n          // of the system.\n          sexpr.path = {\n            type: 'PathExpression',\n            data: false,\n            depth: 0,\n            parts: [literal.original + ''],\n            original: literal.original + '',\n            loc: literal.loc };\n\n        }\n      }\n\n\n    }, { \"../exception\": 20, \"../utils\": 33, \"./ast\": 8 }], 12: [function (require, module, exports) {\n      'use strict';\n\n      exports.__esModule = true;\n      exports.SourceLocation = SourceLocation;\n      exports.id = id;\n      exports.stripFlags = stripFlags;\n      exports.stripComment = stripComment;\n      exports.preparePath = preparePath;\n      exports.prepareMustache = prepareMustache;\n      exports.prepareRawBlock = prepareRawBlock;\n      exports.prepareBlock = prepareBlock;\n      exports.prepareProgram = prepareProgram;\n      exports.preparePartialBlock = preparePartialBlock;\n      // istanbul ignore next\n\n      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { 'default': obj };}\n\n      var _exception = require('../exception');\n\n      var _exception2 = _interopRequireDefault(_exception);\n\n      function validateClose(open, close) {\n        close = close.path ? close.path.original : close;\n\n        if (open.path.original !== close) {\n          var errorNode = { loc: open.path.loc };\n\n          throw new _exception2['default'](open.path.original + \" doesn't match \" + close, errorNode);\n        }\n      }\n\n      function SourceLocation(source, locInfo) {\n        this.source = source;\n        this.start = {\n          line: locInfo.first_line,\n          column: locInfo.first_column };\n\n        this.end = {\n          line: locInfo.last_line,\n          column: locInfo.last_column };\n\n      }\n\n      function id(token) {\n        if (/^\\[.*\\]$/.test(token)) {\n          return token.substr(1, token.length - 2);\n        } else {\n          return token;\n        }\n      }\n\n      function stripFlags(open, close) {\n        return {\n          open: open.charAt(2) === '~',\n          close: close.charAt(close.length - 3) === '~' };\n\n      }\n\n      function stripComment(comment) {\n        return comment.replace(/^\\{\\{~?\\!-?-?/, '').replace(/-?-?~?\\}\\}$/, '');\n      }\n\n      function preparePath(data, parts, loc) {\n        loc = this.locInfo(loc);\n\n        var original = data ? '@' : '',\n        dig = [],\n        depth = 0,\n        depthString = '';\n\n        for (var i = 0, l = parts.length; i < l; i++) {\n          var part = parts[i].part,\n\n          // If we have [] syntax then we do not treat path references as operators,\n          // i.e. foo.[this] resolves to approximately context.foo['this']\n          isLiteral = parts[i].original !== part;\n          original += (parts[i].separator || '') + part;\n\n          if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {\n            if (dig.length > 0) {\n              throw new _exception2['default']('Invalid path: ' + original, { loc: loc });\n            } else if (part === '..') {\n              depth++;\n              depthString += '../';\n            }\n          } else {\n            dig.push(part);\n          }\n        }\n\n        return {\n          type: 'PathExpression',\n          data: data,\n          depth: depth,\n          parts: dig,\n          original: original,\n          loc: loc };\n\n      }\n\n      function prepareMustache(path, params, hash, open, strip, locInfo) {\n        // Must use charAt to support IE pre-10\n        var escapeFlag = open.charAt(3) || open.charAt(2),\n        escaped = escapeFlag !== '{' && escapeFlag !== '&';\n\n        var decorator = /\\*/.test(open);\n        return {\n          type: decorator ? 'Decorator' : 'MustacheStatement',\n          path: path,\n          params: params,\n          hash: hash,\n          escaped: escaped,\n          strip: strip,\n          loc: this.locInfo(locInfo) };\n\n      }\n\n      function prepareRawBlock(openRawBlock, contents, close, locInfo) {\n        validateClose(openRawBlock, close);\n\n        locInfo = this.locInfo(locInfo);\n        var program = {\n          type: 'Program',\n          body: contents,\n          strip: {},\n          loc: locInfo };\n\n\n        return {\n          type: 'BlockStatement',\n          path: openRawBlock.path,\n          params: openRawBlock.params,\n          hash: openRawBlock.hash,\n          program: program,\n          openStrip: {},\n          inverseStrip: {},\n          closeStrip: {},\n          loc: locInfo };\n\n      }\n\n      function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {\n        if (close && close.path) {\n          validateClose(openBlock, close);\n        }\n\n        var decorator = /\\*/.test(openBlock.open);\n\n        program.blockParams = openBlock.blockParams;\n\n        var inverse = undefined,\n        inverseStrip = undefined;\n\n        if (inverseAndProgram) {\n          if (decorator) {\n            throw new _exception2['default']('Unexpected inverse block on decorator', inverseAndProgram);\n          }\n\n          if (inverseAndProgram.chain) {\n            inverseAndProgram.program.body[0].closeStrip = close.strip;\n          }\n\n          inverseStrip = inverseAndProgram.strip;\n          inverse = inverseAndProgram.program;\n        }\n\n        if (inverted) {\n          inverted = inverse;\n          inverse = program;\n          program = inverted;\n        }\n\n        return {\n          type: decorator ? 'DecoratorBlock' : 'BlockStatement',\n          path: openBlock.path,\n          params: openBlock.params,\n          hash: openBlock.hash,\n          program: program,\n          inverse: inverse,\n          openStrip: openBlock.strip,\n          inverseStrip: inverseStrip,\n          closeStrip: close && close.strip,\n          loc: this.locInfo(locInfo) };\n\n      }\n\n      function prepareProgram(statements, loc) {\n        if (!loc && statements.length) {\n          var firstLoc = statements[0].loc,\n          lastLoc = statements[statements.length - 1].loc;\n\n          /* istanbul ignore else */\n          if (firstLoc && lastLoc) {\n            loc = {\n              source: firstLoc.source,\n              start: {\n                line: firstLoc.start.line,\n                column: firstLoc.start.column },\n\n              end: {\n                line: lastLoc.end.line,\n                column: lastLoc.end.column } };\n\n\n          }\n        }\n\n        return {\n          type: 'Program',\n          body: statements,\n          strip: {},\n          loc: loc };\n\n      }\n\n      function preparePartialBlock(open, program, close, locInfo) {\n        validateClose(open, close);\n\n        return {\n          type: 'PartialBlockStatement',\n          name: open.path,\n          params: open.params,\n          hash: open.hash,\n          program: program,\n          openStrip: open.strip,\n          closeStrip: close && close.strip,\n          loc: this.locInfo(locInfo) };\n\n      }\n\n\n    }, { \"../exception\": 20 }], 13: [function (require, module, exports) {\n      'use strict';\n\n      exports.__esModule = true;\n      // istanbul ignore next\n\n      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { 'default': obj };}\n\n      var _base = require('../base');\n\n      var _exception = require('../exception');\n\n      var _exception2 = _interopRequireDefault(_exception);\n\n      var _utils = require('../utils');\n\n      var _codeGen = require('./code-gen');\n\n      var _codeGen2 = _interopRequireDefault(_codeGen);\n\n      function Literal(value) {\n        this.value = value;\n      }\n\n      function JavaScriptCompiler() {}\n\n      JavaScriptCompiler.prototype = {\n        // PUBLIC API: You can override these methods in a subclass to provide\n        // alternative compiled forms for name lookup and buffering semantics\n        nameLookup: function nameLookup(parent, name /* , type*/) {\n          if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {\n            return [parent, '.', name];\n          } else {\n            return [parent, '[', JSON.stringify(name), ']'];\n          }\n        },\n        depthedLookup: function depthedLookup(name) {\n          return [this.aliasable('container.lookup'), '(depths, \"', name, '\")'];\n        },\n\n        compilerInfo: function compilerInfo() {\n          var revision = _base.COMPILER_REVISION,\n          versions = _base.REVISION_CHANGES[revision];\n          return [revision, versions];\n        },\n\n        appendToBuffer: function appendToBuffer(source, location, explicit) {\n          // Force a source as this simplifies the merge logic.\n          if (!_utils.isArray(source)) {\n            source = [source];\n          }\n          source = this.source.wrap(source, location);\n\n          if (this.environment.isSimple) {\n            return ['return ', source, ';'];\n          } else if (explicit) {\n            // This is a case where the buffer operation occurs as a child of another\n            // construct, generally braces. We have to explicitly output these buffer\n            // operations to ensure that the emitted code goes in the correct location.\n            return ['buffer += ', source, ';'];\n          } else {\n            source.appendToBuffer = true;\n            return source;\n          }\n        },\n\n        initializeBuffer: function initializeBuffer() {\n          return this.quotedString('');\n        },\n        // END PUBLIC API\n\n        compile: function compile(environment, options, context, asObject) {\n          this.environment = environment;\n          this.options = options;\n          this.stringParams = this.options.stringParams;\n          this.trackIds = this.options.trackIds;\n          this.precompile = !asObject;\n\n          this.name = this.environment.name;\n          this.isChild = !!context;\n          this.context = context || {\n            decorators: [],\n            programs: [],\n            environments: [] };\n\n\n          this.preamble();\n\n          this.stackSlot = 0;\n          this.stackVars = [];\n          this.aliases = {};\n          this.registers = { list: [] };\n          this.hashes = [];\n          this.compileStack = [];\n          this.inlineStack = [];\n          this.blockParams = [];\n\n          this.compileChildren(environment, options);\n\n          this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;\n          this.useBlockParams = this.useBlockParams || environment.useBlockParams;\n\n          var opcodes = environment.opcodes,\n          opcode = undefined,\n          firstLoc = undefined,\n          i = undefined,\n          l = undefined;\n\n          for (i = 0, l = opcodes.length; i < l; i++) {\n            opcode = opcodes[i];\n\n            this.source.currentLocation = opcode.loc;\n            firstLoc = firstLoc || opcode.loc;\n            this[opcode.opcode].apply(this, opcode.args);\n          }\n\n          // Flush any trailing content that might be pending.\n          this.source.currentLocation = firstLoc;\n          this.pushSource('');\n\n          /* istanbul ignore next */\n          if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {\n            throw new _exception2['default']('Compile completed with content left on stack');\n          }\n\n          if (!this.decorators.isEmpty()) {\n            this.useDecorators = true;\n\n            this.decorators.prepend('var decorators = container.decorators;\\n');\n            this.decorators.push('return fn;');\n\n            if (asObject) {\n              this.decorators = Function.apply(this, ['fn', 'props', 'container', 'depth0', 'data', 'blockParams', 'depths', this.decorators.merge()]);\n            } else {\n              this.decorators.prepend('function(fn, props, container, depth0, data, blockParams, depths) {\\n');\n              this.decorators.push('}\\n');\n              this.decorators = this.decorators.merge();\n            }\n          } else {\n            this.decorators = undefined;\n          }\n\n          var fn = this.createFunctionContext(asObject);\n          if (!this.isChild) {\n            var ret = {\n              compiler: this.compilerInfo(),\n              main: fn };\n\n\n            if (this.decorators) {\n              ret.main_d = this.decorators; // eslint-disable-line camelcase\n              ret.useDecorators = true;\n            }\n\n            var _context = this.context;\n            var programs = _context.programs;\n            var decorators = _context.decorators;\n\n            for (i = 0, l = programs.length; i < l; i++) {\n              if (programs[i]) {\n                ret[i] = programs[i];\n                if (decorators[i]) {\n                  ret[i + '_d'] = decorators[i];\n                  ret.useDecorators = true;\n                }\n              }\n            }\n\n            if (this.environment.usePartial) {\n              ret.usePartial = true;\n            }\n            if (this.options.data) {\n              ret.useData = true;\n            }\n            if (this.useDepths) {\n              ret.useDepths = true;\n            }\n            if (this.useBlockParams) {\n              ret.useBlockParams = true;\n            }\n            if (this.options.compat) {\n              ret.compat = true;\n            }\n\n            if (!asObject) {\n              ret.compiler = JSON.stringify(ret.compiler);\n\n              this.source.currentLocation = { start: { line: 1, column: 0 } };\n              ret = this.objectLiteral(ret);\n\n              if (options.srcName) {\n                ret = ret.toStringWithSourceMap({ file: options.destName });\n                ret.map = ret.map && ret.map.toString();\n              } else {\n                ret = ret.toString();\n              }\n            } else {\n              ret.compilerOptions = this.options;\n            }\n\n            return ret;\n          } else {\n            return fn;\n          }\n        },\n\n        preamble: function preamble() {\n          // track the last context pushed into place to allow skipping the\n          // getContext opcode when it would be a noop\n          this.lastContext = 0;\n          this.source = new _codeGen2['default'](this.options.srcName);\n          this.decorators = new _codeGen2['default'](this.options.srcName);\n        },\n\n        createFunctionContext: function createFunctionContext(asObject) {\n          var varDeclarations = '';\n\n          var locals = this.stackVars.concat(this.registers.list);\n          if (locals.length > 0) {\n            varDeclarations += ', ' + locals.join(', ');\n          }\n\n          // Generate minimizer alias mappings\n          //\n          // When using true SourceNodes, this will update all references to the given alias\n          // as the source nodes are reused in situ. For the non-source node compilation mode,\n          // aliases will not be used, but this case is already being run on the client and\n          // we aren't concern about minimizing the template size.\n          var aliasCount = 0;\n          for (var alias in this.aliases) {\n            // eslint-disable-line guard-for-in\n            var node = this.aliases[alias];\n\n            if (this.aliases.hasOwnProperty(alias) && node.children && node.referenceCount > 1) {\n              varDeclarations += ', alias' + ++aliasCount + '=' + alias;\n              node.children[0] = 'alias' + aliasCount;\n            }\n          }\n\n          var params = ['container', 'depth0', 'helpers', 'partials', 'data'];\n\n          if (this.useBlockParams || this.useDepths) {\n            params.push('blockParams');\n          }\n          if (this.useDepths) {\n            params.push('depths');\n          }\n\n          // Perform a second pass over the output to merge content when possible\n          var source = this.mergeSource(varDeclarations);\n\n          if (asObject) {\n            params.push(source);\n\n            return Function.apply(this, params);\n          } else {\n            return this.source.wrap(['function(', params.join(','), ') {\\n  ', source, '}']);\n          }\n        },\n        mergeSource: function mergeSource(varDeclarations) {\n          var isSimple = this.environment.isSimple,\n          appendOnly = !this.forceBuffer,\n          appendFirst = undefined,\n          sourceSeen = undefined,\n          bufferStart = undefined,\n          bufferEnd = undefined;\n          this.source.each(function (line) {\n            if (line.appendToBuffer) {\n              if (bufferStart) {\n                line.prepend('  + ');\n              } else {\n                bufferStart = line;\n              }\n              bufferEnd = line;\n            } else {\n              if (bufferStart) {\n                if (!sourceSeen) {\n                  appendFirst = true;\n                } else {\n                  bufferStart.prepend('buffer += ');\n                }\n                bufferEnd.add(';');\n                bufferStart = bufferEnd = undefined;\n              }\n\n              sourceSeen = true;\n              if (!isSimple) {\n                appendOnly = false;\n              }\n            }\n          });\n\n          if (appendOnly) {\n            if (bufferStart) {\n              bufferStart.prepend('return ');\n              bufferEnd.add(';');\n            } else if (!sourceSeen) {\n              this.source.push('return \"\";');\n            }\n          } else {\n            varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());\n\n            if (bufferStart) {\n              bufferStart.prepend('return buffer + ');\n              bufferEnd.add(';');\n            } else {\n              this.source.push('return buffer;');\n            }\n          }\n\n          if (varDeclarations) {\n            this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\\n'));\n          }\n\n          return this.source.merge();\n        },\n\n        // [blockValue]\n        //\n        // On stack, before: hash, inverse, program, value\n        // On stack, after: return value of blockHelperMissing\n        //\n        // The purpose of this opcode is to take a block of the form\n        // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and\n        // replace it on the stack with the result of properly\n        // invoking blockHelperMissing.\n        blockValue: function blockValue(name) {\n          var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),\n          params = [this.contextName(0)];\n          this.setupHelperArgs(name, 0, params);\n\n          var blockName = this.popStack();\n          params.splice(1, 0, blockName);\n\n          this.push(this.source.functionCall(blockHelperMissing, 'call', params));\n        },\n\n        // [ambiguousBlockValue]\n        //\n        // On stack, before: hash, inverse, program, value\n        // Compiler value, before: lastHelper=value of last found helper, if any\n        // On stack, after, if no lastHelper: same as [blockValue]\n        // On stack, after, if lastHelper: value\n        ambiguousBlockValue: function ambiguousBlockValue() {\n          // We're being a bit cheeky and reusing the options value from the prior exec\n          var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),\n          params = [this.contextName(0)];\n          this.setupHelperArgs('', 0, params, true);\n\n          this.flushInline();\n\n          var current = this.topStack();\n          params.splice(1, 0, current);\n\n          this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);\n        },\n\n        // [appendContent]\n        //\n        // On stack, before: ...\n        // On stack, after: ...\n        //\n        // Appends the string value of `content` to the current buffer\n        appendContent: function appendContent(content) {\n          if (this.pendingContent) {\n            content = this.pendingContent + content;\n          } else {\n            this.pendingLocation = this.source.currentLocation;\n          }\n\n          this.pendingContent = content;\n        },\n\n        // [append]\n        //\n        // On stack, before: value, ...\n        // On stack, after: ...\n        //\n        // Coerces `value` to a String and appends it to the current buffer.\n        //\n        // If `value` is truthy, or 0, it is coerced into a string and appended\n        // Otherwise, the empty string is appended\n        append: function append() {\n          if (this.isInline()) {\n            this.replaceStack(function (current) {\n              return [' != null ? ', current, ' : \"\"'];\n            });\n\n            this.pushSource(this.appendToBuffer(this.popStack()));\n          } else {\n            var local = this.popStack();\n            this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);\n            if (this.environment.isSimple) {\n              this.pushSource(['else { ', this.appendToBuffer(\"''\", undefined, true), ' }']);\n            }\n          }\n        },\n\n        // [appendEscaped]\n        //\n        // On stack, before: value, ...\n        // On stack, after: ...\n        //\n        // Escape `value` and append it to the buffer\n        appendEscaped: function appendEscaped() {\n          this.pushSource(this.appendToBuffer([this.aliasable('container.escapeExpression'), '(', this.popStack(), ')']));\n        },\n\n        // [getContext]\n        //\n        // On stack, before: ...\n        // On stack, after: ...\n        // Compiler value, after: lastContext=depth\n        //\n        // Set the value of the `lastContext` compiler value to the depth\n        getContext: function getContext(depth) {\n          this.lastContext = depth;\n        },\n\n        // [pushContext]\n        //\n        // On stack, before: ...\n        // On stack, after: currentContext, ...\n        //\n        // Pushes the value of the current context onto the stack.\n        pushContext: function pushContext() {\n          this.pushStackLiteral(this.contextName(this.lastContext));\n        },\n\n        // [lookupOnContext]\n        //\n        // On stack, before: ...\n        // On stack, after: currentContext[name], ...\n        //\n        // Looks up the value of `name` on the current context and pushes\n        // it onto the stack.\n        lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {\n          var i = 0;\n\n          if (!scoped && this.options.compat && !this.lastContext) {\n            // The depthed query is expected to handle the undefined logic for the root level that\n            // is implemented below, so we evaluate that directly in compat mode\n            this.push(this.depthedLookup(parts[i++]));\n          } else {\n            this.pushContext();\n          }\n\n          this.resolvePath('context', parts, i, falsy, strict);\n        },\n\n        // [lookupBlockParam]\n        //\n        // On stack, before: ...\n        // On stack, after: blockParam[name], ...\n        //\n        // Looks up the value of `parts` on the given block param and pushes\n        // it onto the stack.\n        lookupBlockParam: function lookupBlockParam(blockParamId, parts) {\n          this.useBlockParams = true;\n\n          this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);\n          this.resolvePath('context', parts, 1);\n        },\n\n        // [lookupData]\n        //\n        // On stack, before: ...\n        // On stack, after: data, ...\n        //\n        // Push the data lookup operator\n        lookupData: function lookupData(depth, parts, strict) {\n          if (!depth) {\n            this.pushStackLiteral('data');\n          } else {\n            this.pushStackLiteral('container.data(data, ' + depth + ')');\n          }\n\n          this.resolvePath('data', parts, 0, true, strict);\n        },\n\n        resolvePath: function resolvePath(type, parts, i, falsy, strict) {\n          // istanbul ignore next\n\n          var _this = this;\n\n          if (this.options.strict || this.options.assumeObjects) {\n            this.push(strictLookup(this.options.strict && strict, this, parts, type));\n            return;\n          }\n\n          var len = parts.length;\n          for (; i < len; i++) {\n            /* eslint-disable no-loop-func */\n            this.replaceStack(function (current) {\n              var lookup = _this.nameLookup(current, parts[i], type);\n              // We want to ensure that zero and false are handled properly if the context (falsy flag)\n              // needs to have the special handling for these values.\n              if (!falsy) {\n                return [' != null ? ', lookup, ' : ', current];\n              } else {\n                // Otherwise we can use generic falsy handling\n                return [' && ', lookup];\n              }\n            });\n            /* eslint-enable no-loop-func */\n          }\n        },\n\n        // [resolvePossibleLambda]\n        //\n        // On stack, before: value, ...\n        // On stack, after: resolved value, ...\n        //\n        // If the `value` is a lambda, replace it on the stack by\n        // the return value of the lambda\n        resolvePossibleLambda: function resolvePossibleLambda() {\n          this.push([this.aliasable('container.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);\n        },\n\n        // [pushStringParam]\n        //\n        // On stack, before: ...\n        // On stack, after: string, currentContext, ...\n        //\n        // This opcode is designed for use in string mode, which\n        // provides the string value of a parameter along with its\n        // depth rather than resolving it immediately.\n        pushStringParam: function pushStringParam(string, type) {\n          this.pushContext();\n          this.pushString(type);\n\n          // If it's a subexpression, the string result\n          // will be pushed after this opcode.\n          if (type !== 'SubExpression') {\n            if (typeof string === 'string') {\n              this.pushString(string);\n            } else {\n              this.pushStackLiteral(string);\n            }\n          }\n        },\n\n        emptyHash: function emptyHash(omitEmpty) {\n          if (this.trackIds) {\n            this.push('{}'); // hashIds\n          }\n          if (this.stringParams) {\n            this.push('{}'); // hashContexts\n            this.push('{}'); // hashTypes\n          }\n          this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');\n        },\n        pushHash: function pushHash() {\n          if (this.hash) {\n            this.hashes.push(this.hash);\n          }\n          this.hash = { values: [], types: [], contexts: [], ids: [] };\n        },\n        popHash: function popHash() {\n          var hash = this.hash;\n          this.hash = this.hashes.pop();\n\n          if (this.trackIds) {\n            this.push(this.objectLiteral(hash.ids));\n          }\n          if (this.stringParams) {\n            this.push(this.objectLiteral(hash.contexts));\n            this.push(this.objectLiteral(hash.types));\n          }\n\n          this.push(this.objectLiteral(hash.values));\n        },\n\n        // [pushString]\n        //\n        // On stack, before: ...\n        // On stack, after: quotedString(string), ...\n        //\n        // Push a quoted version of `string` onto the stack\n        pushString: function pushString(string) {\n          this.pushStackLiteral(this.quotedString(string));\n        },\n\n        // [pushLiteral]\n        //\n        // On stack, before: ...\n        // On stack, after: value, ...\n        //\n        // Pushes a value onto the stack. This operation prevents\n        // the compiler from creating a temporary variable to hold\n        // it.\n        pushLiteral: function pushLiteral(value) {\n          this.pushStackLiteral(value);\n        },\n\n        // [pushProgram]\n        //\n        // On stack, before: ...\n        // On stack, after: program(guid), ...\n        //\n        // Push a program expression onto the stack. This takes\n        // a compile-time guid and converts it into a runtime-accessible\n        // expression.\n        pushProgram: function pushProgram(guid) {\n          if (guid != null) {\n            this.pushStackLiteral(this.programExpression(guid));\n          } else {\n            this.pushStackLiteral(null);\n          }\n        },\n\n        // [registerDecorator]\n        //\n        // On stack, before: hash, program, params..., ...\n        // On stack, after: ...\n        //\n        // Pops off the decorator's parameters, invokes the decorator,\n        // and inserts the decorator into the decorators list.\n        registerDecorator: function registerDecorator(paramSize, name) {\n          var foundDecorator = this.nameLookup('decorators', name, 'decorator'),\n          options = this.setupHelperArgs(name, paramSize);\n\n          this.decorators.push(['fn = ', this.decorators.functionCall(foundDecorator, '', ['fn', 'props', 'container', options]), ' || fn;']);\n        },\n\n        // [invokeHelper]\n        //\n        // On stack, before: hash, inverse, program, params..., ...\n        // On stack, after: result of helper invocation\n        //\n        // Pops off the helper's parameters, invokes the helper,\n        // and pushes the helper's return value onto the stack.\n        //\n        // If the helper is not found, `helperMissing` is called.\n        invokeHelper: function invokeHelper(paramSize, name, isSimple) {\n          var nonHelper = this.popStack(),\n          helper = this.setupHelper(paramSize, name),\n          simple = isSimple ? [helper.name, ' || '] : '';\n\n          var lookup = ['('].concat(simple, nonHelper);\n          if (!this.options.strict) {\n            lookup.push(' || ', this.aliasable('helpers.helperMissing'));\n          }\n          lookup.push(')');\n\n          this.push(this.source.functionCall(lookup, 'call', helper.callParams));\n        },\n\n        // [invokeKnownHelper]\n        //\n        // On stack, before: hash, inverse, program, params..., ...\n        // On stack, after: result of helper invocation\n        //\n        // This operation is used when the helper is known to exist,\n        // so a `helperMissing` fallback is not required.\n        invokeKnownHelper: function invokeKnownHelper(paramSize, name) {\n          var helper = this.setupHelper(paramSize, name);\n          this.push(this.source.functionCall(helper.name, 'call', helper.callParams));\n        },\n\n        // [invokeAmbiguous]\n        //\n        // On stack, before: hash, inverse, program, params..., ...\n        // On stack, after: result of disambiguation\n        //\n        // This operation is used when an expression like `{{foo}}`\n        // is provided, but we don't know at compile-time whether it\n        // is a helper or a path.\n        //\n        // This operation emits more code than the other options,\n        // and can be avoided by passing the `knownHelpers` and\n        // `knownHelpersOnly` flags at compile-time.\n        invokeAmbiguous: function invokeAmbiguous(name, helperCall) {\n          this.useRegister('helper');\n\n          var nonHelper = this.popStack();\n\n          this.emptyHash();\n          var helper = this.setupHelper(0, name, helperCall);\n\n          var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');\n\n          var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];\n          if (!this.options.strict) {\n            lookup[0] = '(helper = ';\n            lookup.push(' != null ? helper : ', this.aliasable('helpers.helperMissing'));\n          }\n\n          this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('\"function\"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);\n        },\n\n        // [invokePartial]\n        //\n        // On stack, before: context, ...\n        // On stack after: result of partial invocation\n        //\n        // This operation pops off a context, invokes a partial with that context,\n        // and pushes the result of the invocation back.\n        invokePartial: function invokePartial(isDynamic, name, indent) {\n          var params = [],\n          options = this.setupParams(name, 1, params);\n\n          if (isDynamic) {\n            name = this.popStack();\n            delete options.name;\n          }\n\n          if (indent) {\n            options.indent = JSON.stringify(indent);\n          }\n          options.helpers = 'helpers';\n          options.partials = 'partials';\n          options.decorators = 'container.decorators';\n\n          if (!isDynamic) {\n            params.unshift(this.nameLookup('partials', name, 'partial'));\n          } else {\n            params.unshift(name);\n          }\n\n          if (this.options.compat) {\n            options.depths = 'depths';\n          }\n          options = this.objectLiteral(options);\n          params.push(options);\n\n          this.push(this.source.functionCall('container.invokePartial', '', params));\n        },\n\n        // [assignToHash]\n        //\n        // On stack, before: value, ..., hash, ...\n        // On stack, after: ..., hash, ...\n        //\n        // Pops a value off the stack and assigns it to the current hash\n        assignToHash: function assignToHash(key) {\n          var value = this.popStack(),\n          context = undefined,\n          type = undefined,\n          id = undefined;\n\n          if (this.trackIds) {\n            id = this.popStack();\n          }\n          if (this.stringParams) {\n            type = this.popStack();\n            context = this.popStack();\n          }\n\n          var hash = this.hash;\n          if (context) {\n            hash.contexts[key] = context;\n          }\n          if (type) {\n            hash.types[key] = type;\n          }\n          if (id) {\n            hash.ids[key] = id;\n          }\n          hash.values[key] = value;\n        },\n\n        pushId: function pushId(type, name, child) {\n          if (type === 'BlockParam') {\n            this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));\n          } else if (type === 'PathExpression') {\n            this.pushString(name);\n          } else if (type === 'SubExpression') {\n            this.pushStackLiteral('true');\n          } else {\n            this.pushStackLiteral('null');\n          }\n        },\n\n        // HELPERS\n\n        compiler: JavaScriptCompiler,\n\n        compileChildren: function compileChildren(environment, options) {\n          var children = environment.children,\n          child = undefined,\n          compiler = undefined;\n\n          for (var i = 0, l = children.length; i < l; i++) {\n            child = children[i];\n            compiler = new this.compiler(); // eslint-disable-line new-cap\n\n            var existing = this.matchExistingProgram(child);\n\n            if (existing == null) {\n              this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children\n              var index = this.context.programs.length;\n              child.index = index;\n              child.name = 'program' + index;\n              this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);\n              this.context.decorators[index] = compiler.decorators;\n              this.context.environments[index] = child;\n\n              this.useDepths = this.useDepths || compiler.useDepths;\n              this.useBlockParams = this.useBlockParams || compiler.useBlockParams;\n              child.useDepths = this.useDepths;\n              child.useBlockParams = this.useBlockParams;\n            } else {\n              child.index = existing.index;\n              child.name = 'program' + existing.index;\n\n              this.useDepths = this.useDepths || existing.useDepths;\n              this.useBlockParams = this.useBlockParams || existing.useBlockParams;\n            }\n          }\n        },\n        matchExistingProgram: function matchExistingProgram(child) {\n          for (var i = 0, len = this.context.environments.length; i < len; i++) {\n            var environment = this.context.environments[i];\n            if (environment && environment.equals(child)) {\n              return environment;\n            }\n          }\n        },\n\n        programExpression: function programExpression(guid) {\n          var child = this.environment.children[guid],\n          programParams = [child.index, 'data', child.blockParams];\n\n          if (this.useBlockParams || this.useDepths) {\n            programParams.push('blockParams');\n          }\n          if (this.useDepths) {\n            programParams.push('depths');\n          }\n\n          return 'container.program(' + programParams.join(', ') + ')';\n        },\n\n        useRegister: function useRegister(name) {\n          if (!this.registers[name]) {\n            this.registers[name] = true;\n            this.registers.list.push(name);\n          }\n        },\n\n        push: function push(expr) {\n          if (!(expr instanceof Literal)) {\n            expr = this.source.wrap(expr);\n          }\n\n          this.inlineStack.push(expr);\n          return expr;\n        },\n\n        pushStackLiteral: function pushStackLiteral(item) {\n          this.push(new Literal(item));\n        },\n\n        pushSource: function pushSource(source) {\n          if (this.pendingContent) {\n            this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));\n            this.pendingContent = undefined;\n          }\n\n          if (source) {\n            this.source.push(source);\n          }\n        },\n\n        replaceStack: function replaceStack(callback) {\n          var prefix = ['('],\n          stack = undefined,\n          createdStack = undefined,\n          usedLiteral = undefined;\n\n          /* istanbul ignore next */\n          if (!this.isInline()) {\n            throw new _exception2['default']('replaceStack on non-inline');\n          }\n\n          // We want to merge the inline statement into the replacement statement via ','\n          var top = this.popStack(true);\n\n          if (top instanceof Literal) {\n            // Literals do not need to be inlined\n            stack = [top.value];\n            prefix = ['(', stack];\n            usedLiteral = true;\n          } else {\n            // Get or create the current stack name for use by the inline\n            createdStack = true;\n            var _name = this.incrStack();\n\n            prefix = ['((', this.push(_name), ' = ', top, ')'];\n            stack = this.topStack();\n          }\n\n          var item = callback.call(this, stack);\n\n          if (!usedLiteral) {\n            this.popStack();\n          }\n          if (createdStack) {\n            this.stackSlot--;\n          }\n          this.push(prefix.concat(item, ')'));\n        },\n\n        incrStack: function incrStack() {\n          this.stackSlot++;\n          if (this.stackSlot > this.stackVars.length) {\n            this.stackVars.push('stack' + this.stackSlot);\n          }\n          return this.topStackName();\n        },\n        topStackName: function topStackName() {\n          return 'stack' + this.stackSlot;\n        },\n        flushInline: function flushInline() {\n          var inlineStack = this.inlineStack;\n          this.inlineStack = [];\n          for (var i = 0, len = inlineStack.length; i < len; i++) {\n            var entry = inlineStack[i];\n            /* istanbul ignore if */\n            if (entry instanceof Literal) {\n              this.compileStack.push(entry);\n            } else {\n              var stack = this.incrStack();\n              this.pushSource([stack, ' = ', entry, ';']);\n              this.compileStack.push(stack);\n            }\n          }\n        },\n        isInline: function isInline() {\n          return this.inlineStack.length;\n        },\n\n        popStack: function popStack(wrapped) {\n          var inline = this.isInline(),\n          item = (inline ? this.inlineStack : this.compileStack).pop();\n\n          if (!wrapped && item instanceof Literal) {\n            return item.value;\n          } else {\n            if (!inline) {\n              /* istanbul ignore next */\n              if (!this.stackSlot) {\n                throw new _exception2['default']('Invalid stack pop');\n              }\n              this.stackSlot--;\n            }\n            return item;\n          }\n        },\n\n        topStack: function topStack() {\n          var stack = this.isInline() ? this.inlineStack : this.compileStack,\n          item = stack[stack.length - 1];\n\n          /* istanbul ignore if */\n          if (item instanceof Literal) {\n            return item.value;\n          } else {\n            return item;\n          }\n        },\n\n        contextName: function contextName(context) {\n          if (this.useDepths && context) {\n            return 'depths[' + context + ']';\n          } else {\n            return 'depth' + context;\n          }\n        },\n\n        quotedString: function quotedString(str) {\n          return this.source.quotedString(str);\n        },\n\n        objectLiteral: function objectLiteral(obj) {\n          return this.source.objectLiteral(obj);\n        },\n\n        aliasable: function aliasable(name) {\n          var ret = this.aliases[name];\n          if (ret) {\n            ret.referenceCount++;\n            return ret;\n          }\n\n          ret = this.aliases[name] = this.source.wrap(name);\n          ret.aliasable = true;\n          ret.referenceCount = 1;\n\n          return ret;\n        },\n\n        setupHelper: function setupHelper(paramSize, name, blockHelper) {\n          var params = [],\n          paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);\n          var foundHelper = this.nameLookup('helpers', name, 'helper'),\n          callContext = this.aliasable(this.contextName(0) + ' != null ? ' + this.contextName(0) + ' : {}');\n\n          return {\n            params: params,\n            paramsInit: paramsInit,\n            name: foundHelper,\n            callParams: [callContext].concat(params) };\n\n        },\n\n        setupParams: function setupParams(helper, paramSize, params) {\n          var options = {},\n          contexts = [],\n          types = [],\n          ids = [],\n          objectArgs = !params,\n          param = undefined;\n\n          if (objectArgs) {\n            params = [];\n          }\n\n          options.name = this.quotedString(helper);\n          options.hash = this.popStack();\n\n          if (this.trackIds) {\n            options.hashIds = this.popStack();\n          }\n          if (this.stringParams) {\n            options.hashTypes = this.popStack();\n            options.hashContexts = this.popStack();\n          }\n\n          var inverse = this.popStack(),\n          program = this.popStack();\n\n          // Avoid setting fn and inverse if neither are set. This allows\n          // helpers to do a check for `if (options.fn)`\n          if (program || inverse) {\n            options.fn = program || 'container.noop';\n            options.inverse = inverse || 'container.noop';\n          }\n\n          // The parameters go on to the stack in order (making sure that they are evaluated in order)\n          // so we need to pop them off the stack in reverse order\n          var i = paramSize;\n          while (i--) {\n            param = this.popStack();\n            params[i] = param;\n\n            if (this.trackIds) {\n              ids[i] = this.popStack();\n            }\n            if (this.stringParams) {\n              types[i] = this.popStack();\n              contexts[i] = this.popStack();\n            }\n          }\n\n          if (objectArgs) {\n            options.args = this.source.generateArray(params);\n          }\n\n          if (this.trackIds) {\n            options.ids = this.source.generateArray(ids);\n          }\n          if (this.stringParams) {\n            options.types = this.source.generateArray(types);\n            options.contexts = this.source.generateArray(contexts);\n          }\n\n          if (this.options.data) {\n            options.data = 'data';\n          }\n          if (this.useBlockParams) {\n            options.blockParams = 'blockParams';\n          }\n          return options;\n        },\n\n        setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {\n          var options = this.setupParams(helper, paramSize, params);\n          options = this.objectLiteral(options);\n          if (useRegister) {\n            this.useRegister('options');\n            params.push('options');\n            return ['options=', options];\n          } else if (params) {\n            params.push(options);\n            return '';\n          } else {\n            return options;\n          }\n        } };\n\n\n      (function () {\n        var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');\n\n        var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};\n\n        for (var i = 0, l = reservedWords.length; i < l; i++) {\n          compilerWords[reservedWords[i]] = true;\n        }\n      })();\n\n      JavaScriptCompiler.isValidJavaScriptVariableName = function (name) {\n        return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);\n      };\n\n      function strictLookup(requireTerminal, compiler, parts, type) {\n        var stack = compiler.popStack(),\n        i = 0,\n        len = parts.length;\n        if (requireTerminal) {\n          len--;\n        }\n\n        for (; i < len; i++) {\n          stack = compiler.nameLookup(stack, parts[i], type);\n        }\n\n        if (requireTerminal) {\n          return [compiler.aliasable('container.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ')'];\n        } else {\n          return stack;\n        }\n      }\n\n      exports['default'] = JavaScriptCompiler;\n      module.exports = exports['default'];\n\n\n    }, { \"../base\": 7, \"../exception\": 20, \"../utils\": 33, \"./code-gen\": 10 }], 14: [function (require, module, exports) {\n      /* istanbul ignore next */\n      /* Jison generated parser */\n      \"use strict\";\n\n      var handlebars = function () {\n        var parser = { trace: function trace() {},\n          yy: {},\n          symbols_: { \"error\": 2, \"root\": 3, \"program\": 4, \"EOF\": 5, \"program_repetition0\": 6, \"statement\": 7, \"mustache\": 8, \"block\": 9, \"rawBlock\": 10, \"partial\": 11, \"partialBlock\": 12, \"content\": 13, \"COMMENT\": 14, \"CONTENT\": 15, \"openRawBlock\": 16, \"rawBlock_repetition_plus0\": 17, \"END_RAW_BLOCK\": 18, \"OPEN_RAW_BLOCK\": 19, \"helperName\": 20, \"openRawBlock_repetition0\": 21, \"openRawBlock_option0\": 22, \"CLOSE_RAW_BLOCK\": 23, \"openBlock\": 24, \"block_option0\": 25, \"closeBlock\": 26, \"openInverse\": 27, \"block_option1\": 28, \"OPEN_BLOCK\": 29, \"openBlock_repetition0\": 30, \"openBlock_option0\": 31, \"openBlock_option1\": 32, \"CLOSE\": 33, \"OPEN_INVERSE\": 34, \"openInverse_repetition0\": 35, \"openInverse_option0\": 36, \"openInverse_option1\": 37, \"openInverseChain\": 38, \"OPEN_INVERSE_CHAIN\": 39, \"openInverseChain_repetition0\": 40, \"openInverseChain_option0\": 41, \"openInverseChain_option1\": 42, \"inverseAndProgram\": 43, \"INVERSE\": 44, \"inverseChain\": 45, \"inverseChain_option0\": 46, \"OPEN_ENDBLOCK\": 47, \"OPEN\": 48, \"mustache_repetition0\": 49, \"mustache_option0\": 50, \"OPEN_UNESCAPED\": 51, \"mustache_repetition1\": 52, \"mustache_option1\": 53, \"CLOSE_UNESCAPED\": 54, \"OPEN_PARTIAL\": 55, \"partialName\": 56, \"partial_repetition0\": 57, \"partial_option0\": 58, \"openPartialBlock\": 59, \"OPEN_PARTIAL_BLOCK\": 60, \"openPartialBlock_repetition0\": 61, \"openPartialBlock_option0\": 62, \"param\": 63, \"sexpr\": 64, \"OPEN_SEXPR\": 65, \"sexpr_repetition0\": 66, \"sexpr_option0\": 67, \"CLOSE_SEXPR\": 68, \"hash\": 69, \"hash_repetition_plus0\": 70, \"hashSegment\": 71, \"ID\": 72, \"EQUALS\": 73, \"blockParams\": 74, \"OPEN_BLOCK_PARAMS\": 75, \"blockParams_repetition_plus0\": 76, \"CLOSE_BLOCK_PARAMS\": 77, \"path\": 78, \"dataName\": 79, \"STRING\": 80, \"NUMBER\": 81, \"BOOLEAN\": 82, \"UNDEFINED\": 83, \"NULL\": 84, \"DATA\": 85, \"pathSegments\": 86, \"SEP\": 87, \"$accept\": 0, \"$end\": 1 },\n          terminals_: { 2: \"error\", 5: \"EOF\", 14: \"COMMENT\", 15: \"CONTENT\", 18: \"END_RAW_BLOCK\", 19: \"OPEN_RAW_BLOCK\", 23: \"CLOSE_RAW_BLOCK\", 29: \"OPEN_BLOCK\", 33: \"CLOSE\", 34: \"OPEN_INVERSE\", 39: \"OPEN_INVERSE_CHAIN\", 44: \"INVERSE\", 47: \"OPEN_ENDBLOCK\", 48: \"OPEN\", 51: \"OPEN_UNESCAPED\", 54: \"CLOSE_UNESCAPED\", 55: \"OPEN_PARTIAL\", 60: \"OPEN_PARTIAL_BLOCK\", 65: \"OPEN_SEXPR\", 68: \"CLOSE_SEXPR\", 72: \"ID\", 73: \"EQUALS\", 75: \"OPEN_BLOCK_PARAMS\", 77: \"CLOSE_BLOCK_PARAMS\", 80: \"STRING\", 81: \"NUMBER\", 82: \"BOOLEAN\", 83: \"UNDEFINED\", 84: \"NULL\", 85: \"DATA\", 87: \"SEP\" },\n          productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 1], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],\n          performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$\n          /**/) {\n\n            var $0 = $$.length - 1;\n            switch (yystate) {\n              case 1:\n                return $$[$0 - 1];\n                break;\n              case 2:\n                this.$ = yy.prepareProgram($$[$0]);\n                break;\n              case 3:\n                this.$ = $$[$0];\n                break;\n              case 4:\n                this.$ = $$[$0];\n                break;\n              case 5:\n                this.$ = $$[$0];\n                break;\n              case 6:\n                this.$ = $$[$0];\n                break;\n              case 7:\n                this.$ = $$[$0];\n                break;\n              case 8:\n                this.$ = $$[$0];\n                break;\n              case 9:\n                this.$ = {\n                  type: 'CommentStatement',\n                  value: yy.stripComment($$[$0]),\n                  strip: yy.stripFlags($$[$0], $$[$0]),\n                  loc: yy.locInfo(this._$) };\n\n\n                break;\n              case 10:\n                this.$ = {\n                  type: 'ContentStatement',\n                  original: $$[$0],\n                  value: $$[$0],\n                  loc: yy.locInfo(this._$) };\n\n\n                break;\n              case 11:\n                this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);\n                break;\n              case 12:\n                this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };\n                break;\n              case 13:\n                this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);\n                break;\n              case 14:\n                this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);\n                break;\n              case 15:\n                this.$ = { open: $$[$0 - 5], path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };\n                break;\n              case 16:\n                this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };\n                break;\n              case 17:\n                this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };\n                break;\n              case 18:\n                this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };\n                break;\n              case 19:\n                var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$),\n                program = yy.prepareProgram([inverse], $$[$0 - 1].loc);\n                program.chained = true;\n\n                this.$ = { strip: $$[$0 - 2].strip, program: program, chain: true };\n\n                break;\n              case 20:\n                this.$ = $$[$0];\n                break;\n              case 21:\n                this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };\n                break;\n              case 22:\n                this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);\n                break;\n              case 23:\n                this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);\n                break;\n              case 24:\n                this.$ = {\n                  type: 'PartialStatement',\n                  name: $$[$0 - 3],\n                  params: $$[$0 - 2],\n                  hash: $$[$0 - 1],\n                  indent: '',\n                  strip: yy.stripFlags($$[$0 - 4], $$[$0]),\n                  loc: yy.locInfo(this._$) };\n\n\n                break;\n              case 25:\n                this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);\n                break;\n              case 26:\n                this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 4], $$[$0]) };\n                break;\n              case 27:\n                this.$ = $$[$0];\n                break;\n              case 28:\n                this.$ = $$[$0];\n                break;\n              case 29:\n                this.$ = {\n                  type: 'SubExpression',\n                  path: $$[$0 - 3],\n                  params: $$[$0 - 2],\n                  hash: $$[$0 - 1],\n                  loc: yy.locInfo(this._$) };\n\n\n                break;\n              case 30:\n                this.$ = { type: 'Hash', pairs: $$[$0], loc: yy.locInfo(this._$) };\n                break;\n              case 31:\n                this.$ = { type: 'HashPair', key: yy.id($$[$0 - 2]), value: $$[$0], loc: yy.locInfo(this._$) };\n                break;\n              case 32:\n                this.$ = yy.id($$[$0 - 1]);\n                break;\n              case 33:\n                this.$ = $$[$0];\n                break;\n              case 34:\n                this.$ = $$[$0];\n                break;\n              case 35:\n                this.$ = { type: 'StringLiteral', value: $$[$0], original: $$[$0], loc: yy.locInfo(this._$) };\n                break;\n              case 36:\n                this.$ = { type: 'NumberLiteral', value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };\n                break;\n              case 37:\n                this.$ = { type: 'BooleanLiteral', value: $$[$0] === 'true', original: $$[$0] === 'true', loc: yy.locInfo(this._$) };\n                break;\n              case 38:\n                this.$ = { type: 'UndefinedLiteral', original: undefined, value: undefined, loc: yy.locInfo(this._$) };\n                break;\n              case 39:\n                this.$ = { type: 'NullLiteral', original: null, value: null, loc: yy.locInfo(this._$) };\n                break;\n              case 40:\n                this.$ = $$[$0];\n                break;\n              case 41:\n                this.$ = $$[$0];\n                break;\n              case 42:\n                this.$ = yy.preparePath(true, $$[$0], this._$);\n                break;\n              case 43:\n                this.$ = yy.preparePath(false, $$[$0], this._$);\n                break;\n              case 44:\n                $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });this.$ = $$[$0 - 2];\n                break;\n              case 45:\n                this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];\n                break;\n              case 46:\n                this.$ = [];\n                break;\n              case 47:\n                $$[$0 - 1].push($$[$0]);\n                break;\n              case 48:\n                this.$ = [$$[$0]];\n                break;\n              case 49:\n                $$[$0 - 1].push($$[$0]);\n                break;\n              case 50:\n                this.$ = [];\n                break;\n              case 51:\n                $$[$0 - 1].push($$[$0]);\n                break;\n              case 58:\n                this.$ = [];\n                break;\n              case 59:\n                $$[$0 - 1].push($$[$0]);\n                break;\n              case 64:\n                this.$ = [];\n                break;\n              case 65:\n                $$[$0 - 1].push($$[$0]);\n                break;\n              case 70:\n                this.$ = [];\n                break;\n              case 71:\n                $$[$0 - 1].push($$[$0]);\n                break;\n              case 78:\n                this.$ = [];\n                break;\n              case 79:\n                $$[$0 - 1].push($$[$0]);\n                break;\n              case 82:\n                this.$ = [];\n                break;\n              case 83:\n                $$[$0 - 1].push($$[$0]);\n                break;\n              case 86:\n                this.$ = [];\n                break;\n              case 87:\n                $$[$0 - 1].push($$[$0]);\n                break;\n              case 90:\n                this.$ = [];\n                break;\n              case 91:\n                $$[$0 - 1].push($$[$0]);\n                break;\n              case 94:\n                this.$ = [];\n                break;\n              case 95:\n                $$[$0 - 1].push($$[$0]);\n                break;\n              case 98:\n                this.$ = [$$[$0]];\n                break;\n              case 99:\n                $$[$0 - 1].push($$[$0]);\n                break;\n              case 100:\n                this.$ = [$$[$0]];\n                break;\n              case 101:\n                $$[$0 - 1].push($$[$0]);\n                break;}\n\n          },\n          table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 13: 40, 15: [1, 20], 17: 39 }, { 20: 42, 56: 41, 64: 43, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 45, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 48, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 42, 56: 49, 64: 43, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 50, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 51] }, { 72: [1, 35], 86: 52 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 53, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 54, 38: 56, 39: [1, 58], 43: 57, 44: [1, 59], 45: 55, 47: [2, 54] }, { 28: 60, 43: 61, 44: [1, 59], 47: [2, 56] }, { 13: 63, 15: [1, 20], 18: [1, 62] }, { 15: [2, 48], 18: [2, 48] }, { 33: [2, 86], 57: 64, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 65, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 66, 47: [1, 67] }, { 30: 68, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 69, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 70, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 71, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 75, 33: [2, 80], 50: 72, 63: 73, 64: 76, 65: [1, 44], 69: 74, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 80] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 51] }, { 20: 75, 53: 81, 54: [2, 84], 63: 82, 64: 76, 65: [1, 44], 69: 83, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 84, 47: [1, 67] }, { 47: [2, 55] }, { 4: 85, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 86, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 87, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 88, 47: [1, 67] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 75, 33: [2, 88], 58: 89, 63: 90, 64: 76, 65: [1, 44], 69: 91, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 92, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 93, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 31: 94, 33: [2, 60], 63: 95, 64: 76, 65: [1, 44], 69: 96, 70: 77, 71: 78, 72: [1, 79], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 33: [2, 66], 36: 97, 63: 98, 64: 76, 65: [1, 44], 69: 99, 70: 77, 71: 78, 72: [1, 79], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 22: 100, 23: [2, 52], 63: 101, 64: 76, 65: [1, 44], 69: 102, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 33: [2, 92], 62: 103, 63: 104, 64: 76, 65: [1, 44], 69: 105, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 106] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 107, 72: [1, 108], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 109], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 110] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 56, 39: [1, 58], 43: 57, 44: [1, 59], 45: 112, 46: 111, 47: [2, 76] }, { 33: [2, 70], 40: 113, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 114] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 75, 63: 116, 64: 76, 65: [1, 44], 67: 115, 68: [2, 96], 69: 117, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 118] }, { 32: 119, 33: [2, 62], 74: 120, 75: [1, 121] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 122, 74: 123, 75: [1, 121] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 124] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 125] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 109] }, { 20: 75, 63: 126, 64: 76, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 75, 33: [2, 72], 41: 127, 63: 128, 64: 76, 65: [1, 44], 69: 129, 70: 77, 71: 78, 72: [1, 79], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 130] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 131] }, { 33: [2, 63] }, { 72: [1, 133], 76: 132 }, { 33: [1, 134] }, { 33: [2, 69] }, { 15: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 135, 74: 136, 75: [1, 121] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 138], 77: [1, 137] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 139] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],\n          defaultActions: { 4: [2, 1], 55: [2, 55], 57: [2, 20], 61: [2, 57], 74: [2, 81], 83: [2, 85], 87: [2, 18], 91: [2, 89], 102: [2, 53], 105: [2, 93], 111: [2, 19], 112: [2, 77], 117: [2, 97], 120: [2, 63], 123: [2, 69], 124: [2, 12], 136: [2, 75], 137: [2, 32] },\n          parseError: function parseError(str, hash) {\n            throw new Error(str);\n          },\n          parse: function parse(input) {\n            var self = this,\n            stack = [0],\n            vstack = [null],\n            lstack = [],\n            table = this.table,\n            yytext = \"\",\n            yylineno = 0,\n            yyleng = 0,\n            recovering = 0,\n            TERROR = 2,\n            EOF = 1;\n            this.lexer.setInput(input);\n            this.lexer.yy = this.yy;\n            this.yy.lexer = this.lexer;\n            this.yy.parser = this;\n            if (typeof this.lexer.yylloc == \"undefined\") this.lexer.yylloc = {};\n            var yyloc = this.lexer.yylloc;\n            lstack.push(yyloc);\n            var ranges = this.lexer.options && this.lexer.options.ranges;\n            if (typeof this.yy.parseError === \"function\") this.parseError = this.yy.parseError;\n            function popStack(n) {\n              stack.length = stack.length - 2 * n;\n              vstack.length = vstack.length - n;\n              lstack.length = lstack.length - n;\n            }\n            function lex() {\n              var token;\n              token = self.lexer.lex() || 1;\n              if (typeof token !== \"number\") {\n                token = self.symbols_[token] || token;\n              }\n              return token;\n            }\n            var symbol,\n            preErrorSymbol,\n            state,\n            action,\n            a,\n            r,\n            yyval = {},\n            p,\n            len,\n            newState,\n            expected;\n            while (true) {\n              state = stack[stack.length - 1];\n              if (this.defaultActions[state]) {\n                action = this.defaultActions[state];\n              } else {\n                if (symbol === null || typeof symbol == \"undefined\") {\n                  symbol = lex();\n                }\n                action = table[state] && table[state][symbol];\n              }\n              if (typeof action === \"undefined\" || !action.length || !action[0]) {\n                var errStr = \"\";\n                if (!recovering) {\n                  expected = [];\n                  for (p in table[state]) {if (this.terminals_[p] && p > 2) {\n                      expected.push(\"'\" + this.terminals_[p] + \"'\");\n                    }}\n                  if (this.lexer.showPosition) {\n                    errStr = \"Parse error on line \" + (yylineno + 1) + \":\\n\" + this.lexer.showPosition() + \"\\nExpecting \" + expected.join(\", \") + \", got '\" + (this.terminals_[symbol] || symbol) + \"'\";\n                  } else {\n                    errStr = \"Parse error on line \" + (yylineno + 1) + \": Unexpected \" + (symbol == 1 ? \"end of input\" : \"'\" + (this.terminals_[symbol] || symbol) + \"'\");\n                  }\n                  this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected });\n                }\n              }\n              if (action[0] instanceof Array && action.length > 1) {\n                throw new Error(\"Parse Error: multiple actions possible at state: \" + state + \", token: \" + symbol);\n              }\n              switch (action[0]) {\n                case 1:\n                  stack.push(symbol);\n                  vstack.push(this.lexer.yytext);\n                  lstack.push(this.lexer.yylloc);\n                  stack.push(action[1]);\n                  symbol = null;\n                  if (!preErrorSymbol) {\n                    yyleng = this.lexer.yyleng;\n                    yytext = this.lexer.yytext;\n                    yylineno = this.lexer.yylineno;\n                    yyloc = this.lexer.yylloc;\n                    if (recovering > 0) recovering--;\n                  } else {\n                    symbol = preErrorSymbol;\n                    preErrorSymbol = null;\n                  }\n                  break;\n                case 2:\n                  len = this.productions_[action[1]][1];\n                  yyval.$ = vstack[vstack.length - len];\n                  yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };\n                  if (ranges) {\n                    yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];\n                  }\n                  r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);\n                  if (typeof r !== \"undefined\") {\n                    return r;\n                  }\n                  if (len) {\n                    stack = stack.slice(0, -1 * len * 2);\n                    vstack = vstack.slice(0, -1 * len);\n                    lstack = lstack.slice(0, -1 * len);\n                  }\n                  stack.push(this.productions_[action[1]][0]);\n                  vstack.push(yyval.$);\n                  lstack.push(yyval._$);\n                  newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n                  stack.push(newState);\n                  break;\n                case 3:\n                  return true;}\n\n            }\n            return true;\n          } };\n\n        /* Jison generated lexer */\n        var lexer = function () {\n          var lexer = { EOF: 1,\n            parseError: function parseError(str, hash) {\n              if (this.yy.parser) {\n                this.yy.parser.parseError(str, hash);\n              } else {\n                throw new Error(str);\n              }\n            },\n            setInput: function setInput(input) {\n              this._input = input;\n              this._more = this._less = this.done = false;\n              this.yylineno = this.yyleng = 0;\n              this.yytext = this.matched = this.match = '';\n              this.conditionStack = ['INITIAL'];\n              this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };\n              if (this.options.ranges) this.yylloc.range = [0, 0];\n              this.offset = 0;\n              return this;\n            },\n            input: function input() {\n              var ch = this._input[0];\n              this.yytext += ch;\n              this.yyleng++;\n              this.offset++;\n              this.match += ch;\n              this.matched += ch;\n              var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n              if (lines) {\n                this.yylineno++;\n                this.yylloc.last_line++;\n              } else {\n                this.yylloc.last_column++;\n              }\n              if (this.options.ranges) this.yylloc.range[1]++;\n\n              this._input = this._input.slice(1);\n              return ch;\n            },\n            unput: function unput(ch) {\n              var len = ch.length;\n              var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n              this._input = ch + this._input;\n              this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);\n              //this.yyleng -= len;\n              this.offset -= len;\n              var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n              this.match = this.match.substr(0, this.match.length - 1);\n              this.matched = this.matched.substr(0, this.matched.length - 1);\n\n              if (lines.length - 1) this.yylineno -= lines.length - 1;\n              var r = this.yylloc.range;\n\n              this.yylloc = { first_line: this.yylloc.first_line,\n                last_line: this.yylineno + 1,\n                first_column: this.yylloc.first_column,\n                last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len };\n\n\n              if (this.options.ranges) {\n                this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n              }\n              return this;\n            },\n            more: function more() {\n              this._more = true;\n              return this;\n            },\n            less: function less(n) {\n              this.unput(this.match.slice(n));\n            },\n            pastInput: function pastInput() {\n              var past = this.matched.substr(0, this.matched.length - this.match.length);\n              return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\\n/g, \"\");\n            },\n            upcomingInput: function upcomingInput() {\n              var next = this.match;\n              if (next.length < 20) {\n                next += this._input.substr(0, 20 - next.length);\n              }\n              return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n            },\n            showPosition: function showPosition() {\n              var pre = this.pastInput();\n              var c = new Array(pre.length + 1).join(\"-\");\n              return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n            },\n            next: function next() {\n              if (this.done) {\n                return this.EOF;\n              }\n              if (!this._input) this.done = true;\n\n              var token, match, tempMatch, index, col, lines;\n              if (!this._more) {\n                this.yytext = '';\n                this.match = '';\n              }\n              var rules = this._currentRules();\n              for (var i = 0; i < rules.length; i++) {\n                tempMatch = this._input.match(this.rules[rules[i]]);\n                if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                  match = tempMatch;\n                  index = i;\n                  if (!this.options.flex) break;\n                }\n              }\n              if (match) {\n                lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n                if (lines) this.yylineno += lines.length;\n                this.yylloc = { first_line: this.yylloc.last_line,\n                  last_line: this.yylineno + 1,\n                  first_column: this.yylloc.last_column,\n                  last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length : this.yylloc.last_column + match[0].length };\n                this.yytext += match[0];\n                this.match += match[0];\n                this.matches = match;\n                this.yyleng = this.yytext.length;\n                if (this.options.ranges) {\n                  this.yylloc.range = [this.offset, this.offset += this.yyleng];\n                }\n                this._more = false;\n                this._input = this._input.slice(match[0].length);\n                this.matched += match[0];\n                token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);\n                if (this.done && this._input) this.done = false;\n                if (token) return token;else return;\n              }\n              if (this._input === \"\") {\n                return this.EOF;\n              } else {\n                return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), { text: \"\", token: null, line: this.yylineno });\n              }\n            },\n            lex: function lex() {\n              var r = this.next();\n              if (typeof r !== 'undefined') {\n                return r;\n              } else {\n                return this.lex();\n              }\n            },\n            begin: function begin(condition) {\n              this.conditionStack.push(condition);\n            },\n            popState: function popState() {\n              return this.conditionStack.pop();\n            },\n            _currentRules: function _currentRules() {\n              return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n            },\n            topState: function topState() {\n              return this.conditionStack[this.conditionStack.length - 2];\n            },\n            pushState: function begin(condition) {\n              this.begin(condition);\n            } };\n          lexer.options = {};\n          lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START\n          /**/) {\n\n            function strip(start, end) {\n              return yy_.yytext = yy_.yytext.substr(start, yy_.yyleng - end);\n            }\n\n            var YYSTATE = YY_START;\n            switch ($avoiding_name_collisions) {\n              case 0:\n                if (yy_.yytext.slice(-2) === \"\\\\\\\\\") {\n                  strip(0, 1);\n                  this.begin(\"mu\");\n                } else if (yy_.yytext.slice(-1) === \"\\\\\") {\n                  strip(0, 1);\n                  this.begin(\"emu\");\n                } else {\n                  this.begin(\"mu\");\n                }\n                if (yy_.yytext) return 15;\n\n                break;\n              case 1:\n                return 15;\n                break;\n              case 2:\n                this.popState();\n                return 15;\n\n                break;\n              case 3:\n                this.begin('raw');return 15;\n                break;\n              case 4:\n                this.popState();\n                // Should be using `this.topState()` below, but it currently\n                // returns the second top instead of the first top. Opened an\n                // issue about it at https://github.com/zaach/jison/issues/291\n                if (this.conditionStack[this.conditionStack.length - 1] === 'raw') {\n                  return 15;\n                } else {\n                  yy_.yytext = yy_.yytext.substr(5, yy_.yyleng - 9);\n                  return 'END_RAW_BLOCK';\n                }\n\n                break;\n              case 5:\n                return 15;\n                break;\n              case 6:\n                this.popState();\n                return 14;\n\n                break;\n              case 7:\n                return 65;\n                break;\n              case 8:\n                return 68;\n                break;\n              case 9:\n                return 19;\n                break;\n              case 10:\n                this.popState();\n                this.begin('raw');\n                return 23;\n\n                break;\n              case 11:\n                return 55;\n                break;\n              case 12:\n                return 60;\n                break;\n              case 13:\n                return 29;\n                break;\n              case 14:\n                return 47;\n                break;\n              case 15:\n                this.popState();return 44;\n                break;\n              case 16:\n                this.popState();return 44;\n                break;\n              case 17:\n                return 34;\n                break;\n              case 18:\n                return 39;\n                break;\n              case 19:\n                return 51;\n                break;\n              case 20:\n                return 48;\n                break;\n              case 21:\n                this.unput(yy_.yytext);\n                this.popState();\n                this.begin('com');\n\n                break;\n              case 22:\n                this.popState();\n                return 14;\n\n                break;\n              case 23:\n                return 48;\n                break;\n              case 24:\n                return 73;\n                break;\n              case 25:\n                return 72;\n                break;\n              case 26:\n                return 72;\n                break;\n              case 27:\n                return 87;\n                break;\n              case 28:\n                // ignore whitespace\n                break;\n              case 29:\n                this.popState();return 54;\n                break;\n              case 30:\n                this.popState();return 33;\n                break;\n              case 31:\n                yy_.yytext = strip(1, 2).replace(/\\\\\"/g, '\"');return 80;\n                break;\n              case 32:\n                yy_.yytext = strip(1, 2).replace(/\\\\'/g, \"'\");return 80;\n                break;\n              case 33:\n                return 85;\n                break;\n              case 34:\n                return 82;\n                break;\n              case 35:\n                return 82;\n                break;\n              case 36:\n                return 83;\n                break;\n              case 37:\n                return 84;\n                break;\n              case 38:\n                return 81;\n                break;\n              case 39:\n                return 75;\n                break;\n              case 40:\n                return 77;\n                break;\n              case 41:\n                return 72;\n                break;\n              case 42:\n                yy_.yytext = yy_.yytext.replace(/\\\\([\\\\\\]])/g, '$1');return 72;\n                break;\n              case 43:\n                return 'INVALID';\n                break;\n              case 44:\n                return 5;\n                break;}\n\n          };\n          lexer.rules = [/^(?:[^\\x00]*?(?=(\\{\\{)))/, /^(?:[^\\x00]+)/, /^(?:[^\\x00]{2,}?(?=(\\{\\{|\\\\\\{\\{|\\\\\\\\\\{\\{|$)))/, /^(?:\\{\\{\\{\\{(?=[^\\/]))/, /^(?:\\{\\{\\{\\{\\/[^\\s!\"#%-,\\.\\/;->@\\[-\\^`\\{-~]+(?=[=}\\s\\/.])\\}\\}\\}\\})/, /^(?:[^\\x00]*?(?=(\\{\\{\\{\\{)))/, /^(?:[\\s\\S]*?--(~)?\\}\\})/, /^(?:\\()/, /^(?:\\))/, /^(?:\\{\\{\\{\\{)/, /^(?:\\}\\}\\}\\})/, /^(?:\\{\\{(~)?>)/, /^(?:\\{\\{(~)?#>)/, /^(?:\\{\\{(~)?#\\*?)/, /^(?:\\{\\{(~)?\\/)/, /^(?:\\{\\{(~)?\\^\\s*(~)?\\}\\})/, /^(?:\\{\\{(~)?\\s*else\\s*(~)?\\}\\})/, /^(?:\\{\\{(~)?\\^)/, /^(?:\\{\\{(~)?\\s*else\\b)/, /^(?:\\{\\{(~)?\\{)/, /^(?:\\{\\{(~)?&)/, /^(?:\\{\\{(~)?!--)/, /^(?:\\{\\{(~)?![\\s\\S]*?\\}\\})/, /^(?:\\{\\{(~)?\\*?)/, /^(?:=)/, /^(?:\\.\\.)/, /^(?:\\.(?=([=~}\\s\\/.)|])))/, /^(?:[\\/.])/, /^(?:\\s+)/, /^(?:\\}(~)?\\}\\})/, /^(?:(~)?\\}\\})/, /^(?:\"(\\\\[\"]|[^\"])*\")/, /^(?:'(\\\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\\s)])))/, /^(?:false(?=([~}\\s)])))/, /^(?:undefined(?=([~}\\s)])))/, /^(?:null(?=([~}\\s)])))/, /^(?:-?[0-9]+(?:\\.[0-9]+)?(?=([~}\\s)])))/, /^(?:as\\s+\\|)/, /^(?:\\|)/, /^(?:([^\\s!\"#%-,\\.\\/;->@\\[-\\^`\\{-~]+(?=([=~}\\s\\/.)|]))))/, /^(?:\\[(\\\\\\]|[^\\]])*\\])/, /^(?:.)/, /^(?:$)/];\n          lexer.conditions = { \"mu\": { \"rules\": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], \"inclusive\": false }, \"emu\": { \"rules\": [2], \"inclusive\": false }, \"com\": { \"rules\": [6], \"inclusive\": false }, \"raw\": { \"rules\": [3, 4, 5], \"inclusive\": false }, \"INITIAL\": { \"rules\": [0, 1, 44], \"inclusive\": true } };\n          return lexer;\n        }();\n        parser.lexer = lexer;\n        function Parser() {\n          this.yy = {};\n        }Parser.prototype = parser;parser.Parser = Parser;\n        return new Parser();\n      }();exports.__esModule = true;\n      exports['default'] = handlebars;\n\n\n    }, {}], 15: [function (require, module, exports) {\n      /* eslint-disable new-cap */\n      'use strict';\n\n      exports.__esModule = true;\n      exports.print = print;\n      exports.PrintVisitor = PrintVisitor;\n      // istanbul ignore next\n\n      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { 'default': obj };}\n\n      var _visitor = require('./visitor');\n\n      var _visitor2 = _interopRequireDefault(_visitor);\n\n      function print(ast) {\n        return new PrintVisitor().accept(ast);\n      }\n\n      function PrintVisitor() {\n        this.padding = 0;\n      }\n\n      PrintVisitor.prototype = new _visitor2['default']();\n\n      PrintVisitor.prototype.pad = function (string) {\n        var out = '';\n\n        for (var i = 0, l = this.padding; i < l; i++) {\n          out += '  ';\n        }\n\n        out += string + '\\n';\n        return out;\n      };\n\n      PrintVisitor.prototype.Program = function (program) {\n        var out = '',\n        body = program.body,\n        i = undefined,\n        l = undefined;\n\n        if (program.blockParams) {\n          var blockParams = 'BLOCK PARAMS: [';\n          for (i = 0, l = program.blockParams.length; i < l; i++) {\n            blockParams += ' ' + program.blockParams[i];\n          }\n          blockParams += ' ]';\n          out += this.pad(blockParams);\n        }\n\n        for (i = 0, l = body.length; i < l; i++) {\n          out += this.accept(body[i]);\n        }\n\n        this.padding--;\n\n        return out;\n      };\n\n      PrintVisitor.prototype.MustacheStatement = function (mustache) {\n        return this.pad('{{ ' + this.SubExpression(mustache) + ' }}');\n      };\n      PrintVisitor.prototype.Decorator = function (mustache) {\n        return this.pad('{{ DIRECTIVE ' + this.SubExpression(mustache) + ' }}');\n      };\n\n      PrintVisitor.prototype.BlockStatement = PrintVisitor.prototype.DecoratorBlock = function (block) {\n        var out = '';\n\n        out += this.pad((block.type === 'DecoratorBlock' ? 'DIRECTIVE ' : '') + 'BLOCK:');\n        this.padding++;\n        out += this.pad(this.SubExpression(block));\n        if (block.program) {\n          out += this.pad('PROGRAM:');\n          this.padding++;\n          out += this.accept(block.program);\n          this.padding--;\n        }\n        if (block.inverse) {\n          if (block.program) {\n            this.padding++;\n          }\n          out += this.pad('{{^}}');\n          this.padding++;\n          out += this.accept(block.inverse);\n          this.padding--;\n          if (block.program) {\n            this.padding--;\n          }\n        }\n        this.padding--;\n\n        return out;\n      };\n\n      PrintVisitor.prototype.PartialStatement = function (partial) {\n        var content = 'PARTIAL:' + partial.name.original;\n        if (partial.params[0]) {\n          content += ' ' + this.accept(partial.params[0]);\n        }\n        if (partial.hash) {\n          content += ' ' + this.accept(partial.hash);\n        }\n        return this.pad('{{> ' + content + ' }}');\n      };\n      PrintVisitor.prototype.PartialBlockStatement = function (partial) {\n        var content = 'PARTIAL BLOCK:' + partial.name.original;\n        if (partial.params[0]) {\n          content += ' ' + this.accept(partial.params[0]);\n        }\n        if (partial.hash) {\n          content += ' ' + this.accept(partial.hash);\n        }\n\n        content += ' ' + this.pad('PROGRAM:');\n        this.padding++;\n        content += this.accept(partial.program);\n        this.padding--;\n\n        return this.pad('{{> ' + content + ' }}');\n      };\n\n      PrintVisitor.prototype.ContentStatement = function (content) {\n        return this.pad(\"CONTENT[ '\" + content.value + \"' ]\");\n      };\n\n      PrintVisitor.prototype.CommentStatement = function (comment) {\n        return this.pad(\"{{! '\" + comment.value + \"' }}\");\n      };\n\n      PrintVisitor.prototype.SubExpression = function (sexpr) {\n        var params = sexpr.params,\n        paramStrings = [],\n        hash = undefined;\n\n        for (var i = 0, l = params.length; i < l; i++) {\n          paramStrings.push(this.accept(params[i]));\n        }\n\n        params = '[' + paramStrings.join(', ') + ']';\n\n        hash = sexpr.hash ? ' ' + this.accept(sexpr.hash) : '';\n\n        return this.accept(sexpr.path) + ' ' + params + hash;\n      };\n\n      PrintVisitor.prototype.PathExpression = function (id) {\n        var path = id.parts.join('/');\n        return (id.data ? '@' : '') + 'PATH:' + path;\n      };\n\n      PrintVisitor.prototype.StringLiteral = function (string) {\n        return '\"' + string.value + '\"';\n      };\n\n      PrintVisitor.prototype.NumberLiteral = function (number) {\n        return 'NUMBER{' + number.value + '}';\n      };\n\n      PrintVisitor.prototype.BooleanLiteral = function (bool) {\n        return 'BOOLEAN{' + bool.value + '}';\n      };\n\n      PrintVisitor.prototype.UndefinedLiteral = function () {\n        return 'UNDEFINED';\n      };\n\n      PrintVisitor.prototype.NullLiteral = function () {\n        return 'NULL';\n      };\n\n      PrintVisitor.prototype.Hash = function (hash) {\n        var pairs = hash.pairs,\n        joinedPairs = [];\n\n        for (var i = 0, l = pairs.length; i < l; i++) {\n          joinedPairs.push(this.accept(pairs[i]));\n        }\n\n        return 'HASH{' + joinedPairs.join(', ') + '}';\n      };\n      PrintVisitor.prototype.HashPair = function (pair) {\n        return pair.key + '=' + this.accept(pair.value);\n      };\n      /* eslint-enable new-cap */\n\n\n    }, { \"./visitor\": 16 }], 16: [function (require, module, exports) {\n      'use strict';\n\n      exports.__esModule = true;\n      // istanbul ignore next\n\n      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { 'default': obj };}\n\n      var _exception = require('../exception');\n\n      var _exception2 = _interopRequireDefault(_exception);\n\n      function Visitor() {\n        this.parents = [];\n      }\n\n      Visitor.prototype = {\n        constructor: Visitor,\n        mutating: false,\n\n        // Visits a given value. If mutating, will replace the value if necessary.\n        acceptKey: function acceptKey(node, name) {\n          var value = this.accept(node[name]);\n          if (this.mutating) {\n            // Hacky sanity check: This may have a few false positives for type for the helper\n            // methods but will generally do the right thing without a lot of overhead.\n            if (value && !Visitor.prototype[value.type]) {\n              throw new _exception2['default']('Unexpected node type \"' + value.type + '\" found when accepting ' + name + ' on ' + node.type);\n            }\n            node[name] = value;\n          }\n        },\n\n        // Performs an accept operation with added sanity check to ensure\n        // required keys are not removed.\n        acceptRequired: function acceptRequired(node, name) {\n          this.acceptKey(node, name);\n\n          if (!node[name]) {\n            throw new _exception2['default'](node.type + ' requires ' + name);\n          }\n        },\n\n        // Traverses a given array. If mutating, empty respnses will be removed\n        // for child elements.\n        acceptArray: function acceptArray(array) {\n          for (var i = 0, l = array.length; i < l; i++) {\n            this.acceptKey(array, i);\n\n            if (!array[i]) {\n              array.splice(i, 1);\n              i--;\n              l--;\n            }\n          }\n        },\n\n        accept: function accept(object) {\n          if (!object) {\n            return;\n          }\n\n          /* istanbul ignore next: Sanity code */\n          if (!this[object.type]) {\n            throw new _exception2['default']('Unknown type: ' + object.type, object);\n          }\n\n          if (this.current) {\n            this.parents.unshift(this.current);\n          }\n          this.current = object;\n\n          var ret = this[object.type](object);\n\n          this.current = this.parents.shift();\n\n          if (!this.mutating || ret) {\n            return ret;\n          } else if (ret !== false) {\n            return object;\n          }\n        },\n\n        Program: function Program(program) {\n          this.acceptArray(program.body);\n        },\n\n        MustacheStatement: visitSubExpression,\n        Decorator: visitSubExpression,\n\n        BlockStatement: visitBlock,\n        DecoratorBlock: visitBlock,\n\n        PartialStatement: visitPartial,\n        PartialBlockStatement: function PartialBlockStatement(partial) {\n          visitPartial.call(this, partial);\n\n          this.acceptKey(partial, 'program');\n        },\n\n        ContentStatement: function ContentStatement() /* content */{},\n        CommentStatement: function CommentStatement() /* comment */{},\n\n        SubExpression: visitSubExpression,\n\n        PathExpression: function PathExpression() /* path */{},\n\n        StringLiteral: function StringLiteral() /* string */{},\n        NumberLiteral: function NumberLiteral() /* number */{},\n        BooleanLiteral: function BooleanLiteral() /* bool */{},\n        UndefinedLiteral: function UndefinedLiteral() /* literal */{},\n        NullLiteral: function NullLiteral() /* literal */{},\n\n        Hash: function Hash(hash) {\n          this.acceptArray(hash.pairs);\n        },\n        HashPair: function HashPair(pair) {\n          this.acceptRequired(pair, 'value');\n        } };\n\n\n      function visitSubExpression(mustache) {\n        this.acceptRequired(mustache, 'path');\n        this.acceptArray(mustache.params);\n        this.acceptKey(mustache, 'hash');\n      }\n      function visitBlock(block) {\n        visitSubExpression.call(this, block);\n\n        this.acceptKey(block, 'program');\n        this.acceptKey(block, 'inverse');\n      }\n      function visitPartial(partial) {\n        this.acceptRequired(partial, 'name');\n        this.acceptArray(partial.params);\n        this.acceptKey(partial, 'hash');\n      }\n\n      exports['default'] = Visitor;\n      module.exports = exports['default'];\n\n\n    }, { \"../exception\": 20 }], 17: [function (require, module, exports) {\n      'use strict';\n\n      exports.__esModule = true;\n      // istanbul ignore next\n\n      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { 'default': obj };}\n\n      var _visitor = require('./visitor');\n\n      var _visitor2 = _interopRequireDefault(_visitor);\n\n      function WhitespaceControl() {\n        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n        this.options = options;\n      }\n      WhitespaceControl.prototype = new _visitor2['default']();\n\n      WhitespaceControl.prototype.Program = function (program) {\n        var doStandalone = !this.options.ignoreStandalone;\n\n        var isRoot = !this.isRootSeen;\n        this.isRootSeen = true;\n\n        var body = program.body;\n        for (var i = 0, l = body.length; i < l; i++) {\n          var current = body[i],\n          strip = this.accept(current);\n\n          if (!strip) {\n            continue;\n          }\n\n          var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),\n          _isNextWhitespace = isNextWhitespace(body, i, isRoot),\n          openStandalone = strip.openStandalone && _isPrevWhitespace,\n          closeStandalone = strip.closeStandalone && _isNextWhitespace,\n          inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;\n\n          if (strip.close) {\n            omitRight(body, i, true);\n          }\n          if (strip.open) {\n            omitLeft(body, i, true);\n          }\n\n          if (doStandalone && inlineStandalone) {\n            omitRight(body, i);\n\n            if (omitLeft(body, i)) {\n              // If we are on a standalone node, save the indent info for partials\n              if (current.type === 'PartialStatement') {\n                // Pull out the whitespace from the final line\n                current.indent = /([ \\t]+$)/.exec(body[i - 1].original)[1];\n              }\n            }\n          }\n          if (doStandalone && openStandalone) {\n            omitRight((current.program || current.inverse).body);\n\n            // Strip out the previous content node if it's whitespace only\n            omitLeft(body, i);\n          }\n          if (doStandalone && closeStandalone) {\n            // Always strip the next node\n            omitRight(body, i);\n\n            omitLeft((current.inverse || current.program).body);\n          }\n        }\n\n        return program;\n      };\n\n      WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function (block) {\n        this.accept(block.program);\n        this.accept(block.inverse);\n\n        // Find the inverse program that is involed with whitespace stripping.\n        var program = block.program || block.inverse,\n        inverse = block.program && block.inverse,\n        firstInverse = inverse,\n        lastInverse = inverse;\n\n        if (inverse && inverse.chained) {\n          firstInverse = inverse.body[0].program;\n\n          // Walk the inverse chain to find the last inverse that is actually in the chain.\n          while (lastInverse.chained) {\n            lastInverse = lastInverse.body[lastInverse.body.length - 1].program;\n          }\n        }\n\n        var strip = {\n          open: block.openStrip.open,\n          close: block.closeStrip.close,\n\n          // Determine the standalone candiacy. Basically flag our content as being possibly standalone\n          // so our parent can determine if we actually are standalone\n          openStandalone: isNextWhitespace(program.body),\n          closeStandalone: isPrevWhitespace((firstInverse || program).body) };\n\n\n        if (block.openStrip.close) {\n          omitRight(program.body, null, true);\n        }\n\n        if (inverse) {\n          var inverseStrip = block.inverseStrip;\n\n          if (inverseStrip.open) {\n            omitLeft(program.body, null, true);\n          }\n\n          if (inverseStrip.close) {\n            omitRight(firstInverse.body, null, true);\n          }\n          if (block.closeStrip.open) {\n            omitLeft(lastInverse.body, null, true);\n          }\n\n          // Find standalone else statments\n          if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {\n            omitLeft(program.body);\n            omitRight(firstInverse.body);\n          }\n        } else if (block.closeStrip.open) {\n          omitLeft(program.body, null, true);\n        }\n\n        return strip;\n      };\n\n      WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function (mustache) {\n        return mustache.strip;\n      };\n\n      WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node) {\n        /* istanbul ignore next */\n        var strip = node.strip || {};\n        return {\n          inlineStandalone: true,\n          open: strip.open,\n          close: strip.close };\n\n      };\n\n      function isPrevWhitespace(body, i, isRoot) {\n        if (i === undefined) {\n          i = body.length;\n        }\n\n        // Nodes that end with newlines are considered whitespace (but are special\n        // cased for strip operations)\n        var prev = body[i - 1],\n        sibling = body[i - 2];\n        if (!prev) {\n          return isRoot;\n        }\n\n        if (prev.type === 'ContentStatement') {\n          return (sibling || !isRoot ? /\\r?\\n\\s*?$/ : /(^|\\r?\\n)\\s*?$/).test(prev.original);\n        }\n      }\n      function isNextWhitespace(body, i, isRoot) {\n        if (i === undefined) {\n          i = -1;\n        }\n\n        var next = body[i + 1],\n        sibling = body[i + 2];\n        if (!next) {\n          return isRoot;\n        }\n\n        if (next.type === 'ContentStatement') {\n          return (sibling || !isRoot ? /^\\s*?\\r?\\n/ : /^\\s*?(\\r?\\n|$)/).test(next.original);\n        }\n      }\n\n      // Marks the node to the right of the position as omitted.\n      // I.e. {{foo}}' ' will mark the ' ' node as omitted.\n      //\n      // If i is undefined, then the first child will be marked as such.\n      //\n      // If mulitple is truthy then all whitespace will be stripped out until non-whitespace\n      // content is met.\n      function omitRight(body, i, multiple) {\n        var current = body[i == null ? 0 : i + 1];\n        if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {\n          return;\n        }\n\n        var original = current.value;\n        current.value = current.value.replace(multiple ? /^\\s+/ : /^[ \\t]*\\r?\\n?/, '');\n        current.rightStripped = current.value !== original;\n      }\n\n      // Marks the node to the left of the position as omitted.\n      // I.e. ' '{{foo}} will mark the ' ' node as omitted.\n      //\n      // If i is undefined then the last child will be marked as such.\n      //\n      // If mulitple is truthy then all whitespace will be stripped out until non-whitespace\n      // content is met.\n      function omitLeft(body, i, multiple) {\n        var current = body[i == null ? body.length - 1 : i - 1];\n        if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {\n          return;\n        }\n\n        // We omit the last node if it's whitespace only and not preceeded by a non-content node.\n        var original = current.value;\n        current.value = current.value.replace(multiple ? /\\s+$/ : /[ \\t]+$/, '');\n        current.leftStripped = current.value !== original;\n        return current.leftStripped;\n      }\n\n      exports['default'] = WhitespaceControl;\n      module.exports = exports['default'];\n\n\n    }, { \"./visitor\": 16 }], 18: [function (require, module, exports) {\n      'use strict';\n\n      exports.__esModule = true;\n      exports.registerDefaultDecorators = registerDefaultDecorators;\n      // istanbul ignore next\n\n      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { 'default': obj };}\n\n      var _decoratorsInline = require('./decorators/inline');\n\n      var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);\n\n      function registerDefaultDecorators(instance) {\n        _decoratorsInline2['default'](instance);\n      }\n\n\n    }, { \"./decorators/inline\": 19 }], 19: [function (require, module, exports) {\n      'use strict';\n\n      exports.__esModule = true;\n\n      var _utils = require('../utils');\n\n      exports['default'] = function (instance) {\n        instance.registerDecorator('inline', function (fn, props, container, options) {\n          var ret = fn;\n          if (!props.partials) {\n            props.partials = {};\n            ret = function ret(context, options) {\n              // Create a new partials stack frame prior to exec.\n              var original = container.partials;\n              container.partials = _utils.extend({}, original, props.partials);\n              var ret = fn(context, options);\n              container.partials = original;\n              return ret;\n            };\n          }\n\n          props.partials[options.args[0]] = options.fn;\n\n          return ret;\n        });\n      };\n\n      module.exports = exports['default'];\n\n\n    }, { \"../utils\": 33 }], 20: [function (require, module, exports) {\n      'use strict';\n\n      exports.__esModule = true;\n\n      var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];\n\n      function Exception(message, node) {\n        var loc = node && node.loc,\n        line = undefined,\n        column = undefined;\n        if (loc) {\n          line = loc.start.line;\n          column = loc.start.column;\n\n          message += ' - ' + line + ':' + column;\n        }\n\n        var tmp = Error.prototype.constructor.call(this, message);\n\n        // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.\n        for (var idx = 0; idx < errorProps.length; idx++) {\n          this[errorProps[idx]] = tmp[errorProps[idx]];\n        }\n\n        /* istanbul ignore else */\n        if (Error.captureStackTrace) {\n          Error.captureStackTrace(this, Exception);\n        }\n\n        try {\n          if (loc) {\n            this.lineNumber = line;\n\n            // Work around issue under safari where we can't directly set the column value\n            /* istanbul ignore next */\n            if (Object.defineProperty) {\n              Object.defineProperty(this, 'column', { value: column });\n            } else {\n              this.column = column;\n            }\n          }\n        } catch (nop) {\n          /* Ignore if the browser is very particular */\n        }\n      }\n\n      Exception.prototype = new Error();\n\n      exports['default'] = Exception;\n      module.exports = exports['default'];\n\n\n    }, {}], 21: [function (require, module, exports) {\n      'use strict';\n\n      exports.__esModule = true;\n      exports.registerDefaultHelpers = registerDefaultHelpers;\n      // istanbul ignore next\n\n      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { 'default': obj };}\n\n      var _helpersBlockHelperMissing = require('./helpers/block-helper-missing');\n\n      var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);\n\n      var _helpersEach = require('./helpers/each');\n\n      var _helpersEach2 = _interopRequireDefault(_helpersEach);\n\n      var _helpersHelperMissing = require('./helpers/helper-missing');\n\n      var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);\n\n      var _helpersIf = require('./helpers/if');\n\n      var _helpersIf2 = _interopRequireDefault(_helpersIf);\n\n      var _helpersLog = require('./helpers/log');\n\n      var _helpersLog2 = _interopRequireDefault(_helpersLog);\n\n      var _helpersLookup = require('./helpers/lookup');\n\n      var _helpersLookup2 = _interopRequireDefault(_helpersLookup);\n\n      var _helpersWith = require('./helpers/with');\n\n      var _helpersWith2 = _interopRequireDefault(_helpersWith);\n\n      function registerDefaultHelpers(instance) {\n        _helpersBlockHelperMissing2['default'](instance);\n        _helpersEach2['default'](instance);\n        _helpersHelperMissing2['default'](instance);\n        _helpersIf2['default'](instance);\n        _helpersLog2['default'](instance);\n        _helpersLookup2['default'](instance);\n        _helpersWith2['default'](instance);\n      }\n\n\n    }, { \"./helpers/block-helper-missing\": 22, \"./helpers/each\": 23, \"./helpers/helper-missing\": 24, \"./helpers/if\": 25, \"./helpers/log\": 26, \"./helpers/lookup\": 27, \"./helpers/with\": 28 }], 22: [function (require, module, exports) {\n      'use strict';\n\n      exports.__esModule = true;\n\n      var _utils = require('../utils');\n\n      exports['default'] = function (instance) {\n        instance.registerHelper('blockHelperMissing', function (context, options) {\n          var inverse = options.inverse,\n          fn = options.fn;\n\n          if (context === true) {\n            return fn(this);\n          } else if (context === false || context == null) {\n            return inverse(this);\n          } else if (_utils.isArray(context)) {\n            if (context.length > 0) {\n              if (options.ids) {\n                options.ids = [options.name];\n              }\n\n              return instance.helpers.each(context, options);\n            } else {\n              return inverse(this);\n            }\n          } else {\n            if (options.data && options.ids) {\n              var data = _utils.createFrame(options.data);\n              data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);\n              options = { data: data };\n            }\n\n            return fn(context, options);\n          }\n        });\n      };\n\n      module.exports = exports['default'];\n\n\n    }, { \"../utils\": 33 }], 23: [function (require, module, exports) {\n      'use strict';\n\n      exports.__esModule = true;\n      // istanbul ignore next\n\n      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { 'default': obj };}\n\n      var _utils = require('../utils');\n\n      var _exception = require('../exception');\n\n      var _exception2 = _interopRequireDefault(_exception);\n\n      exports['default'] = function (instance) {\n        instance.registerHelper('each', function (context, options) {\n          if (!options) {\n            throw new _exception2['default']('Must pass iterator to #each');\n          }\n\n          var fn = options.fn,\n          inverse = options.inverse,\n          i = 0,\n          ret = '',\n          data = undefined,\n          contextPath = undefined;\n\n          if (options.data && options.ids) {\n            contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';\n          }\n\n          if (_utils.isFunction(context)) {\n            context = context.call(this);\n          }\n\n          if (options.data) {\n            data = _utils.createFrame(options.data);\n          }\n\n          function execIteration(field, index, last) {\n            if (data) {\n              data.key = field;\n              data.index = index;\n              data.first = index === 0;\n              data.last = !!last;\n\n              if (contextPath) {\n                data.contextPath = contextPath + field;\n              }\n            }\n\n            ret = ret + fn(context[field], {\n              data: data,\n              blockParams: _utils.blockParams([context[field], field], [contextPath + field, null]) });\n\n          }\n\n          if (context && (typeof context === \"undefined\" ? \"undefined\" : _typeof2(context)) === 'object') {\n            if (_utils.isArray(context)) {\n              for (var j = context.length; i < j; i++) {\n                if (i in context) {\n                  execIteration(i, i, i === context.length - 1);\n                }\n              }\n            } else {\n              var priorKey = undefined;\n\n              for (var key in context) {\n                if (context.hasOwnProperty(key)) {\n                  // We're running the iterations one step out of sync so we can detect\n                  // the last iteration without have to scan the object twice and create\n                  // an itermediate keys array.\n                  if (priorKey !== undefined) {\n                    execIteration(priorKey, i - 1);\n                  }\n                  priorKey = key;\n                  i++;\n                }\n              }\n              if (priorKey !== undefined) {\n                execIteration(priorKey, i - 1, true);\n              }\n            }\n          }\n\n          if (i === 0) {\n            ret = inverse(this);\n          }\n\n          return ret;\n        });\n      };\n\n      module.exports = exports['default'];\n\n\n    }, { \"../exception\": 20, \"../utils\": 33 }], 24: [function (require, module, exports) {\n      'use strict';\n\n      exports.__esModule = true;\n      // istanbul ignore next\n\n      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { 'default': obj };}\n\n      var _exception = require('../exception');\n\n      var _exception2 = _interopRequireDefault(_exception);\n\n      exports['default'] = function (instance) {\n        instance.registerHelper('helperMissing', function () /* [args, ]options */{\n          if (arguments.length === 1) {\n            // A missing field in a {{foo}} construct.\n            return undefined;\n          } else {\n            // Someone is actually trying to call something, blow up.\n            throw new _exception2['default']('Missing helper: \"' + arguments[arguments.length - 1].name + '\"');\n          }\n        });\n      };\n\n      module.exports = exports['default'];\n\n\n    }, { \"../exception\": 20 }], 25: [function (require, module, exports) {\n      'use strict';\n\n      exports.__esModule = true;\n\n      var _utils = require('../utils');\n\n      exports['default'] = function (instance) {\n        instance.registerHelper('if', function (conditional, options) {\n          if (_utils.isFunction(conditional)) {\n            conditional = conditional.call(this);\n          }\n\n          // Default behavior is to render the positive path if the value is truthy and not empty.\n          // The `includeZero` option may be set to treat the condtional as purely not empty based on the\n          // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.\n          if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {\n            return options.inverse(this);\n          } else {\n            return options.fn(this);\n          }\n        });\n\n        instance.registerHelper('unless', function (conditional, options) {\n          return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });\n        });\n      };\n\n      module.exports = exports['default'];\n\n\n    }, { \"../utils\": 33 }], 26: [function (require, module, exports) {\n      'use strict';\n\n      exports.__esModule = true;\n\n      exports['default'] = function (instance) {\n        instance.registerHelper('log', function () /* message, options */{\n          var args = [undefined],\n          options = arguments[arguments.length - 1];\n          for (var i = 0; i < arguments.length - 1; i++) {\n            args.push(arguments[i]);\n          }\n\n          var level = 1;\n          if (options.hash.level != null) {\n            level = options.hash.level;\n          } else if (options.data && options.data.level != null) {\n            level = options.data.level;\n          }\n          args[0] = level;\n\n          instance.log.apply(instance, args);\n        });\n      };\n\n      module.exports = exports['default'];\n\n\n    }, {}], 27: [function (require, module, exports) {\n      'use strict';\n\n      exports.__esModule = true;\n\n      exports['default'] = function (instance) {\n        instance.registerHelper('lookup', function (obj, field) {\n          return obj && obj[field];\n        });\n      };\n\n      module.exports = exports['default'];\n\n\n    }, {}], 28: [function (require, module, exports) {\n      'use strict';\n\n      exports.__esModule = true;\n\n      var _utils = require('../utils');\n\n      exports['default'] = function (instance) {\n        instance.registerHelper('with', function (context, options) {\n          if (_utils.isFunction(context)) {\n            context = context.call(this);\n          }\n\n          var fn = options.fn;\n\n          if (!_utils.isEmpty(context)) {\n            var data = options.data;\n            if (options.data && options.ids) {\n              data = _utils.createFrame(options.data);\n              data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);\n            }\n\n            return fn(context, {\n              data: data,\n              blockParams: _utils.blockParams([context], [data && data.contextPath]) });\n\n          } else {\n            return options.inverse(this);\n          }\n        });\n      };\n\n      module.exports = exports['default'];\n\n\n    }, { \"../utils\": 33 }], 29: [function (require, module, exports) {\n      'use strict';\n\n      exports.__esModule = true;\n\n      var _utils = require('./utils');\n\n      var logger = {\n        methodMap: ['debug', 'info', 'warn', 'error'],\n        level: 'info',\n\n        // Maps a given level value to the `methodMap` indexes above.\n        lookupLevel: function lookupLevel(level) {\n          if (typeof level === 'string') {\n            var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());\n            if (levelMap >= 0) {\n              level = levelMap;\n            } else {\n              level = parseInt(level, 10);\n            }\n          }\n\n          return level;\n        },\n\n        // Can be overridden in the host environment\n        log: function log(level) {\n          level = logger.lookupLevel(level);\n\n          if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {\n            var method = logger.methodMap[level];\n            if (!console[method]) {\n              // eslint-disable-line no-console\n              method = 'log';\n            }\n\n            for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n              message[_key - 1] = arguments[_key];\n            }\n\n            console[method].apply(console, message); // eslint-disable-line no-console\n          }\n        } };\n\n\n      exports['default'] = logger;\n      module.exports = exports['default'];\n\n\n    }, { \"./utils\": 33 }], 30: [function (require, module, exports) {\n      (function (global) {\n        /* global window */\n        'use strict';\n\n        exports.__esModule = true;\n\n        exports['default'] = function (Handlebars) {\n          /* istanbul ignore next */\n          var root = typeof global !== 'undefined' ? global : window,\n          $Handlebars = root.Handlebars;\n          /* istanbul ignore next */\n          Handlebars.noConflict = function () {\n            if (root.Handlebars === Handlebars) {\n              root.Handlebars = $Handlebars;\n            }\n            return Handlebars;\n          };\n        };\n\n        module.exports = exports['default'];\n\n\n      }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {}], 31: [function (require, module, exports) {\n      'use strict';\n\n      exports.__esModule = true;\n      exports.checkRevision = checkRevision;\n      exports.template = template;\n      exports.wrapProgram = wrapProgram;\n      exports.resolvePartial = resolvePartial;\n      exports.invokePartial = invokePartial;\n      exports.noop = noop;\n      // istanbul ignore next\n\n      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { 'default': obj };}\n\n      // istanbul ignore next\n\n      function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;} else {var newObj = {};if (obj != null) {for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];}}newObj['default'] = obj;return newObj;}}\n\n      var _utils = require('./utils');\n\n      var Utils = _interopRequireWildcard(_utils);\n\n      var _exception = require('./exception');\n\n      var _exception2 = _interopRequireDefault(_exception);\n\n      var _base = require('./base');\n\n      function checkRevision(compilerInfo) {\n        var compilerRevision = compilerInfo && compilerInfo[0] || 1,\n        currentRevision = _base.COMPILER_REVISION;\n\n        if (compilerRevision !== currentRevision) {\n          if (compilerRevision < currentRevision) {\n            var runtimeVersions = _base.REVISION_CHANGES[currentRevision],\n            compilerVersions = _base.REVISION_CHANGES[compilerRevision];\n            throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');\n          } else {\n            // Use the embedded version info since the runtime doesn't know about this revision yet\n            throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');\n          }\n        }\n      }\n\n      function template(templateSpec, env) {\n        /* istanbul ignore next */\n        if (!env) {\n          throw new _exception2['default']('No environment passed to template');\n        }\n        if (!templateSpec || !templateSpec.main) {\n          throw new _exception2['default']('Unknown template object: ' + (typeof templateSpec === \"undefined\" ? \"undefined\" : _typeof2(templateSpec)));\n        }\n\n        templateSpec.main.decorator = templateSpec.main_d;\n\n        // Note: Using env.VM references rather than local var references throughout this section to allow\n        // for external users to override these as psuedo-supported APIs.\n        env.VM.checkRevision(templateSpec.compiler);\n\n        function invokePartialWrapper(partial, context, options) {\n          if (options.hash) {\n            context = Utils.extend({}, context, options.hash);\n            if (options.ids) {\n              options.ids[0] = true;\n            }\n          }\n\n          partial = env.VM.resolvePartial.call(this, partial, context, options);\n          var result = env.VM.invokePartial.call(this, partial, context, options);\n\n          if (result == null && env.compile) {\n            options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);\n            result = options.partials[options.name](context, options);\n          }\n          if (result != null) {\n            if (options.indent) {\n              var lines = result.split('\\n');\n              for (var i = 0, l = lines.length; i < l; i++) {\n                if (!lines[i] && i + 1 === l) {\n                  break;\n                }\n\n                lines[i] = options.indent + lines[i];\n              }\n              result = lines.join('\\n');\n            }\n            return result;\n          } else {\n            throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');\n          }\n        }\n\n        // Just add water\n        var container = {\n          strict: function strict(obj, name) {\n            if (!(name in obj)) {\n              throw new _exception2['default']('\"' + name + '\" not defined in ' + obj);\n            }\n            return obj[name];\n          },\n          lookup: function lookup(depths, name) {\n            var len = depths.length;\n            for (var i = 0; i < len; i++) {\n              if (depths[i] && depths[i][name] != null) {\n                return depths[i][name];\n              }\n            }\n          },\n          lambda: function lambda(current, context) {\n            return typeof current === 'function' ? current.call(context) : current;\n          },\n\n          escapeExpression: Utils.escapeExpression,\n          invokePartial: invokePartialWrapper,\n\n          fn: function fn(i) {\n            var ret = templateSpec[i];\n            ret.decorator = templateSpec[i + '_d'];\n            return ret;\n          },\n\n          programs: [],\n          program: function program(i, data, declaredBlockParams, blockParams, depths) {\n            var programWrapper = this.programs[i],\n            fn = this.fn(i);\n            if (data || depths || blockParams || declaredBlockParams) {\n              programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);\n            } else if (!programWrapper) {\n              programWrapper = this.programs[i] = wrapProgram(this, i, fn);\n            }\n            return programWrapper;\n          },\n\n          data: function data(value, depth) {\n            while (value && depth--) {\n              value = value._parent;\n            }\n            return value;\n          },\n          merge: function merge(param, common) {\n            var obj = param || common;\n\n            if (param && common && param !== common) {\n              obj = Utils.extend({}, common, param);\n            }\n\n            return obj;\n          },\n\n          noop: env.VM.noop,\n          compilerInfo: templateSpec.compiler };\n\n\n        function ret(context) {\n          var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n          var data = options.data;\n\n          ret._setup(options);\n          if (!options.partial && templateSpec.useData) {\n            data = initData(context, data);\n          }\n          var depths = undefined,\n          blockParams = templateSpec.useBlockParams ? [] : undefined;\n          if (templateSpec.useDepths) {\n            if (options.depths) {\n              depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;\n            } else {\n              depths = [context];\n            }\n          }\n\n          function main(context /*, options*/) {\n            return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);\n          }\n          main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);\n          return main(context, options);\n        }\n        ret.isTop = true;\n\n        ret._setup = function (options) {\n          if (!options.partial) {\n            container.helpers = container.merge(options.helpers, env.helpers);\n\n            if (templateSpec.usePartial) {\n              container.partials = container.merge(options.partials, env.partials);\n            }\n            if (templateSpec.usePartial || templateSpec.useDecorators) {\n              container.decorators = container.merge(options.decorators, env.decorators);\n            }\n          } else {\n            container.helpers = options.helpers;\n            container.partials = options.partials;\n            container.decorators = options.decorators;\n          }\n        };\n\n        ret._child = function (i, data, blockParams, depths) {\n          if (templateSpec.useBlockParams && !blockParams) {\n            throw new _exception2['default']('must pass block params');\n          }\n          if (templateSpec.useDepths && !depths) {\n            throw new _exception2['default']('must pass parent depths');\n          }\n\n          return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);\n        };\n        return ret;\n      }\n\n      function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {\n        function prog(context) {\n          var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n          var currentDepths = depths;\n          if (depths && context != depths[0]) {\n            currentDepths = [context].concat(depths);\n          }\n\n          return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);\n        }\n\n        prog = executeDecorators(fn, prog, container, depths, data, blockParams);\n\n        prog.program = i;\n        prog.depth = depths ? depths.length : 0;\n        prog.blockParams = declaredBlockParams || 0;\n        return prog;\n      }\n\n      function resolvePartial(partial, context, options) {\n        if (!partial) {\n          if (options.name === '@partial-block') {\n            var data = options.data;\n            while (data['partial-block'] === noop) {\n              data = data._parent;\n            }\n            partial = data['partial-block'];\n            data['partial-block'] = noop;\n          } else {\n            partial = options.partials[options.name];\n          }\n        } else if (!partial.call && !options.name) {\n          // This is a dynamic partial that returned a string\n          options.name = partial;\n          partial = options.partials[partial];\n        }\n        return partial;\n      }\n\n      function invokePartial(partial, context, options) {\n        options.partial = true;\n        if (options.ids) {\n          options.data.contextPath = options.ids[0] || options.data.contextPath;\n        }\n\n        var partialBlock = undefined;\n        if (options.fn && options.fn !== noop) {\n          options.data = _base.createFrame(options.data);\n          partialBlock = options.data['partial-block'] = options.fn;\n\n          if (partialBlock.partials) {\n            options.partials = Utils.extend({}, options.partials, partialBlock.partials);\n          }\n        }\n\n        if (partial === undefined && partialBlock) {\n          partial = partialBlock;\n        }\n\n        if (partial === undefined) {\n          throw new _exception2['default']('The partial ' + options.name + ' could not be found');\n        } else if (partial instanceof Function) {\n          return partial(context, options);\n        }\n      }\n\n      function noop() {\n        return '';\n      }\n\n      function initData(context, data) {\n        if (!data || !('root' in data)) {\n          data = data ? _base.createFrame(data) : {};\n          data.root = context;\n        }\n        return data;\n      }\n\n      function executeDecorators(fn, prog, container, depths, data, blockParams) {\n        if (fn.decorator) {\n          var props = {};\n          prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);\n          Utils.extend(prog, props);\n        }\n        return prog;\n      }\n\n\n    }, { \"./base\": 7, \"./exception\": 20, \"./utils\": 33 }], 32: [function (require, module, exports) {\n      // Build out our basic SafeString type\n      'use strict';\n\n      exports.__esModule = true;\n      function SafeString(string) {\n        this.string = string;\n      }\n\n      SafeString.prototype.toString = SafeString.prototype.toHTML = function () {\n        return '' + this.string;\n      };\n\n      exports['default'] = SafeString;\n      module.exports = exports['default'];\n\n\n    }, {}], 33: [function (require, module, exports) {\n      'use strict';\n\n      exports.__esModule = true;\n      exports.extend = extend;\n      exports.indexOf = indexOf;\n      exports.escapeExpression = escapeExpression;\n      exports.isEmpty = isEmpty;\n      exports.createFrame = createFrame;\n      exports.blockParams = blockParams;\n      exports.appendContextPath = appendContextPath;\n      var escape = {\n        '&': '&amp;',\n        '<': '&lt;',\n        '>': '&gt;',\n        '\"': '&quot;',\n        \"'\": '&#x27;',\n        '`': '&#x60;',\n        '=': '&#x3D;' };\n\n\n      var badChars = /[&<>\"'`=]/g,\n      possible = /[&<>\"'`=]/;\n\n      function escapeChar(chr) {\n        return escape[chr];\n      }\n\n      function extend(obj /* , ...source */) {\n        for (var i = 1; i < arguments.length; i++) {\n          for (var key in arguments[i]) {\n            if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {\n              obj[key] = arguments[i][key];\n            }\n          }\n        }\n\n        return obj;\n      }\n\n      var toString = Object.prototype.toString;\n\n      exports.toString = toString;\n      // Sourced from lodash\n      // https://github.com/bestiejs/lodash/blob/master/LICENSE.txt\n      /* eslint-disable func-style */\n      var isFunction = function isFunction(value) {\n        return typeof value === 'function';\n      };\n      // fallback for older versions of Chrome and Safari\n      /* istanbul ignore next */\n      if (isFunction(/x/)) {\n        exports.isFunction = isFunction = function isFunction(value) {\n          return typeof value === 'function' && toString.call(value) === '[object Function]';\n        };\n      }\n      exports.isFunction = isFunction;\n\n      /* eslint-enable func-style */\n\n      /* istanbul ignore next */\n      var isArray = Array.isArray || function (value) {\n        return value && (typeof value === \"undefined\" ? \"undefined\" : _typeof2(value)) === 'object' ? toString.call(value) === '[object Array]' : false;\n      };\n\n      exports.isArray = isArray;\n      // Older IE versions do not directly support indexOf so we must implement our own, sadly.\n\n      function indexOf(array, value) {\n        for (var i = 0, len = array.length; i < len; i++) {\n          if (array[i] === value) {\n            return i;\n          }\n        }\n        return -1;\n      }\n\n      function escapeExpression(string) {\n        if (typeof string !== 'string') {\n          // don't escape SafeStrings, since they're already safe\n          if (string && string.toHTML) {\n            return string.toHTML();\n          } else if (string == null) {\n            return '';\n          } else if (!string) {\n            return string + '';\n          }\n\n          // Force a string conversion as this will be done by the append regardless and\n          // the regex test will do this transparently behind the scenes, causing issues if\n          // an object's to string has escaped characters in it.\n          string = '' + string;\n        }\n\n        if (!possible.test(string)) {\n          return string;\n        }\n        return string.replace(badChars, escapeChar);\n      }\n\n      function isEmpty(value) {\n        if (!value && value !== 0) {\n          return true;\n        } else if (isArray(value) && value.length === 0) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n\n      function createFrame(object) {\n        var frame = extend({}, object);\n        frame._parent = object;\n        return frame;\n      }\n\n      function blockParams(params, ids) {\n        params.path = ids;\n        return params;\n      }\n\n      function appendContextPath(contextPath, id) {\n        return (contextPath ? contextPath + '.' : '') + id;\n      }\n\n\n    }, {}], 34: [function (require, module, exports) {\n      // USAGE:\n      // var handlebars = require('handlebars');\n      /* eslint-disable no-var */\n\n      // var local = handlebars.create();\n\n      var handlebars = require('../dist/cjs/handlebars')['default'];\n\n      var printer = require('../dist/cjs/handlebars/compiler/printer');\n      handlebars.PrintVisitor = printer.PrintVisitor;\n      handlebars.print = printer.print;\n\n      module.exports = handlebars;\n\n      // Publish a Node.js require() handler for .handlebars and .hbs files\n      function extension(module, filename) {\n        var fs = require('fs');\n        var templateString = fs.readFileSync(filename, 'utf8');\n        module.exports = handlebars.compile(templateString);\n      }\n      /* istanbul ignore else */\n      if (typeof require !== 'undefined' && require.extensions) {\n        require.extensions['.handlebars'] = extension;\n        require.extensions['.hbs'] = extension;\n      }\n\n    }, { \"../dist/cjs/handlebars\": 5, \"../dist/cjs/handlebars/compiler/printer\": 15, \"fs\": 63 }], 35: [function (require, module, exports) {\n      // Create a simple path alias to allow browserify to resolve\n      // the runtime on a supported path.\n      module.exports = require('./dist/cjs/handlebars.runtime')['default'];\n\n    }, { \"./dist/cjs/handlebars.runtime\": 6 }], 36: [function (require, module, exports) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true });\n\n\n      var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();\n\n      require('whatwg-fetch');\n\n      function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}\n\n      require('es6-promise').polyfill(); // needed for fetch\n\n      var Handlebars = require('handlebars');\n      /**\n                                               * Makes sure that a path is converted to an array.\n                                               * @param paths\n                                               * @returns {*}\n                                               */\n      var ensurePathArray = function ensurePathArray(paths) {\n        if (!paths) {\n          paths = [];\n        } else if (typeof paths === 'string') {\n          paths = [paths];\n        }\n        return paths;\n      };\n\n      /**\n          The Resource Manager.\n          @class ResourceManager\n          @description Represents a manager that loads any CSS and Javascript Resources on the fly.\n          */\n\n      var ResourceManager = function () {\n\n        /**\n                                          * Upon initialization.\n                                          * @memberOf ResourceManager\n                                          */\n        function ResourceManager() {\n          _classCallCheck(this, ResourceManager);\n\n          this._head = document.getElementsByTagName('head')[0];\n          this._cssPaths = {};\n          this._scriptMaps = {};\n          this._dataPromises = {};\n        }\n\n        /**\n           * Loads a javascript file.\n           * @param {string|Array} paths - The path to the view's js file\n           * @memberOf ResourceManager\n           * @return {Promise} Returns a promise that resolves when all scripts have been loaded\n           */\n\n\n        _createClass(ResourceManager, [{\n          key: 'loadScript',\n          value: function loadScript(paths) {\n            var script,\n            map,\n            loadPromises = [];\n            paths = ensurePathArray(paths);\n            paths.forEach(function (path) {\n              map = this._scriptMaps[path] = this._scriptMaps[path] || {};\n              if (!map.promise) {\n                map.path = path;\n                map.promise = new Promise(function (resolve) {\n                  script = this.createScriptElement();\n                  script.setAttribute('type', 'text/javascript');\n                  script.src = path;\n                  script.addEventListener('load', resolve);\n                  this._head.appendChild(script);\n                }.bind(this));\n              }\n              loadPromises.push(map.promise);\n            }.bind(this));\n            return Promise.all(loadPromises);\n          }\n\n          /**\n             * Removes a script that has the specified path from the head of the document.\n             * @param {string|Array} paths - The paths of the scripts to unload\n             * @memberOf ResourceManager\n             */ },\n\n        {\n          key: 'unloadScript',\n          value: function unloadScript(paths) {\n            var file;\n            return new Promise(function (resolve) {\n              paths = ensurePathArray(paths);\n              paths.forEach(function (path) {\n                file = this._head.querySelectorAll('script[src=\"' + path + '\"]')[0];\n                if (file) {\n                  this._head.removeChild(file);\n                  delete this._scriptMaps[path];\n                }\n              }.bind(this));\n              resolve();\n            }.bind(this));\n          }\n\n          /**\n             * Creates a new script element.\n             * @returns {HTMLElement}\n             */ },\n\n        {\n          key: 'createScriptElement',\n          value: function createScriptElement() {\n            return document.createElement('script');\n          }\n\n          /**\n             * Makes a request to get data and caches it.\n             * @param {string} url - The url to fetch data from\n             * @param [reqOptions] - options to be passed to fetch call\n             * @returns {*}\n             */ },\n\n        {\n          key: 'fetchData',\n          value: function fetchData(url) {\n            var _this = this;\n\n            var reqOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            var cacheId = url + JSON.stringify(reqOptions);\n\n            reqOptions.cache = reqOptions.cache === undefined ? true : reqOptions.cache;\n\n            if (!url) {\n              return Promise.resolve();\n            }\n            if (!this._dataPromises[cacheId] || !reqOptions.cache) {\n              this._dataPromises[cacheId] = fetch(url, reqOptions).catch(function (e) {\n                // if failure, remove cache so that subsequent\n                // requests will trigger new ajax call\n                _this._dataPromises[cacheId] = null;\n                throw e;\n              });\n            }\n            return this._dataPromises[cacheId];\n          }\n\n          /**\n             * Loads css files.\n             * @param {Array|String} paths - An array of css paths files to load\n             * @memberOf ResourceManager\n             * @return {Promise}\n             */ },\n\n        {\n          key: 'loadCss',\n          value: function loadCss(paths) {\n            return new Promise(function (resolve) {\n              paths = ensurePathArray(paths);\n              paths.forEach(function (path) {\n                // TODO: figure out a way to find out when css is guaranteed to be loaded,\n                // and make this return a truely asynchronous promise\n                if (!this._cssPaths[path]) {\n                  var el = document.createElement('link');\n                  el.setAttribute('rel', 'stylesheet');\n                  el.setAttribute('href', path);\n                  this._head.appendChild(el);\n                  this._cssPaths[path] = el;\n                }\n              }.bind(this));\n              resolve();\n            }.bind(this));\n          }\n\n          /**\n             * Unloads css paths.\n             * @param {string|Array} paths - The css paths to unload\n             * @memberOf ResourceManager\n             * @return {Promise}\n             */ },\n\n        {\n          key: 'unloadCss',\n          value: function unloadCss(paths) {\n            var el;\n            return new Promise(function (resolve) {\n              paths = ensurePathArray(paths);\n              paths.forEach(function (path) {\n                el = this._cssPaths[path];\n                if (el) {\n                  this._head.removeChild(el);\n                  this._cssPaths[path] = null;\n                }\n              }.bind(this));\n              resolve();\n            }.bind(this));\n          }\n\n          /**\n             * Parses a template into a DOM element, then returns element back to you.\n             * @param {string} path - The path to the template\n             * @param {HTMLElement} [el] - The element to attach template to\n             * @param {Object|Array} [hbsData] - The data to use for the handlebar template (if applicable)\n             * @returns {Promise} Returns a promise that resolves with contents of template file\n             */ },\n\n        {\n          key: 'loadTemplate',\n          value: function loadTemplate(path, el, hbsData) {\n\n            var isHandlebarFile = function isHandlebarFile(filePath) {\n              if (filePath) {\n                var frags = filePath.split('.');\n                var ext = frags[frags.length - 1];\n                return ext === 'hbs';\n              }\n            };\n\n            if (!path) {\n              return Promise.resolve();\n            }\n\n            return fetch(path).then(function (resp) {\n              return resp.text().then(function (contents) {\n                if (isHandlebarFile(path)) {\n                  contents = Handlebars.compile(contents)(hbsData || {});\n                }\n                if (el) {\n                  el.innerHTML = contents;\n                  contents = el;\n                }\n                return contents;\n              });\n            });\n          }\n\n          /**\n             * Removes all cached resources.\n             * @memberOf ResourceManager\n             */ },\n\n        {\n          key: 'flush',\n          value: function flush() {\n            this.unloadCss(Object.getOwnPropertyNames(this._cssPaths));\n            this._cssPaths = {};\n            for (var s in this._scriptMaps) {\n              if (this._scriptMaps.hasOwnProperty(s)) {\n                var map = this._scriptMaps[s];\n                this.unloadScript(map.path);\n              }\n            }\n            this._scriptMaps = {};\n            this._dataPromises = {};\n          } }]);\n\n\n        return ResourceManager;\n      }();\n\n      exports.default = new ResourceManager();\n\n    }, { \"es6-promise\": 4, \"handlebars\": 34, \"whatwg-fetch\": 57 }], 37: [function (require, module, exports) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true });\n\n\n      var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {return typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);} : function (obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);};\n\n      var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();\n\n      var _resourceManagerJs = require('resource-manager-js');\n\n      var _resourceManagerJs2 = _interopRequireDefault(_resourceManagerJs);\n\n      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}\n\n      function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}\n\n      var Promise = require('es6-promise').Promise;\n      var runtime = require('handlebars/runtime');\n\n      /**\n                                                    * Takes a value and separates the number and unit into a key/value map.\n                                                    * @param v - The value\n                                                    * @returns {{num: Number, unit: string}} Returns the map\n                                                    * @private\n                                                    */\n      var getCssPropUnitMap = function getCssPropUnitMap(v) {\n        v.trim();\n        var num = v.match('[0-9\\.]+'),\n        unit = 'ms';\n\n        num = num ? num[0] : '';\n        if (num) {\n          unit = v.split(num)[1];\n          num = Number(num);\n        }\n        return {\n          num: num,\n          unit: unit };\n\n      };\n\n      /**\n          * Converts a css timing unit value into milliseconds.\n          * @param {string} val - The value string\n          * @returns {string} Returns the timing unit value in milliseconds\n          */\n      var convertCssTimeValueToMilliseconds = function convertCssTimeValueToMilliseconds(val) {\n        var number = getCssPropUnitMap(val).num,\n        unit = val.replace(number, '');\n        if (unit === 's') {\n          val = number * 1000;\n        } else {\n          val = number;\n        }\n        return val + 'ms';\n      };\n\n      /**\n          * Takes a css property name and returns the javascript version of it.\n          * @param {string} cssProp - The css property\n          * @returns {string} Returns the javascript version\n          * @private\n          */\n      var getJsPropName = function getJsPropName(cssProp) {\n        // convert to camelCase\n        return cssProp.replace(/-([a-z])/g, function (letter) {\n          return letter[1].toUpperCase();\n        });\n      };\n\n      /**\n          * Bubbles up each parent node of the element, triggering the callback on each element until traversal\n          * either runs out of parent nodes, reaches the document element, or if callback returns a falsy value\n          * @param {Function} callback - A callback that fires which gets passed the current element\n          * @param {HTMLElement} [startEl] - The element where traversal will begin (including the passed element), defaults to current el\n          */\n      var traverseEachParent = function traverseEachParent(callback, startEl) {\n        var parentNode = startEl;\n        var predicate = null;\n        // check if the node has classname property, if not, we know we're at the #document element\n        while (parentNode && typeof parentNode.className === 'string') {\n          predicate = callback(parentNode);\n          if (predicate !== undefined && !predicate) {\n            break;\n          }\n          parentNode = parentNode.parentNode;\n        }\n      };\n\n      /**\n          * A function that fires when the module's load() method is called\n          * @callback Module~onLoad\n          * @return {*} May return a promise when done\n          */\n\n      /**\n              * A function that fires when the module's show() method is called\n              * which can be overridden by subclass custom implementations.\n              * @callback Module~onShow\n              * @return {*} May return a promise when done\n              */\n\n      /**\n                  * A function that fires when the module's hide() method is called\n                  * which can be overridden by subclass custom implementations.\n                  * @callback Module~onHide\n                  */\n\n      /**\n                      * A function that fires when the module's enable() method is called\n                      * @callback Module~onEnable\n                      */\n\n      /**\n                          * A function that fires when the module's disable() method is called\n                          * @callback Module~onDisable\n                          */\n\n      /**\n                              * A function that fires when the error() method is called\n                              * @callback Module~onError\n                              * @param {Object} [e] - The error object that was triggered\n                              */\n\n      /**\n                                  * @class Module\n                                  * @description Base class that represents all modules of an App.\n                                  */\n\n      var Module = function () {\n\n        /**\n                                 * Initialization.\n                                 * @param {HTMLElement} el - The module element\n                                 * @param {Object} [options] - An object of options\n                                 * @param {string} [options.loadedClass] - The class that will be applied to the module element when it is loaded\n                                 * @param {string} [options.activeClass] - The class that will be applied to the module element when it is shown\n                                 * @param {string} [options.disabledClass] - The class that will be applied to the module element when disabled\n                                 * @param {string} [options.errorClass] - The class that will be applied to the module element when it has a load error\n                                 * @param {Array|string} [options.styles] - Array of stylesheet urls or single url\n                                 * @param {string|HTMLTemplateElement|HTMLElement} [options.template] - The template to load (can be url to html or handlebars file or html template, just an element, or an html string)\n                                 * @param {Object|string} [options.data] - The data or url to the module's data\n                                 * @param {Object} [options.requestOptions] - The request options to use when running the fetch method to get data\n                                 * @param {Module~onLoad} [options.onLoad] - A function that fires when module's load() method is called\n                                 * @param {Module~onShow} [options.onShow] - A function that fires when module is shown\n                                 * @param {Module~onHide} [options.onHide] - A function that fires when module is hidden\n                                 * @param {Module~onEnable} [options.onEnable] - A function that fires when module is enabled\n                                 * @param {Module~onDisable} [options.onDisable] - A function that fires when module is disabled\n                                 * @param {Module~onError} [options.onError] - A function that fires when module goes into error state\n                                 * @param {Object} [options.helpers] - An object containing a mapping of handlebar helper ids (keys) to their functions (values) to use when handlebar compiling\n                                 */\n        function Module(el, options) {\n          _classCallCheck(this, Module);\n\n          options = options || {};\n\n          if (!el) {\n            console.error(\"Module error: No element was passed to constructor\");\n          }\n\n          this.el = el;\n\n          var defaultOptions = {\n            loadedClass: 'module-loaded',\n            activeClass: 'module-active',\n            disabledClass: 'module-disabled',\n            errorClass: 'module-error',\n            styles: [],\n            template: \"\",\n            data: null,\n            requestOptions: null,\n            onLoad: function onLoad() {},\n            onShow: function onShow() {},\n            onHide: function onHide() {},\n            onEnable: function onEnable() {},\n            onDisable: function onDisable() {},\n            onError: function onError() {},\n            helpers: {} };\n\n\n          // we are adding default options to passed custom options\n          // to ensure all expected options exist when instantiating sub classes\n          for (var name in defaultOptions) {\n            if (defaultOptions.hasOwnProperty(name)) {\n              if (!options[name]) {\n                options[name] = defaultOptions[name];\n              }\n            }\n          }\n\n          this.options = options;\n\n          // setup helpers\n          for (var _name in options.helpers) {\n            if (options.helpers.hasOwnProperty(_name)) {\n              runtime.registerHelper(_name, options.helpers[_name]);\n            }\n          }\n\n          this._handleElementInitialState();\n\n          this.subModules = {};\n          this.active = false;\n          this.loaded = false;\n          this._elChildren = [];\n          this.loadStatus = 'notLoaded';\n        }\n\n        /**\n           * Loads the module's styles, template, and data and applies loaded css classes and state.\n           * @return {Promise}\n           */\n\n\n        _createClass(Module, [{\n          key: 'load',\n          value: function load() {\n            var _this = this;\n\n            if (!this.loaded) {\n              this.loadStatus = 'loading';\n              // load all subModules\n              var loadPromises = [];\n              for (var key in this.subModules) {\n                if (this.subModules.hasOwnProperty(key)) {\n                  var view = this.subModules[key];\n                  loadPromises.push(view.load());\n                }\n              }\n              return Promise.all(loadPromises).then(function () {\n                return _this.getStyles(_this.options.styles).then(function () {\n                  return _this.fetchData(_this.options.data, _this.options.requestOptions).then(function (data) {\n                    return _this.getTemplate(data).then(function (nodes) {\n                      nodes = nodes || [];\n                      var frag = document.createDocumentFragment();\n                      // hold reference to children to remove them later\n                      while (nodes.length) {\n                        // order matters here so we always start from the first node\n                        var node = nodes[0];\n                        _this._elChildren.push(node);\n                        // appending child changes length of nodes array\n                        frag.appendChild(node);\n                      }\n                      _this.el.appendChild(frag);\n                      _this.loaded = true;\n                      _this.loadStatus = 'loaded';\n                      if (_this.el) {\n                        _this.el.classList.add(_this.options.loadedClass);\n                      }\n                      _this.options.onLoad();\n                    });\n                  });\n                });\n              }).catch(function (e) {\n                _this.error(e);\n                // throw error to reject promise\n                throw e;\n              });\n            } else {\n              return Promise.resolve();\n            }\n          }\n\n          /**\n             * Makes a request to get the data for the module.\n             * @param {string|Object} url - The url to fetch data from or data object\n             * @param [options] - fetch options\n             * @returns {*}\n             */ },\n\n        {\n          key: 'fetchData',\n          value: function fetchData(url, options) {\n            if (typeof url !== 'string') {\n              return Promise.resolve(url);\n            }\n            return _resourceManagerJs2.default.fetchData(url, options);\n          }\n\n          /**\n             * Gets the css files for the module.\n             * @param cssUrl\n             * @return {Promise}\n             */ },\n\n        {\n          key: 'getStyles',\n          value: function getStyles(cssUrl) {\n            return _resourceManagerJs2.default.loadCss(cssUrl);\n          }\n\n          /**\n             * Gets the html template for the module.\n             * @param {Object} [data] - The data to inject (if template is a handlebar file)\n             * @returns {Promise} Returns a document fragment containing the contents of the template with the data injected\n             */ },\n\n        {\n          key: 'getTemplate',\n          value: function getTemplate(data) {\n            var template = this.options.template || '';\n\n            if (!template) {\n              return Promise.resolve();\n            }\n\n            var isHandlebarFile = function isHandlebarFile(filePath) {\n              if (filePath) {\n                var frags = filePath.split('.');\n                var ext = frags[frags.length - 1];\n                return ext === 'hbs';\n              }\n            };\n\n            if (this._isHTMLTemplate(template)) {\n              // template element\n              // TODO: update to accommodate situations where the user wants to adoptNode instead of cloning it\n              var tpl = document.importNode(template.content, true);\n              return Promise.resolve(tpl.childNodes);\n            } else if (template instanceof HTMLElement) {\n              // already an html element\n              var frag = document.createDocumentFragment();\n              frag.appendChild(template);\n              return Promise.resolve(frag.childNodes);\n            } else {\n              var _ret = function () {\n                // html or handlebar file\n                var tempDiv = document.createElement('div');\n                return {\n                  v: _resourceManagerJs2.default.loadTemplate(template, tempDiv, data).then(function (html) {\n                    return tempDiv.childNodes;\n                  }) };\n\n              }();\n\n              if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n            }\n          }\n\n          /**\n             * Checks if the provided template argument is indeed an html template element.\n             * This is mainly for testing purposes where phantom is not aware of HTMLTemplateElement\n             * @param template\n             * @returns {boolean}\n             * @private\n             */ },\n\n        {\n          key: '_isHTMLTemplate',\n          value: function _isHTMLTemplate(template) {\n            return template instanceof HTMLTemplateElement;\n          }\n\n          /**\n             * Triggers a load error on the module.\n             * @param {Object} [err] - The error object to trigger\n             * @return {Promise} Returns a promise when erroring operation is complete\n             */ },\n\n        {\n          key: 'error',\n          value: function error(err) {\n            var e = err || new Error();\n\n            this.el.classList.add(this.options.errorClass);\n\n            this.errored = true;\n            this.loaded = false;\n            this.loadStatus = 'notLoaded';\n\n            this.options.onError(e);\n            return this.waitForTransition().then(function () {\n              return e;\n            });\n          }\n\n          /**\n             * Enables the module.\n             * @return {Promise}\n             */ },\n\n        {\n          key: 'enable',\n          value: function enable() {\n            var el = this.el;\n            if (el) {\n              el.classList.remove(this.options.disabledClass);\n            }\n            this.disabled = false;\n            this.options.onEnable();\n            return this.waitForTransition();\n          }\n\n          /**\n             * Disables the module.\n             * @return {Promise}\n             */ },\n\n        {\n          key: 'disable',\n          value: function disable() {\n            var el = this.el;\n            if (el) {\n              el.classList.add(this.options.disabledClass);\n            }\n            this.disabled = true;\n\n            this.options.onDisable();\n            return this.waitForTransition();\n          }\n\n          /**\n             * Shows the module.\n             * @return {Promise}\n             */ },\n\n        {\n          key: 'show',\n          value: function show() {\n            var el = this.el;\n            if (el) {\n              el.classList.add(this.options.activeClass);\n            }\n            this.active = true;\n            this.options.onShow();\n            return this.waitForTransition();\n          }\n\n          /**\n             * Hides the module.\n             * @return {Promise}\n             */ },\n\n        {\n          key: 'hide',\n          value: function hide() {\n            var el = this.el;\n            if (el) {\n              el.classList.remove(this.options.activeClass);\n            }\n            this.active = false;\n            this.options.onHide();\n            return this.waitForTransition();\n          }\n\n          /**\n             * Sets up element internally by evaluating its initial state.\n             * @private\n             */ },\n\n        {\n          key: '_handleElementInitialState',\n          value: function _handleElementInitialState() {\n            var el = this.el;\n            if (!el) {\n              return;\n            }\n            if (el.classList.contains(this.options.disabledClass)) {\n              this._origDisabled = true;\n              this.disable();\n            }\n\n            if (el.classList.contains(this.options.errorClass)) {\n              this._origError = true;\n              this.error(new Error());\n            }\n          }\n\n          /**\n             * Restores the elements classes back to the way they were before instantiation.\n             * @private\n             */ },\n\n        {\n          key: '_resetElementInitialState',\n          value: function _resetElementInitialState() {\n            var options = this.options,\n            disabledClass = options.disabledClass,\n            errorClass = options.errorClass;\n\n            if (!this.el) {\n              return;\n            }\n            if (this._origDisabled) {\n              this.el.classList.add(disabledClass);\n            } else {\n              this.el.classList.remove(disabledClass);\n            }\n\n            if (!this._origError) {\n              this.el.classList.remove(errorClass);\n            } else {\n              this.el.classList.add(errorClass);\n            }\n          }\n\n          /**\n             * Builds a transition promise that waits to resolve until the module el's CSS transition is completed (if applicable).\n             * @returns {Promise} Returns a promise that resolves when the element has finished animating\n             */ },\n\n        {\n          key: 'waitForTransition',\n          value: function waitForTransition() {\n            var _this2 = this;\n\n            var duration = this.getTransitionDuration();\n            return new Promise(function (resolve) {\n              if (duration > 0) {\n                setTimeout(resolve.bind(_this2, _this2.el), duration);\n              } else {\n                resolve(_this2.el);\n              }\n            });\n          }\n\n          /**\n             * Gets the time is takes for the element to transition to its show state.\n             * @returns {Number} Returns the total CSS transition time in milliseconds\n             */ },\n\n        {\n          key: 'getTransitionDuration',\n          value: function getTransitionDuration() {\n            var delayProp = this.getCssComputedProperty('transition-delay') || '0ms',\n            durationProp = this.getCssComputedProperty('transition-duration') || '0ms',\n            times = Array.isArray(durationProp) ? durationProp : [durationProp],\n            delay = Array.isArray(delayProp) ? delayProp : [delayProp],\n            highest = 0,\n            map;\n\n            times.push.apply(times, delay); // account for delay\n\n            // calculate highest number of time\n            times.forEach(function (value) {\n              value.split(',').forEach(function (v) {\n                v = convertCssTimeValueToMilliseconds(v);\n                map = getCssPropUnitMap(v);\n                if (map.num > highest) {\n                  highest = map.num;\n                }\n              });\n            });\n\n            return highest;\n          }\n\n          /**\n             * Gets the computed property of the element.\n             * @param {string} prop - The name of the property to get\n             * @returns {string} Returns the value of the property\n             */ },\n\n        {\n          key: 'getCssComputedProperty',\n          value: function getCssComputedProperty(prop) {\n            var style = window.getComputedStyle(this.el);\n            return style.getPropertyValue(prop) || this.el.style[getJsPropName(prop)];\n          }\n\n          /**\n             * Gets the closest ancestor element that has a css class.\n             * @param {string} className - The class name that the ancestor must have to match\n             * @param {Element} startTarget - The element the method should start from\n             */ },\n\n        {\n          key: 'getClosestAncestorElementByClassName',\n          value: function getClosestAncestorElementByClassName(className, startTarget) {\n            var result = null;\n            traverseEachParent(function (parent) {\n              if (parent.classList.contains(className)) {\n                result = parent;\n                return false;\n              }\n            }, startTarget || this.el.parentNode || this.el);\n            return result;\n          }\n\n          /**\n             * Destroys all nested views and cleans up.\n             */ },\n\n        {\n          key: 'destroy',\n          value: function destroy() {\n            var _this3 = this;\n\n            var subModules = this.subModules;\n\n            for (var key in subModules) {\n              if (subModules.hasOwnProperty(key) && subModules[key]) {\n                subModules[key].destroy();\n              }\n            }\n            this.subModules = {};\n            this.active = false;\n            this.loaded = false;\n            this.errored = false;\n            this.loadStatus = 'notLoaded';\n\n            this.el.classList.remove(this.options.loadedClass);\n            this.el.classList.remove(this.options.activeClass);\n\n            this._resetElementInitialState();\n\n            this._elChildren.forEach(function (el) {\n              if (_this3.el.contains(el)) {\n                _this3.el.removeChild(el);\n              }\n            });\n            this._elChildren = [];\n          } }]);\n\n\n        return Module;\n      }();\n\n      exports.default = Module;\n\n    }, { \"es6-promise\": 4, \"handlebars/runtime\": 35, \"resource-manager-js\": 36 }], 38: [function (require, module, exports) {\n      'use strict';\n\n      module.exports = require('./lib');\n\n    }, { \"./lib\": 43 }], 39: [function (require, module, exports) {\n      'use strict';\n\n      var asap = require('asap/raw');\n\n      function noop() {}\n\n      // States:\n      //\n      // 0 - pending\n      // 1 - fulfilled with _value\n      // 2 - rejected with _value\n      // 3 - adopted the state of another promise, _value\n      //\n      // once the state is no longer pending (0) it is immutable\n\n      // All `_` prefixed properties will be reduced to `_{random number}`\n      // at build time to obfuscate them and discourage their use.\n      // We don't use symbols or Object.defineProperty to fully hide them\n      // because the performance isn't good enough.\n\n\n      // to avoid using try/catch inside critical functions, we\n      // extract them to here.\n      var LAST_ERROR = null;\n      var IS_ERROR = {};\n      function getThen(obj) {\n        try {\n          return obj.then;\n        } catch (ex) {\n          LAST_ERROR = ex;\n          return IS_ERROR;\n        }\n      }\n\n      function tryCallOne(fn, a) {\n        try {\n          return fn(a);\n        } catch (ex) {\n          LAST_ERROR = ex;\n          return IS_ERROR;\n        }\n      }\n      function tryCallTwo(fn, a, b) {\n        try {\n          fn(a, b);\n        } catch (ex) {\n          LAST_ERROR = ex;\n          return IS_ERROR;\n        }\n      }\n\n      module.exports = Promise;\n\n      function Promise(fn) {\n        if (_typeof2(this) !== 'object') {\n          throw new TypeError('Promises must be constructed via new');\n        }\n        if (typeof fn !== 'function') {\n          throw new TypeError('not a function');\n        }\n        this._45 = 0;\n        this._81 = 0;\n        this._65 = null;\n        this._54 = null;\n        if (fn === noop) return;\n        doResolve(fn, this);\n      }\n      Promise._10 = null;\n      Promise._97 = null;\n      Promise._61 = noop;\n\n      Promise.prototype.then = function (onFulfilled, onRejected) {\n        if (this.constructor !== Promise) {\n          return safeThen(this, onFulfilled, onRejected);\n        }\n        var res = new Promise(noop);\n        handle(this, new Handler(onFulfilled, onRejected, res));\n        return res;\n      };\n\n      function safeThen(self, onFulfilled, onRejected) {\n        return new self.constructor(function (resolve, reject) {\n          var res = new Promise(noop);\n          res.then(resolve, reject);\n          handle(self, new Handler(onFulfilled, onRejected, res));\n        });\n      };\n      function handle(self, deferred) {\n        while (self._81 === 3) {\n          self = self._65;\n        }\n        if (Promise._10) {\n          Promise._10(self);\n        }\n        if (self._81 === 0) {\n          if (self._45 === 0) {\n            self._45 = 1;\n            self._54 = deferred;\n            return;\n          }\n          if (self._45 === 1) {\n            self._45 = 2;\n            self._54 = [self._54, deferred];\n            return;\n          }\n          self._54.push(deferred);\n          return;\n        }\n        handleResolved(self, deferred);\n      }\n\n      function handleResolved(self, deferred) {\n        asap(function () {\n          var cb = self._81 === 1 ? deferred.onFulfilled : deferred.onRejected;\n          if (cb === null) {\n            if (self._81 === 1) {\n              resolve(deferred.promise, self._65);\n            } else {\n              reject(deferred.promise, self._65);\n            }\n            return;\n          }\n          var ret = tryCallOne(cb, self._65);\n          if (ret === IS_ERROR) {\n            reject(deferred.promise, LAST_ERROR);\n          } else {\n            resolve(deferred.promise, ret);\n          }\n        });\n      }\n      function resolve(self, newValue) {\n        // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n        if (newValue === self) {\n          return reject(\n          self,\n          new TypeError('A promise cannot be resolved with itself.'));\n\n        }\n        if (\n        newValue && (\n        (typeof newValue === \"undefined\" ? \"undefined\" : _typeof2(newValue)) === 'object' || typeof newValue === 'function'))\n        {\n          var then = getThen(newValue);\n          if (then === IS_ERROR) {\n            return reject(self, LAST_ERROR);\n          }\n          if (\n          then === self.then &&\n          newValue instanceof Promise)\n          {\n            self._81 = 3;\n            self._65 = newValue;\n            finale(self);\n            return;\n          } else if (typeof then === 'function') {\n            doResolve(then.bind(newValue), self);\n            return;\n          }\n        }\n        self._81 = 1;\n        self._65 = newValue;\n        finale(self);\n      }\n\n      function reject(self, newValue) {\n        self._81 = 2;\n        self._65 = newValue;\n        if (Promise._97) {\n          Promise._97(self, newValue);\n        }\n        finale(self);\n      }\n      function finale(self) {\n        if (self._45 === 1) {\n          handle(self, self._54);\n          self._54 = null;\n        }\n        if (self._45 === 2) {\n          for (var i = 0; i < self._54.length; i++) {\n            handle(self, self._54[i]);\n          }\n          self._54 = null;\n        }\n      }\n\n      function Handler(onFulfilled, onRejected, promise) {\n        this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n        this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n        this.promise = promise;\n      }\n\n      /**\n         * Take a potentially misbehaving resolver function and make sure\n         * onFulfilled and onRejected are only called once.\n         *\n         * Makes no guarantees about asynchrony.\n         */\n      function doResolve(fn, promise) {\n        var done = false;\n        var res = tryCallTwo(fn, function (value) {\n          if (done) return;\n          done = true;\n          resolve(promise, value);\n        }, function (reason) {\n          if (done) return;\n          done = true;\n          reject(promise, reason);\n        });\n        if (!done && res === IS_ERROR) {\n          done = true;\n          reject(promise, LAST_ERROR);\n        }\n      }\n\n    }, { \"asap/raw\": 3 }], 40: [function (require, module, exports) {\n      'use strict';\n\n      var Promise = require('./core.js');\n\n      module.exports = Promise;\n      Promise.prototype.done = function (onFulfilled, onRejected) {\n        var self = arguments.length ? this.then.apply(this, arguments) : this;\n        self.then(null, function (err) {\n          setTimeout(function () {\n            throw err;\n          }, 0);\n        });\n      };\n\n    }, { \"./core.js\": 39 }], 41: [function (require, module, exports) {\n      'use strict';\n\n      //This file contains the ES6 extensions to the core Promises/A+ API\n\n      var Promise = require('./core.js');\n\n      module.exports = Promise;\n\n      /* Static Functions */\n\n      var TRUE = valuePromise(true);\n      var FALSE = valuePromise(false);\n      var NULL = valuePromise(null);\n      var UNDEFINED = valuePromise(undefined);\n      var ZERO = valuePromise(0);\n      var EMPTYSTRING = valuePromise('');\n\n      function valuePromise(value) {\n        var p = new Promise(Promise._61);\n        p._81 = 1;\n        p._65 = value;\n        return p;\n      }\n      Promise.resolve = function (value) {\n        if (value instanceof Promise) return value;\n\n        if (value === null) return NULL;\n        if (value === undefined) return UNDEFINED;\n        if (value === true) return TRUE;\n        if (value === false) return FALSE;\n        if (value === 0) return ZERO;\n        if (value === '') return EMPTYSTRING;\n\n        if ((typeof value === \"undefined\" ? \"undefined\" : _typeof2(value)) === 'object' || typeof value === 'function') {\n          try {\n            var then = value.then;\n            if (typeof then === 'function') {\n              return new Promise(then.bind(value));\n            }\n          } catch (ex) {\n            return new Promise(function (resolve, reject) {\n              reject(ex);\n            });\n          }\n        }\n        return valuePromise(value);\n      };\n\n      Promise.all = function (arr) {\n        var args = Array.prototype.slice.call(arr);\n\n        return new Promise(function (resolve, reject) {\n          if (args.length === 0) return resolve([]);\n          var remaining = args.length;\n          function res(i, val) {\n            if (val && ((typeof val === \"undefined\" ? \"undefined\" : _typeof2(val)) === 'object' || typeof val === 'function')) {\n              if (val instanceof Promise && val.then === Promise.prototype.then) {\n                while (val._81 === 3) {\n                  val = val._65;\n                }\n                if (val._81 === 1) return res(i, val._65);\n                if (val._81 === 2) reject(val._65);\n                val.then(function (val) {\n                  res(i, val);\n                }, reject);\n                return;\n              } else {\n                var then = val.then;\n                if (typeof then === 'function') {\n                  var p = new Promise(then.bind(val));\n                  p.then(function (val) {\n                    res(i, val);\n                  }, reject);\n                  return;\n                }\n              }\n            }\n            args[i] = val;\n            if (--remaining === 0) {\n              resolve(args);\n            }\n          }\n          for (var i = 0; i < args.length; i++) {\n            res(i, args[i]);\n          }\n        });\n      };\n\n      Promise.reject = function (value) {\n        return new Promise(function (resolve, reject) {\n          reject(value);\n        });\n      };\n\n      Promise.race = function (values) {\n        return new Promise(function (resolve, reject) {\n          values.forEach(function (value) {\n            Promise.resolve(value).then(resolve, reject);\n          });\n        });\n      };\n\n      /* Prototype Methods */\n\n      Promise.prototype['catch'] = function (onRejected) {\n        return this.then(null, onRejected);\n      };\n\n    }, { \"./core.js\": 39 }], 42: [function (require, module, exports) {\n      'use strict';\n\n      var Promise = require('./core.js');\n\n      module.exports = Promise;\n      Promise.prototype['finally'] = function (f) {\n        return this.then(function (value) {\n          return Promise.resolve(f()).then(function () {\n            return value;\n          });\n        }, function (err) {\n          return Promise.resolve(f()).then(function () {\n            throw err;\n          });\n        });\n      };\n\n    }, { \"./core.js\": 39 }], 43: [function (require, module, exports) {\n      'use strict';\n\n      module.exports = require('./core.js');\n      require('./done.js');\n      require('./finally.js');\n      require('./es6-extensions.js');\n      require('./node-extensions.js');\n      require('./synchronous.js');\n\n    }, { \"./core.js\": 39, \"./done.js\": 40, \"./es6-extensions.js\": 41, \"./finally.js\": 42, \"./node-extensions.js\": 44, \"./synchronous.js\": 45 }], 44: [function (require, module, exports) {\n      'use strict';\n\n      // This file contains then/promise specific extensions that are only useful\n      // for node.js interop\n\n      var Promise = require('./core.js');\n      var asap = require('asap');\n\n      module.exports = Promise;\n\n      /* Static Functions */\n\n      Promise.denodeify = function (fn, argumentCount) {\n        if (\n        typeof argumentCount === 'number' && argumentCount !== Infinity)\n        {\n          return denodeifyWithCount(fn, argumentCount);\n        } else {\n          return denodeifyWithoutCount(fn);\n        }\n      };\n\n      var callbackFn =\n      'function (err, res) {' +\n      'if (err) { rj(err); } else { rs(res); }' +\n      '}';\n\n      function denodeifyWithCount(fn, argumentCount) {\n        var args = [];\n        for (var i = 0; i < argumentCount; i++) {\n          args.push('a' + i);\n        }\n        var body = [\n        'return function (' + args.join(',') + ') {',\n        'var self = this;',\n        'return new Promise(function (rs, rj) {',\n        'var res = fn.call(',\n        ['self'].concat(args).concat([callbackFn]).join(','),\n        ');',\n        'if (res &&',\n        '(typeof res === \"object\" || typeof res === \"function\") &&',\n        'typeof res.then === \"function\"',\n        ') {rs(res);}',\n        '});',\n        '};'].\n        join('');\n        return Function(['Promise', 'fn'], body)(Promise, fn);\n      }\n      function denodeifyWithoutCount(fn) {\n        var fnLength = Math.max(fn.length - 1, 3);\n        var args = [];\n        for (var i = 0; i < fnLength; i++) {\n          args.push('a' + i);\n        }\n        var body = [\n        'return function (' + args.join(',') + ') {',\n        'var self = this;',\n        'var args;',\n        'var argLength = arguments.length;',\n        'if (arguments.length > ' + fnLength + ') {',\n        'args = new Array(arguments.length + 1);',\n        'for (var i = 0; i < arguments.length; i++) {',\n        'args[i] = arguments[i];',\n        '}',\n        '}',\n        'return new Promise(function (rs, rj) {',\n        'var cb = ' + callbackFn + ';',\n        'var res;',\n        'switch (argLength) {',\n        args.concat(['extra']).map(function (_, index) {\n          return (\n            'case ' + index + ':' +\n            'res = fn.call(' + ['self'].concat(args.slice(0, index)).concat('cb').join(',') + ');' +\n            'break;');\n\n        }).join(''),\n        'default:',\n        'args[argLength] = cb;',\n        'res = fn.apply(self, args);',\n        '}',\n\n        'if (res &&',\n        '(typeof res === \"object\" || typeof res === \"function\") &&',\n        'typeof res.then === \"function\"',\n        ') {rs(res);}',\n        '});',\n        '};'].\n        join('');\n\n        return Function(\n        ['Promise', 'fn'],\n        body)(\n        Promise, fn);\n      }\n\n      Promise.nodeify = function (fn) {\n        return function () {\n          var args = Array.prototype.slice.call(arguments);\n          var callback =\n          typeof args[args.length - 1] === 'function' ? args.pop() : null;\n          var ctx = this;\n          try {\n            return fn.apply(this, arguments).nodeify(callback, ctx);\n          } catch (ex) {\n            if (callback === null || typeof callback == 'undefined') {\n              return new Promise(function (resolve, reject) {\n                reject(ex);\n              });\n            } else {\n              asap(function () {\n                callback.call(ctx, ex);\n              });\n            }\n          }\n        };\n      };\n\n      Promise.prototype.nodeify = function (callback, ctx) {\n        if (typeof callback != 'function') return this;\n\n        this.then(function (value) {\n          asap(function () {\n            callback.call(ctx, null, value);\n          });\n        }, function (err) {\n          asap(function () {\n            callback.call(ctx, err);\n          });\n        });\n      };\n\n    }, { \"./core.js\": 39, \"asap\": 2 }], 45: [function (require, module, exports) {\n      'use strict';\n\n      var Promise = require('./core.js');\n\n      module.exports = Promise;\n      Promise.enableSynchronous = function () {\n        Promise.prototype.isPending = function () {\n          return this.getState() == 0;\n        };\n\n        Promise.prototype.isFulfilled = function () {\n          return this.getState() == 1;\n        };\n\n        Promise.prototype.isRejected = function () {\n          return this.getState() == 2;\n        };\n\n        Promise.prototype.getValue = function () {\n          if (this._81 === 3) {\n            return this._65.getValue();\n          }\n\n          if (!this.isFulfilled()) {\n            throw new Error('Cannot get a value of an unfulfilled promise.');\n          }\n\n          return this._65;\n        };\n\n        Promise.prototype.getReason = function () {\n          if (this._81 === 3) {\n            return this._65.getReason();\n          }\n\n          if (!this.isRejected()) {\n            throw new Error('Cannot get a rejection reason of a non-rejected promise.');\n          }\n\n          return this._65;\n        };\n\n        Promise.prototype.getState = function () {\n          if (this._81 === 3) {\n            return this._65.getState();\n          }\n          if (this._81 === -1 || this._81 === -2) {\n            return 0;\n          }\n\n          return this._81;\n        };\n      };\n\n      Promise.disableSynchronous = function () {\n        Promise.prototype.isPending = undefined;\n        Promise.prototype.isFulfilled = undefined;\n        Promise.prototype.isRejected = undefined;\n        Promise.prototype.getValue = undefined;\n        Promise.prototype.getReason = undefined;\n        Promise.prototype.getState = undefined;\n      };\n\n    }, { \"./core.js\": 39 }], 46: [function (require, module, exports) {\n      /*\n                                                                        * Copyright 2009-2011 Mozilla Foundation and contributors\n                                                                        * Licensed under the New BSD license. See LICENSE.txt or:\n                                                                        * http://opensource.org/licenses/BSD-3-Clause\n                                                                        */\n      exports.SourceMapGenerator = require('./source-map/source-map-generator').SourceMapGenerator;\n      exports.SourceMapConsumer = require('./source-map/source-map-consumer').SourceMapConsumer;\n      exports.SourceNode = require('./source-map/source-node').SourceNode;\n\n    }, { \"./source-map/source-map-consumer\": 53, \"./source-map/source-map-generator\": 54, \"./source-map/source-node\": 55 }], 47: [function (require, module, exports) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n      /*\n                                                   * Copyright 2011 Mozilla Foundation and contributors\n                                                   * Licensed under the New BSD license. See LICENSE or:\n                                                   * http://opensource.org/licenses/BSD-3-Clause\n                                                   */\n      if (typeof define !== 'function') {\n        var define = require('amdefine')(module, require);\n      }\n      define(function (require, exports, module) {\n\n        var util = require('./util');\n\n        /**\n                                       * A data structure which is a combination of an array and a set. Adding a new\n                                       * member is O(1), testing for membership is O(1), and finding the index of an\n                                       * element is O(1). Removing elements from the set is not supported. Only\n                                       * strings are supported for membership.\n                                       */\n        function ArraySet() {\n          this._array = [];\n          this._set = {};\n        }\n\n        /**\n           * Static method for creating ArraySet instances from an existing array.\n           */\n        ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n          var set = new ArraySet();\n          for (var i = 0, len = aArray.length; i < len; i++) {\n            set.add(aArray[i], aAllowDuplicates);\n          }\n          return set;\n        };\n\n        /**\n            * Return how many unique items are in this ArraySet. If duplicates have been\n            * added, than those do not count towards the size.\n            *\n            * @returns Number\n            */\n        ArraySet.prototype.size = function ArraySet_size() {\n          return Object.getOwnPropertyNames(this._set).length;\n        };\n\n        /**\n            * Add the given string to this set.\n            *\n            * @param String aStr\n            */\n        ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n          var isDuplicate = this.has(aStr);\n          var idx = this._array.length;\n          if (!isDuplicate || aAllowDuplicates) {\n            this._array.push(aStr);\n          }\n          if (!isDuplicate) {\n            this._set[util.toSetString(aStr)] = idx;\n          }\n        };\n\n        /**\n            * Is the given string a member of this set?\n            *\n            * @param String aStr\n            */\n        ArraySet.prototype.has = function ArraySet_has(aStr) {\n          return Object.prototype.hasOwnProperty.call(this._set,\n          util.toSetString(aStr));\n        };\n\n        /**\n            * What is the index of the given string in the array?\n            *\n            * @param String aStr\n            */\n        ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n          if (this.has(aStr)) {\n            return this._set[util.toSetString(aStr)];\n          }\n          throw new Error('\"' + aStr + '\" is not in the set.');\n        };\n\n        /**\n            * What is the element at the given index?\n            *\n            * @param Number aIdx\n            */\n        ArraySet.prototype.at = function ArraySet_at(aIdx) {\n          if (aIdx >= 0 && aIdx < this._array.length) {\n            return this._array[aIdx];\n          }\n          throw new Error('No element indexed by ' + aIdx);\n        };\n\n        /**\n            * Returns the array representation of this set (which has the proper indices\n            * indicated by indexOf). Note that this is a copy of the internal array used\n            * for storing the members so that no one can mess with internal state.\n            */\n        ArraySet.prototype.toArray = function ArraySet_toArray() {\n          return this._array.slice();\n        };\n\n        exports.ArraySet = ArraySet;\n\n      });\n\n    }, { \"./util\": 56, \"amdefine\": 1 }], 48: [function (require, module, exports) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n      /*\n                                                   * Copyright 2011 Mozilla Foundation and contributors\n                                                   * Licensed under the New BSD license. See LICENSE or:\n                                                   * http://opensource.org/licenses/BSD-3-Clause\n                                                   *\n                                                   * Based on the Base 64 VLQ implementation in Closure Compiler:\n                                                   * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n                                                   *\n                                                   * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n                                                   * Redistribution and use in source and binary forms, with or without\n                                                   * modification, are permitted provided that the following conditions are\n                                                   * met:\n                                                   *\n                                                   *  * Redistributions of source code must retain the above copyright\n                                                   *    notice, this list of conditions and the following disclaimer.\n                                                   *  * Redistributions in binary form must reproduce the above\n                                                   *    copyright notice, this list of conditions and the following\n                                                   *    disclaimer in the documentation and/or other materials provided\n                                                   *    with the distribution.\n                                                   *  * Neither the name of Google Inc. nor the names of its\n                                                   *    contributors may be used to endorse or promote products derived\n                                                   *    from this software without specific prior written permission.\n                                                   *\n                                                   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n                                                   * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n                                                   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n                                                   * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n                                                   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n                                                   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n                                                   * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n                                                   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n                                                   * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n                                                   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n                                                   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n                                                   */\n      if (typeof define !== 'function') {\n        var define = require('amdefine')(module, require);\n      }\n      define(function (require, exports, module) {\n\n        var base64 = require('./base64');\n\n        // A single base 64 digit can contain 6 bits of data. For the base 64 variable\n        // length quantities we use in the source map spec, the first bit is the sign,\n        // the next four bits are the actual value, and the 6th bit is the\n        // continuation bit. The continuation bit tells us whether there are more\n        // digits in this value following this digit.\n        //\n        //   Continuation\n        //   |    Sign\n        //   |    |\n        //   V    V\n        //   101011\n\n        var VLQ_BASE_SHIFT = 5;\n\n        // binary: 100000\n        var VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n        // binary: 011111\n        var VLQ_BASE_MASK = VLQ_BASE - 1;\n\n        // binary: 100000\n        var VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n        /**\n                                              * Converts from a two-complement value to a value where the sign bit is\n                                              * placed in the least significant bit.  For example, as decimals:\n                                              *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n                                              *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n                                              */\n        function toVLQSigned(aValue) {\n          return aValue < 0 ?\n          (-aValue << 1) + 1 :\n          (aValue << 1) + 0;\n        }\n\n        /**\n           * Converts to a two-complement value from a value where the sign bit is\n           * placed in the least significant bit.  For example, as decimals:\n           *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n           *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n           */\n        function fromVLQSigned(aValue) {\n          var isNegative = (aValue & 1) === 1;\n          var shifted = aValue >> 1;\n          return isNegative ?\n          -shifted :\n          shifted;\n        }\n\n        /**\n           * Returns the base 64 VLQ encoded value.\n           */\n        exports.encode = function base64VLQ_encode(aValue) {\n          var encoded = \"\";\n          var digit;\n\n          var vlq = toVLQSigned(aValue);\n\n          do {\n            digit = vlq & VLQ_BASE_MASK;\n            vlq >>>= VLQ_BASE_SHIFT;\n            if (vlq > 0) {\n              // There are still more digits in this value, so we must make sure the\n              // continuation bit is marked.\n              digit |= VLQ_CONTINUATION_BIT;\n            }\n            encoded += base64.encode(digit);\n          } while (vlq > 0);\n\n          return encoded;\n        };\n\n        /**\n            * Decodes the next base 64 VLQ value from the given string and returns the\n            * value and the rest of the string via the out parameter.\n            */\n        exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n          var strLen = aStr.length;\n          var result = 0;\n          var shift = 0;\n          var continuation, digit;\n\n          do {\n            if (aIndex >= strLen) {\n              throw new Error(\"Expected more digits in base 64 VLQ value.\");\n            }\n\n            digit = base64.decode(aStr.charCodeAt(aIndex++));\n            if (digit === -1) {\n              throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n            }\n\n            continuation = !!(digit & VLQ_CONTINUATION_BIT);\n            digit &= VLQ_BASE_MASK;\n            result = result + (digit << shift);\n            shift += VLQ_BASE_SHIFT;\n          } while (continuation);\n\n          aOutParam.value = fromVLQSigned(result);\n          aOutParam.rest = aIndex;\n        };\n\n      });\n\n    }, { \"./base64\": 49, \"amdefine\": 1 }], 49: [function (require, module, exports) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n      /*\n                                                   * Copyright 2011 Mozilla Foundation and contributors\n                                                   * Licensed under the New BSD license. See LICENSE or:\n                                                   * http://opensource.org/licenses/BSD-3-Clause\n                                                   */\n      if (typeof define !== 'function') {\n        var define = require('amdefine')(module, require);\n      }\n      define(function (require, exports, module) {\n\n        var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n        /**\n                                                                                                          * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n                                                                                                          */\n        exports.encode = function (number) {\n          if (0 <= number && number < intToCharMap.length) {\n            return intToCharMap[number];\n          }\n          throw new TypeError(\"Must be between 0 and 63: \" + aNumber);\n        };\n\n        /**\n            * Decode a single base 64 character code digit to an integer. Returns -1 on\n            * failure.\n            */\n        exports.decode = function (charCode) {\n          var bigA = 65; // 'A'\n          var bigZ = 90; // 'Z'\n\n          var littleA = 97; // 'a'\n          var littleZ = 122; // 'z'\n\n          var zero = 48; // '0'\n          var nine = 57; // '9'\n\n          var plus = 43; // '+'\n          var slash = 47; // '/'\n\n          var littleOffset = 26;\n          var numberOffset = 52;\n\n          // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n          if (bigA <= charCode && charCode <= bigZ) {\n            return charCode - bigA;\n          }\n\n          // 26 - 51: abcdefghijklmnopqrstuvwxyz\n          if (littleA <= charCode && charCode <= littleZ) {\n            return charCode - littleA + littleOffset;\n          }\n\n          // 52 - 61: 0123456789\n          if (zero <= charCode && charCode <= nine) {\n            return charCode - zero + numberOffset;\n          }\n\n          // 62: +\n          if (charCode == plus) {\n            return 62;\n          }\n\n          // 63: /\n          if (charCode == slash) {\n            return 63;\n          }\n\n          // Invalid base64 digit.\n          return -1;\n        };\n\n      });\n\n    }, { \"amdefine\": 1 }], 50: [function (require, module, exports) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n      /*\n                                                   * Copyright 2011 Mozilla Foundation and contributors\n                                                   * Licensed under the New BSD license. See LICENSE or:\n                                                   * http://opensource.org/licenses/BSD-3-Clause\n                                                   */\n      if (typeof define !== 'function') {\n        var define = require('amdefine')(module, require);\n      }\n      define(function (require, exports, module) {\n\n        exports.GREATEST_LOWER_BOUND = 1;\n        exports.LEAST_UPPER_BOUND = 2;\n\n        /**\n                                        * Recursive implementation of binary search.\n                                        *\n                                        * @param aLow Indices here and lower do not contain the needle.\n                                        * @param aHigh Indices here and higher do not contain the needle.\n                                        * @param aNeedle The element being searched for.\n                                        * @param aHaystack The non-empty array being searched.\n                                        * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n                                        * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n                                        *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n                                        *     closest element that is smaller than or greater than the one we are\n                                        *     searching for, respectively, if the exact element cannot be found.\n                                        */\n        function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n          // This function terminates when one of the following is true:\n          //\n          //   1. We find the exact element we are looking for.\n          //\n          //   2. We did not find the exact element, but we can return the index of\n          //      the next-closest element.\n          //\n          //   3. We did not find the exact element, and there is no next-closest\n          //      element than the one we are searching for, so we return -1.\n          var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n          var cmp = aCompare(aNeedle, aHaystack[mid], true);\n          if (cmp === 0) {\n            // Found the element we are looking for.\n            return mid;\n          } else\n          if (cmp > 0) {\n            // Our needle is greater than aHaystack[mid].\n            if (aHigh - mid > 1) {\n              // The element is in the upper half.\n              return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n            }\n\n            // The exact needle element was not found in this haystack. Determine if\n            // we are in termination case (3) or (2) and return the appropriate thing.\n            if (aBias == exports.LEAST_UPPER_BOUND) {\n              return aHigh < aHaystack.length ? aHigh : -1;\n            } else {\n              return mid;\n            }\n          } else\n          {\n            // Our needle is less than aHaystack[mid].\n            if (mid - aLow > 1) {\n              // The element is in the lower half.\n              return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n            }\n\n            // we are in termination case (3) or (2) and return the appropriate thing.\n            if (aBias == exports.LEAST_UPPER_BOUND) {\n              return mid;\n            } else {\n              return aLow < 0 ? -1 : aLow;\n            }\n          }\n        }\n\n        /**\n           * This is an implementation of binary search which will always try and return\n           * the index of the closest element if there is no exact hit. This is because\n           * mappings between original and generated line/col pairs are single points,\n           * and there is an implicit region between each of them, so a miss just means\n           * that you aren't on the very start of a region.\n           *\n           * @param aNeedle The element you are looking for.\n           * @param aHaystack The array that is being searched.\n           * @param aCompare A function which takes the needle and an element in the\n           *     array and returns -1, 0, or 1 depending on whether the needle is less\n           *     than, equal to, or greater than the element, respectively.\n           * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n           *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n           *     closest element that is smaller than or greater than the one we are\n           *     searching for, respectively, if the exact element cannot be found.\n           *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n           */\n        exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n          if (aHaystack.length === 0) {\n            return -1;\n          }\n\n          var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n          aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n          if (index < 0) {\n            return -1;\n          }\n\n          // We have found either the exact element, or the next-closest element than\n          // the one we are searching for. However, there may be more than one such\n          // element. Make sure we always return the smallest of these.\n          while (index - 1 >= 0) {\n            if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n              break;\n            }\n            --index;\n          }\n\n          return index;\n        };\n\n      });\n\n    }, { \"amdefine\": 1 }], 51: [function (require, module, exports) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n      /*\n                                                   * Copyright 2014 Mozilla Foundation and contributors\n                                                   * Licensed under the New BSD license. See LICENSE or:\n                                                   * http://opensource.org/licenses/BSD-3-Clause\n                                                   */\n      if (typeof define !== 'function') {\n        var define = require('amdefine')(module, require);\n      }\n      define(function (require, exports, module) {\n\n        var util = require('./util');\n\n        /**\n                                       * Determine whether mappingB is after mappingA with respect to generated\n                                       * position.\n                                       */\n        function generatedPositionAfter(mappingA, mappingB) {\n          // Optimized for most common case\n          var lineA = mappingA.generatedLine;\n          var lineB = mappingB.generatedLine;\n          var columnA = mappingA.generatedColumn;\n          var columnB = mappingB.generatedColumn;\n          return lineB > lineA || lineB == lineA && columnB >= columnA ||\n          util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n        }\n\n        /**\n           * A data structure to provide a sorted view of accumulated mappings in a\n           * performance conscious manner. It trades a neglibable overhead in general\n           * case for a large speedup in case of mappings being added in order.\n           */\n        function MappingList() {\n          this._array = [];\n          this._sorted = true;\n          // Serves as infimum\n          this._last = { generatedLine: -1, generatedColumn: 0 };\n        }\n\n        /**\n           * Iterate through internal items. This method takes the same arguments that\n           * `Array.prototype.forEach` takes.\n           *\n           * NOTE: The order of the mappings is NOT guaranteed.\n           */\n        MappingList.prototype.unsortedForEach =\n        function MappingList_forEach(aCallback, aThisArg) {\n          this._array.forEach(aCallback, aThisArg);\n        };\n\n        /**\n            * Add the given source mapping.\n            *\n            * @param Object aMapping\n            */\n        MappingList.prototype.add = function MappingList_add(aMapping) {\n          var mapping;\n          if (generatedPositionAfter(this._last, aMapping)) {\n            this._last = aMapping;\n            this._array.push(aMapping);\n          } else {\n            this._sorted = false;\n            this._array.push(aMapping);\n          }\n        };\n\n        /**\n            * Returns the flat, sorted array of mappings. The mappings are sorted by\n            * generated position.\n            *\n            * WARNING: This method returns internal data without copying, for\n            * performance. The return value must NOT be mutated, and should be treated as\n            * an immutable borrow. If you want to take ownership, you must make your own\n            * copy.\n            */\n        MappingList.prototype.toArray = function MappingList_toArray() {\n          if (!this._sorted) {\n            this._array.sort(util.compareByGeneratedPositionsInflated);\n            this._sorted = true;\n          }\n          return this._array;\n        };\n\n        exports.MappingList = MappingList;\n\n      });\n\n    }, { \"./util\": 56, \"amdefine\": 1 }], 52: [function (require, module, exports) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n      /*\n                                                   * Copyright 2011 Mozilla Foundation and contributors\n                                                   * Licensed under the New BSD license. See LICENSE or:\n                                                   * http://opensource.org/licenses/BSD-3-Clause\n                                                   */\n      if (typeof define !== 'function') {\n        var define = require('amdefine')(module, require);\n      }\n      define(function (require, exports, module) {\n\n        // It turns out that some (most?) JavaScript engines don't self-host\n        // `Array.prototype.sort`. This makes sense because C++ will likely remain\n        // faster than JS when doing raw CPU-intensive sorting. However, when using a\n        // custom comparator function, calling back and forth between the VM's C++ and\n        // JIT'd JS is rather slow *and* loses JIT type information, resulting in\n        // worse generated code for the comparator function than would be optimal. In\n        // fact, when sorting with a comparator, these costs outweigh the benefits of\n        // sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n        // a ~3500ms mean speed-up in `bench/bench.html`.\n\n        /**\n         * Swap the elements indexed by `x` and `y` in the array `ary`.\n         *\n         * @param {Array} ary\n         *        The array.\n         * @param {Number} x\n         *        The index of the first item.\n         * @param {Number} y\n         *        The index of the second item.\n         */\n        function swap(ary, x, y) {\n          var temp = ary[x];\n          ary[x] = ary[y];\n          ary[y] = temp;\n        }\n\n        /**\n           * Returns a random integer within the range `low .. high` inclusive.\n           *\n           * @param {Number} low\n           *        The lower bound on the range.\n           * @param {Number} high\n           *        The upper bound on the range.\n           */\n        function randomIntInRange(low, high) {\n          return Math.round(low + Math.random() * (high - low));\n        }\n\n        /**\n           * The Quick Sort algorithm.\n           *\n           * @param {Array} ary\n           *        An array to sort.\n           * @param {function} comparator\n           *        Function to use to compare two items.\n           * @param {Number} p\n           *        Start index of the array\n           * @param {Number} r\n           *        End index of the array\n           */\n        function doQuickSort(ary, comparator, p, r) {\n          // If our lower bound is less than our upper bound, we (1) partition the\n          // array into two pieces and (2) recurse on each half. If it is not, this is\n          // the empty array and our base case.\n\n          if (p < r) {\n            // (1) Partitioning.\n            //\n            // The partitioning chooses a pivot between `p` and `r` and moves all\n            // elements that are less than or equal to the pivot to the before it, and\n            // all the elements that are greater than it after it. The effect is that\n            // once partition is done, the pivot is in the exact place it will be when\n            // the array is put in sorted order, and it will not need to be moved\n            // again. This runs in O(n) time.\n\n            // Always choose a random pivot so that an input array which is reverse\n            // sorted does not cause O(n^2) running time.\n            var pivotIndex = randomIntInRange(p, r);\n            var i = p - 1;\n\n            swap(ary, pivotIndex, r);\n            var pivot = ary[r];\n\n            // Immediately after `j` is incremented in this loop, the following hold\n            // true:\n            //\n            //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n            //\n            //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n            for (var j = p; j < r; j++) {\n              if (comparator(ary[j], pivot) <= 0) {\n                i += 1;\n                swap(ary, i, j);\n              }\n            }\n\n            swap(ary, i + 1, j);\n            var q = i + 1;\n\n            // (2) Recurse on each half.\n\n            doQuickSort(ary, comparator, p, q - 1);\n            doQuickSort(ary, comparator, q + 1, r);\n          }\n        }\n\n        /**\n           * Sort the given array in-place with the given comparator function.\n           *\n           * @param {Array} ary\n           *        An array to sort.\n           * @param {function} comparator\n           *        Function to use to compare two items.\n           */\n        exports.quickSort = function (ary, comparator) {\n          doQuickSort(ary, comparator, 0, ary.length - 1);\n        };\n\n      });\n\n    }, { \"amdefine\": 1 }], 53: [function (require, module, exports) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n      /*\n                                                   * Copyright 2011 Mozilla Foundation and contributors\n                                                   * Licensed under the New BSD license. See LICENSE or:\n                                                   * http://opensource.org/licenses/BSD-3-Clause\n                                                   */\n      if (typeof define !== 'function') {\n        var define = require('amdefine')(module, require);\n      }\n      define(function (require, exports, module) {\n\n        var util = require('./util');\n        var binarySearch = require('./binary-search');\n        var ArraySet = require('./array-set').ArraySet;\n        var base64VLQ = require('./base64-vlq');\n        var quickSort = require('./quick-sort').quickSort;\n\n        function SourceMapConsumer(aSourceMap) {\n          var sourceMap = aSourceMap;\n          if (typeof aSourceMap === 'string') {\n            sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n          }\n\n          return sourceMap.sections != null ?\n          new IndexedSourceMapConsumer(sourceMap) :\n          new BasicSourceMapConsumer(sourceMap);\n        }\n\n        SourceMapConsumer.fromSourceMap = function (aSourceMap) {\n          return BasicSourceMapConsumer.fromSourceMap(aSourceMap);\n        };\n\n        /**\n            * The version of the source mapping spec that we are consuming.\n            */\n        SourceMapConsumer.prototype._version = 3;\n\n        // `__generatedMappings` and `__originalMappings` are arrays that hold the\n        // parsed mapping coordinates from the source map's \"mappings\" attribute. They\n        // are lazily instantiated, accessed via the `_generatedMappings` and\n        // `_originalMappings` getters respectively, and we only parse the mappings\n        // and create these arrays once queried for a source location. We jump through\n        // these hoops because there can be many thousands of mappings, and parsing\n        // them is expensive, so we only want to do it if we must.\n        //\n        // Each object in the arrays is of the form:\n        //\n        //     {\n        //       generatedLine: The line number in the generated code,\n        //       generatedColumn: The column number in the generated code,\n        //       source: The path to the original source file that generated this\n        //               chunk of code,\n        //       originalLine: The line number in the original source that\n        //                     corresponds to this chunk of generated code,\n        //       originalColumn: The column number in the original source that\n        //                       corresponds to this chunk of generated code,\n        //       name: The name of the original symbol which generated this chunk of\n        //             code.\n        //     }\n        //\n        // All properties except for `generatedLine` and `generatedColumn` can be\n        // `null`.\n        //\n        // `_generatedMappings` is ordered by the generated positions.\n        //\n        // `_originalMappings` is ordered by the original positions.\n\n        SourceMapConsumer.prototype.__generatedMappings = null;\n        Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n          get: function get() {\n            if (!this.__generatedMappings) {\n              this._parseMappings(this._mappings, this.sourceRoot);\n            }\n\n            return this.__generatedMappings;\n          } });\n\n\n        SourceMapConsumer.prototype.__originalMappings = null;\n        Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n          get: function get() {\n            if (!this.__originalMappings) {\n              this._parseMappings(this._mappings, this.sourceRoot);\n            }\n\n            return this.__originalMappings;\n          } });\n\n\n        SourceMapConsumer.prototype._charIsMappingSeparator =\n        function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n          var c = aStr.charAt(index);\n          return c === \";\" || c === \",\";\n        };\n\n        /**\n            * Parse the mappings in a string in to a data structure which we can easily\n            * query (the ordered arrays in the `this.__generatedMappings` and\n            * `this.__originalMappings` properties).\n            */\n        SourceMapConsumer.prototype._parseMappings =\n        function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n          throw new Error(\"Subclasses must implement _parseMappings\");\n        };\n\n        SourceMapConsumer.GENERATED_ORDER = 1;\n        SourceMapConsumer.ORIGINAL_ORDER = 2;\n\n        SourceMapConsumer.GREATEST_LOWER_BOUND = 1;\n        SourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\n        /**\n                                                  * Iterate over each mapping between an original source/line/column and a\n                                                  * generated line/column in this source map.\n                                                  *\n                                                  * @param Function aCallback\n                                                  *        The function that is called with each mapping.\n                                                  * @param Object aContext\n                                                  *        Optional. If specified, this object will be the value of `this` every\n                                                  *        time that `aCallback` is called.\n                                                  * @param aOrder\n                                                  *        Either `SourceMapConsumer.GENERATED_ORDER` or\n                                                  *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n                                                  *        iterate over the mappings sorted by the generated file's line/column\n                                                  *        order or the original's source/line/column order, respectively. Defaults to\n                                                  *        `SourceMapConsumer.GENERATED_ORDER`.\n                                                  */\n        SourceMapConsumer.prototype.eachMapping =\n        function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n          var context = aContext || null;\n          var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n          var mappings;\n          switch (order) {\n            case SourceMapConsumer.GENERATED_ORDER:\n              mappings = this._generatedMappings;\n              break;\n            case SourceMapConsumer.ORIGINAL_ORDER:\n              mappings = this._originalMappings;\n              break;\n            default:\n              throw new Error(\"Unknown order of iteration.\");}\n\n\n          var sourceRoot = this.sourceRoot;\n          mappings.map(function (mapping) {\n            var source = mapping.source === null ? null : this._sources.at(mapping.source);\n            if (source != null && sourceRoot != null) {\n              source = util.join(sourceRoot, source);\n            }\n            return {\n              source: source,\n              generatedLine: mapping.generatedLine,\n              generatedColumn: mapping.generatedColumn,\n              originalLine: mapping.originalLine,\n              originalColumn: mapping.originalColumn,\n              name: mapping.name === null ? null : this._names.at(mapping.name) };\n\n          }, this).forEach(aCallback, context);\n        };\n\n        /**\n            * Returns all generated line and column information for the original source,\n            * line, and column provided. If no column is provided, returns all mappings\n            * corresponding to a either the line we are searching for or the next\n            * closest line that has any mappings. Otherwise, returns all mappings\n            * corresponding to the given line and either the column we are searching for\n            * or the next closest column that has any offsets.\n            *\n            * The only argument is an object with the following properties:\n            *\n            *   - source: The filename of the original source.\n            *   - line: The line number in the original source.\n            *   - column: Optional. the column number in the original source.\n            *\n            * and an array of objects is returned, each with the following properties:\n            *\n            *   - line: The line number in the generated source, or null.\n            *   - column: The column number in the generated source, or null.\n            */\n        SourceMapConsumer.prototype.allGeneratedPositionsFor =\n        function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n          var line = util.getArg(aArgs, 'line');\n\n          // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n          // returns the index of the closest mapping less than the needle. By\n          // setting needle.originalColumn to 0, we thus find the last mapping for\n          // the given line, provided such a mapping exists.\n          var needle = {\n            source: util.getArg(aArgs, 'source'),\n            originalLine: line,\n            originalColumn: util.getArg(aArgs, 'column', 0) };\n\n\n          if (this.sourceRoot != null) {\n            needle.source = util.relative(this.sourceRoot, needle.source);\n          }\n          if (!this._sources.has(needle.source)) {\n            return [];\n          }\n          needle.source = this._sources.indexOf(needle.source);\n\n          var mappings = [];\n\n          var index = this._findMapping(needle,\n          this._originalMappings,\n          \"originalLine\",\n          \"originalColumn\",\n          util.compareByOriginalPositions,\n          binarySearch.LEAST_UPPER_BOUND);\n          if (index >= 0) {\n            var mapping = this._originalMappings[index];\n\n            if (aArgs.column === undefined) {\n              var originalLine = mapping.originalLine;\n\n              // Iterate until either we run out of mappings, or we run into\n              // a mapping for a different line than the one we found. Since\n              // mappings are sorted, this is guaranteed to find all mappings for\n              // the line we found.\n              while (mapping && mapping.originalLine === originalLine) {\n                mappings.push({\n                  line: util.getArg(mapping, 'generatedLine', null),\n                  column: util.getArg(mapping, 'generatedColumn', null),\n                  lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null) });\n\n\n                mapping = this._originalMappings[++index];\n              }\n            } else {\n              var originalColumn = mapping.originalColumn;\n\n              // Iterate until either we run out of mappings, or we run into\n              // a mapping for a different line than the one we were searching for.\n              // Since mappings are sorted, this is guaranteed to find all mappings for\n              // the line we are searching for.\n              while (mapping &&\n              mapping.originalLine === line &&\n              mapping.originalColumn == originalColumn) {\n                mappings.push({\n                  line: util.getArg(mapping, 'generatedLine', null),\n                  column: util.getArg(mapping, 'generatedColumn', null),\n                  lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null) });\n\n\n                mapping = this._originalMappings[++index];\n              }\n            }\n          }\n\n          return mappings;\n        };\n\n        exports.SourceMapConsumer = SourceMapConsumer;\n\n        /**\n                                                        * A BasicSourceMapConsumer instance represents a parsed source map which we can\n                                                        * query for information about the original file positions by giving it a file\n                                                        * position in the generated source.\n                                                        *\n                                                        * The only parameter is the raw source map (either as a JSON string, or\n                                                        * already parsed to an object). According to the spec, source maps have the\n                                                        * following attributes:\n                                                        *\n                                                        *   - version: Which version of the source map spec this map is following.\n                                                        *   - sources: An array of URLs to the original source files.\n                                                        *   - names: An array of identifiers which can be referrenced by individual mappings.\n                                                        *   - sourceRoot: Optional. The URL root from which all sources are relative.\n                                                        *   - sourcesContent: Optional. An array of contents of the original source files.\n                                                        *   - mappings: A string of base64 VLQs which contain the actual mappings.\n                                                        *   - file: Optional. The generated file this source map is associated with.\n                                                        *\n                                                        * Here is an example source map, taken from the source map spec[0]:\n                                                        *\n                                                        *     {\n                                                        *       version : 3,\n                                                        *       file: \"out.js\",\n                                                        *       sourceRoot : \"\",\n                                                        *       sources: [\"foo.js\", \"bar.js\"],\n                                                        *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n                                                        *       mappings: \"AA,AB;;ABCDE;\"\n                                                        *     }\n                                                        *\n                                                        * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n                                                        */\n        function BasicSourceMapConsumer(aSourceMap) {\n          var sourceMap = aSourceMap;\n          if (typeof aSourceMap === 'string') {\n            sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n          }\n\n          var version = util.getArg(sourceMap, 'version');\n          var sources = util.getArg(sourceMap, 'sources');\n          // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n          // requires the array) to play nice here.\n          var names = util.getArg(sourceMap, 'names', []);\n          var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n          var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n          var mappings = util.getArg(sourceMap, 'mappings');\n          var file = util.getArg(sourceMap, 'file', null);\n\n          // Once again, Sass deviates from the spec and supplies the version as a\n          // string rather than a number, so we use loose equality checking here.\n          if (version != this._version) {\n            throw new Error('Unsupported version: ' + version);\n          }\n\n          // Some source maps produce relative source paths like \"./foo.js\" instead of\n          // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n          // See bugzil.la/1090768.\n          sources = sources.map(util.normalize);\n\n          // Pass `true` below to allow duplicate names and sources. While source maps\n          // are intended to be compressed and deduplicated, the TypeScript compiler\n          // sometimes generates source maps with duplicates in them. See Github issue\n          // #72 and bugzil.la/889492.\n          this._names = ArraySet.fromArray(names, true);\n          this._sources = ArraySet.fromArray(sources, true);\n\n          this.sourceRoot = sourceRoot;\n          this.sourcesContent = sourcesContent;\n          this._mappings = mappings;\n          this.file = file;\n        }\n\n        BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\n        BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n        /**\n                                                                        * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n                                                                        *\n                                                                        * @param SourceMapGenerator aSourceMap\n                                                                        *        The source map that will be consumed.\n                                                                        * @returns BasicSourceMapConsumer\n                                                                        */\n        BasicSourceMapConsumer.fromSourceMap =\n        function SourceMapConsumer_fromSourceMap(aSourceMap) {\n          var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n          var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n          var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n          smc.sourceRoot = aSourceMap._sourceRoot;\n          smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n          smc.sourceRoot);\n          smc.file = aSourceMap._file;\n\n          // Because we are modifying the entries (by converting string sources and\n          // names to indices into the sources and names ArraySets), we have to make\n          // a copy of the entry or else bad things happen. Shared mutable state\n          // strikes again! See github issue #191.\n\n          var generatedMappings = aSourceMap._mappings.toArray().slice();\n          var destGeneratedMappings = smc.__generatedMappings = [];\n          var destOriginalMappings = smc.__originalMappings = [];\n\n          for (var i = 0, length = generatedMappings.length; i < length; i++) {\n            var srcMapping = generatedMappings[i];\n            var destMapping = new Mapping();\n            destMapping.generatedLine = srcMapping.generatedLine;\n            destMapping.generatedColumn = srcMapping.generatedColumn;\n\n            if (srcMapping.source) {\n              destMapping.source = sources.indexOf(srcMapping.source);\n              destMapping.originalLine = srcMapping.originalLine;\n              destMapping.originalColumn = srcMapping.originalColumn;\n\n              if (srcMapping.name) {\n                destMapping.name = names.indexOf(srcMapping.name);\n              }\n\n              destOriginalMappings.push(destMapping);\n            }\n\n            destGeneratedMappings.push(destMapping);\n          }\n\n          quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\n          return smc;\n        };\n\n        /**\n            * The version of the source mapping spec that we are consuming.\n            */\n        BasicSourceMapConsumer.prototype._version = 3;\n\n        /**\n                                                        * The list of original sources.\n                                                        */\n        Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n          get: function get() {\n            return this._sources.toArray().map(function (s) {\n              return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;\n            }, this);\n          } });\n\n\n        /**\n                 * Provide the JIT with a nice shape / hidden class.\n                 */\n        function Mapping() {\n          this.generatedLine = 0;\n          this.generatedColumn = 0;\n          this.source = null;\n          this.originalLine = null;\n          this.originalColumn = null;\n          this.name = null;\n        }\n\n        /**\n           * Parse the mappings in a string in to a data structure which we can easily\n           * query (the ordered arrays in the `this.__generatedMappings` and\n           * `this.__originalMappings` properties).\n           */\n        BasicSourceMapConsumer.prototype._parseMappings =\n        function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n          var generatedLine = 1;\n          var previousGeneratedColumn = 0;\n          var previousOriginalLine = 0;\n          var previousOriginalColumn = 0;\n          var previousSource = 0;\n          var previousName = 0;\n          var length = aStr.length;\n          var index = 0;\n          var cachedSegments = {};\n          var temp = {};\n          var originalMappings = [];\n          var generatedMappings = [];\n          var mapping, str, segment, end, value;\n\n          while (index < length) {\n            if (aStr.charAt(index) === ';') {\n              generatedLine++;\n              index++;\n              previousGeneratedColumn = 0;\n            } else\n            if (aStr.charAt(index) === ',') {\n              index++;\n            } else\n            {\n              mapping = new Mapping();\n              mapping.generatedLine = generatedLine;\n\n              // Because each offset is encoded relative to the previous one,\n              // many segments often have the same encoding. We can exploit this\n              // fact by caching the parsed variable length fields of each segment,\n              // allowing us to avoid a second parse if we encounter the same\n              // segment again.\n              for (end = index; end < length; end++) {\n                if (this._charIsMappingSeparator(aStr, end)) {\n                  break;\n                }\n              }\n              str = aStr.slice(index, end);\n\n              segment = cachedSegments[str];\n              if (segment) {\n                index += str.length;\n              } else {\n                segment = [];\n                while (index < end) {\n                  base64VLQ.decode(aStr, index, temp);\n                  value = temp.value;\n                  index = temp.rest;\n                  segment.push(value);\n                }\n\n                if (segment.length === 2) {\n                  throw new Error('Found a source, but no line and column');\n                }\n\n                if (segment.length === 3) {\n                  throw new Error('Found a source and line, but no column');\n                }\n\n                cachedSegments[str] = segment;\n              }\n\n              // Generated column.\n              mapping.generatedColumn = previousGeneratedColumn + segment[0];\n              previousGeneratedColumn = mapping.generatedColumn;\n\n              if (segment.length > 1) {\n                // Original source.\n                mapping.source = previousSource + segment[1];\n                previousSource += segment[1];\n\n                // Original line.\n                mapping.originalLine = previousOriginalLine + segment[2];\n                previousOriginalLine = mapping.originalLine;\n                // Lines are stored 0-based\n                mapping.originalLine += 1;\n\n                // Original column.\n                mapping.originalColumn = previousOriginalColumn + segment[3];\n                previousOriginalColumn = mapping.originalColumn;\n\n                if (segment.length > 4) {\n                  // Original name.\n                  mapping.name = previousName + segment[4];\n                  previousName += segment[4];\n                }\n              }\n\n              generatedMappings.push(mapping);\n              if (typeof mapping.originalLine === 'number') {\n                originalMappings.push(mapping);\n              }\n            }\n          }\n\n          quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n          this.__generatedMappings = generatedMappings;\n\n          quickSort(originalMappings, util.compareByOriginalPositions);\n          this.__originalMappings = originalMappings;\n        };\n\n        /**\n            * Find the mapping that best matches the hypothetical \"needle\" mapping that\n            * we are searching for in the given \"haystack\" of mappings.\n            */\n        BasicSourceMapConsumer.prototype._findMapping =\n        function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n        aColumnName, aComparator, aBias) {\n          // To return the position we are searching for, we must first find the\n          // mapping for the given position and then return the opposite position it\n          // points to. Because the mappings are sorted, we can use binary search to\n          // find the best mapping.\n\n          if (aNeedle[aLineName] <= 0) {\n            throw new TypeError('Line must be greater than or equal to 1, got ' +\n            aNeedle[aLineName]);\n          }\n          if (aNeedle[aColumnName] < 0) {\n            throw new TypeError('Column must be greater than or equal to 0, got ' +\n            aNeedle[aColumnName]);\n          }\n\n          return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n        };\n\n        /**\n            * Compute the last column for each generated mapping. The last column is\n            * inclusive.\n            */\n        BasicSourceMapConsumer.prototype.computeColumnSpans =\n        function SourceMapConsumer_computeColumnSpans() {\n          for (var index = 0; index < this._generatedMappings.length; ++index) {\n            var mapping = this._generatedMappings[index];\n\n            // Mappings do not contain a field for the last generated columnt. We\n            // can come up with an optimistic estimate, however, by assuming that\n            // mappings are contiguous (i.e. given two consecutive mappings, the\n            // first mapping ends where the second one starts).\n            if (index + 1 < this._generatedMappings.length) {\n              var nextMapping = this._generatedMappings[index + 1];\n\n              if (mapping.generatedLine === nextMapping.generatedLine) {\n                mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n                continue;\n              }\n            }\n\n            // The last mapping for each line spans the entire line.\n            mapping.lastGeneratedColumn = Infinity;\n          }\n        };\n\n        /**\n            * Returns the original source, line, and column information for the generated\n            * source's line and column positions provided. The only argument is an object\n            * with the following properties:\n            *\n            *   - line: The line number in the generated source.\n            *   - column: The column number in the generated source.\n            *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n            *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n            *     closest element that is smaller than or greater than the one we are\n            *     searching for, respectively, if the exact element cannot be found.\n            *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n            *\n            * and an object is returned with the following properties:\n            *\n            *   - source: The original source file, or null.\n            *   - line: The line number in the original source, or null.\n            *   - column: The column number in the original source, or null.\n            *   - name: The original identifier, or null.\n            */\n        BasicSourceMapConsumer.prototype.originalPositionFor =\n        function SourceMapConsumer_originalPositionFor(aArgs) {\n          var needle = {\n            generatedLine: util.getArg(aArgs, 'line'),\n            generatedColumn: util.getArg(aArgs, 'column') };\n\n\n          var index = this._findMapping(\n          needle,\n          this._generatedMappings,\n          \"generatedLine\",\n          \"generatedColumn\",\n          util.compareByGeneratedPositionsDeflated,\n          util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));\n\n\n          if (index >= 0) {\n            var mapping = this._generatedMappings[index];\n\n            if (mapping.generatedLine === needle.generatedLine) {\n              var source = util.getArg(mapping, 'source', null);\n              if (source !== null) {\n                source = this._sources.at(source);\n                if (this.sourceRoot != null) {\n                  source = util.join(this.sourceRoot, source);\n                }\n              }\n              var name = util.getArg(mapping, 'name', null);\n              if (name !== null) {\n                name = this._names.at(name);\n              }\n              return {\n                source: source,\n                line: util.getArg(mapping, 'originalLine', null),\n                column: util.getArg(mapping, 'originalColumn', null),\n                name: name };\n\n            }\n          }\n\n          return {\n            source: null,\n            line: null,\n            column: null,\n            name: null };\n\n        };\n\n        /**\n            * Return true if we have the source content for every source in the source\n            * map, false otherwise.\n            */\n        BasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n        function BasicSourceMapConsumer_hasContentsOfAllSources() {\n          if (!this.sourcesContent) {\n            return false;\n          }\n          return this.sourcesContent.length >= this._sources.size() &&\n          !this.sourcesContent.some(function (sc) {return sc == null;});\n        };\n\n        /**\n            * Returns the original source content. The only argument is the url of the\n            * original source file. Returns null if no original source content is\n            * availible.\n            */\n        BasicSourceMapConsumer.prototype.sourceContentFor =\n        function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n          if (!this.sourcesContent) {\n            return null;\n          }\n\n          if (this.sourceRoot != null) {\n            aSource = util.relative(this.sourceRoot, aSource);\n          }\n\n          if (this._sources.has(aSource)) {\n            return this.sourcesContent[this._sources.indexOf(aSource)];\n          }\n\n          var url;\n          if (this.sourceRoot != null && (\n          url = util.urlParse(this.sourceRoot))) {\n            // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n            // many users. We can help them out when they expect file:// URIs to\n            // behave like it would if they were running a local HTTP server. See\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n            var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");\n            if (url.scheme == \"file\" &&\n            this._sources.has(fileUriAbsPath)) {\n              return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];\n            }\n\n            if ((!url.path || url.path == \"/\") &&\n            this._sources.has(\"/\" + aSource)) {\n              return this.sourcesContent[this._sources.indexOf(\"/\" + aSource)];\n            }\n          }\n\n          // This function is used recursively from\n          // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n          // don't want to throw if we can't find the source - we just want to\n          // return null, so we provide a flag to exit gracefully.\n          if (nullOnMissing) {\n            return null;\n          } else\n          {\n            throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n          }\n        };\n\n        /**\n            * Returns the generated line and column information for the original source,\n            * line, and column positions provided. The only argument is an object with\n            * the following properties:\n            *\n            *   - source: The filename of the original source.\n            *   - line: The line number in the original source.\n            *   - column: The column number in the original source.\n            *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n            *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n            *     closest element that is smaller than or greater than the one we are\n            *     searching for, respectively, if the exact element cannot be found.\n            *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n            *\n            * and an object is returned with the following properties:\n            *\n            *   - line: The line number in the generated source, or null.\n            *   - column: The column number in the generated source, or null.\n            */\n        BasicSourceMapConsumer.prototype.generatedPositionFor =\n        function SourceMapConsumer_generatedPositionFor(aArgs) {\n          var source = util.getArg(aArgs, 'source');\n          if (this.sourceRoot != null) {\n            source = util.relative(this.sourceRoot, source);\n          }\n          if (!this._sources.has(source)) {\n            return {\n              line: null,\n              column: null,\n              lastColumn: null };\n\n          }\n          source = this._sources.indexOf(source);\n\n          var needle = {\n            source: source,\n            originalLine: util.getArg(aArgs, 'line'),\n            originalColumn: util.getArg(aArgs, 'column') };\n\n\n          var index = this._findMapping(\n          needle,\n          this._originalMappings,\n          \"originalLine\",\n          \"originalColumn\",\n          util.compareByOriginalPositions,\n          util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));\n\n\n          if (index >= 0) {\n            var mapping = this._originalMappings[index];\n\n            if (mapping.source === needle.source) {\n              return {\n                line: util.getArg(mapping, 'generatedLine', null),\n                column: util.getArg(mapping, 'generatedColumn', null),\n                lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null) };\n\n            }\n          }\n\n          return {\n            line: null,\n            column: null,\n            lastColumn: null };\n\n        };\n\n        exports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n        /**\n                                                                  * An IndexedSourceMapConsumer instance represents a parsed source map which\n                                                                  * we can query for information. It differs from BasicSourceMapConsumer in\n                                                                  * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n                                                                  * input.\n                                                                  *\n                                                                  * The only parameter is a raw source map (either as a JSON string, or already\n                                                                  * parsed to an object). According to the spec for indexed source maps, they\n                                                                  * have the following attributes:\n                                                                  *\n                                                                  *   - version: Which version of the source map spec this map is following.\n                                                                  *   - file: Optional. The generated file this source map is associated with.\n                                                                  *   - sections: A list of section definitions.\n                                                                  *\n                                                                  * Each value under the \"sections\" field has two fields:\n                                                                  *   - offset: The offset into the original specified at which this section\n                                                                  *       begins to apply, defined as an object with a \"line\" and \"column\"\n                                                                  *       field.\n                                                                  *   - map: A source map definition. This source map could also be indexed,\n                                                                  *       but doesn't have to be.\n                                                                  *\n                                                                  * Instead of the \"map\" field, it's also possible to have a \"url\" field\n                                                                  * specifying a URL to retrieve a source map from, but that's currently\n                                                                  * unsupported.\n                                                                  *\n                                                                  * Here's an example source map, taken from the source map spec[0], but\n                                                                  * modified to omit a section which uses the \"url\" field.\n                                                                  *\n                                                                  *  {\n                                                                  *    version : 3,\n                                                                  *    file: \"app.js\",\n                                                                  *    sections: [{\n                                                                  *      offset: {line:100, column:10},\n                                                                  *      map: {\n                                                                  *        version : 3,\n                                                                  *        file: \"section.js\",\n                                                                  *        sources: [\"foo.js\", \"bar.js\"],\n                                                                  *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n                                                                  *        mappings: \"AAAA,E;;ABCDE;\"\n                                                                  *      }\n                                                                  *    }],\n                                                                  *  }\n                                                                  *\n                                                                  * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n                                                                  */\n        function IndexedSourceMapConsumer(aSourceMap) {\n          var sourceMap = aSourceMap;\n          if (typeof aSourceMap === 'string') {\n            sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n          }\n\n          var version = util.getArg(sourceMap, 'version');\n          var sections = util.getArg(sourceMap, 'sections');\n\n          if (version != this._version) {\n            throw new Error('Unsupported version: ' + version);\n          }\n\n          this._sources = new ArraySet();\n          this._names = new ArraySet();\n\n          var lastOffset = {\n            line: -1,\n            column: 0 };\n\n          this._sections = sections.map(function (s) {\n            if (s.url) {\n              // The url field will require support for asynchronicity.\n              // See https://github.com/mozilla/source-map/issues/16\n              throw new Error('Support for url field in sections not implemented.');\n            }\n            var offset = util.getArg(s, 'offset');\n            var offsetLine = util.getArg(offset, 'line');\n            var offsetColumn = util.getArg(offset, 'column');\n\n            if (offsetLine < lastOffset.line ||\n            offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {\n              throw new Error('Section offsets must be ordered and non-overlapping.');\n            }\n            lastOffset = offset;\n\n            return {\n              generatedOffset: {\n                // The offset fields are 0-based, but we use 1-based indices when\n                // encoding/decoding from VLQ.\n                generatedLine: offsetLine + 1,\n                generatedColumn: offsetColumn + 1 },\n\n              consumer: new SourceMapConsumer(util.getArg(s, 'map')) };\n\n          });\n        }\n\n        IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\n        IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n        /**\n                                                                             * The version of the source mapping spec that we are consuming.\n                                                                             */\n        IndexedSourceMapConsumer.prototype._version = 3;\n\n        /**\n                                                          * The list of original sources.\n                                                          */\n        Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n          get: function get() {\n            var sources = [];\n            for (var i = 0; i < this._sections.length; i++) {\n              for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n                sources.push(this._sections[i].consumer.sources[j]);\n              }\n            };\n            return sources;\n          } });\n\n\n        /**\n                 * Returns the original source, line, and column information for the generated\n                 * source's line and column positions provided. The only argument is an object\n                 * with the following properties:\n                 *\n                 *   - line: The line number in the generated source.\n                 *   - column: The column number in the generated source.\n                 *\n                 * and an object is returned with the following properties:\n                 *\n                 *   - source: The original source file, or null.\n                 *   - line: The line number in the original source, or null.\n                 *   - column: The column number in the original source, or null.\n                 *   - name: The original identifier, or null.\n                 */\n        IndexedSourceMapConsumer.prototype.originalPositionFor =\n        function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n          var needle = {\n            generatedLine: util.getArg(aArgs, 'line'),\n            generatedColumn: util.getArg(aArgs, 'column') };\n\n\n          // Find the section containing the generated position we're trying to map\n          // to an original position.\n          var sectionIndex = binarySearch.search(needle, this._sections,\n          function (needle, section) {\n            var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n            if (cmp) {\n              return cmp;\n            }\n\n            return needle.generatedColumn -\n            section.generatedOffset.generatedColumn;\n          });\n          var section = this._sections[sectionIndex];\n\n          if (!section) {\n            return {\n              source: null,\n              line: null,\n              column: null,\n              name: null };\n\n          }\n\n          return section.consumer.originalPositionFor({\n            line: needle.generatedLine - (\n            section.generatedOffset.generatedLine - 1),\n            column: needle.generatedColumn - (\n            section.generatedOffset.generatedLine === needle.generatedLine ?\n            section.generatedOffset.generatedColumn - 1 :\n            0),\n            bias: aArgs.bias });\n\n        };\n\n        /**\n            * Return true if we have the source content for every source in the source\n            * map, false otherwise.\n            */\n        IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n        function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n          return this._sections.every(function (s) {\n            return s.consumer.hasContentsOfAllSources();\n          });\n        };\n\n        /**\n            * Returns the original source content. The only argument is the url of the\n            * original source file. Returns null if no original source content is\n            * available.\n            */\n        IndexedSourceMapConsumer.prototype.sourceContentFor =\n        function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n          for (var i = 0; i < this._sections.length; i++) {\n            var section = this._sections[i];\n\n            var content = section.consumer.sourceContentFor(aSource, true);\n            if (content) {\n              return content;\n            }\n          }\n          if (nullOnMissing) {\n            return null;\n          } else\n          {\n            throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n          }\n        };\n\n        /**\n            * Returns the generated line and column information for the original source,\n            * line, and column positions provided. The only argument is an object with\n            * the following properties:\n            *\n            *   - source: The filename of the original source.\n            *   - line: The line number in the original source.\n            *   - column: The column number in the original source.\n            *\n            * and an object is returned with the following properties:\n            *\n            *   - line: The line number in the generated source, or null.\n            *   - column: The column number in the generated source, or null.\n            */\n        IndexedSourceMapConsumer.prototype.generatedPositionFor =\n        function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n          for (var i = 0; i < this._sections.length; i++) {\n            var section = this._sections[i];\n\n            // Only consider this section if the requested source is in the list of\n            // sources of the consumer.\n            if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {\n              continue;\n            }\n            var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n            if (generatedPosition) {\n              var ret = {\n                line: generatedPosition.line + (\n                section.generatedOffset.generatedLine - 1),\n                column: generatedPosition.column + (\n                section.generatedOffset.generatedLine === generatedPosition.line ?\n                section.generatedOffset.generatedColumn - 1 :\n                0) };\n\n              return ret;\n            }\n          }\n\n          return {\n            line: null,\n            column: null };\n\n        };\n\n        /**\n            * Parse the mappings in a string in to a data structure which we can easily\n            * query (the ordered arrays in the `this.__generatedMappings` and\n            * `this.__originalMappings` properties).\n            */\n        IndexedSourceMapConsumer.prototype._parseMappings =\n        function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n          this.__generatedMappings = [];\n          this.__originalMappings = [];\n          for (var i = 0; i < this._sections.length; i++) {\n            var section = this._sections[i];\n            var sectionMappings = section.consumer._generatedMappings;\n            for (var j = 0; j < sectionMappings.length; j++) {\n              var mapping = sectionMappings[i];\n\n              var source = section.consumer._sources.at(mapping.source);\n              if (section.consumer.sourceRoot !== null) {\n                source = util.join(section.consumer.sourceRoot, source);\n              }\n              this._sources.add(source);\n              source = this._sources.indexOf(source);\n\n              var name = section.consumer._names.at(mapping.name);\n              this._names.add(name);\n              name = this._names.indexOf(name);\n\n              // The mappings coming from the consumer for the section have\n              // generated positions relative to the start of the section, so we\n              // need to offset them to be relative to the start of the concatenated\n              // generated file.\n              var adjustedMapping = {\n                source: source,\n                generatedLine: mapping.generatedLine + (\n                section.generatedOffset.generatedLine - 1),\n                generatedColumn: mapping.column + (\n                section.generatedOffset.generatedLine === mapping.generatedLine) ?\n                section.generatedOffset.generatedColumn - 1 :\n                0,\n                originalLine: mapping.originalLine,\n                originalColumn: mapping.originalColumn,\n                name: name };\n\n\n              this.__generatedMappings.push(adjustedMapping);\n              if (typeof adjustedMapping.originalLine === 'number') {\n                this.__originalMappings.push(adjustedMapping);\n              }\n            };\n          };\n\n          quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n          quickSort(this.__originalMappings, util.compareByOriginalPositions);\n        };\n\n        exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n\n      });\n\n    }, { \"./array-set\": 47, \"./base64-vlq\": 48, \"./binary-search\": 50, \"./quick-sort\": 52, \"./util\": 56, \"amdefine\": 1 }], 54: [function (require, module, exports) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n      /*\n                                                   * Copyright 2011 Mozilla Foundation and contributors\n                                                   * Licensed under the New BSD license. See LICENSE or:\n                                                   * http://opensource.org/licenses/BSD-3-Clause\n                                                   */\n      if (typeof define !== 'function') {\n        var define = require('amdefine')(module, require);\n      }\n      define(function (require, exports, module) {\n\n        var base64VLQ = require('./base64-vlq');\n        var util = require('./util');\n        var ArraySet = require('./array-set').ArraySet;\n        var MappingList = require('./mapping-list').MappingList;\n\n        /**\n                                                                  * An instance of the SourceMapGenerator represents a source map which is\n                                                                  * being built incrementally. You may pass an object with the following\n                                                                  * properties:\n                                                                  *\n                                                                  *   - file: The filename of the generated source.\n                                                                  *   - sourceRoot: A root for all relative URLs in this source map.\n                                                                  */\n        function SourceMapGenerator(aArgs) {\n          if (!aArgs) {\n            aArgs = {};\n          }\n          this._file = util.getArg(aArgs, 'file', null);\n          this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n          this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n          this._sources = new ArraySet();\n          this._names = new ArraySet();\n          this._mappings = new MappingList();\n          this._sourcesContents = null;\n        }\n\n        SourceMapGenerator.prototype._version = 3;\n\n        /**\n                                                    * Creates a new SourceMapGenerator based on a SourceMapConsumer\n                                                    *\n                                                    * @param aSourceMapConsumer The SourceMap.\n                                                    */\n        SourceMapGenerator.fromSourceMap =\n        function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n          var sourceRoot = aSourceMapConsumer.sourceRoot;\n          var generator = new SourceMapGenerator({\n            file: aSourceMapConsumer.file,\n            sourceRoot: sourceRoot });\n\n          aSourceMapConsumer.eachMapping(function (mapping) {\n            var newMapping = {\n              generated: {\n                line: mapping.generatedLine,\n                column: mapping.generatedColumn } };\n\n\n\n            if (mapping.source != null) {\n              newMapping.source = mapping.source;\n              if (sourceRoot != null) {\n                newMapping.source = util.relative(sourceRoot, newMapping.source);\n              }\n\n              newMapping.original = {\n                line: mapping.originalLine,\n                column: mapping.originalColumn };\n\n\n              if (mapping.name != null) {\n                newMapping.name = mapping.name;\n              }\n            }\n\n            generator.addMapping(newMapping);\n          });\n          aSourceMapConsumer.sources.forEach(function (sourceFile) {\n            var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n            if (content != null) {\n              generator.setSourceContent(sourceFile, content);\n            }\n          });\n          return generator;\n        };\n\n        /**\n            * Add a single mapping from original source line and column to the generated\n            * source's line and column for this source map being created. The mapping\n            * object should have the following properties:\n            *\n            *   - generated: An object with the generated line and column positions.\n            *   - original: An object with the original line and column positions.\n            *   - source: The original source file (relative to the sourceRoot).\n            *   - name: An optional original token name for this mapping.\n            */\n        SourceMapGenerator.prototype.addMapping =\n        function SourceMapGenerator_addMapping(aArgs) {\n          var generated = util.getArg(aArgs, 'generated');\n          var original = util.getArg(aArgs, 'original', null);\n          var source = util.getArg(aArgs, 'source', null);\n          var name = util.getArg(aArgs, 'name', null);\n\n          if (!this._skipValidation) {\n            this._validateMapping(generated, original, source, name);\n          }\n\n          if (source != null && !this._sources.has(source)) {\n            this._sources.add(source);\n          }\n\n          if (name != null && !this._names.has(name)) {\n            this._names.add(name);\n          }\n\n          this._mappings.add({\n            generatedLine: generated.line,\n            generatedColumn: generated.column,\n            originalLine: original != null && original.line,\n            originalColumn: original != null && original.column,\n            source: source,\n            name: name });\n\n        };\n\n        /**\n            * Set the source content for a source file.\n            */\n        SourceMapGenerator.prototype.setSourceContent =\n        function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n          var source = aSourceFile;\n          if (this._sourceRoot != null) {\n            source = util.relative(this._sourceRoot, source);\n          }\n\n          if (aSourceContent != null) {\n            // Add the source content to the _sourcesContents map.\n            // Create a new _sourcesContents map if the property is null.\n            if (!this._sourcesContents) {\n              this._sourcesContents = {};\n            }\n            this._sourcesContents[util.toSetString(source)] = aSourceContent;\n          } else if (this._sourcesContents) {\n            // Remove the source file from the _sourcesContents map.\n            // If the _sourcesContents map is empty, set the property to null.\n            delete this._sourcesContents[util.toSetString(source)];\n            if (Object.keys(this._sourcesContents).length === 0) {\n              this._sourcesContents = null;\n            }\n          }\n        };\n\n        /**\n            * Applies the mappings of a sub-source-map for a specific source file to the\n            * source map being generated. Each mapping to the supplied source file is\n            * rewritten using the supplied source map. Note: The resolution for the\n            * resulting mappings is the minimium of this map and the supplied map.\n            *\n            * @param aSourceMapConsumer The source map to be applied.\n            * @param aSourceFile Optional. The filename of the source file.\n            *        If omitted, SourceMapConsumer's file property will be used.\n            * @param aSourceMapPath Optional. The dirname of the path to the source map\n            *        to be applied. If relative, it is relative to the SourceMapConsumer.\n            *        This parameter is needed when the two source maps aren't in the same\n            *        directory, and the source map to be applied contains relative source\n            *        paths. If so, those relative source paths need to be rewritten\n            *        relative to the SourceMapGenerator.\n            */\n        SourceMapGenerator.prototype.applySourceMap =\n        function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n          var sourceFile = aSourceFile;\n          // If aSourceFile is omitted, we will use the file property of the SourceMap\n          if (aSourceFile == null) {\n            if (aSourceMapConsumer.file == null) {\n              throw new Error(\n              'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n              'or the source map\\'s \"file\" property. Both were omitted.');\n\n            }\n            sourceFile = aSourceMapConsumer.file;\n          }\n          var sourceRoot = this._sourceRoot;\n          // Make \"sourceFile\" relative if an absolute Url is passed.\n          if (sourceRoot != null) {\n            sourceFile = util.relative(sourceRoot, sourceFile);\n          }\n          // Applying the SourceMap can add and remove items from the sources and\n          // the names array.\n          var newSources = new ArraySet();\n          var newNames = new ArraySet();\n\n          // Find mappings for the \"sourceFile\"\n          this._mappings.unsortedForEach(function (mapping) {\n            if (mapping.source === sourceFile && mapping.originalLine != null) {\n              // Check if it can be mapped by the source map, then update the mapping.\n              var original = aSourceMapConsumer.originalPositionFor({\n                line: mapping.originalLine,\n                column: mapping.originalColumn });\n\n              if (original.source != null) {\n                // Copy mapping\n                mapping.source = original.source;\n                if (aSourceMapPath != null) {\n                  mapping.source = util.join(aSourceMapPath, mapping.source);\n                }\n                if (sourceRoot != null) {\n                  mapping.source = util.relative(sourceRoot, mapping.source);\n                }\n                mapping.originalLine = original.line;\n                mapping.originalColumn = original.column;\n                if (original.name != null) {\n                  mapping.name = original.name;\n                }\n              }\n            }\n\n            var source = mapping.source;\n            if (source != null && !newSources.has(source)) {\n              newSources.add(source);\n            }\n\n            var name = mapping.name;\n            if (name != null && !newNames.has(name)) {\n              newNames.add(name);\n            }\n\n          }, this);\n          this._sources = newSources;\n          this._names = newNames;\n\n          // Copy sourcesContents of applied map.\n          aSourceMapConsumer.sources.forEach(function (sourceFile) {\n            var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n            if (content != null) {\n              if (aSourceMapPath != null) {\n                sourceFile = util.join(aSourceMapPath, sourceFile);\n              }\n              if (sourceRoot != null) {\n                sourceFile = util.relative(sourceRoot, sourceFile);\n              }\n              this.setSourceContent(sourceFile, content);\n            }\n          }, this);\n        };\n\n        /**\n            * A mapping can have one of the three levels of data:\n            *\n            *   1. Just the generated position.\n            *   2. The Generated position, original position, and original source.\n            *   3. Generated and original position, original source, as well as a name\n            *      token.\n            *\n            * To maintain consistency, we validate that any new mapping being added falls\n            * in to one of these categories.\n            */\n        SourceMapGenerator.prototype._validateMapping =\n        function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n        aName) {\n          if (aGenerated && 'line' in aGenerated && 'column' in aGenerated &&\n          aGenerated.line > 0 && aGenerated.column >= 0 &&\n          !aOriginal && !aSource && !aName) {\n            // Case 1.\n            return;\n          } else\n          if (aGenerated && 'line' in aGenerated && 'column' in aGenerated &&\n          aOriginal && 'line' in aOriginal && 'column' in aOriginal &&\n          aGenerated.line > 0 && aGenerated.column >= 0 &&\n          aOriginal.line > 0 && aOriginal.column >= 0 &&\n          aSource) {\n            // Cases 2 and 3.\n            return;\n          } else\n          {\n            throw new Error('Invalid mapping: ' + JSON.stringify({\n              generated: aGenerated,\n              source: aSource,\n              original: aOriginal,\n              name: aName }));\n\n          }\n        };\n\n        /**\n            * Serialize the accumulated mappings in to the stream of base 64 VLQs\n            * specified by the source map format.\n            */\n        SourceMapGenerator.prototype._serializeMappings =\n        function SourceMapGenerator_serializeMappings() {\n          var previousGeneratedColumn = 0;\n          var previousGeneratedLine = 1;\n          var previousOriginalColumn = 0;\n          var previousOriginalLine = 0;\n          var previousName = 0;\n          var previousSource = 0;\n          var result = '';\n          var mapping;\n\n          var mappings = this._mappings.toArray();\n          for (var i = 0, len = mappings.length; i < len; i++) {\n            mapping = mappings[i];\n\n            if (mapping.generatedLine !== previousGeneratedLine) {\n              previousGeneratedColumn = 0;\n              while (mapping.generatedLine !== previousGeneratedLine) {\n                result += ';';\n                previousGeneratedLine++;\n              }\n            } else\n            {\n              if (i > 0) {\n                if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n                  continue;\n                }\n                result += ',';\n              }\n            }\n\n            result += base64VLQ.encode(mapping.generatedColumn -\n            previousGeneratedColumn);\n            previousGeneratedColumn = mapping.generatedColumn;\n\n            if (mapping.source != null) {\n              result += base64VLQ.encode(this._sources.indexOf(mapping.source) -\n              previousSource);\n              previousSource = this._sources.indexOf(mapping.source);\n\n              // lines are stored 0-based in SourceMap spec version 3\n              result += base64VLQ.encode(mapping.originalLine - 1 -\n              previousOriginalLine);\n              previousOriginalLine = mapping.originalLine - 1;\n\n              result += base64VLQ.encode(mapping.originalColumn -\n              previousOriginalColumn);\n              previousOriginalColumn = mapping.originalColumn;\n\n              if (mapping.name != null) {\n                result += base64VLQ.encode(this._names.indexOf(mapping.name) -\n                previousName);\n                previousName = this._names.indexOf(mapping.name);\n              }\n            }\n          }\n\n          return result;\n        };\n\n        SourceMapGenerator.prototype._generateSourcesContent =\n        function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n          return aSources.map(function (source) {\n            if (!this._sourcesContents) {\n              return null;\n            }\n            if (aSourceRoot != null) {\n              source = util.relative(aSourceRoot, source);\n            }\n            var key = util.toSetString(source);\n            return Object.prototype.hasOwnProperty.call(this._sourcesContents,\n            key) ?\n            this._sourcesContents[key] :\n            null;\n          }, this);\n        };\n\n        /**\n            * Externalize the source map.\n            */\n        SourceMapGenerator.prototype.toJSON =\n        function SourceMapGenerator_toJSON() {\n          var map = {\n            version: this._version,\n            sources: this._sources.toArray(),\n            names: this._names.toArray(),\n            mappings: this._serializeMappings() };\n\n          if (this._file != null) {\n            map.file = this._file;\n          }\n          if (this._sourceRoot != null) {\n            map.sourceRoot = this._sourceRoot;\n          }\n          if (this._sourcesContents) {\n            map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n          }\n\n          return map;\n        };\n\n        /**\n            * Render the source map being generated to a string.\n            */\n        SourceMapGenerator.prototype.toString =\n        function SourceMapGenerator_toString() {\n          return JSON.stringify(this.toJSON());\n        };\n\n        exports.SourceMapGenerator = SourceMapGenerator;\n\n      });\n\n    }, { \"./array-set\": 47, \"./base64-vlq\": 48, \"./mapping-list\": 51, \"./util\": 56, \"amdefine\": 1 }], 55: [function (require, module, exports) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n      /*\n                                                   * Copyright 2011 Mozilla Foundation and contributors\n                                                   * Licensed under the New BSD license. See LICENSE or:\n                                                   * http://opensource.org/licenses/BSD-3-Clause\n                                                   */\n      if (typeof define !== 'function') {\n        var define = require('amdefine')(module, require);\n      }\n      define(function (require, exports, module) {\n\n        var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\n        var util = require('./util');\n\n        // Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n        // operating systems these days (capturing the result).\n        var REGEX_NEWLINE = /(\\r?\\n)/;\n\n        // Newline character code for charCodeAt() comparisons\n        var NEWLINE_CODE = 10;\n\n        // Private symbol for identifying `SourceNode`s when multiple versions of\n        // the source-map library are loaded. This MUST NOT CHANGE across\n        // versions!\n        var isSourceNode = \"$$$isSourceNode$$$\";\n\n        /**\n                                                  * SourceNodes provide a way to abstract over interpolating/concatenating\n                                                  * snippets of generated JavaScript source code while maintaining the line and\n                                                  * column information associated with the original source code.\n                                                  *\n                                                  * @param aLine The original line number.\n                                                  * @param aColumn The original column number.\n                                                  * @param aSource The original source's filename.\n                                                  * @param aChunks Optional. An array of strings which are snippets of\n                                                  *        generated JS, or other SourceNodes.\n                                                  * @param aName The original identifier.\n                                                  */\n        function SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n          this.children = [];\n          this.sourceContents = {};\n          this.line = aLine == null ? null : aLine;\n          this.column = aColumn == null ? null : aColumn;\n          this.source = aSource == null ? null : aSource;\n          this.name = aName == null ? null : aName;\n          this[isSourceNode] = true;\n          if (aChunks != null) this.add(aChunks);\n        }\n\n        /**\n           * Creates a SourceNode from generated code and a SourceMapConsumer.\n           *\n           * @param aGeneratedCode The generated code\n           * @param aSourceMapConsumer The SourceMap for the generated code\n           * @param aRelativePath Optional. The path that relative sources in the\n           *        SourceMapConsumer should be relative to.\n           */\n        SourceNode.fromStringWithSourceMap =\n        function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n          // The SourceNode we want to fill with the generated code\n          // and the SourceMap\n          var node = new SourceNode();\n\n          // All even indices of this array are one line of the generated code,\n          // while all odd indices are the newlines between two adjacent lines\n          // (since `REGEX_NEWLINE` captures its match).\n          // Processed fragments are removed from this array, by calling `shiftNextLine`.\n          var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n          var shiftNextLine = function shiftNextLine() {\n            var lineContents = remainingLines.shift();\n            // The last line of a file might not have a newline.\n            var newLine = remainingLines.shift() || \"\";\n            return lineContents + newLine;\n          };\n\n          // We need to remember the position of \"remainingLines\"\n          var lastGeneratedLine = 1,lastGeneratedColumn = 0;\n\n          // The generate SourceNodes we need a code range.\n          // To extract it current and last mapping is used.\n          // Here we store the last mapping.\n          var lastMapping = null;\n\n          aSourceMapConsumer.eachMapping(function (mapping) {\n            if (lastMapping !== null) {\n              // We add the code from \"lastMapping\" to \"mapping\":\n              // First check if there is a new line in between.\n              if (lastGeneratedLine < mapping.generatedLine) {\n                var code = \"\";\n                // Associate first line with \"lastMapping\"\n                addMappingWithCode(lastMapping, shiftNextLine());\n                lastGeneratedLine++;\n                lastGeneratedColumn = 0;\n                // The remaining code is added without mapping\n              } else {\n                // There is no new line in between.\n                // Associate the code between \"lastGeneratedColumn\" and\n                // \"mapping.generatedColumn\" with \"lastMapping\"\n                var nextLine = remainingLines[0];\n                var code = nextLine.substr(0, mapping.generatedColumn -\n                lastGeneratedColumn);\n                remainingLines[0] = nextLine.substr(mapping.generatedColumn -\n                lastGeneratedColumn);\n                lastGeneratedColumn = mapping.generatedColumn;\n                addMappingWithCode(lastMapping, code);\n                // No more remaining code, continue\n                lastMapping = mapping;\n                return;\n              }\n            }\n            // We add the generated code until the first mapping\n            // to the SourceNode without any mapping.\n            // Each line is added as separate string.\n            while (lastGeneratedLine < mapping.generatedLine) {\n              node.add(shiftNextLine());\n              lastGeneratedLine++;\n            }\n            if (lastGeneratedColumn < mapping.generatedColumn) {\n              var nextLine = remainingLines[0];\n              node.add(nextLine.substr(0, mapping.generatedColumn));\n              remainingLines[0] = nextLine.substr(mapping.generatedColumn);\n              lastGeneratedColumn = mapping.generatedColumn;\n            }\n            lastMapping = mapping;\n          }, this);\n          // We have processed all mappings.\n          if (remainingLines.length > 0) {\n            if (lastMapping) {\n              // Associate the remaining code in the current line with \"lastMapping\"\n              addMappingWithCode(lastMapping, shiftNextLine());\n            }\n            // and add the remaining lines without any mapping\n            node.add(remainingLines.join(\"\"));\n          }\n\n          // Copy sourcesContent into SourceNode\n          aSourceMapConsumer.sources.forEach(function (sourceFile) {\n            var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n            if (content != null) {\n              if (aRelativePath != null) {\n                sourceFile = util.join(aRelativePath, sourceFile);\n              }\n              node.setSourceContent(sourceFile, content);\n            }\n          });\n\n          return node;\n\n          function addMappingWithCode(mapping, code) {\n            if (mapping === null || mapping.source === undefined) {\n              node.add(code);\n            } else {\n              var source = aRelativePath ?\n              util.join(aRelativePath, mapping.source) :\n              mapping.source;\n              node.add(new SourceNode(mapping.originalLine,\n              mapping.originalColumn,\n              source,\n              code,\n              mapping.name));\n            }\n          }\n        };\n\n        /**\n            * Add a chunk of generated JS to this source node.\n            *\n            * @param aChunk A string snippet of generated JS code, another instance of\n            *        SourceNode, or an array where each member is one of those things.\n            */\n        SourceNode.prototype.add = function SourceNode_add(aChunk) {\n          if (Array.isArray(aChunk)) {\n            aChunk.forEach(function (chunk) {\n              this.add(chunk);\n            }, this);\n          } else\n          if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n            if (aChunk) {\n              this.children.push(aChunk);\n            }\n          } else\n          {\n            throw new TypeError(\n            \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n\n          }\n          return this;\n        };\n\n        /**\n            * Add a chunk of generated JS to the beginning of this source node.\n            *\n            * @param aChunk A string snippet of generated JS code, another instance of\n            *        SourceNode, or an array where each member is one of those things.\n            */\n        SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n          if (Array.isArray(aChunk)) {\n            for (var i = aChunk.length - 1; i >= 0; i--) {\n              this.prepend(aChunk[i]);\n            }\n          } else\n          if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n            this.children.unshift(aChunk);\n          } else\n          {\n            throw new TypeError(\n            \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n\n          }\n          return this;\n        };\n\n        /**\n            * Walk over the tree of JS snippets in this node and its children. The\n            * walking function is called once for each snippet of JS and is passed that\n            * snippet and the its original associated source's line/column location.\n            *\n            * @param aFn The traversal function.\n            */\n        SourceNode.prototype.walk = function SourceNode_walk(aFn) {\n          var chunk;\n          for (var i = 0, len = this.children.length; i < len; i++) {\n            chunk = this.children[i];\n            if (chunk[isSourceNode]) {\n              chunk.walk(aFn);\n            } else\n            {\n              if (chunk !== '') {\n                aFn(chunk, { source: this.source,\n                  line: this.line,\n                  column: this.column,\n                  name: this.name });\n              }\n            }\n          }\n        };\n\n        /**\n            * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n            * each of `this.children`.\n            *\n            * @param aSep The separator.\n            */\n        SourceNode.prototype.join = function SourceNode_join(aSep) {\n          var newChildren;\n          var i;\n          var len = this.children.length;\n          if (len > 0) {\n            newChildren = [];\n            for (i = 0; i < len - 1; i++) {\n              newChildren.push(this.children[i]);\n              newChildren.push(aSep);\n            }\n            newChildren.push(this.children[i]);\n            this.children = newChildren;\n          }\n          return this;\n        };\n\n        /**\n            * Call String.prototype.replace on the very right-most source snippet. Useful\n            * for trimming whitespace from the end of a source node, etc.\n            *\n            * @param aPattern The pattern to replace.\n            * @param aReplacement The thing to replace the pattern with.\n            */\n        SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n          var lastChild = this.children[this.children.length - 1];\n          if (lastChild[isSourceNode]) {\n            lastChild.replaceRight(aPattern, aReplacement);\n          } else\n          if (typeof lastChild === 'string') {\n            this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n          } else\n          {\n            this.children.push(''.replace(aPattern, aReplacement));\n          }\n          return this;\n        };\n\n        /**\n            * Set the source content for a source file. This will be added to the SourceMapGenerator\n            * in the sourcesContent field.\n            *\n            * @param aSourceFile The filename of the source file\n            * @param aSourceContent The content of the source file\n            */\n        SourceNode.prototype.setSourceContent =\n        function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n          this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n        };\n\n        /**\n            * Walk over the tree of SourceNodes. The walking function is called for each\n            * source file content and is passed the filename and source content.\n            *\n            * @param aFn The traversal function.\n            */\n        SourceNode.prototype.walkSourceContents =\n        function SourceNode_walkSourceContents(aFn) {\n          for (var i = 0, len = this.children.length; i < len; i++) {\n            if (this.children[i][isSourceNode]) {\n              this.children[i].walkSourceContents(aFn);\n            }\n          }\n\n          var sources = Object.keys(this.sourceContents);\n          for (var i = 0, len = sources.length; i < len; i++) {\n            aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n          }\n        };\n\n        /**\n            * Return the string representation of this source node. Walks over the tree\n            * and concatenates all the various snippets together to one string.\n            */\n        SourceNode.prototype.toString = function SourceNode_toString() {\n          var str = \"\";\n          this.walk(function (chunk) {\n            str += chunk;\n          });\n          return str;\n        };\n\n        /**\n            * Returns the string representation of this source node along with a source\n            * map.\n            */\n        SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n          var generated = {\n            code: \"\",\n            line: 1,\n            column: 0 };\n\n          var map = new SourceMapGenerator(aArgs);\n          var sourceMappingActive = false;\n          var lastOriginalSource = null;\n          var lastOriginalLine = null;\n          var lastOriginalColumn = null;\n          var lastOriginalName = null;\n          this.walk(function (chunk, original) {\n            generated.code += chunk;\n            if (original.source !== null &&\n            original.line !== null &&\n            original.column !== null) {\n              if (lastOriginalSource !== original.source ||\n              lastOriginalLine !== original.line ||\n              lastOriginalColumn !== original.column ||\n              lastOriginalName !== original.name) {\n                map.addMapping({\n                  source: original.source,\n                  original: {\n                    line: original.line,\n                    column: original.column },\n\n                  generated: {\n                    line: generated.line,\n                    column: generated.column },\n\n                  name: original.name });\n\n              }\n              lastOriginalSource = original.source;\n              lastOriginalLine = original.line;\n              lastOriginalColumn = original.column;\n              lastOriginalName = original.name;\n              sourceMappingActive = true;\n            } else if (sourceMappingActive) {\n              map.addMapping({\n                generated: {\n                  line: generated.line,\n                  column: generated.column } });\n\n\n              lastOriginalSource = null;\n              sourceMappingActive = false;\n            }\n            for (var idx = 0, length = chunk.length; idx < length; idx++) {\n              if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n                generated.line++;\n                generated.column = 0;\n                // Mappings end at eol\n                if (idx + 1 === length) {\n                  lastOriginalSource = null;\n                  sourceMappingActive = false;\n                } else if (sourceMappingActive) {\n                  map.addMapping({\n                    source: original.source,\n                    original: {\n                      line: original.line,\n                      column: original.column },\n\n                    generated: {\n                      line: generated.line,\n                      column: generated.column },\n\n                    name: original.name });\n\n                }\n              } else {\n                generated.column++;\n              }\n            }\n          });\n          this.walkSourceContents(function (sourceFile, sourceContent) {\n            map.setSourceContent(sourceFile, sourceContent);\n          });\n\n          return { code: generated.code, map: map };\n        };\n\n        exports.SourceNode = SourceNode;\n\n      });\n\n    }, { \"./source-map-generator\": 54, \"./util\": 56, \"amdefine\": 1 }], 56: [function (require, module, exports) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n      /*\n                                                   * Copyright 2011 Mozilla Foundation and contributors\n                                                   * Licensed under the New BSD license. See LICENSE or:\n                                                   * http://opensource.org/licenses/BSD-3-Clause\n                                                   */\n      if (typeof define !== 'function') {\n        var define = require('amdefine')(module, require);\n      }\n      define(function (require, exports, module) {\n\n        /**\n                                                   * This is a helper function for getting values from parameter/options\n                                                   * objects.\n                                                   *\n                                                   * @param args The object we are extracting values from\n                                                   * @param name The name of the property we are getting.\n                                                   * @param defaultValue An optional value to return if the property is missing\n                                                   * from the object. If this is not specified and the property is missing, an\n                                                   * error will be thrown.\n                                                   */\n        function getArg(aArgs, aName, aDefaultValue) {\n          if (aName in aArgs) {\n            return aArgs[aName];\n          } else if (arguments.length === 3) {\n            return aDefaultValue;\n          } else {\n            throw new Error('\"' + aName + '\" is a required argument.');\n          }\n        }\n        exports.getArg = getArg;\n\n        var urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\n        var dataUrlRegexp = /^data:.+\\,.+$/;\n\n        function urlParse(aUrl) {\n          var match = aUrl.match(urlRegexp);\n          if (!match) {\n            return null;\n          }\n          return {\n            scheme: match[1],\n            auth: match[2],\n            host: match[3],\n            port: match[4],\n            path: match[5] };\n\n        }\n        exports.urlParse = urlParse;\n\n        function urlGenerate(aParsedUrl) {\n          var url = '';\n          if (aParsedUrl.scheme) {\n            url += aParsedUrl.scheme + ':';\n          }\n          url += '//';\n          if (aParsedUrl.auth) {\n            url += aParsedUrl.auth + '@';\n          }\n          if (aParsedUrl.host) {\n            url += aParsedUrl.host;\n          }\n          if (aParsedUrl.port) {\n            url += \":\" + aParsedUrl.port;\n          }\n          if (aParsedUrl.path) {\n            url += aParsedUrl.path;\n          }\n          return url;\n        }\n        exports.urlGenerate = urlGenerate;\n\n        /**\n                                            * Normalizes a path, or the path portion of a URL:\n                                            *\n                                            * - Replaces consequtive slashes with one slash.\n                                            * - Removes unnecessary '.' parts.\n                                            * - Removes unnecessary '<dir>/..' parts.\n                                            *\n                                            * Based on code in the Node.js 'path' core module.\n                                            *\n                                            * @param aPath The path or url to normalize.\n                                            */\n        function normalize(aPath) {\n          var path = aPath;\n          var url = urlParse(aPath);\n          if (url) {\n            if (!url.path) {\n              return aPath;\n            }\n            path = url.path;\n          }\n          var isAbsolute = path.charAt(0) === '/';\n\n          var parts = path.split(/\\/+/);\n          for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n            part = parts[i];\n            if (part === '.') {\n              parts.splice(i, 1);\n            } else if (part === '..') {\n              up++;\n            } else if (up > 0) {\n              if (part === '') {\n                // The first part is blank if the path is absolute. Trying to go\n                // above the root is a no-op. Therefore we can remove all '..' parts\n                // directly after the root.\n                parts.splice(i + 1, up);\n                up = 0;\n              } else {\n                parts.splice(i, 2);\n                up--;\n              }\n            }\n          }\n          path = parts.join('/');\n\n          if (path === '') {\n            path = isAbsolute ? '/' : '.';\n          }\n\n          if (url) {\n            url.path = path;\n            return urlGenerate(url);\n          }\n          return path;\n        }\n        exports.normalize = normalize;\n\n        /**\n                                        * Joins two paths/URLs.\n                                        *\n                                        * @param aRoot The root path or URL.\n                                        * @param aPath The path or URL to be joined with the root.\n                                        *\n                                        * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n                                        *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n                                        *   first.\n                                        * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n                                        *   is updated with the result and aRoot is returned. Otherwise the result\n                                        *   is returned.\n                                        *   - If aPath is absolute, the result is aPath.\n                                        *   - Otherwise the two paths are joined with a slash.\n                                        * - Joining for example 'http://' and 'www.example.com' is also supported.\n                                        */\n        function join(aRoot, aPath) {\n          if (aRoot === \"\") {\n            aRoot = \".\";\n          }\n          if (aPath === \"\") {\n            aPath = \".\";\n          }\n          var aPathUrl = urlParse(aPath);\n          var aRootUrl = urlParse(aRoot);\n          if (aRootUrl) {\n            aRoot = aRootUrl.path || '/';\n          }\n\n          // `join(foo, '//www.example.org')`\n          if (aPathUrl && !aPathUrl.scheme) {\n            if (aRootUrl) {\n              aPathUrl.scheme = aRootUrl.scheme;\n            }\n            return urlGenerate(aPathUrl);\n          }\n\n          if (aPathUrl || aPath.match(dataUrlRegexp)) {\n            return aPath;\n          }\n\n          // `join('http://', 'www.example.com')`\n          if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n            aRootUrl.host = aPath;\n            return urlGenerate(aRootUrl);\n          }\n\n          var joined = aPath.charAt(0) === '/' ?\n          aPath :\n          normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n          if (aRootUrl) {\n            aRootUrl.path = joined;\n            return urlGenerate(aRootUrl);\n          }\n          return joined;\n        }\n        exports.join = join;\n\n        /**\n                              * Make a path relative to a URL or another path.\n                              *\n                              * @param aRoot The root path or URL.\n                              * @param aPath The path or URL to be made relative to aRoot.\n                              */\n        function relative(aRoot, aPath) {\n          if (aRoot === \"\") {\n            aRoot = \".\";\n          }\n\n          aRoot = aRoot.replace(/\\/$/, '');\n\n          // It is possible for the path to be above the root. In this case, simply\n          // checking whether the root is a prefix of the path won't work. Instead, we\n          // need to remove components from the root one by one, until either we find\n          // a prefix that fits, or we run out of components to remove.\n          var level = 0;\n          while (aPath.indexOf(aRoot + '/') !== 0) {\n            var index = aRoot.lastIndexOf(\"/\");\n            if (index < 0) {\n              return aPath;\n            }\n\n            // If the only part of the root that is left is the scheme (i.e. http://,\n            // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n            // have exhausted all components, so the path is not relative to the root.\n            aRoot = aRoot.slice(0, index);\n            if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n              return aPath;\n            }\n\n            ++level;\n          }\n\n          // Make sure we add a \"../\" for each component we removed from the root.\n          return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n        }\n        exports.relative = relative;\n\n        /**\n                                      * Because behavior goes wacky when you set `__proto__` on objects, we\n                                      * have to prefix all the strings in our set with an arbitrary character.\n                                      *\n                                      * See https://github.com/mozilla/source-map/pull/31 and\n                                      * https://github.com/mozilla/source-map/issues/30\n                                      *\n                                      * @param String aStr\n                                      */\n        function toSetString(aStr) {\n          return '$' + aStr;\n        }\n        exports.toSetString = toSetString;\n\n        function fromSetString(aStr) {\n          return aStr.substr(1);\n        }\n        exports.fromSetString = fromSetString;\n\n        /**\n                                                * Comparator between two mappings where the original positions are compared.\n                                                *\n                                                * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n                                                * mappings with the same original source/line/column, but different generated\n                                                * line and column the same. Useful when searching for a mapping with a\n                                                * stubbed out mapping.\n                                                */\n        function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n          var cmp = mappingA.source - mappingB.source;\n          if (cmp !== 0) {\n            return cmp;\n          }\n\n          cmp = mappingA.originalLine - mappingB.originalLine;\n          if (cmp !== 0) {\n            return cmp;\n          }\n\n          cmp = mappingA.originalColumn - mappingB.originalColumn;\n          if (cmp !== 0 || onlyCompareOriginal) {\n            return cmp;\n          }\n\n          cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n          if (cmp !== 0) {\n            return cmp;\n          }\n\n          cmp = mappingA.generatedLine - mappingB.generatedLine;\n          if (cmp !== 0) {\n            return cmp;\n          }\n\n          return mappingA.name - mappingB.name;\n        };\n        exports.compareByOriginalPositions = compareByOriginalPositions;\n\n        /**\n                                                                          * Comparator between two mappings with deflated source and name indices where\n                                                                          * the generated positions are compared.\n                                                                          *\n                                                                          * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n                                                                          * mappings with the same generated line and column, but different\n                                                                          * source/name/original line and column the same. Useful when searching for a\n                                                                          * mapping with a stubbed out mapping.\n                                                                          */\n        function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n          var cmp = mappingA.generatedLine - mappingB.generatedLine;\n          if (cmp !== 0) {\n            return cmp;\n          }\n\n          cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n          if (cmp !== 0 || onlyCompareGenerated) {\n            return cmp;\n          }\n\n          cmp = mappingA.source - mappingB.source;\n          if (cmp !== 0) {\n            return cmp;\n          }\n\n          cmp = mappingA.originalLine - mappingB.originalLine;\n          if (cmp !== 0) {\n            return cmp;\n          }\n\n          cmp = mappingA.originalColumn - mappingB.originalColumn;\n          if (cmp !== 0) {\n            return cmp;\n          }\n\n          return mappingA.name - mappingB.name;\n        };\n        exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\n        function strcmp(aStr1, aStr2) {\n          if (aStr1 === aStr2) {\n            return 0;\n          }\n\n          if (aStr1 > aStr2) {\n            return 1;\n          }\n\n          return -1;\n        }\n\n        /**\n           * Comparator between two mappings with inflated source and name strings where\n           * the generated positions are compared.\n           */\n        function compareByGeneratedPositionsInflated(mappingA, mappingB) {\n          var cmp = mappingA.generatedLine - mappingB.generatedLine;\n          if (cmp !== 0) {\n            return cmp;\n          }\n\n          cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n          if (cmp !== 0) {\n            return cmp;\n          }\n\n          cmp = strcmp(mappingA.source, mappingB.source);\n          if (cmp !== 0) {\n            return cmp;\n          }\n\n          cmp = mappingA.originalLine - mappingB.originalLine;\n          if (cmp !== 0) {\n            return cmp;\n          }\n\n          cmp = mappingA.originalColumn - mappingB.originalColumn;\n          if (cmp !== 0) {\n            return cmp;\n          }\n\n          return strcmp(mappingA.name, mappingB.name);\n        };\n        exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n      });\n\n    }, { \"amdefine\": 1 }], 57: [function (require, module, exports) {\n      (function (self) {\n        'use strict';\n\n        if (self.fetch) {\n          return;\n        }\n\n        var support = {\n          searchParams: 'URLSearchParams' in self,\n          iterable: 'Symbol' in self && 'iterator' in Symbol,\n          blob: 'FileReader' in self && 'Blob' in self && function () {\n            try {\n              new Blob();\n              return true;\n            } catch (e) {\n              return false;\n            }\n          }(),\n          formData: 'FormData' in self,\n          arrayBuffer: 'ArrayBuffer' in self };\n\n\n        if (support.arrayBuffer) {\n          var viewClasses = [\n          '[object Int8Array]',\n          '[object Uint8Array]',\n          '[object Uint8ClampedArray]',\n          '[object Int16Array]',\n          '[object Uint16Array]',\n          '[object Int32Array]',\n          '[object Uint32Array]',\n          '[object Float32Array]',\n          '[object Float64Array]'];\n\n\n          var isDataView = function isDataView(obj) {\n            return obj && DataView.prototype.isPrototypeOf(obj);\n          };\n\n          var isArrayBufferView = ArrayBuffer.isView || function (obj) {\n            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;\n          };\n        }\n\n        function normalizeName(name) {\n          if (typeof name !== 'string') {\n            name = String(name);\n          }\n          if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n            throw new TypeError('Invalid character in header field name');\n          }\n          return name.toLowerCase();\n        }\n\n        function normalizeValue(value) {\n          if (typeof value !== 'string') {\n            value = String(value);\n          }\n          return value;\n        }\n\n        // Build a destructive iterator for the value list\n        function iteratorFor(items) {\n          var iterator = {\n            next: function next() {\n              var value = items.shift();\n              return { done: value === undefined, value: value };\n            } };\n\n\n          if (support.iterable) {\n            iterator[Symbol.iterator] = function () {\n              return iterator;\n            };\n          }\n\n          return iterator;\n        }\n\n        function Headers(headers) {\n          this.map = {};\n\n          if (headers instanceof Headers) {\n            headers.forEach(function (value, name) {\n              this.append(name, value);\n            }, this);\n\n          } else if (headers) {\n            Object.getOwnPropertyNames(headers).forEach(function (name) {\n              this.append(name, headers[name]);\n            }, this);\n          }\n        }\n\n        Headers.prototype.append = function (name, value) {\n          name = normalizeName(name);\n          value = normalizeValue(value);\n          var list = this.map[name];\n          if (!list) {\n            list = [];\n            this.map[name] = list;\n          }\n          list.push(value);\n        };\n\n        Headers.prototype['delete'] = function (name) {\n          delete this.map[normalizeName(name)];\n        };\n\n        Headers.prototype.get = function (name) {\n          var values = this.map[normalizeName(name)];\n          return values ? values[0] : null;\n        };\n\n        Headers.prototype.getAll = function (name) {\n          return this.map[normalizeName(name)] || [];\n        };\n\n        Headers.prototype.has = function (name) {\n          return this.map.hasOwnProperty(normalizeName(name));\n        };\n\n        Headers.prototype.set = function (name, value) {\n          this.map[normalizeName(name)] = [normalizeValue(value)];\n        };\n\n        Headers.prototype.forEach = function (callback, thisArg) {\n          Object.getOwnPropertyNames(this.map).forEach(function (name) {\n            this.map[name].forEach(function (value) {\n              callback.call(thisArg, value, name, this);\n            }, this);\n          }, this);\n        };\n\n        Headers.prototype.keys = function () {\n          var items = [];\n          this.forEach(function (value, name) {items.push(name);});\n          return iteratorFor(items);\n        };\n\n        Headers.prototype.values = function () {\n          var items = [];\n          this.forEach(function (value) {items.push(value);});\n          return iteratorFor(items);\n        };\n\n        Headers.prototype.entries = function () {\n          var items = [];\n          this.forEach(function (value, name) {items.push([name, value]);});\n          return iteratorFor(items);\n        };\n\n        if (support.iterable) {\n          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n        }\n\n        function consumed(body) {\n          if (body.bodyUsed) {\n            return Promise.reject(new TypeError('Already read'));\n          }\n          body.bodyUsed = true;\n        }\n\n        function fileReaderReady(reader) {\n          return new Promise(function (resolve, reject) {\n            reader.onload = function () {\n              resolve(reader.result);\n            };\n            reader.onerror = function () {\n              reject(reader.error);\n            };\n          });\n        }\n\n        function readBlobAsArrayBuffer(blob) {\n          var reader = new FileReader();\n          var promise = fileReaderReady(reader);\n          reader.readAsArrayBuffer(blob);\n          return promise;\n        }\n\n        function readBlobAsText(blob) {\n          var reader = new FileReader();\n          var promise = fileReaderReady(reader);\n          reader.readAsText(blob);\n          return promise;\n        }\n\n        function readArrayBufferAsText(buf) {\n          var view = new Uint8Array(buf);\n          var chars = new Array(view.length);\n\n          for (var i = 0; i < view.length; i++) {\n            chars[i] = String.fromCharCode(view[i]);\n          }\n          return chars.join('');\n        }\n\n        function bufferClone(buf) {\n          if (buf.slice) {\n            return buf.slice(0);\n          } else {\n            var view = new Uint8Array(buf.byteLength);\n            view.set(new Uint8Array(buf));\n            return view.buffer;\n          }\n        }\n\n        function Body() {\n          this.bodyUsed = false;\n\n          this._initBody = function (body) {\n            this._bodyInit = body;\n            if (!body) {\n              this._bodyText = '';\n            } else if (typeof body === 'string') {\n              this._bodyText = body;\n            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n              this._bodyBlob = body;\n            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n              this._bodyFormData = body;\n            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n              this._bodyText = body.toString();\n            } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n              this._bodyArrayBuffer = bufferClone(body.buffer);\n              // IE 10-11 can't handle a DataView body.\n              this._bodyInit = new Blob([this._bodyArrayBuffer]);\n            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n              this._bodyArrayBuffer = bufferClone(body);\n            } else {\n              throw new Error('unsupported BodyInit type');\n            }\n\n            if (!this.headers.get('content-type')) {\n              if (typeof body === 'string') {\n                this.headers.set('content-type', 'text/plain;charset=UTF-8');\n              } else if (this._bodyBlob && this._bodyBlob.type) {\n                this.headers.set('content-type', this._bodyBlob.type);\n              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n                this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n              }\n            }\n          };\n\n          if (support.blob) {\n            this.blob = function () {\n              var rejected = consumed(this);\n              if (rejected) {\n                return rejected;\n              }\n\n              if (this._bodyBlob) {\n                return Promise.resolve(this._bodyBlob);\n              } else if (this._bodyArrayBuffer) {\n                return Promise.resolve(new Blob([this._bodyArrayBuffer]));\n              } else if (this._bodyFormData) {\n                throw new Error('could not read FormData body as blob');\n              } else {\n                return Promise.resolve(new Blob([this._bodyText]));\n              }\n            };\n\n            this.arrayBuffer = function () {\n              if (this._bodyArrayBuffer) {\n                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);\n              } else {\n                return this.blob().then(readBlobAsArrayBuffer);\n              }\n            };\n          }\n\n          this.text = function () {\n            var rejected = consumed(this);\n            if (rejected) {\n              return rejected;\n            }\n\n            if (this._bodyBlob) {\n              return readBlobAsText(this._bodyBlob);\n            } else if (this._bodyArrayBuffer) {\n              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));\n            } else if (this._bodyFormData) {\n              throw new Error('could not read FormData body as text');\n            } else {\n              return Promise.resolve(this._bodyText);\n            }\n          };\n\n          if (support.formData) {\n            this.formData = function () {\n              return this.text().then(decode);\n            };\n          }\n\n          this.json = function () {\n            return this.text().then(JSON.parse);\n          };\n\n          return this;\n        }\n\n        // HTTP methods whose capitalization should be normalized\n        var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n        function normalizeMethod(method) {\n          var upcased = method.toUpperCase();\n          return methods.indexOf(upcased) > -1 ? upcased : method;\n        }\n\n        function Request(input, options) {\n          options = options || {};\n          var body = options.body;\n\n          if (typeof input === 'string') {\n            this.url = input;\n          } else {\n            if (input.bodyUsed) {\n              throw new TypeError('Already read');\n            }\n            this.url = input.url;\n            this.credentials = input.credentials;\n            if (!options.headers) {\n              this.headers = new Headers(input.headers);\n            }\n            this.method = input.method;\n            this.mode = input.mode;\n            if (!body && input._bodyInit != null) {\n              body = input._bodyInit;\n              input.bodyUsed = true;\n            }\n          }\n\n          this.credentials = options.credentials || this.credentials || 'omit';\n          if (options.headers || !this.headers) {\n            this.headers = new Headers(options.headers);\n          }\n          this.method = normalizeMethod(options.method || this.method || 'GET');\n          this.mode = options.mode || this.mode || null;\n          this.referrer = null;\n\n          if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n            throw new TypeError('Body not allowed for GET or HEAD requests');\n          }\n          this._initBody(body);\n        }\n\n        Request.prototype.clone = function () {\n          return new Request(this, { body: this._bodyInit });\n        };\n\n        function decode(body) {\n          var form = new FormData();\n          body.trim().split('&').forEach(function (bytes) {\n            if (bytes) {\n              var split = bytes.split('=');\n              var name = split.shift().replace(/\\+/g, ' ');\n              var value = split.join('=').replace(/\\+/g, ' ');\n              form.append(decodeURIComponent(name), decodeURIComponent(value));\n            }\n          });\n          return form;\n        }\n\n        function parseHeaders(rawHeaders) {\n          var headers = new Headers();\n          rawHeaders.split('\\r\\n').forEach(function (line) {\n            var parts = line.split(':');\n            var key = parts.shift().trim();\n            if (key) {\n              var value = parts.join(':').trim();\n              headers.append(key, value);\n            }\n          });\n          return headers;\n        }\n\n        Body.call(Request.prototype);\n\n        function Response(bodyInit, options) {\n          if (!options) {\n            options = {};\n          }\n\n          this.type = 'default';\n          this.status = 'status' in options ? options.status : 200;\n          this.ok = this.status >= 200 && this.status < 300;\n          this.statusText = 'statusText' in options ? options.statusText : 'OK';\n          this.headers = new Headers(options.headers);\n          this.url = options.url || '';\n          this._initBody(bodyInit);\n        }\n\n        Body.call(Response.prototype);\n\n        Response.prototype.clone = function () {\n          return new Response(this._bodyInit, {\n            status: this.status,\n            statusText: this.statusText,\n            headers: new Headers(this.headers),\n            url: this.url });\n\n        };\n\n        Response.error = function () {\n          var response = new Response(null, { status: 0, statusText: '' });\n          response.type = 'error';\n          return response;\n        };\n\n        var redirectStatuses = [301, 302, 303, 307, 308];\n\n        Response.redirect = function (url, status) {\n          if (redirectStatuses.indexOf(status) === -1) {\n            throw new RangeError('Invalid status code');\n          }\n\n          return new Response(null, { status: status, headers: { location: url } });\n        };\n\n        self.Headers = Headers;\n        self.Request = Request;\n        self.Response = Response;\n\n        self.fetch = function (input, init) {\n          return new Promise(function (resolve, reject) {\n            var request = new Request(input, init);\n            var xhr = new XMLHttpRequest();\n\n            xhr.onload = function () {\n              var options = {\n                status: xhr.status,\n                statusText: xhr.statusText,\n                headers: parseHeaders(xhr.getAllResponseHeaders() || '') };\n\n              options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n              var body = 'response' in xhr ? xhr.response : xhr.responseText;\n              resolve(new Response(body, options));\n            };\n\n            xhr.onerror = function () {\n              reject(new TypeError('Network request failed'));\n            };\n\n            xhr.ontimeout = function () {\n              reject(new TypeError('Network request failed'));\n            };\n\n            xhr.open(request.method, request.url, true);\n\n            if (request.credentials === 'include') {\n              xhr.withCredentials = true;\n            }\n\n            if ('responseType' in xhr && support.blob) {\n              xhr.responseType = 'blob';\n            }\n\n            request.headers.forEach(function (value, name) {\n              xhr.setRequestHeader(name, value);\n            });\n\n            xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n          });\n        };\n        self.fetch.polyfill = true;\n      })(typeof self !== 'undefined' ? self : this);\n\n    }, {}], 58: [function (require, module, exports) {\n      'use strict';\n\n      /**\n                     * A callback function that fires after the left arrow is clicked\n                     * @callback CarouselArrows~onLeftArrowClick\n                     */\n\n      /**\n                         * A callback function that fires after the right arrow is clicked\n                         * @callback CarouselArrows~onRightArrowClick\n                         */\n\n      /**\n                             * Adds functionality for carousel's left and right arrows.\n                             * @constructor CarouselArrows\n                             */\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true });\n\n\n      var _extends = Object.assign || function (target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i];for (var key in source) {if (Object.prototype.hasOwnProperty.call(source, key)) {target[key] = source[key];}}}return target;};\n\n      var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();\n\n      function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}\n\n      var CarouselArrows = function () {\n\n        /**\n                                         * When the carousel is instantiated.\n                                         * @param {object} options - Options passed into instance\n                                         * @param {HTMLElement} options.leftArrow - The html element to use as the left arrow\n                                         * @param {HTMLElement} options.rightArrow - The html element to use as the right arrow\n                                         * @param {HTMLCollection} options.panels - The carousel panel elements that to be associated with the arrows\n                                         * @param {string} [options.arrowDisabledClass] - The CSS class that gets added to an arrow when it becomes disabled\n                                         * @param {CarouselArrows~onLeftArrowClick} [options.onLeftArrowClick] - When the left arrow is clicked\n                                         * @param {CarouselArrows~onRightArrowClick} [options.onRightArrowClick] - When the right arrow is clicked\n                                         */\n        function CarouselArrows(options) {\n          var _this = this;\n\n          _classCallCheck(this, CarouselArrows);\n\n          options = _extends({\n            leftArrow: null,\n            rightArrow: null,\n            panels: [],\n            arrowDisabledClass: 'carousel-arrow-disabled',\n            onLeftArrowClick: null,\n            onRightArrowClick: null,\n            initialIndex: 0 },\n          options);\n\n          if (!options.leftArrow && !options.rightArrow) {\n            console.error('Carousel Arrows Error: no left and right arrows were passed into constructor');\n          }\n\n          this.options = options;\n\n          this.arrows = [];\n\n          // setup listeners\n          if (options.leftArrow) {\n            this.arrows.push(options.leftArrow);\n            this._leftArrowEventListener = function (e) {\n              return _this.onLeftArrowClick(e);\n            };\n            options.leftArrow.addEventListener('click', this._leftArrowEventListener);\n          }\n\n          if (options.rightArrow) {\n            this.arrows.push(options.rightArrow);\n            this._rightArrowEventListener = function (e) {\n              return _this.onRightArrowClick(e);\n            };\n            options.rightArrow.addEventListener('click', this._rightArrowEventListener);\n          }\n        }\n\n        /**\n           * Updates the arrow based on the supplied panel index.\n           * @param {Number} panelIndex - The new panel index\n           */\n\n\n        _createClass(CarouselArrows, [{\n          key: 'update',\n          value: function update(panelIndex) {\n            var currentItemNum = panelIndex + 1,\n            maxItems = this.options.panels.length,\n            minItems = 1;\n\n            if (currentItemNum < maxItems && currentItemNum > minItems) {\n              // not on first or last item\n              this.enable();\n            } else if (currentItemNum === maxItems && currentItemNum === minItems) {\n              // on the only panel available\n              this.disable();\n            } else if (currentItemNum === maxItems) {\n              // on last item\n              this.disableRightArrow();\n              this.enableLeftArrow();\n            } else if (currentItemNum === minItems) {\n              // on first item\n              this.disableLeftArrow();\n              this.enableRightArrow();\n            }\n          }\n\n          /**\n             * Disables all arrows\n             */ },\n\n        {\n          key: 'disable',\n          value: function disable() {\n            this.disableLeftArrow();\n            this.disableRightArrow();\n          }\n\n          /**\n             * Disables left arrow.\n             */ },\n\n        {\n          key: 'disableLeftArrow',\n          value: function disableLeftArrow() {\n            if (this.options.leftArrow) {\n              this.options.leftArrow.classList.add(this.options.arrowDisabledClass);\n            }\n          }\n\n          /**\n             * Disables right arrow.\n             */ },\n\n        {\n          key: 'disableRightArrow',\n          value: function disableRightArrow() {\n            if (this.options.rightArrow) {\n              this.options.rightArrow.classList.add(this.options.arrowDisabledClass);\n            }\n          }\n\n          /**\n             * Re-enables all arrows.\n             */ },\n\n        {\n          key: 'enable',\n          value: function enable() {\n            this.enableLeftArrow();\n            this.enableRightArrow();\n          }\n\n          /**\n             * Re-enables left arrow.\n             */ },\n\n        {\n          key: 'enableLeftArrow',\n          value: function enableLeftArrow() {\n            if (this.options.leftArrow) {\n              this.options.leftArrow.classList.remove(this.options.arrowDisabledClass);\n            }\n          }\n\n          /**\n             * Re-enables right arrow.\n             */ },\n\n        {\n          key: 'enableRightArrow',\n          value: function enableRightArrow() {\n            if (this.options.rightArrow) {\n              this.options.rightArrow.classList.remove(this.options.arrowDisabledClass);\n            }\n          }\n\n          /**\n             * When the left arrow is clicked.\n             * @param {Event} e\n             */ },\n\n        {\n          key: 'onLeftArrowClick',\n          value: function onLeftArrowClick(e) {\n            var isDisabled = this.options.leftArrow.classList.contains(this.options.arrowDisabledClass);\n            if (this.options.onLeftArrowClick && !isDisabled) {\n              this.options.onLeftArrowClick(e);\n            }\n          }\n\n          /**\n             * When the right arrow is clicked.\n             * @param {Event} e\n             */ },\n\n        {\n          key: 'onRightArrowClick',\n          value: function onRightArrowClick(e) {\n            var isDisabled = this.options.rightArrow.classList.contains(this.options.arrowDisabledClass);\n            if (this.options.onRightArrowClick && !isDisabled) {\n              this.options.onRightArrowClick(e);\n            }\n          }\n\n          /**\n             * Final cleanup of instance.\n             * @memberOf CarouselArrows\n             */ },\n\n        {\n          key: 'destroy',\n          value: function destroy() {\n            if (this.options.leftArrow) {\n              this.options.leftArrow.removeEventListener('click', this._leftArrowEventListener);\n            }\n\n            if (this.options.rightArrow) {\n              this.options.rightArrow.removeEventListener('click', this._rightArrowEventListener);\n            }\n          } }]);\n\n\n        return CarouselArrows;\n      }();\n\n      exports.default = CarouselArrows;\n\n      module.exports = exports['default'];\n\n    }, {}], 59: [function (require, module, exports) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true });\n\n\n      var _extends = Object.assign || function (target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i];for (var key in source) {if (Object.prototype.hasOwnProperty.call(source, key)) {target[key] = source[key];}}}return target;};\n\n      var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();\n\n      var _get = function get(object, property, receiver) {if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {var parent = Object.getPrototypeOf(object);if (parent === null) {return undefined;} else {return get(parent, property, receiver);}} else if (\"value\" in desc) {return desc.value;} else {var getter = desc.get;if (getter === undefined) {return undefined;}return getter.call(receiver);}};\n\n      var _promise = require('promise');\n\n      var _promise2 = _interopRequireDefault(_promise);\n\n      var _moduleJs = require('module-js');\n\n      var _moduleJs2 = _interopRequireDefault(_moduleJs);\n\n      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}\n\n      function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}\n\n      function _possibleConstructorReturn(self, call) {if (!self) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call && ((typeof call === \"undefined\" ? \"undefined\" : _typeof2(call)) === \"object\" || typeof call === \"function\") ? call : self;}\n\n      function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : _typeof2(superClass)));}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;}\n\n      var CarouselPanel = function (_Module) {\n        _inherits(CarouselPanel, _Module);\n\n        /**\n                                            * Sets some stuff up.\n                                            * @param {HTMLElement} el - The element that represents a panel.\n                                            * @param {Object} options - The options\n                                            * @param {String} [options.activeClass] - The css class that gets applied when the module is showing\n                                            * @param {String} [options.assetLoadedClass] - The css class that gets added when the asset has been loaded\n                                            * @param {String} [options.lazyLoadAttr] - The lazy loading attribute of the panel element containing the src to load\n                                            */\n        function CarouselPanel(el, options) {\n          _classCallCheck(this, CarouselPanel);\n\n          options = _extends({\n            activeClass: 'carousel-panel-active',\n            lazyLoadAttr: null,\n            loadedClass: 'carousel-panel-loaded',\n            assetLoadedClass: 'carousel-panel-asset-loaded' },\n          options);\n\n          var _this = _possibleConstructorReturn(this, (CarouselPanel.__proto__ || Object.getPrototypeOf(CarouselPanel)).call(this, el, options));\n\n          _this.options = options;\n          _this.el = el;\n          return _this;\n        }\n\n        /**\n           * Loads all lazy-loadable images within the panel.\n           * @returns {Promise}\n           */\n\n\n        _createClass(CarouselPanel, [{\n          key: 'load',\n          value: function load() {\n            var _this2 = this;\n\n            var loadPromises = [];\n            this._loadableImages().forEach(function (imgEl) {\n              var loadedClass = _this2.options.assetLoadedClass;\n              var promise = _this2._loadImage(imgEl).then(function () {\n                _this2.el.classList.add(loadedClass);\n              });\n              loadPromises.push(promise);\n            });\n\n            return _get(CarouselPanel.prototype.__proto__ || Object.getPrototypeOf(CarouselPanel.prototype), 'load', this).call(this).then(function () {\n              return _promise2.default.all(loadPromises);\n            });\n          }\n\n          /**\n             * Gets the live set of loadable image elements within the panel (or the panel itself if it is an <img>).\n             * @returns {Array}\n             * @private\n             */ },\n\n        {\n          key: '_loadableImages',\n          value: function _loadableImages() {\n            // if panel has lazy load attribute,  add to loadable assets\n            if (this.el.tagName.toLowerCase() === 'img' && this.el.getAttribute(this.options.lazyLoadAttr)) {\n              return [this.el];\n            } else {\n              return Array.prototype.slice.call(this.el.querySelectorAll('img[' + this.options.lazyLoadAttr + ']'));\n            }\n          }\n\n          /**\n             * Manually lazy loads a resource using an element's data attribute.\n             * @param {HTMLImageElement} img - The image element to load\n             * @private\n             */ },\n\n        {\n          key: '_loadImage',\n          value: function _loadImage(img) {\n            var src = img.getAttribute(this.options.lazyLoadAttr);\n            return new _promise2.default(function (resolve) {\n              img.onload = function () {\n                resolve(img);\n              };\n              img.onerror = function () {\n                // IE 9-11 have an issue where it automatically triggers an error on some images,\n                // and then will immediately trigger onload() causing intermittent errors to appear\n                // until this is fixed or we have a workaround, we will be resolving\n                // even if there is an error\n                resolve(img);\n              };\n              img.src = src;\n            });\n          } }]);\n\n\n        return CarouselPanel;\n      }(_moduleJs2.default);\n\n      exports.default = CarouselPanel;\n\n      module.exports = exports['default'];\n\n    }, { \"module-js\": 37, \"promise\": 38 }], 60: [function (require, module, exports) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true });\n\n\n      var _extends = Object.assign || function (target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i];for (var key in source) {if (Object.prototype.hasOwnProperty.call(source, key)) {target[key] = source[key];}}}return target;};\n\n      var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();\n\n      var _promise = require('promise');\n\n      var _promise2 = _interopRequireDefault(_promise);\n\n      var _carouselPanel = require('./carousel-panel');\n\n      var _carouselPanel2 = _interopRequireDefault(_carouselPanel);\n\n      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}\n\n      function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}\n\n      /**\n                                                                                                                                                             * A callback function that fires after a new active panel is set\n                                                                                                                                                             * @callback CarouselPanels~onChange\n                                                                                                                                                             * @param {Number} index - The index of the new panel\n                                                                                                                                                             */\n\n      /**\n                                                                                                                                                                 * Adds functionality for carousel panels. Not really meant to be used own its own, unless you want\n                                                                                                                                                                 * to customize the the javascript logic for the \"panels\" of the Carousel (assuming that you actually\n                                                                                                                                                                 * know what you're doing when you do so).\n                                                                                                                                                                 * @constructor CarouselPanels\n                                                                                                                                                                 */\n      var CarouselPanels = function () {\n\n        /**\n                                         * When the carousel is instantiated.\n                                         * @param {object} options - Options passed into instance\n                                         * @param {HTMLCollection|NodeList} options.panels - The panels in which to use for the carousel (an array of photos)\n                                         * @param {string} [options.assetLoadedClass] - The CSS class that gets added to a panel el when it is loaded\n                                         * @param {string} [options.panelActiveClass] - The CSS class that gets added to an panel when it becomes active\n                                         * @param {string} [options.panelBackClass] - The CSS class that gets added to all panel elements that appear before the current panel\n                                         * @param {string} [options.panelForwardClass] - The CSS class that gets added to all panel elements that appear ahead of the current panel\n                                         * @param {CarouselPanels~onChange} [options.onChange] - When the current panel is changed\n                                         * @param {string} [options.lazyLoadAttr] - The lazy loading attribute\n                                         */\n        function CarouselPanels(options) {\n          _classCallCheck(this, CarouselPanels);\n\n          options = _extends({\n            panels: [],\n            assetLoadedClass: 'carousel-asset-loaded',\n            panelActiveClass: 'carousel-panel-active',\n            panelLoadedClass: 'carousel-panel-loaded',\n            onChange: null,\n            lazyLoadAttr: 'data-src',\n            panelBackClass: 'carousel-panel-behind',\n            panelForwardClass: 'carousel-panel-ahead' },\n          options);\n\n          if (!options.panels.length) {\n            console.error('carousel error: no panels were passed in constructor');\n          } else {\n            this._panelModules = this._setupPanelModules(options);\n          }\n\n          // add forward classes initially\n          this._panelModules.forEach(function (panel) {\n            panel.el.classList.add(options.panelForwardClass);\n          });\n\n          this.options = options;\n        }\n\n        /**\n           * Sets up the panel module instances.\n           * @param {Object} options - The initialization options\n           * @returns {Array} Returns an array of the panel instances\n           * @private\n           */\n\n\n        _createClass(CarouselPanels, [{\n          key: '_setupPanelModules',\n          value: function _setupPanelModules(options) {\n            var modules = [];\n            // panels can be either an array or an HTMLCollection so we\n            // are doing an old-school for loop to satisify both scenarios\n            for (var i = 0; i < options.panels.length; i++) {\n              modules[i] = new _carouselPanel2.default(options.panels[i], {\n                activeClass: options.panelActiveClass,\n                lazyLoadAttr: options.lazyLoadAttr,\n                assetLoadedClass: options.assetLoadedClass,\n                loadedClass: options.panelLoadedClass });\n\n            }\n            return modules;\n          }\n\n          /**\n             * Transitions to a panel of an index.\n             * @param {Number} index - The index number to go to\n             * @returns {Promise}\n             */ },\n\n        {\n          key: 'goTo',\n          value: function goTo(index) {\n            var maxIndex = this.options.panels.length - 1,\n            minIndex = 0,\n            prevIndex = this.getCurrentIndex(),\n            errorMsg,\n            promise;\n\n            if (typeof index !== 'number' || index > maxIndex || index < minIndex) {\n              errorMsg = 'carousel panel error: unable to transition to an index of ' + index + 'which does not exist!';\n              console.error(errorMsg);\n              promise = _promise2.default.reject(new Error(errorMsg));\n            } else if (prevIndex === index) {\n              // already at index\n              promise = _promise2.default.resolve();\n            } else {\n              promise = this.load(index);\n              this._updatePanels(index);\n              this._currentIndex = index;\n              if (this.options.onChange) {\n                this.options.onChange(index);\n              }\n            }\n            return promise;\n          }\n\n          /**\n             * Makes all panels inactive except for the one at the index provided.\n             * @param {Number} toIndex - The new index\n             * @private\n             */ },\n\n        {\n          key: '_updatePanels',\n          value: function _updatePanels(toIndex) {\n            var fromIndex = this.getCurrentIndex();\n            var fromPanel = this._panelModules[fromIndex];\n            var toPanel = this._panelModules[toIndex];\n            var rangePanels = [];\n            var toAdd = '';\n            var toRemove = '';\n\n            if (fromIndex > toIndex) {\n              // include fromIndex but not toIndex\n              rangePanels = this._panelModules.slice(toIndex + 1, fromIndex + 1);\n              toAdd = this.options.panelForwardClass;\n              toRemove = this.options.panelBackClass;\n            } else if (fromIndex < toIndex) {\n              rangePanels = this._panelModules.slice(fromIndex, toIndex);\n              toAdd = this.options.panelBackClass;\n              toRemove = this.options.panelForwardClass;\n            }\n\n            rangePanels.forEach(function (p) {\n              p.el.classList.add(toAdd);\n              p.el.classList.remove(toRemove);\n            });\n\n            if (fromPanel) {\n              fromPanel.hide();\n            }\n            toPanel.el.classList.remove(this.options.panelForwardClass, this.options.panelBackClass);\n            toPanel.show();\n          }\n\n          /**\n             * Gets the current index that is showing.\n             * @returns {Number} Returns the index\n             */ },\n\n        {\n          key: 'getCurrentIndex',\n          value: function getCurrentIndex() {\n            return this._currentIndex;\n          }\n\n          /**\n             * Loads assets for a given panel.\n             * @param {Number} idx - The index of the panel containing the assets to load\n             * @returns {Promise}\n             */ },\n\n        {\n          key: 'load',\n          value: function load(idx) {\n            var panelModule = this._panelModules[idx];\n            if (panelModule.loaded) {\n              return _promise2.default.resolve();\n            }\n            return panelModule.load();\n          }\n\n          /**\n             * Loads assets for a given panel.\n             * @deprecated since 2.1.6\n             * @param {Number} index - The index of the panel containing the assets to load\n             * @returns {Promise}\n             */ },\n\n        {\n          key: 'loadPanelAssets',\n          value: function loadPanelAssets(index) {\n            return this.load(index);\n          }\n\n          /**\n             * Final cleanup of instance.\n             */ },\n\n        {\n          key: 'destroy',\n          value: function destroy() {\n            var options = this.options,\n            currentIndex = this.getCurrentIndex();\n\n            if (currentIndex) {\n              options.panels[currentIndex].classList.remove(options.panelActiveClass);\n            }\n            this._currentIndex = undefined;\n\n            this._panelModules.forEach(function (module) {\n              module.el.classList.remove(options.panelForwardClass, options.panelBackClass);\n              module.destroy();\n            });\n          } }]);\n\n\n        return CarouselPanels;\n      }();\n\n      exports.default = CarouselPanels;\n\n      module.exports = exports['default'];\n\n    }, { \"./carousel-panel\": 59, \"promise\": 38 }], 61: [function (require, module, exports) {\n      'use strict';\n\n      /**\n                     * A callback function that fires after a new active panel is set\n                     * @callback CarouselThumbs~onChange\n                     * @param {Number} index - The index of the new panel\n                     */\n\n      /**\n                         * Adds thumbnails for carousel. Not really meant to be used own its own, unless you\n                         * want to customize the javascript logic for the \"thumbnails\" of your Carousel instance (assuming that you actually\n                         * know what you're doing when you do so).\n                         * @class CarouselThumbs\n                         */\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true });\n\n\n      var _extends = Object.assign || function (target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i];for (var key in source) {if (Object.prototype.hasOwnProperty.call(source, key)) {target[key] = source[key];}}}return target;};\n\n      var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();\n\n      function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}\n\n      var CarouselThumbs = function () {\n\n        /**\n                                         * When carousel is instantiated.\n                                         * @param {object} options - Options passed into instance\n                                         * @param {HTMLCollection} [options.thumbnails] - A collection of elements that are the thumbnails\n                                         * @param {string} [options.thumbnailActiveClass] - The CSS class that gets added to a thumbnail element when it becomes active\n                                         * @param {CarouselThumbs~onChange} [options.onChange] - When a new thumbnail becomes active\n                                         * @memberOf CarouselThumbs\n                                         */\n        function CarouselThumbs(options) {\n          _classCallCheck(this, CarouselThumbs);\n\n          options = _extends({\n            thumbnails: [],\n            thumbnailActiveTriggerEvent: 'click',\n            thumbnailActiveClass: 'carousel-thumbnail-active',\n            onChange: null },\n          options);\n\n          this.options = options;\n          this._thumbnailEventListener = this.onThumbnailEvent.bind(this);\n          this.setup();\n        }\n\n        /**\n           * Sets up the carousel instance by adding event listeners to the thumbnails.\n           * @memberOf CarouselThumbs\n           */\n\n\n        _createClass(CarouselThumbs, [{\n          key: 'setup',\n          value: function setup() {\n            var thumbs = this.options.thumbnails;\n            if (thumbs.length) {\n              this.triggerThumbsEventListener('addEventListener');\n            } else {\n              console.error('carousel thumb error: no thumbnails were passed to constructor');\n            }\n          }\n\n          /**\n             * When a thumbnail is clicked.\n             * @param {MouseEvent} e - The click event\n             * @memberOf CarouselThumbs\n             */ },\n\n        {\n          key: 'onThumbnailEvent',\n          value: function onThumbnailEvent(e) {\n            if (!this._thumbnailArr) {\n              // convert thumbnail HTMLCollection to real array so we can perform necessary array methods\n              this._thumbnailArr = Array.prototype.slice.call(this.options.thumbnails);\n            }\n            var index = this._thumbnailArr.indexOf(e.currentTarget);\n            // we are checking that the selected thumbnail is still in the HTMLCollection\n            // because it is live introducing the possibility that the element is no longer in the DOM\n            if (index !== -1 && index !== this.getCurrentIndex()) {\n              this.goTo(index);\n              if (this.options.onChange) {\n                this.options.onChange(index);\n              }\n            }\n          }\n\n          /**\n             * Checks for errors upon initialize.\n             * @memberOf CarouselThumbs\n             * @private\n             */ },\n\n        {\n          key: '_checkForInitErrors',\n          value: function _checkForInitErrors() {\n            var options = this.options,\n            thumbnailCount = options.thumbnails.length;\n            if (!thumbnailCount) {\n              console.error('carousel error: no thumbnails were passed in constructor');\n            }\n          }\n\n          /**\n             * Makes all thumbnails inactive except for the one at the index provided.\n             * @param {Number} index - The new index\n             * @memberOf CarouselThumbs\n             */ },\n\n        {\n          key: 'goTo',\n          value: function goTo(index) {\n            var thumbs = this.options.thumbnails,\n            prevIndex = this.getCurrentIndex() || 0,\n            activeClass = this.options.thumbnailActiveClass,\n            maxIndex = thumbs.length - 1,\n            minIndex = 0;\n\n            if (index > maxIndex || index < minIndex) {\n              console.error('carousel thumbnail error: unable to transition to a thumbnail with an index of ' + index + ', it does not exist!');\n            }\n\n            thumbs[index].classList.add(activeClass);\n\n            if (prevIndex !== index) {\n              thumbs[prevIndex].classList.remove(activeClass);\n            }\n            this._currentIndex = index;\n          }\n\n          /**\n             * Gets the current thumbnail index that is showing.\n             * @returns {Number} Returns the index\n             * @memberOf CarouselThumbs\n             */ },\n\n        {\n          key: 'getCurrentIndex',\n          value: function getCurrentIndex() {\n            return this._currentIndex;\n          }\n\n          /**\n             * Triggers an event listener method on all thumbnail elements.\n             * @param {string} method - The event listener method to call on each of the elements\n             */ },\n\n        {\n          key: 'triggerThumbsEventListener',\n          value: function triggerThumbsEventListener(method) {\n            var count = this.options.thumbnails.length,\n            i,\n            el;\n            for (i = 0; i < count; i++) {\n              el = this.options.thumbnails[i];\n              el[method](this.options.thumbnailActiveTriggerEvent, this._thumbnailEventListener);\n            }\n          }\n\n          /**\n             * Destroys the instance.\n             * @memberOf CarouselThumbs\n             */ },\n\n        {\n          key: 'destroy',\n          value: function destroy() {\n            var thumbs = this.options.thumbnails;\n            this._currentIndex = null;\n            if (thumbs.length) {\n              this.triggerThumbsEventListener('removeEventListener');\n            }\n          } }]);\n\n\n        return CarouselThumbs;\n      }();\n\n      exports.default = CarouselThumbs;\n\n      module.exports = exports['default'];\n\n    }, {}], 62: [function (require, module, exports) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true });\n\n\n      var _extends = Object.assign || function (target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i];for (var key in source) {if (Object.prototype.hasOwnProperty.call(source, key)) {target[key] = source[key];}}}return target;};\n\n      var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();\n\n      var _carouselThumbs = require('./carousel-thumbs');\n\n      var _carouselThumbs2 = _interopRequireDefault(_carouselThumbs);\n\n      var _carouselPanels = require('./carousel-panels');\n\n      var _carouselPanels2 = _interopRequireDefault(_carouselPanels);\n\n      var _carouselArrows = require('./carousel-arrows');\n\n      var _carouselArrows2 = _interopRequireDefault(_carouselArrows);\n\n      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}\n\n      function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}\n\n      /**\n                                                                                                                                                             * A callback function that fires after a new active panel is set\n                                                                                                                                                             * @callback Carousel~onPanelChange\n                                                                                                                                                             * @param {Number} index - The index of the new panel\n                                                                                                                                                             */\n\n      /**\n                                                                                                                                                                 * Adds carousel functionality to a set up pre-determined HTML markup.\n                                                                                                                                                                 * @class Carousel\n                                                                                                                                                                 * @param {object} options - Options passed into instance\n                                                                                                                                                                 * @param {HTMLCollection} options.panels - The panels in which to use for the carousel (an array of photos)\n                                                                                                                                                                 * @param {string} [options.assetLoadingClass] - The CSS class that gets added to an asset when it is loading\n                                                                                                                                                                 * @param {boolean} [options.autoLoadAssets] - Whether or not to automatically load assets when active\n                                                                                                                                                                 * @param {string} [options.panelActiveClass] - The CSS class that gets added to an panel when it becomes active\n                                                                                                                                                                 * @param {string} [options.panelLoadedClass] - The CSS class that gets added to an panel when it is fully loaded\n                                                                                                                                                                 * @param {string} [options.panelBackClass] - The CSS class that gets added to all panel elements that appear before the current panel\n                                                                                                                                                                 * @param {string} [options.panelForwardClass] - The CSS class that gets added to all panel elements that appear ahead of the current panel\n                                                                                                                                                                 * @param {Carousel~onPanelChange} [options.onPanelChange] - When the current panel is changed\n                                                                                                                                                                 * @param {string} [options.lazyLoadAttr] - The attribute containing the url path to content that is to be lazy loaded\n                                                                                                                                                                 * @param {HTMLCollection} [options.thumbnails] - A collection of elements that are the thumbnails\n                                                                                                                                                                 * @param {string} [options.thumbnailActiveClass] - The CSS class that gets added to a thumbnail element when it becomes active\n                                                                                                                                                                 * @param {Number} [options.initialIndex] - The index of the panel to go to upon instantiation (if not declared, goTo() must be called manually).\n                                                                                                                                                                 */\n\n      var Carousel = function () {\n\n        /**\n                                   * Sets up stuff.\n                                   * @param options\n                                   */\n        function Carousel(options) {\n          _classCallCheck(this, Carousel);\n\n          options = options || {};\n\n          // if undefined or null is passed in options for panels or thumbnails,\n          // we need to sanitize it to an empty array to prevent a crash\n          if (!options.panels) {\n            options.panels = [];\n          }\n          if (!options.thumbnails) {\n            options.thumbnails = [];\n          }\n\n          options = _extends({\n            panels: [],\n            assetLoadingClass: 'carousel-asset-loading',\n            autoLoadAssets: true,\n            panelActiveClass: 'carousel-panel-active',\n            panelLoadedClass: 'carousel-panel-loaded',\n            panelBackClass: 'carousel-panel-behind',\n            panelForwardClass: 'carousel-panel-ahead',\n            onPanelChange: null,\n            lazyLoadAttr: 'data-src',\n            thumbnails: [],\n            thumbnailActiveTriggerEvent: 'click',\n            thumbnailActiveClass: 'carousel-thumbnail-active',\n            initialIndex: 0,\n            leftArrow: null,\n            rightArrow: null,\n            arrowActiveClass: 'carousel-arrow-active',\n            arrowDisabledClass: 'carousel-arrow-disabled',\n            onLeftArrowClick: null,\n            onRightArrowClick: null },\n          options);\n\n          this.options = options;\n          this.subModules = {};\n          this._checkForInitErrors();\n          this.setup();\n        }\n\n        /**\n           * Sets up the carousel instance and all controls.\n           */\n\n\n        _createClass(Carousel, [{\n          key: 'setup',\n          value: function setup() {\n\n            if (!this.subModules.panels) {\n              this.subModules.panels = this._setupPanels(this.options);\n            }\n\n            if (this.options.thumbnails.length && !this.subModules.thumbnails) {\n              this.subModules.thumbnails = this._setupThumbs(this.options);\n            }\n\n            if ((this.options.leftArrow || this.options.rightArrow) && !this.subModules.arrows) {\n              this.subModules.arrows = this._setupArrows(this.options);\n            }\n\n            if (typeof this.options.initialIndex === 'number') {\n              this.goTo(this.options.initialIndex);\n            }\n          }\n\n          /**\n             * Sets up the carousel thumbs.\n             * @param {Object} options - The initialize options\n             * @return {CarouselThumbs} Returns thumbnail instance\n             * @private\n             */ },\n\n        {\n          key: '_setupThumbs',\n          value: function _setupThumbs(options) {\n            return new _carouselThumbs2.default(_extends({}, options, {\n              onChange: this.onThumbnailChange.bind(this) }));\n\n          }\n\n          /**\n             * Sets up the carousel panels.\n             * @param {Object} options - The initialize options\n             * @return {CarouselPanels} Returns panels instance\n             * @private\n             */ },\n\n        {\n          key: '_setupPanels',\n          value: function _setupPanels(options) {\n            if (options.panels.length) {\n              return new _carouselPanels2.default(_extends({}, options, {\n                onChange: this.onPanelChange.bind(this) }));\n\n            }\n          }\n\n          /**\n             * Sets up the carousel arrows.\n             * @param {Object} options - The initialize options\n             * @return {CarouselArrows} Returns arrows instance\n             * @private\n             */ },\n\n        {\n          key: '_setupArrows',\n          value: function _setupArrows(options) {\n            var internalOptions;\n            // make clone of original options\n            internalOptions = _extends({}, options);\n\n            internalOptions.onLeftArrowClick = this.onLeftArrowClick.bind(this);\n            internalOptions.onRightArrowClick = this.onRightArrowClick.bind(this);\n            return new _carouselArrows2.default(internalOptions);\n          }\n\n          /**\n             * Checks for errors upon initialize.\n             * @private\n             */ },\n\n        {\n          key: '_checkForInitErrors',\n          value: function _checkForInitErrors() {\n            var options = this.options,\n            panelCount = options.panels.length,\n            thumbnailCount = options.thumbnails.length;\n            if (thumbnailCount && thumbnailCount !== panelCount) {\n              console.warn('carousel warning: number of thumbnails passed in constructor do not equal the number of panels' + '\\n' + 'panels: ' + panelCount + '\\n' + 'thumbnails: ' + thumbnailCount + '\\n');\n            }\n          }\n\n          /**\n             * When a panel index changes.\n             * @param {Number} index - The new index\n             */ },\n\n        {\n          key: 'onPanelChange',\n          value: function onPanelChange(index) {\n            if (this.subModules.thumbnails) {\n              this.subModules.thumbnails.goTo(index);\n            }\n\n            if (this.subModules.arrows) {\n              this.subModules.arrows.update(index);\n            }\n\n            if (this.options.onPanelChange) {\n              this.options.onPanelChange(index);\n            }\n          }\n\n          /**\n             * When the thumbnail index changes.\n             * @param {Number} index - The new index\n             */ },\n\n        {\n          key: 'onThumbnailChange',\n          value: function onThumbnailChange(index) {\n            this.goTo(index);\n          }\n\n          /**\n             * When the right arrow of the carousel is clicked.\n             * @param e\n             */ },\n\n        {\n          key: 'onRightArrowClick',\n          value: function onRightArrowClick(e) {\n            this.goTo(this.subModules.panels.getCurrentIndex() + 1);\n            if (this.options.onRightArrowClick) {\n              this.options.onRightArrowClick(e);\n            }\n          }\n\n          /**\n             * When the left arrow of the carousel is clicked.\n             * @param e\n             */ },\n\n        {\n          key: 'onLeftArrowClick',\n          value: function onLeftArrowClick(e) {\n            this.goTo(this.subModules.panels.getCurrentIndex() - 1);\n            if (this.options.onLeftArrowClick) {\n              this.options.onLeftArrowClick(e);\n            }\n          }\n\n          /**\n             * Transition to a new panel and thumbnail.\n             * @param {Number} index - The index number to go to\n             */ },\n\n        {\n          key: 'goTo',\n          value: function goTo(index) {\n            var options = this.options,\n            maxIndex = options.panels.length - 1,\n            minIndex = 0;\n\n            if (index > maxIndex) {\n              // set to first index if too high\n              index = minIndex;\n            } else if (index < minIndex) {\n              // set to last index if too low\n              index = maxIndex;\n            }\n\n            if (this.subModules.thumbnails) {\n              this.subModules.thumbnails.goTo(index);\n            }\n            if (this.subModules.arrows) {\n              this.subModules.arrows.update(index);\n            }\n\n            if (this.subModules.panels) {\n              return this.subModules.panels.goTo(index);\n            }\n          }\n\n          /**\n             * Gets the current index that is showing.\n             * @returns {Number} Returns the index\n             */ },\n\n        {\n          key: 'getCurrentIndex',\n          value: function getCurrentIndex() {\n            return this.subModules.panels.getCurrentIndex();\n          }\n\n          /**\n             * Moves carousel to next panel.\n             */ },\n\n        {\n          key: 'next',\n          value: function next() {\n            this.goTo(this.getCurrentIndex() + 1);\n          }\n\n          /**\n             * Moves to previous carousel panel.\n             */ },\n\n        {\n          key: 'prev',\n          value: function prev() {\n            this.goTo(this.getCurrentIndex() - 1);\n          }\n\n          /**\n             * Destroys all sub modules.\n             */ },\n\n        {\n          key: 'destroy',\n          value: function destroy() {\n            for (var key in this.subModules) {\n              if (this.subModules.hasOwnProperty(key) && this.subModules[key]) {\n                this.subModules[key].destroy();\n              }\n            }\n          } }]);\n\n\n        return Carousel;\n      }();\n\n      exports.default = Carousel;\n\n      module.exports = exports['default'];\n\n    }, { \"./carousel-arrows\": 58, \"./carousel-panels\": 60, \"./carousel-thumbs\": 61 }], 63: [function (require, module, exports) {\n\n    }, {}], 64: [function (require, module, exports) {\n      (function (process) {\n        // Copyright Joyent, Inc. and other Node contributors.\n        //\n        // Permission is hereby granted, free of charge, to any person obtaining a\n        // copy of this software and associated documentation files (the\n        // \"Software\"), to deal in the Software without restriction, including\n        // without limitation the rights to use, copy, modify, merge, publish,\n        // distribute, sublicense, and/or sell copies of the Software, and to permit\n        // persons to whom the Software is furnished to do so, subject to the\n        // following conditions:\n        //\n        // The above copyright notice and this permission notice shall be included\n        // in all copies or substantial portions of the Software.\n        //\n        // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n        // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n        // resolves . and .. elements in a path array with directory names there\n        // must be no slashes, empty elements, or device names (c:\\) in the array\n        // (so also no leading and trailing slashes - it does not distinguish\n        // relative and absolute paths)\n        function normalizeArray(parts, allowAboveRoot) {\n          // if the path tries to go above the root, `up` ends up > 0\n          var up = 0;\n          for (var i = parts.length - 1; i >= 0; i--) {\n            var last = parts[i];\n            if (last === '.') {\n              parts.splice(i, 1);\n            } else if (last === '..') {\n              parts.splice(i, 1);\n              up++;\n            } else if (up) {\n              parts.splice(i, 1);\n              up--;\n            }\n          }\n\n          // if the path is allowed to go above the root, restore leading ..s\n          if (allowAboveRoot) {\n            for (; up--; up) {\n              parts.unshift('..');\n            }\n          }\n\n          return parts;\n        }\n\n        // Split a filename into [root, dir, basename, ext], unix version\n        // 'root' is just a slash, or nothing.\n        var splitPathRe =\n        /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n        var splitPath = function splitPath(filename) {\n          return splitPathRe.exec(filename).slice(1);\n        };\n\n        // path.resolve([from ...], to)\n        // posix version\n        exports.resolve = function () {\n          var resolvedPath = '',\n          resolvedAbsolute = false;\n\n          for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n            var path = i >= 0 ? arguments[i] : process.cwd();\n\n            // Skip empty and invalid entries\n            if (typeof path !== 'string') {\n              throw new TypeError('Arguments to path.resolve must be strings');\n            } else if (!path) {\n              continue;\n            }\n\n            resolvedPath = path + '/' + resolvedPath;\n            resolvedAbsolute = path.charAt(0) === '/';\n          }\n\n          // At this point the path should be resolved to a full absolute path, but\n          // handle relative paths to be safe (might happen when process.cwd() fails)\n\n          // Normalize the path\n          resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {\n            return !!p;\n          }), !resolvedAbsolute).join('/');\n\n          return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';\n        };\n\n        // path.normalize(path)\n        // posix version\n        exports.normalize = function (path) {\n          var isAbsolute = exports.isAbsolute(path),\n          trailingSlash = substr(path, -1) === '/';\n\n          // Normalize the path\n          path = normalizeArray(filter(path.split('/'), function (p) {\n            return !!p;\n          }), !isAbsolute).join('/');\n\n          if (!path && !isAbsolute) {\n            path = '.';\n          }\n          if (path && trailingSlash) {\n            path += '/';\n          }\n\n          return (isAbsolute ? '/' : '') + path;\n        };\n\n        // posix version\n        exports.isAbsolute = function (path) {\n          return path.charAt(0) === '/';\n        };\n\n        // posix version\n        exports.join = function () {\n          var paths = Array.prototype.slice.call(arguments, 0);\n          return exports.normalize(filter(paths, function (p, index) {\n            if (typeof p !== 'string') {\n              throw new TypeError('Arguments to path.join must be strings');\n            }\n            return p;\n          }).join('/'));\n        };\n\n\n        // path.relative(from, to)\n        // posix version\n        exports.relative = function (from, to) {\n          from = exports.resolve(from).substr(1);\n          to = exports.resolve(to).substr(1);\n\n          function trim(arr) {\n            var start = 0;\n            for (; start < arr.length; start++) {\n              if (arr[start] !== '') break;\n            }\n\n            var end = arr.length - 1;\n            for (; end >= 0; end--) {\n              if (arr[end] !== '') break;\n            }\n\n            if (start > end) return [];\n            return arr.slice(start, end - start + 1);\n          }\n\n          var fromParts = trim(from.split('/'));\n          var toParts = trim(to.split('/'));\n\n          var length = Math.min(fromParts.length, toParts.length);\n          var samePartsLength = length;\n          for (var i = 0; i < length; i++) {\n            if (fromParts[i] !== toParts[i]) {\n              samePartsLength = i;\n              break;\n            }\n          }\n\n          var outputParts = [];\n          for (var i = samePartsLength; i < fromParts.length; i++) {\n            outputParts.push('..');\n          }\n\n          outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n          return outputParts.join('/');\n        };\n\n        exports.sep = '/';\n        exports.delimiter = ':';\n\n        exports.dirname = function (path) {\n          var result = splitPath(path),\n          root = result[0],\n          dir = result[1];\n\n          if (!root && !dir) {\n            // No dirname whatsoever\n            return '.';\n          }\n\n          if (dir) {\n            // It has a dirname, strip trailing slash\n            dir = dir.substr(0, dir.length - 1);\n          }\n\n          return root + dir;\n        };\n\n\n        exports.basename = function (path, ext) {\n          var f = splitPath(path)[2];\n          // TODO: make this comparison case-insensitive on windows?\n          if (ext && f.substr(-1 * ext.length) === ext) {\n            f = f.substr(0, f.length - ext.length);\n          }\n          return f;\n        };\n\n\n        exports.extname = function (path) {\n          return splitPath(path)[3];\n        };\n\n        function filter(xs, f) {\n          if (xs.filter) return xs.filter(f);\n          var res = [];\n          for (var i = 0; i < xs.length; i++) {\n            if (f(xs[i], i, xs)) res.push(xs[i]);\n          }\n          return res;\n        }\n\n        // String.prototype.substr - negative index don't work in IE8\n        var substr = 'ab'.substr(-1) === 'b' ?\n        function (str, start, len) {return str.substr(start, len);} :\n        function (str, start, len) {\n          if (start < 0) start = str.length + start;\n          return str.substr(start, len);\n        };\n\n\n      }).call(this, require('_process'));\n    }, { \"_process\": 65 }], 65: [function (require, module, exports) {\n      // shim for using process in browser\n      var process = module.exports = {};\n\n      // cached from whatever global is present so that test runners that stub it\n      // don't break things.  But we need to wrap it in a try catch in case it is\n      // wrapped in strict mode code which doesn't define any globals.  It's inside a\n      // function because try/catches deoptimize in certain engines.\n\n      var cachedSetTimeout;\n      var cachedClearTimeout;\n\n      function defaultSetTimout() {\n        throw new Error('setTimeout has not been defined');\n      }\n      function defaultClearTimeout() {\n        throw new Error('clearTimeout has not been defined');\n      }\n      (function () {\n        try {\n          if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n          } else {\n            cachedSetTimeout = defaultSetTimout;\n          }\n        } catch (e) {\n          cachedSetTimeout = defaultSetTimout;\n        }\n        try {\n          if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n          } else {\n            cachedClearTimeout = defaultClearTimeout;\n          }\n        } catch (e) {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      })();\n      function runTimeout(fun) {\n        if (cachedSetTimeout === setTimeout) {\n          //normal enviroments in sane situations\n          return setTimeout(fun, 0);\n        }\n        // if setTimeout wasn't available but was latter defined\n        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n          cachedSetTimeout = setTimeout;\n          return setTimeout(fun, 0);\n        }\n        try {\n          // when when somebody has screwed with setTimeout but no I.E. maddness\n          return cachedSetTimeout(fun, 0);\n        } catch (e) {\n          try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n          } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n          }\n        }\n\n\n      }\n      function runClearTimeout(marker) {\n        if (cachedClearTimeout === clearTimeout) {\n          //normal enviroments in sane situations\n          return clearTimeout(marker);\n        }\n        // if clearTimeout wasn't available but was latter defined\n        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n          cachedClearTimeout = clearTimeout;\n          return clearTimeout(marker);\n        }\n        try {\n          // when when somebody has screwed with setTimeout but no I.E. maddness\n          return cachedClearTimeout(marker);\n        } catch (e) {\n          try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n          } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n          }\n        }\n\n\n\n      }\n      var queue = [];\n      var draining = false;\n      var currentQueue;\n      var queueIndex = -1;\n\n      function cleanUpNextTick() {\n        if (!draining || !currentQueue) {\n          return;\n        }\n        draining = false;\n        if (currentQueue.length) {\n          queue = currentQueue.concat(queue);\n        } else {\n          queueIndex = -1;\n        }\n        if (queue.length) {\n          drainQueue();\n        }\n      }\n\n      function drainQueue() {\n        if (draining) {\n          return;\n        }\n        var timeout = runTimeout(cleanUpNextTick);\n        draining = true;\n\n        var len = queue.length;\n        while (len) {\n          currentQueue = queue;\n          queue = [];\n          while (++queueIndex < len) {\n            if (currentQueue) {\n              currentQueue[queueIndex].run();\n            }\n          }\n          queueIndex = -1;\n          len = queue.length;\n        }\n        currentQueue = null;\n        draining = false;\n        runClearTimeout(timeout);\n      }\n\n      process.nextTick = function (fun) {\n        var args = new Array(arguments.length - 1);\n        if (arguments.length > 1) {\n          for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n          }\n        }\n        queue.push(new Item(fun, args));\n        if (queue.length === 1 && !draining) {\n          runTimeout(drainQueue);\n        }\n      };\n\n      // v8 likes predictible objects\n      function Item(fun, array) {\n        this.fun = fun;\n        this.array = array;\n      }\n      Item.prototype.run = function () {\n        this.fun.apply(null, this.array);\n      };\n      process.title = 'browser';\n      process.browser = true;\n      process.env = {};\n      process.argv = [];\n      process.version = ''; // empty string to avoid regexp issues\n      process.versions = {};\n\n      function noop() {}\n\n      process.on = noop;\n      process.addListener = noop;\n      process.once = noop;\n      process.off = noop;\n      process.removeListener = noop;\n      process.removeAllListeners = noop;\n      process.emit = noop;\n\n      process.binding = function (name) {\n        throw new Error('process.binding is not supported');\n      };\n\n      process.cwd = function () {return '/';};\n      process.chdir = function (dir) {\n        throw new Error('process.chdir is not supported');\n      };\n      process.umask = function () {return 0;};\n\n    }, {}] }, {}, [62])(62);\n});\n//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNhcm91c2VsLmpzIl0sIm5hbWVzIjpbImYiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwiYW1kIiwiZyIsIndpbmRvdyIsImdsb2JhbCIsInNlbGYiLCJDYXJvdXNlbCIsImUiLCJ0IiwibiIsInIiLCJzIiwibyIsInUiLCJhIiwicmVxdWlyZSIsImkiLCJFcnJvciIsImNvZGUiLCJsIiwiY2FsbCIsImxlbmd0aCIsInByb2Nlc3MiLCJfX2ZpbGVuYW1lIiwiYW1kZWZpbmUiLCJyZXF1aXJlRm4iLCJkZWZpbmVDYWNoZSIsImxvYWRlckNhY2hlIiwiYWxyZWFkeUNhbGxlZCIsInBhdGgiLCJtYWtlUmVxdWlyZSIsInN0cmluZ1JlcXVpcmUiLCJ0cmltRG90cyIsImFyeSIsInBhcnQiLCJzcGxpY2UiLCJub3JtYWxpemUiLCJuYW1lIiwiYmFzZU5hbWUiLCJiYXNlUGFydHMiLCJjaGFyQXQiLCJzcGxpdCIsInNsaWNlIiwiY29uY2F0Iiwiam9pbiIsIm1ha2VOb3JtYWxpemUiLCJyZWxOYW1lIiwibWFrZUxvYWQiLCJpZCIsImxvYWQiLCJ2YWx1ZSIsImZyb21UZXh0IiwidGV4dCIsInN5c3RlbVJlcXVpcmUiLCJyZWxJZCIsImFtZFJlcXVpcmUiLCJkZXBzIiwiY2FsbGJhY2siLCJtYXAiLCJkZXBOYW1lIiwibmV4dFRpY2siLCJhcHBseSIsInRvVXJsIiwiZmlsZVBhdGgiLCJpbmRleE9mIiwiZGlybmFtZSIsImZpbGVuYW1lIiwicmVxIiwiYXJndW1lbnRzIiwicnVuRmFjdG9yeSIsImZhY3RvcnkiLCJtIiwicmVzdWx0IiwidXJpIiwidW5kZWZpbmVkIiwiaW5kZXgiLCJvcmlnaW5hbElkIiwicHJlZml4IiwicGx1Z2luIiwiaGFzT3duUHJvcGVydHkiLCJzdWJzdHJpbmciLCJBcnJheSIsImlzQXJyYXkiLCJyYXdBc2FwIiwiZnJlZVRhc2tzIiwicGVuZGluZ0Vycm9ycyIsInJlcXVlc3RFcnJvclRocm93IiwibWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyIiwidGhyb3dGaXJzdEVycm9yIiwic2hpZnQiLCJhc2FwIiwidGFzayIsInJhd1Rhc2siLCJwb3AiLCJSYXdUYXNrIiwicHJvdG90eXBlIiwiZXJyb3IiLCJvbmVycm9yIiwicHVzaCIsInF1ZXVlIiwicmVxdWVzdEZsdXNoIiwiZmx1c2hpbmciLCJjYXBhY2l0eSIsImZsdXNoIiwiY3VycmVudEluZGV4Iiwic2NhbiIsIm5ld0xlbmd0aCIsInNjb3BlIiwiQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIiLCJNdXRhdGlvbk9ic2VydmVyIiwiV2ViS2l0TXV0YXRpb25PYnNlcnZlciIsIm1ha2VSZXF1ZXN0Q2FsbEZyb21NdXRhdGlvbk9ic2VydmVyIiwidG9nZ2xlIiwib2JzZXJ2ZXIiLCJub2RlIiwiZG9jdW1lbnQiLCJjcmVhdGVUZXh0Tm9kZSIsIm9ic2VydmUiLCJjaGFyYWN0ZXJEYXRhIiwicmVxdWVzdENhbGwiLCJkYXRhIiwidGltZW91dEhhbmRsZSIsInNldFRpbWVvdXQiLCJoYW5kbGVUaW1lciIsImludGVydmFsSGFuZGxlIiwic2V0SW50ZXJ2YWwiLCJjbGVhclRpbWVvdXQiLCJjbGVhckludGVydmFsIiwiRVM2UHJvbWlzZSIsIm9iamVjdE9yRnVuY3Rpb24iLCJ4IiwiaXNGdW5jdGlvbiIsIl9pc0FycmF5IiwiT2JqZWN0IiwidG9TdHJpbmciLCJsZW4iLCJ2ZXJ0eE5leHQiLCJjdXN0b21TY2hlZHVsZXJGbiIsImFyZyIsInNjaGVkdWxlRmx1c2giLCJzZXRTY2hlZHVsZXIiLCJzY2hlZHVsZUZuIiwic2V0QXNhcCIsImFzYXBGbiIsImJyb3dzZXJXaW5kb3ciLCJicm93c2VyR2xvYmFsIiwiaXNOb2RlIiwiaXNXb3JrZXIiLCJVaW50OENsYW1wZWRBcnJheSIsImltcG9ydFNjcmlwdHMiLCJNZXNzYWdlQ2hhbm5lbCIsInVzZU5leHRUaWNrIiwidXNlVmVydHhUaW1lciIsInVzZVNldFRpbWVvdXQiLCJ1c2VNdXRhdGlvbk9ic2VydmVyIiwiaXRlcmF0aW9ucyIsInVzZU1lc3NhZ2VDaGFubmVsIiwiY2hhbm5lbCIsInBvcnQxIiwib25tZXNzYWdlIiwicG9ydDIiLCJwb3N0TWVzc2FnZSIsImdsb2JhbFNldFRpbWVvdXQiLCJhdHRlbXB0VmVydHgiLCJ2ZXJ0eCIsInJ1bk9uTG9vcCIsInJ1bk9uQ29udGV4dCIsInRoZW4iLCJvbkZ1bGZpbGxtZW50Iiwib25SZWplY3Rpb24iLCJfYXJndW1lbnRzIiwicGFyZW50IiwiY2hpbGQiLCJjb25zdHJ1Y3RvciIsIm5vb3AiLCJQUk9NSVNFX0lEIiwibWFrZVByb21pc2UiLCJfc3RhdGUiLCJpbnZva2VDYWxsYmFjayIsIl9yZXN1bHQiLCJzdWJzY3JpYmUiLCJyZXNvbHZlIiwib2JqZWN0IiwiQ29uc3RydWN0b3IiLCJwcm9taXNlIiwiX3Jlc29sdmUiLCJNYXRoIiwicmFuZG9tIiwiUEVORElORyIsIkZVTEZJTExFRCIsIlJFSkVDVEVEIiwiR0VUX1RIRU5fRVJST1IiLCJFcnJvck9iamVjdCIsInNlbGZGdWxmaWxsbWVudCIsIlR5cGVFcnJvciIsImNhbm5vdFJldHVybk93biIsImdldFRoZW4iLCJ0cnlUaGVuIiwiZnVsZmlsbG1lbnRIYW5kbGVyIiwicmVqZWN0aW9uSGFuZGxlciIsImhhbmRsZUZvcmVpZ25UaGVuYWJsZSIsInRoZW5hYmxlIiwic2VhbGVkIiwiZnVsZmlsbCIsInJlYXNvbiIsIl9yZWplY3QiLCJfbGFiZWwiLCJoYW5kbGVPd25UaGVuYWJsZSIsImhhbmRsZU1heWJlVGhlbmFibGUiLCJtYXliZVRoZW5hYmxlIiwidGhlbiQkIiwicHVibGlzaFJlamVjdGlvbiIsIl9vbmVycm9yIiwicHVibGlzaCIsIl9zdWJzY3JpYmVycyIsInN1YnNjcmliZXJzIiwic2V0dGxlZCIsImRldGFpbCIsIlRSWV9DQVRDSF9FUlJPUiIsInRyeUNhdGNoIiwiaGFzQ2FsbGJhY2siLCJzdWNjZWVkZWQiLCJmYWlsZWQiLCJpbml0aWFsaXplUHJvbWlzZSIsInJlc29sdmVyIiwicmVzb2x2ZVByb21pc2UiLCJyZWplY3RQcm9taXNlIiwibmV4dElkIiwiRW51bWVyYXRvciIsImlucHV0IiwiX2luc3RhbmNlQ29uc3RydWN0b3IiLCJfaW5wdXQiLCJfcmVtYWluaW5nIiwiX2VudW1lcmF0ZSIsInZhbGlkYXRpb25FcnJvciIsIl9lYWNoRW50cnkiLCJlbnRyeSIsImMiLCJyZXNvbHZlJCQiLCJfdGhlbiIsIl9zZXR0bGVkQXQiLCJQcm9taXNlIiwiX3dpbGxTZXR0bGVBdCIsInN0YXRlIiwiZW51bWVyYXRvciIsImFsbCIsImVudHJpZXMiLCJyYWNlIiwiXyIsInJlamVjdCIsIm5lZWRzUmVzb2x2ZXIiLCJuZWVkc05ldyIsIl9zZXRTY2hlZHVsZXIiLCJfc2V0QXNhcCIsIl9hc2FwIiwiX2NhdGNoIiwicG9seWZpbGwiLCJsb2NhbCIsIkZ1bmN0aW9uIiwiUCIsInByb21pc2VUb1N0cmluZyIsImNhc3QiLCJfX2VzTW9kdWxlIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIm9iaiIsIl9oYW5kbGViYXJzUnVudGltZSIsIl9oYW5kbGViYXJzUnVudGltZTIiLCJfaGFuZGxlYmFyc0NvbXBpbGVyQXN0IiwiX2hhbmRsZWJhcnNDb21waWxlckFzdDIiLCJfaGFuZGxlYmFyc0NvbXBpbGVyQmFzZSIsIl9oYW5kbGViYXJzQ29tcGlsZXJDb21waWxlciIsIl9oYW5kbGViYXJzQ29tcGlsZXJKYXZhc2NyaXB0Q29tcGlsZXIiLCJfaGFuZGxlYmFyc0NvbXBpbGVySmF2YXNjcmlwdENvbXBpbGVyMiIsIl9oYW5kbGViYXJzQ29tcGlsZXJWaXNpdG9yIiwiX2hhbmRsZWJhcnNDb21waWxlclZpc2l0b3IyIiwiX2hhbmRsZWJhcnNOb0NvbmZsaWN0IiwiX2hhbmRsZWJhcnNOb0NvbmZsaWN0MiIsIl9jcmVhdGUiLCJjcmVhdGUiLCJoYiIsImNvbXBpbGUiLCJvcHRpb25zIiwicHJlY29tcGlsZSIsIkFTVCIsIkNvbXBpbGVyIiwiSmF2YVNjcmlwdENvbXBpbGVyIiwiUGFyc2VyIiwicGFyc2VyIiwicGFyc2UiLCJpbnN0IiwiVmlzaXRvciIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwibmV3T2JqIiwia2V5IiwiX2hhbmRsZWJhcnNCYXNlIiwiYmFzZSIsIl9oYW5kbGViYXJzU2FmZVN0cmluZyIsIl9oYW5kbGViYXJzU2FmZVN0cmluZzIiLCJfaGFuZGxlYmFyc0V4Y2VwdGlvbiIsIl9oYW5kbGViYXJzRXhjZXB0aW9uMiIsIl9oYW5kbGViYXJzVXRpbHMiLCJVdGlscyIsInJ1bnRpbWUiLCJIYW5kbGViYXJzRW52aXJvbm1lbnQiLCJleHRlbmQiLCJTYWZlU3RyaW5nIiwiRXhjZXB0aW9uIiwiZXNjYXBlRXhwcmVzc2lvbiIsIlZNIiwidGVtcGxhdGUiLCJzcGVjIiwiX3V0aWxzIiwiX2V4Y2VwdGlvbiIsIl9leGNlcHRpb24yIiwiX2hlbHBlcnMiLCJfZGVjb3JhdG9ycyIsIl9sb2dnZXIiLCJfbG9nZ2VyMiIsIlZFUlNJT04iLCJDT01QSUxFUl9SRVZJU0lPTiIsIlJFVklTSU9OX0NIQU5HRVMiLCJvYmplY3RUeXBlIiwiaGVscGVycyIsInBhcnRpYWxzIiwiZGVjb3JhdG9ycyIsInJlZ2lzdGVyRGVmYXVsdEhlbHBlcnMiLCJyZWdpc3RlckRlZmF1bHREZWNvcmF0b3JzIiwibG9nZ2VyIiwibG9nIiwicmVnaXN0ZXJIZWxwZXIiLCJmbiIsInVucmVnaXN0ZXJIZWxwZXIiLCJyZWdpc3RlclBhcnRpYWwiLCJwYXJ0aWFsIiwidW5yZWdpc3RlclBhcnRpYWwiLCJyZWdpc3RlckRlY29yYXRvciIsInVucmVnaXN0ZXJEZWNvcmF0b3IiLCJjcmVhdGVGcmFtZSIsImhlbHBlckV4cHJlc3Npb24iLCJ0eXBlIiwicGFyYW1zIiwiaGFzaCIsInNjb3BlZElkIiwidGVzdCIsIm9yaWdpbmFsIiwic2ltcGxlSWQiLCJwYXJ0cyIsImRlcHRoIiwiX3BhcnNlciIsIl9wYXJzZXIyIiwiX3doaXRlc3BhY2VDb250cm9sIiwiX3doaXRlc3BhY2VDb250cm9sMiIsIkhlbHBlcnMiLCJ5eSIsImxvY0luZm8iLCJTb3VyY2VMb2NhdGlvbiIsInNyY05hbWUiLCJzdHJpcCIsImFjY2VwdCIsIlNvdXJjZU5vZGUiLCJTb3VyY2VNYXAiLCJlcnIiLCJsaW5lIiwiY29sdW1uIiwic3JjRmlsZSIsImNodW5rcyIsInNyYyIsImFkZCIsInByZXBlbmQiLCJ0b1N0cmluZ1dpdGhTb3VyY2VNYXAiLCJjYXN0Q2h1bmsiLCJjaHVuayIsImNvZGVHZW4iLCJsb2MiLCJyZXQiLCJ3cmFwIiwiQ29kZUdlbiIsInNvdXJjZSIsImlzRW1wdHkiLCJ1bnNoaWZ0IiwibWVyZ2UiLCJlbXB0eSIsImVhY2giLCJpdGVyIiwiY3VycmVudExvY2F0aW9uIiwic3RhcnQiLCJmdW5jdGlvbkNhbGwiLCJnZW5lcmF0ZUxpc3QiLCJxdW90ZWRTdHJpbmciLCJzdHIiLCJyZXBsYWNlIiwib2JqZWN0TGl0ZXJhbCIsInBhaXJzIiwiZ2VuZXJhdGVBcnJheSIsIl9hc3QiLCJfYXN0MiIsImNvbXBpbGVyIiwiZXF1YWxzIiwib3RoZXIiLCJvcGNvZGVzIiwib3Bjb2RlIiwib3RoZXJPcGNvZGUiLCJhcmdFcXVhbHMiLCJhcmdzIiwiY2hpbGRyZW4iLCJndWlkIiwicHJvZ3JhbSIsInNvdXJjZU5vZGUiLCJzdHJpbmdQYXJhbXMiLCJ0cmFja0lkcyIsImJsb2NrUGFyYW1zIiwia25vd25IZWxwZXJzIiwiX25hbWUiLCJjb21waWxlUHJvZ3JhbSIsImNoaWxkQ29tcGlsZXIiLCJ1c2VQYXJ0aWFsIiwidXNlRGVwdGhzIiwiUHJvZ3JhbSIsImJvZHkiLCJib2R5TGVuZ3RoIiwiaXNTaW1wbGUiLCJCbG9ja1N0YXRlbWVudCIsImJsb2NrIiwidHJhbnNmb3JtTGl0ZXJhbFRvUGF0aCIsImludmVyc2UiLCJjbGFzc2lmeVNleHByIiwiaGVscGVyU2V4cHIiLCJzaW1wbGVTZXhwciIsImFtYmlndW91c1NleHByIiwiRGVjb3JhdG9yQmxvY2siLCJkZWNvcmF0b3IiLCJzZXR1cEZ1bGxNdXN0YWNoZVBhcmFtcyIsInVzZURlY29yYXRvcnMiLCJQYXJ0aWFsU3RhdGVtZW50IiwiZXhwbGljaXRQYXJ0aWFsQ29udGV4dCIsInBhcnRpYWxOYW1lIiwiaXNEeW5hbWljIiwiaW5kZW50IiwicHJldmVudEluZGVudCIsIlBhcnRpYWxCbG9ja1N0YXRlbWVudCIsInBhcnRpYWxCbG9jayIsIk11c3RhY2hlU3RhdGVtZW50IiwibXVzdGFjaGUiLCJTdWJFeHByZXNzaW9uIiwiZXNjYXBlZCIsIm5vRXNjYXBlIiwiRGVjb3JhdG9yIiwiQ29udGVudFN0YXRlbWVudCIsImNvbnRlbnQiLCJDb21tZW50U3RhdGVtZW50Iiwic2V4cHIiLCJpc0Jsb2NrIiwic3RyaWN0Iiwia25vd25IZWxwZXJzT25seSIsImZhbHN5IiwiUGF0aEV4cHJlc3Npb24iLCJhZGREZXB0aCIsInNjb3BlZCIsImJsb2NrUGFyYW1JZCIsImJsb2NrUGFyYW1JbmRleCIsIlN0cmluZ0xpdGVyYWwiLCJzdHJpbmciLCJOdW1iZXJMaXRlcmFsIiwibnVtYmVyIiwiQm9vbGVhbkxpdGVyYWwiLCJib29sIiwiVW5kZWZpbmVkTGl0ZXJhbCIsIk51bGxMaXRlcmFsIiwiSGFzaCIsInB1c2hQYXJhbSIsImlzQmxvY2tQYXJhbSIsImlzSGVscGVyIiwiaXNFbGlnaWJsZSIsIl9uYW1lMiIsInB1c2hQYXJhbXMiLCJ2YWwiLCJibG9ja1BhcmFtQ2hpbGQiLCJvbWl0RW1wdHkiLCJwYXJhbSIsImVudiIsImNvbXBhdCIsImFzdCIsImVudmlyb25tZW50IiwiY29tcGlsZWQiLCJjb21waWxlSW5wdXQiLCJ0ZW1wbGF0ZVNwZWMiLCJjb250ZXh0IiwiZXhlY09wdGlvbnMiLCJfc2V0dXAiLCJzZXR1cE9wdGlvbnMiLCJfY2hpbGQiLCJkZXB0aHMiLCJiIiwibGl0ZXJhbCIsInN0cmlwRmxhZ3MiLCJzdHJpcENvbW1lbnQiLCJwcmVwYXJlUGF0aCIsInByZXBhcmVNdXN0YWNoZSIsInByZXBhcmVSYXdCbG9jayIsInByZXBhcmVCbG9jayIsInByZXBhcmVQcm9ncmFtIiwicHJlcGFyZVBhcnRpYWxCbG9jayIsInZhbGlkYXRlQ2xvc2UiLCJvcGVuIiwiY2xvc2UiLCJlcnJvck5vZGUiLCJmaXJzdF9saW5lIiwiZmlyc3RfY29sdW1uIiwiZW5kIiwibGFzdF9saW5lIiwibGFzdF9jb2x1bW4iLCJ0b2tlbiIsInN1YnN0ciIsImNvbW1lbnQiLCJkaWciLCJkZXB0aFN0cmluZyIsImlzTGl0ZXJhbCIsInNlcGFyYXRvciIsImVzY2FwZUZsYWciLCJvcGVuUmF3QmxvY2siLCJjb250ZW50cyIsIm9wZW5TdHJpcCIsImludmVyc2VTdHJpcCIsImNsb3NlU3RyaXAiLCJvcGVuQmxvY2siLCJpbnZlcnNlQW5kUHJvZ3JhbSIsImludmVydGVkIiwiY2hhaW4iLCJzdGF0ZW1lbnRzIiwiZmlyc3RMb2MiLCJsYXN0TG9jIiwiX2Jhc2UiLCJfY29kZUdlbiIsIl9jb2RlR2VuMiIsIkxpdGVyYWwiLCJuYW1lTG9va3VwIiwiaXNWYWxpZEphdmFTY3JpcHRWYXJpYWJsZU5hbWUiLCJKU09OIiwic3RyaW5naWZ5IiwiZGVwdGhlZExvb2t1cCIsImFsaWFzYWJsZSIsImNvbXBpbGVySW5mbyIsInJldmlzaW9uIiwidmVyc2lvbnMiLCJhcHBlbmRUb0J1ZmZlciIsImxvY2F0aW9uIiwiZXhwbGljaXQiLCJpbml0aWFsaXplQnVmZmVyIiwiYXNPYmplY3QiLCJpc0NoaWxkIiwicHJvZ3JhbXMiLCJlbnZpcm9ubWVudHMiLCJwcmVhbWJsZSIsInN0YWNrU2xvdCIsInN0YWNrVmFycyIsImFsaWFzZXMiLCJyZWdpc3RlcnMiLCJsaXN0IiwiaGFzaGVzIiwiY29tcGlsZVN0YWNrIiwiaW5saW5lU3RhY2siLCJjb21waWxlQ2hpbGRyZW4iLCJ1c2VCbG9ja1BhcmFtcyIsInB1c2hTb3VyY2UiLCJjcmVhdGVGdW5jdGlvbkNvbnRleHQiLCJtYWluIiwibWFpbl9kIiwiX2NvbnRleHQiLCJ1c2VEYXRhIiwiZmlsZSIsImRlc3ROYW1lIiwiY29tcGlsZXJPcHRpb25zIiwibGFzdENvbnRleHQiLCJ2YXJEZWNsYXJhdGlvbnMiLCJsb2NhbHMiLCJhbGlhc0NvdW50IiwiYWxpYXMiLCJyZWZlcmVuY2VDb3VudCIsIm1lcmdlU291cmNlIiwiYXBwZW5kT25seSIsImZvcmNlQnVmZmVyIiwiYXBwZW5kRmlyc3QiLCJzb3VyY2VTZWVuIiwiYnVmZmVyU3RhcnQiLCJidWZmZXJFbmQiLCJibG9ja1ZhbHVlIiwiYmxvY2tIZWxwZXJNaXNzaW5nIiwiY29udGV4dE5hbWUiLCJzZXR1cEhlbHBlckFyZ3MiLCJibG9ja05hbWUiLCJwb3BTdGFjayIsImFtYmlndW91c0Jsb2NrVmFsdWUiLCJmbHVzaElubGluZSIsImN1cnJlbnQiLCJ0b3BTdGFjayIsImxhc3RIZWxwZXIiLCJhcHBlbmRDb250ZW50IiwicGVuZGluZ0NvbnRlbnQiLCJwZW5kaW5nTG9jYXRpb24iLCJhcHBlbmQiLCJpc0lubGluZSIsInJlcGxhY2VTdGFjayIsImFwcGVuZEVzY2FwZWQiLCJnZXRDb250ZXh0IiwicHVzaENvbnRleHQiLCJwdXNoU3RhY2tMaXRlcmFsIiwibG9va3VwT25Db250ZXh0IiwicmVzb2x2ZVBhdGgiLCJsb29rdXBCbG9ja1BhcmFtIiwibG9va3VwRGF0YSIsIl90aGlzIiwiYXNzdW1lT2JqZWN0cyIsInN0cmljdExvb2t1cCIsImxvb2t1cCIsInJlc29sdmVQb3NzaWJsZUxhbWJkYSIsInB1c2hTdHJpbmdQYXJhbSIsInB1c2hTdHJpbmciLCJlbXB0eUhhc2giLCJwdXNoSGFzaCIsInZhbHVlcyIsInR5cGVzIiwiY29udGV4dHMiLCJpZHMiLCJwb3BIYXNoIiwicHVzaExpdGVyYWwiLCJwdXNoUHJvZ3JhbSIsInByb2dyYW1FeHByZXNzaW9uIiwicGFyYW1TaXplIiwiZm91bmREZWNvcmF0b3IiLCJpbnZva2VIZWxwZXIiLCJub25IZWxwZXIiLCJoZWxwZXIiLCJzZXR1cEhlbHBlciIsInNpbXBsZSIsImNhbGxQYXJhbXMiLCJpbnZva2VLbm93bkhlbHBlciIsImludm9rZUFtYmlndW91cyIsImhlbHBlckNhbGwiLCJ1c2VSZWdpc3RlciIsImhlbHBlck5hbWUiLCJwYXJhbXNJbml0IiwiaW52b2tlUGFydGlhbCIsInNldHVwUGFyYW1zIiwiYXNzaWduVG9IYXNoIiwicHVzaElkIiwiZXhpc3RpbmciLCJtYXRjaEV4aXN0aW5nUHJvZ3JhbSIsInByb2dyYW1QYXJhbXMiLCJleHByIiwiaXRlbSIsInN0YWNrIiwiY3JlYXRlZFN0YWNrIiwidXNlZExpdGVyYWwiLCJ0b3AiLCJpbmNyU3RhY2siLCJ0b3BTdGFja05hbWUiLCJ3cmFwcGVkIiwiaW5saW5lIiwiYmxvY2tIZWxwZXIiLCJmb3VuZEhlbHBlciIsImNhbGxDb250ZXh0Iiwib2JqZWN0QXJncyIsImhhc2hJZHMiLCJoYXNoVHlwZXMiLCJoYXNoQ29udGV4dHMiLCJyZXNlcnZlZFdvcmRzIiwiY29tcGlsZXJXb3JkcyIsIlJFU0VSVkVEX1dPUkRTIiwicmVxdWlyZVRlcm1pbmFsIiwiaGFuZGxlYmFycyIsInRyYWNlIiwic3ltYm9sc18iLCJ0ZXJtaW5hbHNfIiwicHJvZHVjdGlvbnNfIiwicGVyZm9ybUFjdGlvbiIsImFub255bW91cyIsInl5dGV4dCIsInl5bGVuZyIsInl5bGluZW5vIiwieXlzdGF0ZSIsIiQkIiwiXyQiLCIkMCIsIiQiLCJjaGFpbmVkIiwiTnVtYmVyIiwidGFibGUiLCJkZWZhdWx0QWN0aW9ucyIsInBhcnNlRXJyb3IiLCJ2c3RhY2siLCJsc3RhY2siLCJyZWNvdmVyaW5nIiwiVEVSUk9SIiwiRU9GIiwibGV4ZXIiLCJzZXRJbnB1dCIsInl5bGxvYyIsInl5bG9jIiwicmFuZ2VzIiwibGV4Iiwic3ltYm9sIiwicHJlRXJyb3JTeW1ib2wiLCJhY3Rpb24iLCJ5eXZhbCIsInAiLCJuZXdTdGF0ZSIsImV4cGVjdGVkIiwiZXJyU3RyIiwic2hvd1Bvc2l0aW9uIiwibWF0Y2giLCJyYW5nZSIsIl9tb3JlIiwiX2xlc3MiLCJkb25lIiwibWF0Y2hlZCIsImNvbmRpdGlvblN0YWNrIiwib2Zmc2V0IiwiY2giLCJsaW5lcyIsInVucHV0Iiwib2xkTGluZXMiLCJtb3JlIiwibGVzcyIsInBhc3RJbnB1dCIsInBhc3QiLCJ1cGNvbWluZ0lucHV0IiwibmV4dCIsInByZSIsInRlbXBNYXRjaCIsImNvbCIsInJ1bGVzIiwiX2N1cnJlbnRSdWxlcyIsImZsZXgiLCJtYXRjaGVzIiwiYmVnaW4iLCJjb25kaXRpb24iLCJwb3BTdGF0ZSIsImNvbmRpdGlvbnMiLCJ0b3BTdGF0ZSIsInB1c2hTdGF0ZSIsInl5XyIsIiRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMiLCJZWV9TVEFSVCIsIllZU1RBVEUiLCJwcmludCIsIlByaW50VmlzaXRvciIsIl92aXNpdG9yIiwiX3Zpc2l0b3IyIiwicGFkZGluZyIsInBhZCIsIm91dCIsInBhcmFtU3RyaW5ncyIsImpvaW5lZFBhaXJzIiwiSGFzaFBhaXIiLCJwYWlyIiwicGFyZW50cyIsIm11dGF0aW5nIiwiYWNjZXB0S2V5IiwiYWNjZXB0UmVxdWlyZWQiLCJhY2NlcHRBcnJheSIsImFycmF5IiwidmlzaXRTdWJFeHByZXNzaW9uIiwidmlzaXRCbG9jayIsInZpc2l0UGFydGlhbCIsIldoaXRlc3BhY2VDb250cm9sIiwiZG9TdGFuZGFsb25lIiwiaWdub3JlU3RhbmRhbG9uZSIsImlzUm9vdCIsImlzUm9vdFNlZW4iLCJfaXNQcmV2V2hpdGVzcGFjZSIsImlzUHJldldoaXRlc3BhY2UiLCJfaXNOZXh0V2hpdGVzcGFjZSIsImlzTmV4dFdoaXRlc3BhY2UiLCJvcGVuU3RhbmRhbG9uZSIsImNsb3NlU3RhbmRhbG9uZSIsImlubGluZVN0YW5kYWxvbmUiLCJvbWl0UmlnaHQiLCJvbWl0TGVmdCIsImV4ZWMiLCJmaXJzdEludmVyc2UiLCJsYXN0SW52ZXJzZSIsInByZXYiLCJzaWJsaW5nIiwibXVsdGlwbGUiLCJyaWdodFN0cmlwcGVkIiwibGVmdFN0cmlwcGVkIiwiX2RlY29yYXRvcnNJbmxpbmUiLCJfZGVjb3JhdG9yc0lubGluZTIiLCJpbnN0YW5jZSIsInByb3BzIiwiY29udGFpbmVyIiwiZXJyb3JQcm9wcyIsIm1lc3NhZ2UiLCJ0bXAiLCJpZHgiLCJjYXB0dXJlU3RhY2tUcmFjZSIsImxpbmVOdW1iZXIiLCJkZWZpbmVQcm9wZXJ0eSIsIm5vcCIsIl9oZWxwZXJzQmxvY2tIZWxwZXJNaXNzaW5nIiwiX2hlbHBlcnNCbG9ja0hlbHBlck1pc3NpbmcyIiwiX2hlbHBlcnNFYWNoIiwiX2hlbHBlcnNFYWNoMiIsIl9oZWxwZXJzSGVscGVyTWlzc2luZyIsIl9oZWxwZXJzSGVscGVyTWlzc2luZzIiLCJfaGVscGVyc0lmIiwiX2hlbHBlcnNJZjIiLCJfaGVscGVyc0xvZyIsIl9oZWxwZXJzTG9nMiIsIl9oZWxwZXJzTG9va3VwIiwiX2hlbHBlcnNMb29rdXAyIiwiX2hlbHBlcnNXaXRoIiwiX2hlbHBlcnNXaXRoMiIsImNvbnRleHRQYXRoIiwiYXBwZW5kQ29udGV4dFBhdGgiLCJleGVjSXRlcmF0aW9uIiwiZmllbGQiLCJsYXN0IiwiZmlyc3QiLCJqIiwicHJpb3JLZXkiLCJjb25kaXRpb25hbCIsImluY2x1ZGVaZXJvIiwibGV2ZWwiLCJtZXRob2RNYXAiLCJsb29rdXBMZXZlbCIsImxldmVsTWFwIiwidG9Mb3dlckNhc2UiLCJwYXJzZUludCIsImNvbnNvbGUiLCJtZXRob2QiLCJfbGVuIiwiX2tleSIsIkhhbmRsZWJhcnMiLCJyb290IiwiJEhhbmRsZWJhcnMiLCJub0NvbmZsaWN0IiwiY2hlY2tSZXZpc2lvbiIsIndyYXBQcm9ncmFtIiwicmVzb2x2ZVBhcnRpYWwiLCJjb21waWxlclJldmlzaW9uIiwiY3VycmVudFJldmlzaW9uIiwicnVudGltZVZlcnNpb25zIiwiY29tcGlsZXJWZXJzaW9ucyIsImludm9rZVBhcnRpYWxXcmFwcGVyIiwibGFtYmRhIiwiZGVjbGFyZWRCbG9ja1BhcmFtcyIsInByb2dyYW1XcmFwcGVyIiwiX3BhcmVudCIsImNvbW1vbiIsImluaXREYXRhIiwiZXhlY3V0ZURlY29yYXRvcnMiLCJpc1RvcCIsInByb2ciLCJjdXJyZW50RGVwdGhzIiwidG9IVE1MIiwiZXNjYXBlIiwiYmFkQ2hhcnMiLCJwb3NzaWJsZSIsImVzY2FwZUNoYXIiLCJjaHIiLCJmcmFtZSIsInByaW50ZXIiLCJleHRlbnNpb24iLCJmcyIsInRlbXBsYXRlU3RyaW5nIiwicmVhZEZpbGVTeW5jIiwiZXh0ZW5zaW9ucyIsIl9jcmVhdGVDbGFzcyIsImRlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NsYXNzQ2FsbENoZWNrIiwiZW5zdXJlUGF0aEFycmF5IiwicGF0aHMiLCJSZXNvdXJjZU1hbmFnZXIiLCJfaGVhZCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiX2Nzc1BhdGhzIiwiX3NjcmlwdE1hcHMiLCJfZGF0YVByb21pc2VzIiwibG9hZFNjcmlwdCIsInNjcmlwdCIsImxvYWRQcm9taXNlcyIsImZvckVhY2giLCJjcmVhdGVTY3JpcHRFbGVtZW50Iiwic2V0QXR0cmlidXRlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImFwcGVuZENoaWxkIiwiYmluZCIsInVubG9hZFNjcmlwdCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJyZW1vdmVDaGlsZCIsImNyZWF0ZUVsZW1lbnQiLCJmZXRjaERhdGEiLCJ1cmwiLCJyZXFPcHRpb25zIiwiY2FjaGVJZCIsImNhY2hlIiwiZmV0Y2giLCJjYXRjaCIsImxvYWRDc3MiLCJlbCIsInVubG9hZENzcyIsImxvYWRUZW1wbGF0ZSIsImhic0RhdGEiLCJpc0hhbmRsZWJhckZpbGUiLCJmcmFncyIsImV4dCIsInJlc3AiLCJpbm5lckhUTUwiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZGVmYXVsdCIsIl90eXBlb2YiLCJTeW1ib2wiLCJpdGVyYXRvciIsIl9yZXNvdXJjZU1hbmFnZXJKcyIsIl9yZXNvdXJjZU1hbmFnZXJKczIiLCJnZXRDc3NQcm9wVW5pdE1hcCIsInYiLCJ0cmltIiwibnVtIiwidW5pdCIsImNvbnZlcnRDc3NUaW1lVmFsdWVUb01pbGxpc2Vjb25kcyIsImdldEpzUHJvcE5hbWUiLCJjc3NQcm9wIiwibGV0dGVyIiwidG9VcHBlckNhc2UiLCJ0cmF2ZXJzZUVhY2hQYXJlbnQiLCJzdGFydEVsIiwicGFyZW50Tm9kZSIsInByZWRpY2F0ZSIsImNsYXNzTmFtZSIsIk1vZHVsZSIsImRlZmF1bHRPcHRpb25zIiwibG9hZGVkQ2xhc3MiLCJhY3RpdmVDbGFzcyIsImRpc2FibGVkQ2xhc3MiLCJlcnJvckNsYXNzIiwic3R5bGVzIiwicmVxdWVzdE9wdGlvbnMiLCJvbkxvYWQiLCJvblNob3ciLCJvbkhpZGUiLCJvbkVuYWJsZSIsIm9uRGlzYWJsZSIsIm9uRXJyb3IiLCJfaGFuZGxlRWxlbWVudEluaXRpYWxTdGF0ZSIsInN1Yk1vZHVsZXMiLCJhY3RpdmUiLCJsb2FkZWQiLCJfZWxDaGlsZHJlbiIsImxvYWRTdGF0dXMiLCJ2aWV3IiwiZ2V0U3R5bGVzIiwiZ2V0VGVtcGxhdGUiLCJub2RlcyIsImZyYWciLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiY2xhc3NMaXN0IiwiY3NzVXJsIiwiX2lzSFRNTFRlbXBsYXRlIiwidHBsIiwiaW1wb3J0Tm9kZSIsImNoaWxkTm9kZXMiLCJIVE1MRWxlbWVudCIsIl9yZXQiLCJ0ZW1wRGl2IiwiaHRtbCIsIkhUTUxUZW1wbGF0ZUVsZW1lbnQiLCJlcnJvcmVkIiwid2FpdEZvclRyYW5zaXRpb24iLCJlbmFibGUiLCJyZW1vdmUiLCJkaXNhYmxlZCIsImRpc2FibGUiLCJzaG93IiwiaGlkZSIsImNvbnRhaW5zIiwiX29yaWdEaXNhYmxlZCIsIl9vcmlnRXJyb3IiLCJfcmVzZXRFbGVtZW50SW5pdGlhbFN0YXRlIiwiX3RoaXMyIiwiZHVyYXRpb24iLCJnZXRUcmFuc2l0aW9uRHVyYXRpb24iLCJkZWxheVByb3AiLCJnZXRDc3NDb21wdXRlZFByb3BlcnR5IiwiZHVyYXRpb25Qcm9wIiwidGltZXMiLCJkZWxheSIsImhpZ2hlc3QiLCJwcm9wIiwic3R5bGUiLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsImdldENsb3Nlc3RBbmNlc3RvckVsZW1lbnRCeUNsYXNzTmFtZSIsInN0YXJ0VGFyZ2V0IiwiZGVzdHJveSIsIl90aGlzMyIsIkxBU1RfRVJST1IiLCJJU19FUlJPUiIsImV4IiwidHJ5Q2FsbE9uZSIsInRyeUNhbGxUd28iLCJfNDUiLCJfODEiLCJfNjUiLCJfNTQiLCJkb1Jlc29sdmUiLCJfMTAiLCJfOTciLCJfNjEiLCJvbkZ1bGZpbGxlZCIsIm9uUmVqZWN0ZWQiLCJzYWZlVGhlbiIsInJlcyIsImhhbmRsZSIsIkhhbmRsZXIiLCJkZWZlcnJlZCIsImhhbmRsZVJlc29sdmVkIiwiY2IiLCJuZXdWYWx1ZSIsImZpbmFsZSIsIlRSVUUiLCJ2YWx1ZVByb21pc2UiLCJGQUxTRSIsIk5VTEwiLCJVTkRFRklORUQiLCJaRVJPIiwiRU1QVFlTVFJJTkciLCJhcnIiLCJyZW1haW5pbmciLCJkZW5vZGVpZnkiLCJhcmd1bWVudENvdW50IiwiSW5maW5pdHkiLCJkZW5vZGVpZnlXaXRoQ291bnQiLCJkZW5vZGVpZnlXaXRob3V0Q291bnQiLCJjYWxsYmFja0ZuIiwiZm5MZW5ndGgiLCJtYXgiLCJub2RlaWZ5IiwiY3R4IiwiZW5hYmxlU3luY2hyb25vdXMiLCJpc1BlbmRpbmciLCJnZXRTdGF0ZSIsImlzRnVsZmlsbGVkIiwiaXNSZWplY3RlZCIsImdldFZhbHVlIiwiZ2V0UmVhc29uIiwiZGlzYWJsZVN5bmNocm9ub3VzIiwiU291cmNlTWFwR2VuZXJhdG9yIiwiU291cmNlTWFwQ29uc3VtZXIiLCJ1dGlsIiwiQXJyYXlTZXQiLCJfYXJyYXkiLCJfc2V0IiwiZnJvbUFycmF5IiwiQXJyYXlTZXRfZnJvbUFycmF5IiwiYUFycmF5IiwiYUFsbG93RHVwbGljYXRlcyIsInNldCIsInNpemUiLCJBcnJheVNldF9zaXplIiwiQXJyYXlTZXRfYWRkIiwiYVN0ciIsImlzRHVwbGljYXRlIiwiaGFzIiwidG9TZXRTdHJpbmciLCJBcnJheVNldF9oYXMiLCJBcnJheVNldF9pbmRleE9mIiwiYXQiLCJBcnJheVNldF9hdCIsImFJZHgiLCJ0b0FycmF5IiwiQXJyYXlTZXRfdG9BcnJheSIsImJhc2U2NCIsIlZMUV9CQVNFX1NISUZUIiwiVkxRX0JBU0UiLCJWTFFfQkFTRV9NQVNLIiwiVkxRX0NPTlRJTlVBVElPTl9CSVQiLCJ0b1ZMUVNpZ25lZCIsImFWYWx1ZSIsImZyb21WTFFTaWduZWQiLCJpc05lZ2F0aXZlIiwic2hpZnRlZCIsImVuY29kZSIsImJhc2U2NFZMUV9lbmNvZGUiLCJlbmNvZGVkIiwiZGlnaXQiLCJ2bHEiLCJkZWNvZGUiLCJiYXNlNjRWTFFfZGVjb2RlIiwiYUluZGV4IiwiYU91dFBhcmFtIiwic3RyTGVuIiwiY29udGludWF0aW9uIiwiY2hhckNvZGVBdCIsInJlc3QiLCJpbnRUb0NoYXJNYXAiLCJhTnVtYmVyIiwiY2hhckNvZGUiLCJiaWdBIiwiYmlnWiIsImxpdHRsZUEiLCJsaXR0bGVaIiwiemVybyIsIm5pbmUiLCJwbHVzIiwic2xhc2giLCJsaXR0bGVPZmZzZXQiLCJudW1iZXJPZmZzZXQiLCJHUkVBVEVTVF9MT1dFUl9CT1VORCIsIkxFQVNUX1VQUEVSX0JPVU5EIiwicmVjdXJzaXZlU2VhcmNoIiwiYUxvdyIsImFIaWdoIiwiYU5lZWRsZSIsImFIYXlzdGFjayIsImFDb21wYXJlIiwiYUJpYXMiLCJtaWQiLCJmbG9vciIsImNtcCIsInNlYXJjaCIsImdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIiLCJtYXBwaW5nQSIsIm1hcHBpbmdCIiwibGluZUEiLCJnZW5lcmF0ZWRMaW5lIiwibGluZUIiLCJjb2x1bW5BIiwiZ2VuZXJhdGVkQ29sdW1uIiwiY29sdW1uQiIsImNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkIiwiTWFwcGluZ0xpc3QiLCJfc29ydGVkIiwiX2xhc3QiLCJ1bnNvcnRlZEZvckVhY2giLCJNYXBwaW5nTGlzdF9mb3JFYWNoIiwiYUNhbGxiYWNrIiwiYVRoaXNBcmciLCJNYXBwaW5nTGlzdF9hZGQiLCJhTWFwcGluZyIsIm1hcHBpbmciLCJNYXBwaW5nTGlzdF90b0FycmF5Iiwic29ydCIsInN3YXAiLCJ5IiwidGVtcCIsInJhbmRvbUludEluUmFuZ2UiLCJsb3ciLCJoaWdoIiwicm91bmQiLCJkb1F1aWNrU29ydCIsImNvbXBhcmF0b3IiLCJwaXZvdEluZGV4IiwicGl2b3QiLCJxIiwicXVpY2tTb3J0IiwiYmluYXJ5U2VhcmNoIiwiYmFzZTY0VkxRIiwiYVNvdXJjZU1hcCIsInNvdXJjZU1hcCIsInNlY3Rpb25zIiwiSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyIiwiQmFzaWNTb3VyY2VNYXBDb25zdW1lciIsImZyb21Tb3VyY2VNYXAiLCJfdmVyc2lvbiIsIl9fZ2VuZXJhdGVkTWFwcGluZ3MiLCJnZXQiLCJfcGFyc2VNYXBwaW5ncyIsIl9tYXBwaW5ncyIsInNvdXJjZVJvb3QiLCJfX29yaWdpbmFsTWFwcGluZ3MiLCJfY2hhcklzTWFwcGluZ1NlcGFyYXRvciIsIlNvdXJjZU1hcENvbnN1bWVyX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IiLCJTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzIiwiYVNvdXJjZVJvb3QiLCJHRU5FUkFURURfT1JERVIiLCJPUklHSU5BTF9PUkRFUiIsImVhY2hNYXBwaW5nIiwiU291cmNlTWFwQ29uc3VtZXJfZWFjaE1hcHBpbmciLCJhQ29udGV4dCIsImFPcmRlciIsIm9yZGVyIiwibWFwcGluZ3MiLCJfZ2VuZXJhdGVkTWFwcGluZ3MiLCJfb3JpZ2luYWxNYXBwaW5ncyIsIl9zb3VyY2VzIiwib3JpZ2luYWxMaW5lIiwib3JpZ2luYWxDb2x1bW4iLCJfbmFtZXMiLCJhbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IiLCJTb3VyY2VNYXBDb25zdW1lcl9hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IiLCJhQXJncyIsImdldEFyZyIsIm5lZWRsZSIsInJlbGF0aXZlIiwiX2ZpbmRNYXBwaW5nIiwiY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMiLCJsYXN0Q29sdW1uIiwidmVyc2lvbiIsInNvdXJjZXMiLCJuYW1lcyIsInNvdXJjZXNDb250ZW50IiwiY29uc3VtZXIiLCJTb3VyY2VNYXBDb25zdW1lcl9mcm9tU291cmNlTWFwIiwic21jIiwiX3NvdXJjZVJvb3QiLCJfZ2VuZXJhdGVTb3VyY2VzQ29udGVudCIsIl9maWxlIiwiZ2VuZXJhdGVkTWFwcGluZ3MiLCJkZXN0R2VuZXJhdGVkTWFwcGluZ3MiLCJkZXN0T3JpZ2luYWxNYXBwaW5ncyIsInNyY01hcHBpbmciLCJkZXN0TWFwcGluZyIsIk1hcHBpbmciLCJwcmV2aW91c0dlbmVyYXRlZENvbHVtbiIsInByZXZpb3VzT3JpZ2luYWxMaW5lIiwicHJldmlvdXNPcmlnaW5hbENvbHVtbiIsInByZXZpb3VzU291cmNlIiwicHJldmlvdXNOYW1lIiwiY2FjaGVkU2VnbWVudHMiLCJvcmlnaW5hbE1hcHBpbmdzIiwic2VnbWVudCIsImNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkIiwiU291cmNlTWFwQ29uc3VtZXJfZmluZE1hcHBpbmciLCJhTWFwcGluZ3MiLCJhTGluZU5hbWUiLCJhQ29sdW1uTmFtZSIsImFDb21wYXJhdG9yIiwiY29tcHV0ZUNvbHVtblNwYW5zIiwiU291cmNlTWFwQ29uc3VtZXJfY29tcHV0ZUNvbHVtblNwYW5zIiwibmV4dE1hcHBpbmciLCJsYXN0R2VuZXJhdGVkQ29sdW1uIiwib3JpZ2luYWxQb3NpdGlvbkZvciIsIlNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IiLCJoYXNDb250ZW50c09mQWxsU291cmNlcyIsIkJhc2ljU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMiLCJzb21lIiwic2MiLCJzb3VyY2VDb250ZW50Rm9yIiwiU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvciIsImFTb3VyY2UiLCJudWxsT25NaXNzaW5nIiwidXJsUGFyc2UiLCJmaWxlVXJpQWJzUGF0aCIsInNjaGVtZSIsImdlbmVyYXRlZFBvc2l0aW9uRm9yIiwiU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IiLCJsYXN0T2Zmc2V0IiwiX3NlY3Rpb25zIiwib2Zmc2V0TGluZSIsIm9mZnNldENvbHVtbiIsImdlbmVyYXRlZE9mZnNldCIsIkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yIiwic2VjdGlvbkluZGV4Iiwic2VjdGlvbiIsImJpYXMiLCJJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMiLCJldmVyeSIsIkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yIiwiSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yIiwiZ2VuZXJhdGVkUG9zaXRpb24iLCJJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyIsInNlY3Rpb25NYXBwaW5ncyIsImFkanVzdGVkTWFwcGluZyIsIl9za2lwVmFsaWRhdGlvbiIsIl9zb3VyY2VzQ29udGVudHMiLCJTb3VyY2VNYXBHZW5lcmF0b3JfZnJvbVNvdXJjZU1hcCIsImFTb3VyY2VNYXBDb25zdW1lciIsImdlbmVyYXRvciIsIm5ld01hcHBpbmciLCJnZW5lcmF0ZWQiLCJhZGRNYXBwaW5nIiwic291cmNlRmlsZSIsInNldFNvdXJjZUNvbnRlbnQiLCJTb3VyY2VNYXBHZW5lcmF0b3JfYWRkTWFwcGluZyIsIl92YWxpZGF0ZU1hcHBpbmciLCJTb3VyY2VNYXBHZW5lcmF0b3Jfc2V0U291cmNlQ29udGVudCIsImFTb3VyY2VGaWxlIiwiYVNvdXJjZUNvbnRlbnQiLCJrZXlzIiwiYXBwbHlTb3VyY2VNYXAiLCJTb3VyY2VNYXBHZW5lcmF0b3JfYXBwbHlTb3VyY2VNYXAiLCJhU291cmNlTWFwUGF0aCIsIm5ld1NvdXJjZXMiLCJuZXdOYW1lcyIsIlNvdXJjZU1hcEdlbmVyYXRvcl92YWxpZGF0ZU1hcHBpbmciLCJhR2VuZXJhdGVkIiwiYU9yaWdpbmFsIiwiYU5hbWUiLCJfc2VyaWFsaXplTWFwcGluZ3MiLCJTb3VyY2VNYXBHZW5lcmF0b3Jfc2VyaWFsaXplTWFwcGluZ3MiLCJwcmV2aW91c0dlbmVyYXRlZExpbmUiLCJTb3VyY2VNYXBHZW5lcmF0b3JfZ2VuZXJhdGVTb3VyY2VzQ29udGVudCIsImFTb3VyY2VzIiwidG9KU09OIiwiU291cmNlTWFwR2VuZXJhdG9yX3RvSlNPTiIsIlNvdXJjZU1hcEdlbmVyYXRvcl90b1N0cmluZyIsIlJFR0VYX05FV0xJTkUiLCJORVdMSU5FX0NPREUiLCJpc1NvdXJjZU5vZGUiLCJhTGluZSIsImFDb2x1bW4iLCJhQ2h1bmtzIiwic291cmNlQ29udGVudHMiLCJmcm9tU3RyaW5nV2l0aFNvdXJjZU1hcCIsIlNvdXJjZU5vZGVfZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAiLCJhR2VuZXJhdGVkQ29kZSIsImFSZWxhdGl2ZVBhdGgiLCJyZW1haW5pbmdMaW5lcyIsInNoaWZ0TmV4dExpbmUiLCJsaW5lQ29udGVudHMiLCJuZXdMaW5lIiwibGFzdEdlbmVyYXRlZExpbmUiLCJsYXN0TWFwcGluZyIsImFkZE1hcHBpbmdXaXRoQ29kZSIsIm5leHRMaW5lIiwiU291cmNlTm9kZV9hZGQiLCJhQ2h1bmsiLCJTb3VyY2VOb2RlX3ByZXBlbmQiLCJ3YWxrIiwiU291cmNlTm9kZV93YWxrIiwiYUZuIiwiU291cmNlTm9kZV9qb2luIiwiYVNlcCIsIm5ld0NoaWxkcmVuIiwicmVwbGFjZVJpZ2h0IiwiU291cmNlTm9kZV9yZXBsYWNlUmlnaHQiLCJhUGF0dGVybiIsImFSZXBsYWNlbWVudCIsImxhc3RDaGlsZCIsIlNvdXJjZU5vZGVfc2V0U291cmNlQ29udGVudCIsIndhbGtTb3VyY2VDb250ZW50cyIsIlNvdXJjZU5vZGVfd2Fsa1NvdXJjZUNvbnRlbnRzIiwiZnJvbVNldFN0cmluZyIsIlNvdXJjZU5vZGVfdG9TdHJpbmciLCJTb3VyY2VOb2RlX3RvU3RyaW5nV2l0aFNvdXJjZU1hcCIsInNvdXJjZU1hcHBpbmdBY3RpdmUiLCJsYXN0T3JpZ2luYWxTb3VyY2UiLCJsYXN0T3JpZ2luYWxMaW5lIiwibGFzdE9yaWdpbmFsQ29sdW1uIiwibGFzdE9yaWdpbmFsTmFtZSIsInNvdXJjZUNvbnRlbnQiLCJhRGVmYXVsdFZhbHVlIiwidXJsUmVnZXhwIiwiZGF0YVVybFJlZ2V4cCIsImFVcmwiLCJhdXRoIiwiaG9zdCIsInBvcnQiLCJ1cmxHZW5lcmF0ZSIsImFQYXJzZWRVcmwiLCJhUGF0aCIsImlzQWJzb2x1dGUiLCJ1cCIsImFSb290IiwiYVBhdGhVcmwiLCJhUm9vdFVybCIsImpvaW5lZCIsImxhc3RJbmRleE9mIiwib25seUNvbXBhcmVPcmlnaW5hbCIsIm9ubHlDb21wYXJlR2VuZXJhdGVkIiwic3RyY21wIiwiYVN0cjEiLCJhU3RyMiIsInN1cHBvcnQiLCJzZWFyY2hQYXJhbXMiLCJpdGVyYWJsZSIsImJsb2IiLCJCbG9iIiwiZm9ybURhdGEiLCJhcnJheUJ1ZmZlciIsInZpZXdDbGFzc2VzIiwiaXNEYXRhVmlldyIsIkRhdGFWaWV3IiwiaXNQcm90b3R5cGVPZiIsImlzQXJyYXlCdWZmZXJWaWV3IiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJub3JtYWxpemVOYW1lIiwiU3RyaW5nIiwibm9ybWFsaXplVmFsdWUiLCJpdGVyYXRvckZvciIsIml0ZW1zIiwiSGVhZGVycyIsImhlYWRlcnMiLCJnZXRBbGwiLCJ0aGlzQXJnIiwiY29uc3VtZWQiLCJib2R5VXNlZCIsImZpbGVSZWFkZXJSZWFkeSIsInJlYWRlciIsIm9ubG9hZCIsInJlYWRCbG9iQXNBcnJheUJ1ZmZlciIsIkZpbGVSZWFkZXIiLCJyZWFkQXNBcnJheUJ1ZmZlciIsInJlYWRCbG9iQXNUZXh0IiwicmVhZEFzVGV4dCIsInJlYWRBcnJheUJ1ZmZlckFzVGV4dCIsImJ1ZiIsIlVpbnQ4QXJyYXkiLCJjaGFycyIsImZyb21DaGFyQ29kZSIsImJ1ZmZlckNsb25lIiwiYnl0ZUxlbmd0aCIsImJ1ZmZlciIsIkJvZHkiLCJfaW5pdEJvZHkiLCJfYm9keUluaXQiLCJfYm9keVRleHQiLCJfYm9keUJsb2IiLCJGb3JtRGF0YSIsIl9ib2R5Rm9ybURhdGEiLCJVUkxTZWFyY2hQYXJhbXMiLCJfYm9keUFycmF5QnVmZmVyIiwicmVqZWN0ZWQiLCJqc29uIiwibWV0aG9kcyIsIm5vcm1hbGl6ZU1ldGhvZCIsInVwY2FzZWQiLCJSZXF1ZXN0IiwiY3JlZGVudGlhbHMiLCJtb2RlIiwicmVmZXJyZXIiLCJjbG9uZSIsImZvcm0iLCJieXRlcyIsImRlY29kZVVSSUNvbXBvbmVudCIsInBhcnNlSGVhZGVycyIsInJhd0hlYWRlcnMiLCJSZXNwb25zZSIsImJvZHlJbml0Iiwic3RhdHVzIiwib2siLCJzdGF0dXNUZXh0IiwicmVzcG9uc2UiLCJyZWRpcmVjdFN0YXR1c2VzIiwicmVkaXJlY3QiLCJSYW5nZUVycm9yIiwiaW5pdCIsInJlcXVlc3QiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsInJlc3BvbnNlVVJMIiwicmVzcG9uc2VUZXh0Iiwib250aW1lb3V0Iiwid2l0aENyZWRlbnRpYWxzIiwicmVzcG9uc2VUeXBlIiwic2V0UmVxdWVzdEhlYWRlciIsInNlbmQiLCJfZXh0ZW5kcyIsImFzc2lnbiIsIkNhcm91c2VsQXJyb3dzIiwibGVmdEFycm93IiwicmlnaHRBcnJvdyIsInBhbmVscyIsImFycm93RGlzYWJsZWRDbGFzcyIsIm9uTGVmdEFycm93Q2xpY2siLCJvblJpZ2h0QXJyb3dDbGljayIsImluaXRpYWxJbmRleCIsImFycm93cyIsIl9sZWZ0QXJyb3dFdmVudExpc3RlbmVyIiwiX3JpZ2h0QXJyb3dFdmVudExpc3RlbmVyIiwidXBkYXRlIiwicGFuZWxJbmRleCIsImN1cnJlbnRJdGVtTnVtIiwibWF4SXRlbXMiLCJtaW5JdGVtcyIsImRpc2FibGVSaWdodEFycm93IiwiZW5hYmxlTGVmdEFycm93IiwiZGlzYWJsZUxlZnRBcnJvdyIsImVuYWJsZVJpZ2h0QXJyb3ciLCJpc0Rpc2FibGVkIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIl9nZXQiLCJwcm9wZXJ0eSIsInJlY2VpdmVyIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldFByb3RvdHlwZU9mIiwiZ2V0dGVyIiwiX3Byb21pc2UiLCJfcHJvbWlzZTIiLCJfbW9kdWxlSnMiLCJfbW9kdWxlSnMyIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJSZWZlcmVuY2VFcnJvciIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiQ2Fyb3VzZWxQYW5lbCIsIl9Nb2R1bGUiLCJsYXp5TG9hZEF0dHIiLCJhc3NldExvYWRlZENsYXNzIiwiX2xvYWRhYmxlSW1hZ2VzIiwiaW1nRWwiLCJfbG9hZEltYWdlIiwidGFnTmFtZSIsImdldEF0dHJpYnV0ZSIsImltZyIsIl9jYXJvdXNlbFBhbmVsIiwiX2Nhcm91c2VsUGFuZWwyIiwiQ2Fyb3VzZWxQYW5lbHMiLCJwYW5lbEFjdGl2ZUNsYXNzIiwicGFuZWxMb2FkZWRDbGFzcyIsIm9uQ2hhbmdlIiwicGFuZWxCYWNrQ2xhc3MiLCJwYW5lbEZvcndhcmRDbGFzcyIsIl9wYW5lbE1vZHVsZXMiLCJfc2V0dXBQYW5lbE1vZHVsZXMiLCJwYW5lbCIsIm1vZHVsZXMiLCJnb1RvIiwibWF4SW5kZXgiLCJtaW5JbmRleCIsInByZXZJbmRleCIsImdldEN1cnJlbnRJbmRleCIsImVycm9yTXNnIiwiX3VwZGF0ZVBhbmVscyIsIl9jdXJyZW50SW5kZXgiLCJ0b0luZGV4IiwiZnJvbUluZGV4IiwiZnJvbVBhbmVsIiwidG9QYW5lbCIsInJhbmdlUGFuZWxzIiwidG9BZGQiLCJ0b1JlbW92ZSIsInBhbmVsTW9kdWxlIiwibG9hZFBhbmVsQXNzZXRzIiwiQ2Fyb3VzZWxUaHVtYnMiLCJ0aHVtYm5haWxzIiwidGh1bWJuYWlsQWN0aXZlVHJpZ2dlckV2ZW50IiwidGh1bWJuYWlsQWN0aXZlQ2xhc3MiLCJfdGh1bWJuYWlsRXZlbnRMaXN0ZW5lciIsIm9uVGh1bWJuYWlsRXZlbnQiLCJzZXR1cCIsInRodW1icyIsInRyaWdnZXJUaHVtYnNFdmVudExpc3RlbmVyIiwiX3RodW1ibmFpbEFyciIsImN1cnJlbnRUYXJnZXQiLCJfY2hlY2tGb3JJbml0RXJyb3JzIiwidGh1bWJuYWlsQ291bnQiLCJjb3VudCIsIl9jYXJvdXNlbFRodW1icyIsIl9jYXJvdXNlbFRodW1iczIiLCJfY2Fyb3VzZWxQYW5lbHMiLCJfY2Fyb3VzZWxQYW5lbHMyIiwiX2Nhcm91c2VsQXJyb3dzIiwiX2Nhcm91c2VsQXJyb3dzMiIsImFzc2V0TG9hZGluZ0NsYXNzIiwiYXV0b0xvYWRBc3NldHMiLCJvblBhbmVsQ2hhbmdlIiwiYXJyb3dBY3RpdmVDbGFzcyIsIl9zZXR1cFBhbmVscyIsIl9zZXR1cFRodW1icyIsIl9zZXR1cEFycm93cyIsIm9uVGh1bWJuYWlsQ2hhbmdlIiwiaW50ZXJuYWxPcHRpb25zIiwicGFuZWxDb3VudCIsIndhcm4iLCJub3JtYWxpemVBcnJheSIsImFsbG93QWJvdmVSb290Iiwic3BsaXRQYXRoUmUiLCJzcGxpdFBhdGgiLCJyZXNvbHZlZFBhdGgiLCJyZXNvbHZlZEFic29sdXRlIiwiY3dkIiwiZmlsdGVyIiwidHJhaWxpbmdTbGFzaCIsImZyb20iLCJ0byIsImZyb21QYXJ0cyIsInRvUGFydHMiLCJtaW4iLCJzYW1lUGFydHNMZW5ndGgiLCJvdXRwdXRQYXJ0cyIsInNlcCIsImRlbGltaXRlciIsImRpciIsImJhc2VuYW1lIiwiZXh0bmFtZSIsInhzIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsInJ1bkNsZWFyVGltZW91dCIsIm1hcmtlciIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwicnVuIiwiSXRlbSIsInRpdGxlIiwiYnJvd3NlciIsImFyZ3YiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwi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NzVDLElBQWI7QUFDQXhKLGNBQVFzakQsV0FBUixHQUFzQjk1QyxJQUF0QjtBQUNBeEosY0FBUXVqRCxJQUFSLEdBQWUvNUMsSUFBZjtBQUNBeEosY0FBUXdqRCxHQUFSLEdBQWNoNkMsSUFBZDtBQUNBeEosY0FBUXlqRCxjQUFSLEdBQXlCajZDLElBQXpCO0FBQ0F4SixjQUFRMGpELGtCQUFSLEdBQTZCbDZDLElBQTdCO0FBQ0F4SixjQUFRMmpELElBQVIsR0FBZW42QyxJQUFmOztBQUVBeEosY0FBUTRqRCxPQUFSLEdBQWtCLFVBQVU3aUQsSUFBVixFQUFnQjtBQUM5QixjQUFNLElBQUlwQixLQUFKLENBQVUsa0NBQVYsQ0FBTjtBQUNILE9BRkQ7O0FBSUFLLGNBQVFraEQsR0FBUixHQUFjLFlBQVksQ0FBRSxPQUFPLEdBQVAsQ0FBWSxDQUF4QztBQUNBbGhELGNBQVE2akQsS0FBUixHQUFnQixVQUFVL0IsR0FBVixFQUFlO0FBQzNCLGNBQU0sSUFBSW5pRCxLQUFKLENBQVUsZ0NBQVYsQ0FBTjtBQUNILE9BRkQ7QUFHQUssY0FBUThqRCxLQUFSLEdBQWdCLFlBQVcsQ0FBRSxPQUFPLENBQVAsQ0FBVyxDQUF4Qzs7QUFFQyxLQXRMcUIsRUFzTHBCLEVBdExvQixDQWw0WXF4QixFQUEzYixFQXdqWnpXLEVBeGpaeVcsRUF3alp0VyxDQUFDLEVBQUQsQ0F4alpzVyxFQXdqWmhXLEVBeGpaZ1csQ0FBUDtBQXlqWnhXLENBempaRCIsImZpbGUiOiJjYXJvdXNlbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBcbiogY2Fyb3VzZWwtanMgLSB2My4xLjEuXG4qIGdpdDovL2dpdGh1Yi5jb20vbWtheTU4MS9jYXJvdXNlbC1qcy5naXRcbiogQ29weXJpZ2h0IDIwMTYgTWFyayBLZW5uZWR5LiBMaWNlbnNlZCBNSVQuXG4qL1xuXG4oZnVuY3Rpb24oZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiJiZ0eXBlb2YgbW9kdWxlIT09XCJ1bmRlZmluZWRcIil7bW9kdWxlLmV4cG9ydHM9ZigpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtdLGYpfWVsc2V7dmFyIGc7aWYodHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCIpe2c9d2luZG93fWVsc2UgaWYodHlwZW9mIGdsb2JhbCE9PVwidW5kZWZpbmVkXCIpe2c9Z2xvYmFsfWVsc2UgaWYodHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiKXtnPXNlbGZ9ZWxzZXtnPXRoaXN9Zy5DYXJvdXNlbCA9IGYoKX19KShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxfX2ZpbGVuYW1lKXtcbi8qKiB2aW06IGV0OnRzPTQ6c3c9NDpzdHM9NFxuICogQGxpY2Vuc2UgYW1kZWZpbmUgMS4wLjEgQ29weXJpZ2h0IChjKSAyMDExLTIwMTYsIFRoZSBEb2pvIEZvdW5kYXRpb24gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIEF2YWlsYWJsZSB2aWEgdGhlIE1JVCBvciBuZXcgQlNEIGxpY2Vuc2UuXG4gKiBzZWU6IGh0dHA6Ly9naXRodWIuY29tL2pyYnVya2UvYW1kZWZpbmUgZm9yIGRldGFpbHNcbiAqL1xuXG4vKmpzbGludCBub2RlOiB0cnVlICovXG4vKmdsb2JhbCBtb2R1bGUsIHByb2Nlc3MgKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVmaW5lIGZvciBub2RlLlxuICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSB0aGUgXCJtb2R1bGVcIiBvYmplY3QgdGhhdCBpcyBkZWZpbmVkIGJ5IE5vZGUgZm9yIHRoZVxuICogY3VycmVudCBtb2R1bGUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVxdWlyZUZuXS4gTm9kZSdzIHJlcXVpcmUgZnVuY3Rpb24gZm9yIHRoZSBjdXJyZW50IG1vZHVsZS5cbiAqIEl0IG9ubHkgbmVlZHMgdG8gYmUgcGFzc2VkIGluIE5vZGUgdmVyc2lvbnMgYmVmb3JlIDAuNSwgd2hlbiBtb2R1bGUucmVxdWlyZVxuICogZGlkIG5vdCBleGlzdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBkZWZpbmUgZnVuY3Rpb24gdGhhdCBpcyB1c2FibGUgZm9yIHRoZSBjdXJyZW50IG5vZGVcbiAqIG1vZHVsZS5cbiAqL1xuZnVuY3Rpb24gYW1kZWZpbmUobW9kdWxlLCByZXF1aXJlRm4pIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIGRlZmluZUNhY2hlID0ge30sXG4gICAgICAgIGxvYWRlckNhY2hlID0ge30sXG4gICAgICAgIGFscmVhZHlDYWxsZWQgPSBmYWxzZSxcbiAgICAgICAgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKSxcbiAgICAgICAgbWFrZVJlcXVpcmUsIHN0cmluZ1JlcXVpcmU7XG5cbiAgICAvKipcbiAgICAgKiBUcmltcyB0aGUgLiBhbmQgLi4gZnJvbSBhbiBhcnJheSBvZiBwYXRoIHNlZ21lbnRzLlxuICAgICAqIEl0IHdpbGwga2VlcCBhIGxlYWRpbmcgcGF0aCBzZWdtZW50IGlmIGEgLi4gd2lsbCBiZWNvbWVcbiAgICAgKiB0aGUgZmlyc3QgcGF0aCBzZWdtZW50LCB0byBoZWxwIHdpdGggbW9kdWxlIG5hbWUgbG9va3VwcyxcbiAgICAgKiB3aGljaCBhY3QgbGlrZSBwYXRocywgYnV0IGNhbiBiZSByZW1hcHBlZC4gQnV0IHRoZSBlbmQgcmVzdWx0LFxuICAgICAqIGFsbCBwYXRocyB0aGF0IHVzZSB0aGlzIGZ1bmN0aW9uIHNob3VsZCBsb29rIG5vcm1hbGl6ZWQuXG4gICAgICogTk9URTogdGhpcyBtZXRob2QgTU9ESUZJRVMgdGhlIGlucHV0IGFycmF5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyeSB0aGUgYXJyYXkgb2YgcGF0aCBzZWdtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltRG90cyhhcnkpIHtcbiAgICAgICAgdmFyIGksIHBhcnQ7XG4gICAgICAgIGZvciAoaSA9IDA7IGFyeVtpXTsgaSs9IDEpIHtcbiAgICAgICAgICAgIHBhcnQgPSBhcnlbaV07XG4gICAgICAgICAgICBpZiAocGFydCA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgYXJ5LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBpIC09IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMSAmJiAoYXJ5WzJdID09PSAnLi4nIHx8IGFyeVswXSA9PT0gJy4uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9FbmQgb2YgdGhlIGxpbmUuIEtlZXAgYXQgbGVhc3Qgb25lIG5vbi1kb3RcbiAgICAgICAgICAgICAgICAgICAgLy9wYXRoIHNlZ21lbnQgYXQgdGhlIGZyb250IHNvIGl0IGNhbiBiZSBtYXBwZWRcbiAgICAgICAgICAgICAgICAgICAgLy9jb3JyZWN0bHkgdG8gZGlzay4gT3RoZXJ3aXNlLCB0aGVyZSBpcyBsaWtlbHlcbiAgICAgICAgICAgICAgICAgICAgLy9ubyBwYXRoIG1hcHBpbmcgZm9yIGEgcGF0aCBzdGFydGluZyB3aXRoICcuLicuXG4gICAgICAgICAgICAgICAgICAgIC8vVGhpcyBjYW4gc3RpbGwgZmFpbCwgYnV0IGNhdGNoZXMgdGhlIG1vc3QgcmVhc29uYWJsZVxuICAgICAgICAgICAgICAgICAgICAvL3VzZXMgb2YgLi5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBhcnkuc3BsaWNlKGkgLSAxLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgaSAtPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZShuYW1lLCBiYXNlTmFtZSkge1xuICAgICAgICB2YXIgYmFzZVBhcnRzO1xuXG4gICAgICAgIC8vQWRqdXN0IGFueSByZWxhdGl2ZSBwYXRocy5cbiAgICAgICAgaWYgKG5hbWUgJiYgbmFtZS5jaGFyQXQoMCkgPT09ICcuJykge1xuICAgICAgICAgICAgLy9JZiBoYXZlIGEgYmFzZSBuYW1lLCB0cnkgdG8gbm9ybWFsaXplIGFnYWluc3QgaXQsXG4gICAgICAgICAgICAvL290aGVyd2lzZSwgYXNzdW1lIGl0IGlzIGEgdG9wLWxldmVsIHJlcXVpcmUgdGhhdCB3aWxsXG4gICAgICAgICAgICAvL2JlIHJlbGF0aXZlIHRvIGJhc2VVcmwgaW4gdGhlIGVuZC5cbiAgICAgICAgICAgIGlmIChiYXNlTmFtZSkge1xuICAgICAgICAgICAgICAgIGJhc2VQYXJ0cyA9IGJhc2VOYW1lLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICAgICAgYmFzZVBhcnRzID0gYmFzZVBhcnRzLnNsaWNlKDAsIGJhc2VQYXJ0cy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBiYXNlUGFydHMgPSBiYXNlUGFydHMuY29uY2F0KG5hbWUuc3BsaXQoJy8nKSk7XG4gICAgICAgICAgICAgICAgdHJpbURvdHMoYmFzZVBhcnRzKTtcbiAgICAgICAgICAgICAgICBuYW1lID0gYmFzZVBhcnRzLmpvaW4oJy8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgbm9ybWFsaXplKCkgZnVuY3Rpb24gcGFzc2VkIHRvIGEgbG9hZGVyIHBsdWdpbidzXG4gICAgICogbm9ybWFsaXplIG1ldGhvZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYWtlTm9ybWFsaXplKHJlbE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplKG5hbWUsIHJlbE5hbWUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VMb2FkKGlkKSB7XG4gICAgICAgIGZ1bmN0aW9uIGxvYWQodmFsdWUpIHtcbiAgICAgICAgICAgIGxvYWRlckNhY2hlW2lkXSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9hZC5mcm9tVGV4dCA9IGZ1bmN0aW9uIChpZCwgdGV4dCkge1xuICAgICAgICAgICAgLy9UaGlzIG9uZSBpcyBkaWZmaWN1bHQgYmVjYXVzZSB0aGUgdGV4dCBjYW4vcHJvYmFibHkgdXNlc1xuICAgICAgICAgICAgLy9kZWZpbmUsIGFuZCBhbnkgcmVsYXRpdmUgcGF0aHMgYW5kIHJlcXVpcmVzIHNob3VsZCBiZSByZWxhdGl2ZVxuICAgICAgICAgICAgLy90byB0aGF0IGlkIHdhcyBpdCB3b3VsZCBiZSBmb3VuZCBvbiBkaXNrLiBCdXQgdGhpcyB3b3VsZCByZXF1aXJlXG4gICAgICAgICAgICAvL2Jvb3RzdHJhcHBpbmcgYSBtb2R1bGUvcmVxdWlyZSBmYWlybHkgZGVlcGx5IGZyb20gbm9kZSBjb3JlLlxuICAgICAgICAgICAgLy9Ob3Qgc3VyZSBob3cgYmVzdCB0byBnbyBhYm91dCB0aGF0IHlldC5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYW1kZWZpbmUgZG9lcyBub3QgaW1wbGVtZW50IGxvYWQuZnJvbVRleHQnKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbG9hZDtcbiAgICB9XG5cbiAgICBtYWtlUmVxdWlyZSA9IGZ1bmN0aW9uIChzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIHJlbElkKSB7XG4gICAgICAgIGZ1bmN0aW9uIGFtZFJlcXVpcmUoZGVwcywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVwcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL1N5bmNocm9ub3VzLCBzaW5nbGUgbW9kdWxlIHJlcXVpcmUoJycpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1JlcXVpcmUoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCBkZXBzLCByZWxJZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vQXJyYXkgb2YgZGVwZW5kZW5jaWVzIHdpdGggYSBjYWxsYmFjay5cblxuICAgICAgICAgICAgICAgIC8vQ29udmVydCB0aGUgZGVwZW5kZW5jaWVzIHRvIG1vZHVsZXMuXG4gICAgICAgICAgICAgICAgZGVwcyA9IGRlcHMubWFwKGZ1bmN0aW9uIChkZXBOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdSZXF1aXJlKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgZGVwTmFtZSwgcmVsSWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy9XYWl0IGZvciBuZXh0IHRpY2sgdG8gY2FsbCBiYWNrIHRoZSByZXF1aXJlIGNhbGwuXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgZGVwcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFtZFJlcXVpcmUudG9VcmwgPSBmdW5jdGlvbiAoZmlsZVBhdGgpIHtcbiAgICAgICAgICAgIGlmIChmaWxlUGF0aC5pbmRleE9mKCcuJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplKGZpbGVQYXRoLCBwYXRoLmRpcm5hbWUobW9kdWxlLmZpbGVuYW1lKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlUGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gYW1kUmVxdWlyZTtcbiAgICB9O1xuXG4gICAgLy9GYXZvciBleHBsaWNpdCB2YWx1ZSwgcGFzc2VkIGluIGlmIHRoZSBtb2R1bGUgd2FudHMgdG8gc3VwcG9ydCBOb2RlIDAuNC5cbiAgICByZXF1aXJlRm4gPSByZXF1aXJlRm4gfHwgZnVuY3Rpb24gcmVxKCkge1xuICAgICAgICByZXR1cm4gbW9kdWxlLnJlcXVpcmUuYXBwbHkobW9kdWxlLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBydW5GYWN0b3J5KGlkLCBkZXBzLCBmYWN0b3J5KSB7XG4gICAgICAgIHZhciByLCBlLCBtLCByZXN1bHQ7XG5cbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBlID0gbG9hZGVyQ2FjaGVbaWRdID0ge307XG4gICAgICAgICAgICBtID0ge1xuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICB1cmk6IF9fZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgZXhwb3J0czogZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHIgPSBtYWtlUmVxdWlyZShyZXF1aXJlRm4sIGUsIG0sIGlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vT25seSBzdXBwb3J0IG9uZSBkZWZpbmUgY2FsbCBwZXIgZmlsZVxuICAgICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FtZGVmaW5lIHdpdGggbm8gbW9kdWxlIElEIGNhbm5vdCBiZSBjYWxsZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGZpbGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy9Vc2UgdGhlIHJlYWwgdmFyaWFibGVzIGZyb20gbm9kZVxuICAgICAgICAgICAgLy9Vc2UgbW9kdWxlLmV4cG9ydHMgZm9yIGV4cG9ydHMsIHNpbmNlXG4gICAgICAgICAgICAvL3RoZSBleHBvcnRzIGluIGhlcmUgaXMgYW1kZWZpbmUgZXhwb3J0cy5cbiAgICAgICAgICAgIGUgPSBtb2R1bGUuZXhwb3J0cztcbiAgICAgICAgICAgIG0gPSBtb2R1bGU7XG4gICAgICAgICAgICByID0gbWFrZVJlcXVpcmUocmVxdWlyZUZuLCBlLCBtLCBtb2R1bGUuaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9JZiB0aGVyZSBhcmUgZGVwZW5kZW5jaWVzLCB0aGV5IGFyZSBzdHJpbmdzLCBzbyBuZWVkXG4gICAgICAgIC8vdG8gY29udmVydCB0aGVtIHRvIGRlcGVuZGVuY3kgdmFsdWVzLlxuICAgICAgICBpZiAoZGVwcykge1xuICAgICAgICAgICAgZGVwcyA9IGRlcHMubWFwKGZ1bmN0aW9uIChkZXBOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIoZGVwTmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vQ2FsbCB0aGUgZmFjdG9yeSB3aXRoIHRoZSByaWdodCBkZXBlbmRlbmNpZXMuXG4gICAgICAgIGlmICh0eXBlb2YgZmFjdG9yeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFjdG9yeS5hcHBseShtLmV4cG9ydHMsIGRlcHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFjdG9yeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbS5leHBvcnRzID0gcmVzdWx0O1xuICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgbG9hZGVyQ2FjaGVbaWRdID0gbS5leHBvcnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RyaW5nUmVxdWlyZSA9IGZ1bmN0aW9uIChzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIGlkLCByZWxJZCkge1xuICAgICAgICAvL1NwbGl0IHRoZSBJRCBieSBhICEgc28gdGhhdFxuICAgICAgICB2YXIgaW5kZXggPSBpZC5pbmRleE9mKCchJyksXG4gICAgICAgICAgICBvcmlnaW5hbElkID0gaWQsXG4gICAgICAgICAgICBwcmVmaXgsIHBsdWdpbjtcblxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBpZCA9IG5vcm1hbGl6ZShpZCwgcmVsSWQpO1xuXG4gICAgICAgICAgICAvL1N0cmFpZ2h0IG1vZHVsZSBsb29rdXAuIElmIGl0IGlzIG9uZSBvZiB0aGUgc3BlY2lhbCBkZXBlbmRlbmNpZXMsXG4gICAgICAgICAgICAvL2RlYWwgd2l0aCBpdCwgb3RoZXJ3aXNlLCBkZWxlZ2F0ZSB0byBub2RlLlxuICAgICAgICAgICAgaWYgKGlkID09PSAncmVxdWlyZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZVJlcXVpcmUoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCByZWxJZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlkID09PSAnZXhwb3J0cycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaWQgPT09ICdtb2R1bGUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobG9hZGVyQ2FjaGUuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlckNhY2hlW2lkXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVmaW5lQ2FjaGVbaWRdKSB7XG4gICAgICAgICAgICAgICAgcnVuRmFjdG9yeS5hcHBseShudWxsLCBkZWZpbmVDYWNoZVtpZF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkZXJDYWNoZVtpZF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmKHN5c3RlbVJlcXVpcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5c3RlbVJlcXVpcmUob3JpZ2luYWxJZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBtb2R1bGUgd2l0aCBJRDogJyArIGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL1RoZXJlIGlzIGEgcGx1Z2luIGluIHBsYXkuXG4gICAgICAgICAgICBwcmVmaXggPSBpZC5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgICAgICAgaWQgPSBpZC5zdWJzdHJpbmcoaW5kZXggKyAxLCBpZC5sZW5ndGgpO1xuXG4gICAgICAgICAgICBwbHVnaW4gPSBzdHJpbmdSZXF1aXJlKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgcHJlZml4LCByZWxJZCk7XG5cbiAgICAgICAgICAgIGlmIChwbHVnaW4ubm9ybWFsaXplKSB7XG4gICAgICAgICAgICAgICAgaWQgPSBwbHVnaW4ubm9ybWFsaXplKGlkLCBtYWtlTm9ybWFsaXplKHJlbElkKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vTm9ybWFsaXplIHRoZSBJRCBub3JtYWxseS5cbiAgICAgICAgICAgICAgICBpZCA9IG5vcm1hbGl6ZShpZCwgcmVsSWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobG9hZGVyQ2FjaGVbaWRdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlckNhY2hlW2lkXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGx1Z2luLmxvYWQoaWQsIG1ha2VSZXF1aXJlKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgcmVsSWQpLCBtYWtlTG9hZChpZCksIHt9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkZXJDYWNoZVtpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy9DcmVhdGUgYSBkZWZpbmUgZnVuY3Rpb24gc3BlY2lmaWMgdG8gdGhlIG1vZHVsZSBhc2tpbmcgZm9yIGFtZGVmaW5lLlxuICAgIGZ1bmN0aW9uIGRlZmluZShpZCwgZGVwcywgZmFjdG9yeSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpZCkpIHtcbiAgICAgICAgICAgIGZhY3RvcnkgPSBkZXBzO1xuICAgICAgICAgICAgZGVwcyA9IGlkO1xuICAgICAgICAgICAgaWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZmFjdG9yeSA9IGlkO1xuICAgICAgICAgICAgaWQgPSBkZXBzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlcHMgJiYgIUFycmF5LmlzQXJyYXkoZGVwcykpIHtcbiAgICAgICAgICAgIGZhY3RvcnkgPSBkZXBzO1xuICAgICAgICAgICAgZGVwcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGVwcykge1xuICAgICAgICAgICAgZGVwcyA9IFsncmVxdWlyZScsICdleHBvcnRzJywgJ21vZHVsZSddO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9TZXQgdXAgcHJvcGVydGllcyBmb3IgdGhpcyBtb2R1bGUuIElmIGFuIElELCB0aGVuIHVzZVxuICAgICAgICAvL2ludGVybmFsIGNhY2hlLiBJZiBubyBJRCwgdGhlbiB1c2UgdGhlIGV4dGVybmFsIHZhcmlhYmxlc1xuICAgICAgICAvL2ZvciB0aGlzIG5vZGUgbW9kdWxlLlxuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIC8vUHV0IHRoZSBtb2R1bGUgaW4gZGVlcCBmcmVlemUgdW50aWwgdGhlcmUgaXMgYVxuICAgICAgICAgICAgLy9yZXF1aXJlIGNhbGwgZm9yIGl0LlxuICAgICAgICAgICAgZGVmaW5lQ2FjaGVbaWRdID0gW2lkLCBkZXBzLCBmYWN0b3J5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJ1bkZhY3RvcnkoaWQsIGRlcHMsIGZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9kZWZpbmUucmVxdWlyZSwgd2hpY2ggaGFzIGFjY2VzcyB0byBhbGwgdGhlIHZhbHVlcyBpbiB0aGVcbiAgICAvL2NhY2hlLiBVc2VmdWwgZm9yIEFNRCBtb2R1bGVzIHRoYXQgYWxsIGhhdmUgSURzIGluIHRoZSBmaWxlLFxuICAgIC8vYnV0IG5lZWQgdG8gZmluYWxseSBleHBvcnQgYSB2YWx1ZSB0byBub2RlIGJhc2VkIG9uIG9uZSBvZiB0aG9zZVxuICAgIC8vSURzLlxuICAgIGRlZmluZS5yZXF1aXJlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmIChsb2FkZXJDYWNoZVtpZF0pIHtcbiAgICAgICAgICAgIHJldHVybiBsb2FkZXJDYWNoZVtpZF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVmaW5lQ2FjaGVbaWRdKSB7XG4gICAgICAgICAgICBydW5GYWN0b3J5LmFwcGx5KG51bGwsIGRlZmluZUNhY2hlW2lkXSk7XG4gICAgICAgICAgICByZXR1cm4gbG9hZGVyQ2FjaGVbaWRdO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGRlZmluZS5hbWQgPSB7fTtcblxuICAgIHJldHVybiBkZWZpbmU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYW1kZWZpbmU7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLFwiL25vZGVfbW9kdWxlcy9hbWRlZmluZS9hbWRlZmluZS5qc1wiKVxufSx7XCJfcHJvY2Vzc1wiOjY1LFwicGF0aFwiOjY0fV0sMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxuLy8gcmF3QXNhcCBwcm92aWRlcyBldmVyeXRoaW5nIHdlIG5lZWQgZXhjZXB0IGV4Y2VwdGlvbiBtYW5hZ2VtZW50LlxudmFyIHJhd0FzYXAgPSByZXF1aXJlKFwiLi9yYXdcIik7XG4vLyBSYXdUYXNrcyBhcmUgcmVjeWNsZWQgdG8gcmVkdWNlIEdDIGNodXJuLlxudmFyIGZyZWVUYXNrcyA9IFtdO1xuLy8gV2UgcXVldWUgZXJyb3JzIHRvIGVuc3VyZSB0aGV5IGFyZSB0aHJvd24gaW4gcmlnaHQgb3JkZXIgKEZJRk8pLlxuLy8gQXJyYXktYXMtcXVldWUgaXMgZ29vZCBlbm91Z2ggaGVyZSwgc2luY2Ugd2UgYXJlIGp1c3QgZGVhbGluZyB3aXRoIGV4Y2VwdGlvbnMuXG52YXIgcGVuZGluZ0Vycm9ycyA9IFtdO1xudmFyIHJlcXVlc3RFcnJvclRocm93ID0gcmF3QXNhcC5tYWtlUmVxdWVzdENhbGxGcm9tVGltZXIodGhyb3dGaXJzdEVycm9yKTtcblxuZnVuY3Rpb24gdGhyb3dGaXJzdEVycm9yKCkge1xuICAgIGlmIChwZW5kaW5nRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBwZW5kaW5nRXJyb3JzLnNoaWZ0KCk7XG4gICAgfVxufVxuXG4vKipcbiAqIENhbGxzIGEgdGFzayBhcyBzb29uIGFzIHBvc3NpYmxlIGFmdGVyIHJldHVybmluZywgaW4gaXRzIG93biBldmVudCwgd2l0aCBwcmlvcml0eVxuICogb3ZlciBvdGhlciBldmVudHMgbGlrZSBhbmltYXRpb24sIHJlZmxvdywgYW5kIHJlcGFpbnQuIEFuIGVycm9yIHRocm93biBmcm9tIGFuXG4gKiBldmVudCB3aWxsIG5vdCBpbnRlcnJ1cHQsIG5vciBldmVuIHN1YnN0YW50aWFsbHkgc2xvdyBkb3duIHRoZSBwcm9jZXNzaW5nIG9mXG4gKiBvdGhlciBldmVudHMsIGJ1dCB3aWxsIGJlIHJhdGhlciBwb3N0cG9uZWQgdG8gYSBsb3dlciBwcmlvcml0eSBldmVudC5cbiAqIEBwYXJhbSB7e2NhbGx9fSB0YXNrIEEgY2FsbGFibGUgb2JqZWN0LCB0eXBpY2FsbHkgYSBmdW5jdGlvbiB0aGF0IHRha2VzIG5vXG4gKiBhcmd1bWVudHMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gYXNhcDtcbmZ1bmN0aW9uIGFzYXAodGFzaykge1xuICAgIHZhciByYXdUYXNrO1xuICAgIGlmIChmcmVlVGFza3MubGVuZ3RoKSB7XG4gICAgICAgIHJhd1Rhc2sgPSBmcmVlVGFza3MucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmF3VGFzayA9IG5ldyBSYXdUYXNrKCk7XG4gICAgfVxuICAgIHJhd1Rhc2sudGFzayA9IHRhc2s7XG4gICAgcmF3QXNhcChyYXdUYXNrKTtcbn1cblxuLy8gV2Ugd3JhcCB0YXNrcyB3aXRoIHJlY3ljbGFibGUgdGFzayBvYmplY3RzLiAgQSB0YXNrIG9iamVjdCBpbXBsZW1lbnRzXG4vLyBgY2FsbGAsIGp1c3QgbGlrZSBhIGZ1bmN0aW9uLlxuZnVuY3Rpb24gUmF3VGFzaygpIHtcbiAgICB0aGlzLnRhc2sgPSBudWxsO1xufVxuXG4vLyBUaGUgc29sZSBwdXJwb3NlIG9mIHdyYXBwaW5nIHRoZSB0YXNrIGlzIHRvIGNhdGNoIHRoZSBleGNlcHRpb24gYW5kIHJlY3ljbGVcbi8vIHRoZSB0YXNrIG9iamVjdCBhZnRlciBpdHMgc2luZ2xlIHVzZS5cblJhd1Rhc2sucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy50YXNrLmNhbGwoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoYXNhcC5vbmVycm9yKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGhvb2sgZXhpc3RzIHB1cmVseSBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cbiAgICAgICAgICAgIC8vIEl0cyBuYW1lIHdpbGwgYmUgcGVyaW9kaWNhbGx5IHJhbmRvbWl6ZWQgdG8gYnJlYWsgYW55IGNvZGUgdGhhdFxuICAgICAgICAgICAgLy8gZGVwZW5kcyBvbiBpdHMgZXhpc3RlbmNlLlxuICAgICAgICAgICAgYXNhcC5vbmVycm9yKGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEluIGEgd2ViIGJyb3dzZXIsIGV4Y2VwdGlvbnMgYXJlIG5vdCBmYXRhbC4gSG93ZXZlciwgdG8gYXZvaWRcbiAgICAgICAgICAgIC8vIHNsb3dpbmcgZG93biB0aGUgcXVldWUgb2YgcGVuZGluZyB0YXNrcywgd2UgcmV0aHJvdyB0aGUgZXJyb3IgaW4gYVxuICAgICAgICAgICAgLy8gbG93ZXIgcHJpb3JpdHkgdHVybi5cbiAgICAgICAgICAgIHBlbmRpbmdFcnJvcnMucHVzaChlcnJvcik7XG4gICAgICAgICAgICByZXF1ZXN0RXJyb3JUaHJvdygpO1xuICAgICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy50YXNrID0gbnVsbDtcbiAgICAgICAgZnJlZVRhc2tzW2ZyZWVUYXNrcy5sZW5ndGhdID0gdGhpcztcbiAgICB9XG59O1xuXG59LHtcIi4vcmF3XCI6M31dLDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFVzZSB0aGUgZmFzdGVzdCBtZWFucyBwb3NzaWJsZSB0byBleGVjdXRlIGEgdGFzayBpbiBpdHMgb3duIHR1cm4sIHdpdGhcbi8vIHByaW9yaXR5IG92ZXIgb3RoZXIgZXZlbnRzIGluY2x1ZGluZyBJTywgYW5pbWF0aW9uLCByZWZsb3csIGFuZCByZWRyYXdcbi8vIGV2ZW50cyBpbiBicm93c2Vycy5cbi8vXG4vLyBBbiBleGNlcHRpb24gdGhyb3duIGJ5IGEgdGFzayB3aWxsIHBlcm1hbmVudGx5IGludGVycnVwdCB0aGUgcHJvY2Vzc2luZyBvZlxuLy8gc3Vic2VxdWVudCB0YXNrcy4gVGhlIGhpZ2hlciBsZXZlbCBgYXNhcGAgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGlmIGFuXG4vLyBleGNlcHRpb24gaXMgdGhyb3duIGJ5IGEgdGFzaywgdGhhdCB0aGUgdGFzayBxdWV1ZSB3aWxsIGNvbnRpbnVlIGZsdXNoaW5nIGFzXG4vLyBzb29uIGFzIHBvc3NpYmxlLCBidXQgaWYgeW91IHVzZSBgcmF3QXNhcGAgZGlyZWN0bHksIHlvdSBhcmUgcmVzcG9uc2libGUgdG9cbi8vIGVpdGhlciBlbnN1cmUgdGhhdCBubyBleGNlcHRpb25zIGFyZSB0aHJvd24gZnJvbSB5b3VyIHRhc2ssIG9yIHRvIG1hbnVhbGx5XG4vLyBjYWxsIGByYXdBc2FwLnJlcXVlc3RGbHVzaGAgaWYgYW4gZXhjZXB0aW9uIGlzIHRocm93bi5cbm1vZHVsZS5leHBvcnRzID0gcmF3QXNhcDtcbmZ1bmN0aW9uIHJhd0FzYXAodGFzaykge1xuICAgIGlmICghcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHJlcXVlc3RGbHVzaCgpO1xuICAgICAgICBmbHVzaGluZyA9IHRydWU7XG4gICAgfVxuICAgIC8vIEVxdWl2YWxlbnQgdG8gcHVzaCwgYnV0IGF2b2lkcyBhIGZ1bmN0aW9uIGNhbGwuXG4gICAgcXVldWVbcXVldWUubGVuZ3RoXSA9IHRhc2s7XG59XG5cbnZhciBxdWV1ZSA9IFtdO1xuLy8gT25jZSBhIGZsdXNoIGhhcyBiZWVuIHJlcXVlc3RlZCwgbm8gZnVydGhlciBjYWxscyB0byBgcmVxdWVzdEZsdXNoYCBhcmVcbi8vIG5lY2Vzc2FyeSB1bnRpbCB0aGUgbmV4dCBgZmx1c2hgIGNvbXBsZXRlcy5cbnZhciBmbHVzaGluZyA9IGZhbHNlO1xuLy8gYHJlcXVlc3RGbHVzaGAgaXMgYW4gaW1wbGVtZW50YXRpb24tc3BlY2lmaWMgbWV0aG9kIHRoYXQgYXR0ZW1wdHMgdG8ga2lja1xuLy8gb2ZmIGEgYGZsdXNoYCBldmVudCBhcyBxdWlja2x5IGFzIHBvc3NpYmxlLiBgZmx1c2hgIHdpbGwgYXR0ZW1wdCB0byBleGhhdXN0XG4vLyB0aGUgZXZlbnQgcXVldWUgYmVmb3JlIHlpZWxkaW5nIHRvIHRoZSBicm93c2VyJ3Mgb3duIGV2ZW50IGxvb3AuXG52YXIgcmVxdWVzdEZsdXNoO1xuLy8gVGhlIHBvc2l0aW9uIG9mIHRoZSBuZXh0IHRhc2sgdG8gZXhlY3V0ZSBpbiB0aGUgdGFzayBxdWV1ZS4gVGhpcyBpc1xuLy8gcHJlc2VydmVkIGJldHdlZW4gY2FsbHMgdG8gYGZsdXNoYCBzbyB0aGF0IGl0IGNhbiBiZSByZXN1bWVkIGlmXG4vLyBhIHRhc2sgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbnZhciBpbmRleCA9IDA7XG4vLyBJZiBhIHRhc2sgc2NoZWR1bGVzIGFkZGl0aW9uYWwgdGFza3MgcmVjdXJzaXZlbHksIHRoZSB0YXNrIHF1ZXVlIGNhbiBncm93XG4vLyB1bmJvdW5kZWQuIFRvIHByZXZlbnQgbWVtb3J5IGV4aGF1c3Rpb24sIHRoZSB0YXNrIHF1ZXVlIHdpbGwgcGVyaW9kaWNhbGx5XG4vLyB0cnVuY2F0ZSBhbHJlYWR5LWNvbXBsZXRlZCB0YXNrcy5cbnZhciBjYXBhY2l0eSA9IDEwMjQ7XG5cbi8vIFRoZSBmbHVzaCBmdW5jdGlvbiBwcm9jZXNzZXMgYWxsIHRhc2tzIHRoYXQgaGF2ZSBiZWVuIHNjaGVkdWxlZCB3aXRoXG4vLyBgcmF3QXNhcGAgdW5sZXNzIGFuZCB1bnRpbCBvbmUgb2YgdGhvc2UgdGFza3MgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbi8vIElmIGEgdGFzayB0aHJvd3MgYW4gZXhjZXB0aW9uLCBgZmx1c2hgIGVuc3VyZXMgdGhhdCBpdHMgc3RhdGUgd2lsbCByZW1haW5cbi8vIGNvbnNpc3RlbnQgYW5kIHdpbGwgcmVzdW1lIHdoZXJlIGl0IGxlZnQgb2ZmIHdoZW4gY2FsbGVkIGFnYWluLlxuLy8gSG93ZXZlciwgYGZsdXNoYCBkb2VzIG5vdCBtYWtlIGFueSBhcnJhbmdlbWVudHMgdG8gYmUgY2FsbGVkIGFnYWluIGlmIGFuXG4vLyBleGNlcHRpb24gaXMgdGhyb3duLlxuZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgd2hpbGUgKGluZGV4IDwgcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSBpbmRleDtcbiAgICAgICAgLy8gQWR2YW5jZSB0aGUgaW5kZXggYmVmb3JlIGNhbGxpbmcgdGhlIHRhc2suIFRoaXMgZW5zdXJlcyB0aGF0IHdlIHdpbGxcbiAgICAgICAgLy8gYmVnaW4gZmx1c2hpbmcgb24gdGhlIG5leHQgdGFzayB0aGUgdGFzayB0aHJvd3MgYW4gZXJyb3IuXG4gICAgICAgIGluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICBxdWV1ZVtjdXJyZW50SW5kZXhdLmNhbGwoKTtcbiAgICAgICAgLy8gUHJldmVudCBsZWFraW5nIG1lbW9yeSBmb3IgbG9uZyBjaGFpbnMgb2YgcmVjdXJzaXZlIGNhbGxzIHRvIGBhc2FwYC5cbiAgICAgICAgLy8gSWYgd2UgY2FsbCBgYXNhcGAgd2l0aGluIHRhc2tzIHNjaGVkdWxlZCBieSBgYXNhcGAsIHRoZSBxdWV1ZSB3aWxsXG4gICAgICAgIC8vIGdyb3csIGJ1dCB0byBhdm9pZCBhbiBPKG4pIHdhbGsgZm9yIGV2ZXJ5IHRhc2sgd2UgZXhlY3V0ZSwgd2UgZG9uJ3RcbiAgICAgICAgLy8gc2hpZnQgdGFza3Mgb2ZmIHRoZSBxdWV1ZSBhZnRlciB0aGV5IGhhdmUgYmVlbiBleGVjdXRlZC5cbiAgICAgICAgLy8gSW5zdGVhZCwgd2UgcGVyaW9kaWNhbGx5IHNoaWZ0IDEwMjQgdGFza3Mgb2ZmIHRoZSBxdWV1ZS5cbiAgICAgICAgaWYgKGluZGV4ID4gY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IHNoaWZ0IGFsbCB2YWx1ZXMgc3RhcnRpbmcgYXQgdGhlIGluZGV4IGJhY2sgdG8gdGhlXG4gICAgICAgICAgICAvLyBiZWdpbm5pbmcgb2YgdGhlIHF1ZXVlLlxuICAgICAgICAgICAgZm9yICh2YXIgc2NhbiA9IDAsIG5ld0xlbmd0aCA9IHF1ZXVlLmxlbmd0aCAtIGluZGV4OyBzY2FuIDwgbmV3TGVuZ3RoOyBzY2FuKyspIHtcbiAgICAgICAgICAgICAgICBxdWV1ZVtzY2FuXSA9IHF1ZXVlW3NjYW4gKyBpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWV1ZS5sZW5ndGggLT0gaW5kZXg7XG4gICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUubGVuZ3RoID0gMDtcbiAgICBpbmRleCA9IDA7XG4gICAgZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxuLy8gYHJlcXVlc3RGbHVzaGAgaXMgaW1wbGVtZW50ZWQgdXNpbmcgYSBzdHJhdGVneSBiYXNlZCBvbiBkYXRhIGNvbGxlY3RlZCBmcm9tXG4vLyBldmVyeSBhdmFpbGFibGUgU2F1Y2VMYWJzIFNlbGVuaXVtIHdlYiBkcml2ZXIgd29ya2VyIGF0IHRpbWUgb2Ygd3JpdGluZy5cbi8vIGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL3NwcmVhZHNoZWV0cy9kLzFtRy01VVlHdXA1cXhHZEVNV2toUDZCV0N6MDUzTlViMkUxUW9VVFUxNnVBL2VkaXQjZ2lkPTc4MzcyNDU5M1xuXG4vLyBTYWZhcmkgNiBhbmQgNi4xIGZvciBkZXNrdG9wLCBpUGFkLCBhbmQgaVBob25lIGFyZSB0aGUgb25seSBicm93c2VycyB0aGF0XG4vLyBoYXZlIFdlYktpdE11dGF0aW9uT2JzZXJ2ZXIgYnV0IG5vdCB1bi1wcmVmaXhlZCBNdXRhdGlvbk9ic2VydmVyLlxuLy8gTXVzdCB1c2UgYGdsb2JhbGAgb3IgYHNlbGZgIGluc3RlYWQgb2YgYHdpbmRvd2AgdG8gd29yayBpbiBib3RoIGZyYW1lcyBhbmQgd2ViXG4vLyB3b3JrZXJzLiBgZ2xvYmFsYCBpcyBhIHByb3Zpc2lvbiBvZiBCcm93c2VyaWZ5LCBNciwgTXJzLCBvciBNb3AuXG5cbi8qIGdsb2JhbHMgc2VsZiAqL1xudmFyIHNjb3BlID0gdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHNlbGY7XG52YXIgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPSBzY29wZS5NdXRhdGlvbk9ic2VydmVyIHx8IHNjb3BlLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG5cbi8vIE11dGF0aW9uT2JzZXJ2ZXJzIGFyZSBkZXNpcmFibGUgYmVjYXVzZSB0aGV5IGhhdmUgaGlnaCBwcmlvcml0eSBhbmQgd29ya1xuLy8gcmVsaWFibHkgZXZlcnl3aGVyZSB0aGV5IGFyZSBpbXBsZW1lbnRlZC5cbi8vIFRoZXkgYXJlIGltcGxlbWVudGVkIGluIGFsbCBtb2Rlcm4gYnJvd3NlcnMuXG4vL1xuLy8gLSBBbmRyb2lkIDQtNC4zXG4vLyAtIENocm9tZSAyNi0zNFxuLy8gLSBGaXJlZm94IDE0LTI5XG4vLyAtIEludGVybmV0IEV4cGxvcmVyIDExXG4vLyAtIGlQYWQgU2FmYXJpIDYtNy4xXG4vLyAtIGlQaG9uZSBTYWZhcmkgNy03LjFcbi8vIC0gU2FmYXJpIDYtN1xuaWYgKHR5cGVvZiBCcm93c2VyTXV0YXRpb25PYnNlcnZlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmVxdWVzdEZsdXNoID0gbWFrZVJlcXVlc3RDYWxsRnJvbU11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpO1xuXG4vLyBNZXNzYWdlQ2hhbm5lbHMgYXJlIGRlc2lyYWJsZSBiZWNhdXNlIHRoZXkgZ2l2ZSBkaXJlY3QgYWNjZXNzIHRvIHRoZSBIVE1MXG4vLyB0YXNrIHF1ZXVlLCBhcmUgaW1wbGVtZW50ZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAsIFNhZmFyaSA1LjAtMSwgYW5kIE9wZXJhXG4vLyAxMS0xMiwgYW5kIGluIHdlYiB3b3JrZXJzIGluIG1hbnkgZW5naW5lcy5cbi8vIEFsdGhvdWdoIG1lc3NhZ2UgY2hhbm5lbHMgeWllbGQgdG8gYW55IHF1ZXVlZCByZW5kZXJpbmcgYW5kIElPIHRhc2tzLCB0aGV5XG4vLyB3b3VsZCBiZSBiZXR0ZXIgdGhhbiBpbXBvc2luZyB0aGUgNG1zIGRlbGF5IG9mIHRpbWVycy5cbi8vIEhvd2V2ZXIsIHRoZXkgZG8gbm90IHdvcmsgcmVsaWFibHkgaW4gSW50ZXJuZXQgRXhwbG9yZXIgb3IgU2FmYXJpLlxuXG4vLyBJbnRlcm5ldCBFeHBsb3JlciAxMCBpcyB0aGUgb25seSBicm93c2VyIHRoYXQgaGFzIHNldEltbWVkaWF0ZSBidXQgZG9lc1xuLy8gbm90IGhhdmUgTXV0YXRpb25PYnNlcnZlcnMuXG4vLyBBbHRob3VnaCBzZXRJbW1lZGlhdGUgeWllbGRzIHRvIHRoZSBicm93c2VyJ3MgcmVuZGVyZXIsIGl0IHdvdWxkIGJlXG4vLyBwcmVmZXJyYWJsZSB0byBmYWxsaW5nIGJhY2sgdG8gc2V0VGltZW91dCBzaW5jZSBpdCBkb2VzIG5vdCBoYXZlXG4vLyB0aGUgbWluaW11bSA0bXMgcGVuYWx0eS5cbi8vIFVuZm9ydHVuYXRlbHkgdGhlcmUgYXBwZWFycyB0byBiZSBhIGJ1ZyBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMCBNb2JpbGUgKGFuZFxuLy8gRGVza3RvcCB0byBhIGxlc3NlciBleHRlbnQpIHRoYXQgcmVuZGVycyBib3RoIHNldEltbWVkaWF0ZSBhbmRcbi8vIE1lc3NhZ2VDaGFubmVsIHVzZWxlc3MgZm9yIHRoZSBwdXJwb3NlcyBvZiBBU0FQLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2tyaXNrb3dhbC9xL2lzc3Vlcy8zOTZcblxuLy8gVGltZXJzIGFyZSBpbXBsZW1lbnRlZCB1bml2ZXJzYWxseS5cbi8vIFdlIGZhbGwgYmFjayB0byB0aW1lcnMgaW4gd29ya2VycyBpbiBtb3N0IGVuZ2luZXMsIGFuZCBpbiBmb3JlZ3JvdW5kXG4vLyBjb250ZXh0cyBpbiB0aGUgZm9sbG93aW5nIGJyb3dzZXJzLlxuLy8gSG93ZXZlciwgbm90ZSB0aGF0IGV2ZW4gdGhpcyBzaW1wbGUgY2FzZSByZXF1aXJlcyBudWFuY2VzIHRvIG9wZXJhdGUgaW4gYVxuLy8gYnJvYWQgc3BlY3RydW0gb2YgYnJvd3NlcnMuXG4vL1xuLy8gLSBGaXJlZm94IDMtMTNcbi8vIC0gSW50ZXJuZXQgRXhwbG9yZXIgNi05XG4vLyAtIGlQYWQgU2FmYXJpIDQuM1xuLy8gLSBMeW54IDIuOC43XG59IGVsc2Uge1xuICAgIHJlcXVlc3RGbHVzaCA9IG1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lcihmbHVzaCk7XG59XG5cbi8vIGByZXF1ZXN0Rmx1c2hgIHJlcXVlc3RzIHRoYXQgdGhlIGhpZ2ggcHJpb3JpdHkgZXZlbnQgcXVldWUgYmUgZmx1c2hlZCBhc1xuLy8gc29vbiBhcyBwb3NzaWJsZS5cbi8vIFRoaXMgaXMgdXNlZnVsIHRvIHByZXZlbnQgYW4gZXJyb3IgdGhyb3duIGluIGEgdGFzayBmcm9tIHN0YWxsaW5nIHRoZSBldmVudFxuLy8gcXVldWUgaWYgdGhlIGV4Y2VwdGlvbiBoYW5kbGVkIGJ5IE5vZGUuanPigJlzXG4vLyBgcHJvY2Vzcy5vbihcInVuY2F1Z2h0RXhjZXB0aW9uXCIpYCBvciBieSBhIGRvbWFpbi5cbnJhd0FzYXAucmVxdWVzdEZsdXNoID0gcmVxdWVzdEZsdXNoO1xuXG4vLyBUbyByZXF1ZXN0IGEgaGlnaCBwcmlvcml0eSBldmVudCwgd2UgaW5kdWNlIGEgbXV0YXRpb24gb2JzZXJ2ZXIgYnkgdG9nZ2xpbmdcbi8vIHRoZSB0ZXh0IG9mIGEgdGV4dCBub2RlIGJldHdlZW4gXCIxXCIgYW5kIFwiLTFcIi5cbmZ1bmN0aW9uIG1ha2VSZXF1ZXN0Q2FsbEZyb21NdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKSB7XG4gICAgdmFyIHRvZ2dsZSA9IDE7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKTtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpO1xuICAgIG9ic2VydmVyLm9ic2VydmUobm9kZSwge2NoYXJhY3RlckRhdGE6IHRydWV9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVxdWVzdENhbGwoKSB7XG4gICAgICAgIHRvZ2dsZSA9IC10b2dnbGU7XG4gICAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZTtcbiAgICB9O1xufVxuXG4vLyBUaGUgbWVzc2FnZSBjaGFubmVsIHRlY2huaXF1ZSB3YXMgZGlzY292ZXJlZCBieSBNYWx0ZSBVYmwgYW5kIHdhcyB0aGVcbi8vIG9yaWdpbmFsIGZvdW5kYXRpb24gZm9yIHRoaXMgbGlicmFyeS5cbi8vIGh0dHA6Ly93d3cubm9uYmxvY2tpbmcuaW8vMjAxMS8wNi93aW5kb3duZXh0dGljay5odG1sXG5cbi8vIFNhZmFyaSA2LjAuNSAoYXQgbGVhc3QpIGludGVybWl0dGVudGx5IGZhaWxzIHRvIGNyZWF0ZSBtZXNzYWdlIHBvcnRzIG9uIGFcbi8vIHBhZ2UncyBmaXJzdCBsb2FkLiBUaGFua2Z1bGx5LCB0aGlzIHZlcnNpb24gb2YgU2FmYXJpIHN1cHBvcnRzXG4vLyBNdXRhdGlvbk9ic2VydmVycywgc28gd2UgZG9uJ3QgbmVlZCB0byBmYWxsIGJhY2sgaW4gdGhhdCBjYXNlLlxuXG4vLyBmdW5jdGlvbiBtYWtlUmVxdWVzdENhbGxGcm9tTWVzc2FnZUNoYW5uZWwoY2FsbGJhY2spIHtcbi8vICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuLy8gICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gY2FsbGJhY2s7XG4vLyAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlcXVlc3RDYWxsKCkge1xuLy8gICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuLy8gICAgIH07XG4vLyB9XG5cbi8vIEZvciByZWFzb25zIGV4cGxhaW5lZCBhYm92ZSwgd2UgYXJlIGFsc28gdW5hYmxlIHRvIHVzZSBgc2V0SW1tZWRpYXRlYFxuLy8gdW5kZXIgYW55IGNpcmN1bXN0YW5jZXMuXG4vLyBFdmVuIGlmIHdlIHdlcmUsIHRoZXJlIGlzIGFub3RoZXIgYnVnIGluIEludGVybmV0IEV4cGxvcmVyIDEwLlxuLy8gSXQgaXMgbm90IHN1ZmZpY2llbnQgdG8gYXNzaWduIGBzZXRJbW1lZGlhdGVgIHRvIGByZXF1ZXN0Rmx1c2hgIGJlY2F1c2Vcbi8vIGBzZXRJbW1lZGlhdGVgIG11c3QgYmUgY2FsbGVkICpieSBuYW1lKiBhbmQgdGhlcmVmb3JlIG11c3QgYmUgd3JhcHBlZCBpbiBhXG4vLyBjbG9zdXJlLlxuLy8gTmV2ZXIgZm9yZ2V0LlxuXG4vLyBmdW5jdGlvbiBtYWtlUmVxdWVzdENhbGxGcm9tU2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4vLyAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlcXVlc3RDYWxsKCkge1xuLy8gICAgICAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2spO1xuLy8gICAgIH07XG4vLyB9XG5cbi8vIFNhZmFyaSA2LjAgaGFzIGEgcHJvYmxlbSB3aGVyZSB0aW1lcnMgd2lsbCBnZXQgbG9zdCB3aGlsZSB0aGUgdXNlciBpc1xuLy8gc2Nyb2xsaW5nLiBUaGlzIHByb2JsZW0gZG9lcyBub3QgaW1wYWN0IEFTQVAgYmVjYXVzZSBTYWZhcmkgNi4wIHN1cHBvcnRzXG4vLyBtdXRhdGlvbiBvYnNlcnZlcnMsIHNvIHRoYXQgaW1wbGVtZW50YXRpb24gaXMgdXNlZCBpbnN0ZWFkLlxuLy8gSG93ZXZlciwgaWYgd2UgZXZlciBlbGVjdCB0byB1c2UgdGltZXJzIGluIFNhZmFyaSwgdGhlIHByZXZhbGVudCB3b3JrLWFyb3VuZFxuLy8gaXMgdG8gYWRkIGEgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyIHRoYXQgY2FsbHMgZm9yIGEgZmx1c2guXG5cbi8vIGBzZXRUaW1lb3V0YCBkb2VzIG5vdCBjYWxsIHRoZSBwYXNzZWQgY2FsbGJhY2sgaWYgdGhlIGRlbGF5IGlzIGxlc3MgdGhhblxuLy8gYXBwcm94aW1hdGVseSA3IGluIHdlYiB3b3JrZXJzIGluIEZpcmVmb3ggOCB0aHJvdWdoIDE4LCBhbmQgc29tZXRpbWVzIG5vdFxuLy8gZXZlbiB0aGVuLlxuXG5mdW5jdGlvbiBtYWtlUmVxdWVzdENhbGxGcm9tVGltZXIoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVxdWVzdENhbGwoKSB7XG4gICAgICAgIC8vIFdlIGRpc3BhdGNoIGEgdGltZW91dCB3aXRoIGEgc3BlY2lmaWVkIGRlbGF5IG9mIDAgZm9yIGVuZ2luZXMgdGhhdFxuICAgICAgICAvLyBjYW4gcmVsaWFibHkgYWNjb21tb2RhdGUgdGhhdCByZXF1ZXN0LiBUaGlzIHdpbGwgdXN1YWxseSBiZSBzbmFwcGVkXG4gICAgICAgIC8vIHRvIGEgNCBtaWxpc2Vjb25kIGRlbGF5LCBidXQgb25jZSB3ZSdyZSBmbHVzaGluZywgdGhlcmUncyBubyBkZWxheVxuICAgICAgICAvLyBiZXR3ZWVuIGV2ZW50cy5cbiAgICAgICAgdmFyIHRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KGhhbmRsZVRpbWVyLCAwKTtcbiAgICAgICAgLy8gSG93ZXZlciwgc2luY2UgdGhpcyB0aW1lciBnZXRzIGZyZXF1ZW50bHkgZHJvcHBlZCBpbiBGaXJlZm94XG4gICAgICAgIC8vIHdvcmtlcnMsIHdlIGVubGlzdCBhbiBpbnRlcnZhbCBoYW5kbGUgdGhhdCB3aWxsIHRyeSB0byBmaXJlXG4gICAgICAgIC8vIGFuIGV2ZW50IDIwIHRpbWVzIHBlciBzZWNvbmQgdW50aWwgaXQgc3VjY2VlZHMuXG4gICAgICAgIHZhciBpbnRlcnZhbEhhbmRsZSA9IHNldEludGVydmFsKGhhbmRsZVRpbWVyLCA1MCk7XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlVGltZXIoKSB7XG4gICAgICAgICAgICAvLyBXaGljaGV2ZXIgdGltZXIgc3VjY2VlZHMgd2lsbCBjYW5jZWwgYm90aCB0aW1lcnMgYW5kXG4gICAgICAgICAgICAvLyBleGVjdXRlIHRoZSBjYWxsYmFjay5cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SGFuZGxlKTtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxIYW5kbGUpO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8vIFRoaXMgaXMgZm9yIGBhc2FwLmpzYCBvbmx5LlxuLy8gSXRzIG5hbWUgd2lsbCBiZSBwZXJpb2RpY2FsbHkgcmFuZG9taXplZCB0byBicmVhayBhbnkgY29kZSB0aGF0IGRlcGVuZHMgb25cbi8vIGl0cyBleGlzdGVuY2UuXG5yYXdBc2FwLm1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lciA9IG1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lcjtcblxuLy8gQVNBUCB3YXMgb3JpZ2luYWxseSBhIG5leHRUaWNrIHNoaW0gaW5jbHVkZWQgaW4gUS4gVGhpcyB3YXMgZmFjdG9yZWQgb3V0XG4vLyBpbnRvIHRoaXMgQVNBUCBwYWNrYWdlLiBJdCB3YXMgbGF0ZXIgYWRhcHRlZCB0byBSU1ZQIHdoaWNoIG1hZGUgZnVydGhlclxuLy8gYW1lbmRtZW50cy4gVGhlc2UgZGVjaXNpb25zLCBwYXJ0aWN1bGFybHkgdG8gbWFyZ2luYWxpemUgTWVzc2FnZUNoYW5uZWwgYW5kXG4vLyB0byBjYXB0dXJlIHRoZSBNdXRhdGlvbk9ic2VydmVyIGltcGxlbWVudGF0aW9uIGluIGEgY2xvc3VyZSwgd2VyZSBpbnRlZ3JhdGVkXG4vLyBiYWNrIGludG8gQVNBUCBwcm9wZXIuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGlsZGVpby9yc3ZwLmpzL2Jsb2IvY2RkZjcyMzI1NDZhOWNmODU4NTI0Yjc1Y2RlNmY5ZWRmNzI2MjBhNy9saWIvcnN2cC9hc2FwLmpzXG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbi8qIVxuICogQG92ZXJ2aWV3IGVzNi1wcm9taXNlIC0gYSB0aW55IGltcGxlbWVudGF0aW9uIG9mIFByb21pc2VzL0ErLlxuICogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQgWWVodWRhIEthdHosIFRvbSBEYWxlLCBTdGVmYW4gUGVubmVyIGFuZCBjb250cmlidXRvcnMgKENvbnZlcnNpb24gdG8gRVM2IEFQSSBieSBKYWtlIEFyY2hpYmFsZClcbiAqIEBsaWNlbnNlICAgTGljZW5zZWQgdW5kZXIgTUlUIGxpY2Vuc2VcbiAqICAgICAgICAgICAgU2VlIGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9zdGVmYW5wZW5uZXIvZXM2LXByb21pc2UvbWFzdGVyL0xJQ0VOU0VcbiAqIEB2ZXJzaW9uICAgNC4wLjVcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIChnbG9iYWwuRVM2UHJvbWlzZSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb2JqZWN0T3JGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxudmFyIF9pc0FycmF5ID0gdW5kZWZpbmVkO1xuaWYgKCFBcnJheS5pc0FycmF5KSB7XG4gIF9pc0FycmF5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xufSBlbHNlIHtcbiAgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xufVxuXG52YXIgaXNBcnJheSA9IF9pc0FycmF5O1xuXG52YXIgbGVuID0gMDtcbnZhciB2ZXJ0eE5leHQgPSB1bmRlZmluZWQ7XG52YXIgY3VzdG9tU2NoZWR1bGVyRm4gPSB1bmRlZmluZWQ7XG5cbnZhciBhc2FwID0gZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgYXJnKSB7XG4gIHF1ZXVlW2xlbl0gPSBjYWxsYmFjaztcbiAgcXVldWVbbGVuICsgMV0gPSBhcmc7XG4gIGxlbiArPSAyO1xuICBpZiAobGVuID09PSAyKSB7XG4gICAgLy8gSWYgbGVuIGlzIDIsIHRoYXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGFzeW5jIGZsdXNoLlxuICAgIC8vIElmIGFkZGl0aW9uYWwgY2FsbGJhY2tzIGFyZSBxdWV1ZWQgYmVmb3JlIHRoZSBxdWV1ZSBpcyBmbHVzaGVkLCB0aGV5XG4gICAgLy8gd2lsbCBiZSBwcm9jZXNzZWQgYnkgdGhpcyBmbHVzaCB0aGF0IHdlIGFyZSBzY2hlZHVsaW5nLlxuICAgIGlmIChjdXN0b21TY2hlZHVsZXJGbikge1xuICAgICAgY3VzdG9tU2NoZWR1bGVyRm4oZmx1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZUZsdXNoKCk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTY2hlZHVsZXIoc2NoZWR1bGVGbikge1xuICBjdXN0b21TY2hlZHVsZXJGbiA9IHNjaGVkdWxlRm47XG59XG5cbmZ1bmN0aW9uIHNldEFzYXAoYXNhcEZuKSB7XG4gIGFzYXAgPSBhc2FwRm47XG59XG5cbnZhciBicm93c2VyV2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG52YXIgYnJvd3Nlckdsb2JhbCA9IGJyb3dzZXJXaW5kb3cgfHwge307XG52YXIgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPSBicm93c2VyR2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgYnJvd3Nlckdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIGlzTm9kZSA9IHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgKHt9KS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG5cbi8vIHRlc3QgZm9yIHdlYiB3b3JrZXIgYnV0IG5vdCBpbiBJRTEwXG52YXIgaXNXb3JrZXIgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBpbXBvcnRTY3JpcHRzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnO1xuXG4vLyBub2RlXG5mdW5jdGlvbiB1c2VOZXh0VGljaygpIHtcbiAgLy8gbm9kZSB2ZXJzaW9uIDAuMTAueCBkaXNwbGF5cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2hlbiBuZXh0VGljayBpcyB1c2VkIHJlY3Vyc2l2ZWx5XG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3Vqb2pzL3doZW4vaXNzdWVzLzQxMCBmb3IgZGV0YWlsc1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgfTtcbn1cblxuLy8gdmVydHhcbmZ1bmN0aW9uIHVzZVZlcnR4VGltZXIoKSB7XG4gIGlmICh0eXBlb2YgdmVydHhOZXh0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2ZXJ0eE5leHQoZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gdXNlU2V0VGltZW91dCgpO1xufVxuXG5mdW5jdGlvbiB1c2VNdXRhdGlvbk9ic2VydmVyKCkge1xuICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gIHZhciBvYnNlcnZlciA9IG5ldyBCcm93c2VyTXV0YXRpb25PYnNlcnZlcihmbHVzaCk7XG4gIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIG5vZGUuZGF0YSA9IGl0ZXJhdGlvbnMgPSArK2l0ZXJhdGlvbnMgJSAyO1xuICB9O1xufVxuXG4vLyB3ZWIgd29ya2VyXG5mdW5jdGlvbiB1c2VNZXNzYWdlQ2hhbm5lbCgpIHtcbiAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlU2V0VGltZW91dCgpIHtcbiAgLy8gU3RvcmUgc2V0VGltZW91dCByZWZlcmVuY2Ugc28gZXM2LXByb21pc2Ugd2lsbCBiZSB1bmFmZmVjdGVkIGJ5XG4gIC8vIG90aGVyIGNvZGUgbW9kaWZ5aW5nIHNldFRpbWVvdXQgKGxpa2Ugc2lub24udXNlRmFrZVRpbWVycygpKVxuICB2YXIgZ2xvYmFsU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdsb2JhbFNldFRpbWVvdXQoZmx1c2gsIDEpO1xuICB9O1xufVxuXG52YXIgcXVldWUgPSBuZXcgQXJyYXkoMTAwMCk7XG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHZhciBjYWxsYmFjayA9IHF1ZXVlW2ldO1xuICAgIHZhciBhcmcgPSBxdWV1ZVtpICsgMV07XG5cbiAgICBjYWxsYmFjayhhcmcpO1xuXG4gICAgcXVldWVbaV0gPSB1bmRlZmluZWQ7XG4gICAgcXVldWVbaSArIDFdID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gYXR0ZW1wdFZlcnR4KCkge1xuICB0cnkge1xuICAgIHZhciByID0gcmVxdWlyZTtcbiAgICB2YXIgdmVydHggPSByKCd2ZXJ0eCcpO1xuICAgIHZlcnR4TmV4dCA9IHZlcnR4LnJ1bk9uTG9vcCB8fCB2ZXJ0eC5ydW5PbkNvbnRleHQ7XG4gICAgcmV0dXJuIHVzZVZlcnR4VGltZXIoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB1c2VTZXRUaW1lb3V0KCk7XG4gIH1cbn1cblxudmFyIHNjaGVkdWxlRmx1c2ggPSB1bmRlZmluZWQ7XG4vLyBEZWNpZGUgd2hhdCBhc3luYyBtZXRob2QgdG8gdXNlIHRvIHRyaWdnZXJpbmcgcHJvY2Vzc2luZyBvZiBxdWV1ZWQgY2FsbGJhY2tzOlxuaWYgKGlzTm9kZSkge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTmV4dFRpY2soKTtcbn0gZWxzZSBpZiAoQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU11dGF0aW9uT2JzZXJ2ZXIoKTtcbn0gZWxzZSBpZiAoaXNXb3JrZXIpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU1lc3NhZ2VDaGFubmVsKCk7XG59IGVsc2UgaWYgKGJyb3dzZXJXaW5kb3cgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICBzY2hlZHVsZUZsdXNoID0gYXR0ZW1wdFZlcnR4KCk7XG59IGVsc2Uge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlU2V0VGltZW91dCgpO1xufVxuXG5mdW5jdGlvbiB0aGVuKG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gIHZhciBfYXJndW1lbnRzID0gYXJndW1lbnRzO1xuXG4gIHZhciBwYXJlbnQgPSB0aGlzO1xuXG4gIHZhciBjaGlsZCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKG5vb3ApO1xuXG4gIGlmIChjaGlsZFtQUk9NSVNFX0lEXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWFrZVByb21pc2UoY2hpbGQpO1xuICB9XG5cbiAgdmFyIF9zdGF0ZSA9IHBhcmVudC5fc3RhdGU7XG5cbiAgaWYgKF9zdGF0ZSkge1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBfYXJndW1lbnRzW19zdGF0ZSAtIDFdO1xuICAgICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpbnZva2VDYWxsYmFjayhfc3RhdGUsIGNoaWxkLCBjYWxsYmFjaywgcGFyZW50Ll9yZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSkoKTtcbiAgfSBlbHNlIHtcbiAgICBzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkO1xufVxuXG4vKipcbiAgYFByb21pc2UucmVzb2x2ZWAgcmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlY29tZSByZXNvbHZlZCB3aXRoIHRoZVxuICBwYXNzZWQgYHZhbHVlYC4gSXQgaXMgc2hvcnRoYW5kIGZvciB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHJlc29sdmUoMSk7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gdmFsdWUgPT09IDFcbiAgfSk7XG4gIGBgYFxuXG4gIEluc3RlYWQgb2Ygd3JpdGluZyB0aGUgYWJvdmUsIHlvdXIgY29kZSBub3cgc2ltcGx5IGJlY29tZXMgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKDEpO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gdmFsdWUgPT09IDFcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgcmVzb2x2ZVxuICBAc3RhdGljXG4gIEBwYXJhbSB7QW55fSB2YWx1ZSB2YWx1ZSB0aGF0IHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmUgcmVzb2x2ZWQgd2l0aFxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIGZ1bGZpbGxlZCB3aXRoIHRoZSBnaXZlblxuICBgdmFsdWVgXG4qL1xuZnVuY3Rpb24gcmVzb2x2ZShvYmplY3QpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICBpZiAob2JqZWN0ICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdC5jb25zdHJ1Y3RvciA9PT0gQ29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG4gIF9yZXNvbHZlKHByb21pc2UsIG9iamVjdCk7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG52YXIgUFJPTUlTRV9JRCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygxNik7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgUEVORElORyA9IHZvaWQgMDtcbnZhciBGVUxGSUxMRUQgPSAxO1xudmFyIFJFSkVDVEVEID0gMjtcblxudmFyIEdFVF9USEVOX0VSUk9SID0gbmV3IEVycm9yT2JqZWN0KCk7XG5cbmZ1bmN0aW9uIHNlbGZGdWxmaWxsbWVudCgpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJZb3UgY2Fubm90IHJlc29sdmUgYSBwcm9taXNlIHdpdGggaXRzZWxmXCIpO1xufVxuXG5mdW5jdGlvbiBjYW5ub3RSZXR1cm5Pd24oKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKCdBIHByb21pc2VzIGNhbGxiYWNrIGNhbm5vdCByZXR1cm4gdGhhdCBzYW1lIHByb21pc2UuJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRoZW4ocHJvbWlzZSkge1xuICB0cnkge1xuICAgIHJldHVybiBwcm9taXNlLnRoZW47XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgR0VUX1RIRU5fRVJST1IuZXJyb3IgPSBlcnJvcjtcbiAgICByZXR1cm4gR0VUX1RIRU5fRVJST1I7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5VGhlbih0aGVuLCB2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKSB7XG4gIHRyeSB7XG4gICAgdGhlbi5jYWxsKHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlLCB0aGVuKSB7XG4gIGFzYXAoZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICB2YXIgc2VhbGVkID0gZmFsc2U7XG4gICAgdmFyIGVycm9yID0gdHJ5VGhlbih0aGVuLCB0aGVuYWJsZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAoc2VhbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICBpZiAodGhlbmFibGUgIT09IHZhbHVlKSB7XG4gICAgICAgIF9yZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGlmIChzZWFsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VhbGVkID0gdHJ1ZTtcblxuICAgICAgX3JlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0sICdTZXR0bGU6ICcgKyAocHJvbWlzZS5fbGFiZWwgfHwgJyB1bmtub3duIHByb21pc2UnKSk7XG5cbiAgICBpZiAoIXNlYWxlZCAmJiBlcnJvcikge1xuICAgICAgc2VhbGVkID0gdHJ1ZTtcbiAgICAgIF9yZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgIH1cbiAgfSwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlKSB7XG4gIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IEZVTEZJTExFRCkge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gIH0gZWxzZSBpZiAodGhlbmFibGUuX3N0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgIF9yZWplY3QocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgc3Vic2NyaWJlKHRoZW5hYmxlLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIF9yZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICByZXR1cm4gX3JlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbiQkKSB7XG4gIGlmIChtYXliZVRoZW5hYmxlLmNvbnN0cnVjdG9yID09PSBwcm9taXNlLmNvbnN0cnVjdG9yICYmIHRoZW4kJCA9PT0gdGhlbiAmJiBtYXliZVRoZW5hYmxlLmNvbnN0cnVjdG9yLnJlc29sdmUgPT09IHJlc29sdmUpIHtcbiAgICBoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodGhlbiQkID09PSBHRVRfVEhFTl9FUlJPUikge1xuICAgICAgX3JlamVjdChwcm9taXNlLCBHRVRfVEhFTl9FUlJPUi5lcnJvcik7XG4gICAgfSBlbHNlIGlmICh0aGVuJCQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odGhlbiQkKSkge1xuICAgICAgaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIF9yZXNvbHZlKHByb21pc2UsIHZhbHVlKSB7XG4gIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgIF9yZWplY3QocHJvbWlzZSwgc2VsZkZ1bGZpbGxtZW50KCkpO1xuICB9IGVsc2UgaWYgKG9iamVjdE9yRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCB2YWx1ZSwgZ2V0VGhlbih2YWx1ZSkpO1xuICB9IGVsc2Uge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1Ymxpc2hSZWplY3Rpb24ocHJvbWlzZSkge1xuICBpZiAocHJvbWlzZS5fb25lcnJvcikge1xuICAgIHByb21pc2UuX29uZXJyb3IocHJvbWlzZS5fcmVzdWx0KTtcbiAgfVxuXG4gIHB1Ymxpc2gocHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpIHtcbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcHJvbWlzZS5fcmVzdWx0ID0gdmFsdWU7XG4gIHByb21pc2UuX3N0YXRlID0gRlVMRklMTEVEO1xuXG4gIGlmIChwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggIT09IDApIHtcbiAgICBhc2FwKHB1Ymxpc2gsIHByb21pc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9yZWplY3QocHJvbWlzZSwgcmVhc29uKSB7XG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIHJldHVybjtcbiAgfVxuICBwcm9taXNlLl9zdGF0ZSA9IFJFSkVDVEVEO1xuICBwcm9taXNlLl9yZXN1bHQgPSByZWFzb247XG5cbiAgYXNhcChwdWJsaXNoUmVqZWN0aW9uLCBwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gIHZhciBfc3Vic2NyaWJlcnMgPSBwYXJlbnQuX3N1YnNjcmliZXJzO1xuICB2YXIgbGVuZ3RoID0gX3N1YnNjcmliZXJzLmxlbmd0aDtcblxuICBwYXJlbnQuX29uZXJyb3IgPSBudWxsO1xuXG4gIF9zdWJzY3JpYmVyc1tsZW5ndGhdID0gY2hpbGQ7XG4gIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBGVUxGSUxMRURdID0gb25GdWxmaWxsbWVudDtcbiAgX3N1YnNjcmliZXJzW2xlbmd0aCArIFJFSkVDVEVEXSA9IG9uUmVqZWN0aW9uO1xuXG4gIGlmIChsZW5ndGggPT09IDAgJiYgcGFyZW50Ll9zdGF0ZSkge1xuICAgIGFzYXAocHVibGlzaCwgcGFyZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoKHByb21pc2UpIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gcHJvbWlzZS5fc3Vic2NyaWJlcnM7XG4gIHZhciBzZXR0bGVkID0gcHJvbWlzZS5fc3RhdGU7XG5cbiAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjaGlsZCA9IHVuZGVmaW5lZCxcbiAgICAgIGNhbGxiYWNrID0gdW5kZWZpbmVkLFxuICAgICAgZGV0YWlsID0gcHJvbWlzZS5fcmVzdWx0O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICBjaGlsZCA9IHN1YnNjcmliZXJzW2ldO1xuICAgIGNhbGxiYWNrID0gc3Vic2NyaWJlcnNbaSArIHNldHRsZWRdO1xuXG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgfVxuICB9XG5cbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoID0gMDtcbn1cblxuZnVuY3Rpb24gRXJyb3JPYmplY3QoKSB7XG4gIHRoaXMuZXJyb3IgPSBudWxsO1xufVxuXG52YXIgVFJZX0NBVENIX0VSUk9SID0gbmV3IEVycm9yT2JqZWN0KCk7XG5cbmZ1bmN0aW9uIHRyeUNhdGNoKGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FsbGJhY2soZGV0YWlsKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIFRSWV9DQVRDSF9FUlJPUi5lcnJvciA9IGU7XG4gICAgcmV0dXJuIFRSWV9DQVRDSF9FUlJPUjtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBwcm9taXNlLCBjYWxsYmFjaywgZGV0YWlsKSB7XG4gIHZhciBoYXNDYWxsYmFjayA9IGlzRnVuY3Rpb24oY2FsbGJhY2spLFxuICAgICAgdmFsdWUgPSB1bmRlZmluZWQsXG4gICAgICBlcnJvciA9IHVuZGVmaW5lZCxcbiAgICAgIHN1Y2NlZWRlZCA9IHVuZGVmaW5lZCxcbiAgICAgIGZhaWxlZCA9IHVuZGVmaW5lZDtcblxuICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICB2YWx1ZSA9IHRyeUNhdGNoKGNhbGxiYWNrLCBkZXRhaWwpO1xuXG4gICAgaWYgKHZhbHVlID09PSBUUllfQ0FUQ0hfRVJST1IpIHtcbiAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICBlcnJvciA9IHZhbHVlLmVycm9yO1xuICAgICAgdmFsdWUgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgICAgX3JlamVjdChwcm9taXNlLCBjYW5ub3RSZXR1cm5Pd24oKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gZGV0YWlsO1xuICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gIH1cblxuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICAvLyBub29wXG4gIH0gZWxzZSBpZiAoaGFzQ2FsbGJhY2sgJiYgc3VjY2VlZGVkKSB7XG4gICAgICBfcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChmYWlsZWQpIHtcbiAgICAgIF9yZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gRlVMRklMTEVEKSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IFJFSkVDVEVEKSB7XG4gICAgICBfcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVQcm9taXNlKHByb21pc2UsIHJlc29sdmVyKSB7XG4gIHRyeSB7XG4gICAgcmVzb2x2ZXIoZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UodmFsdWUpIHtcbiAgICAgIF9yZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiByZWplY3RQcm9taXNlKHJlYXNvbikge1xuICAgICAgX3JlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgX3JlamVjdChwcm9taXNlLCBlKTtcbiAgfVxufVxuXG52YXIgaWQgPSAwO1xuZnVuY3Rpb24gbmV4dElkKCkge1xuICByZXR1cm4gaWQrKztcbn1cblxuZnVuY3Rpb24gbWFrZVByb21pc2UocHJvbWlzZSkge1xuICBwcm9taXNlW1BST01JU0VfSURdID0gaWQrKztcbiAgcHJvbWlzZS5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gIHByb21pc2UuX3Jlc3VsdCA9IHVuZGVmaW5lZDtcbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMgPSBbXTtcbn1cblxuZnVuY3Rpb24gRW51bWVyYXRvcihDb25zdHJ1Y3RvciwgaW5wdXQpIHtcbiAgdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICB0aGlzLnByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG5cbiAgaWYgKCF0aGlzLnByb21pc2VbUFJPTUlTRV9JRF0pIHtcbiAgICBtYWtlUHJvbWlzZSh0aGlzLnByb21pc2UpO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcbiAgICB0aGlzLmxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICB0aGlzLl9yZW1haW5pbmcgPSBpbnB1dC5sZW5ndGg7XG5cbiAgICB0aGlzLl9yZXN1bHQgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLmxlbmd0aCB8fCAwO1xuICAgICAgdGhpcy5fZW51bWVyYXRlKCk7XG4gICAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgIGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBfcmVqZWN0KHRoaXMucHJvbWlzZSwgdmFsaWRhdGlvbkVycm9yKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRpb25FcnJvcigpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcignQXJyYXkgTWV0aG9kcyBtdXN0IGJlIHByb3ZpZGVkIGFuIEFycmF5Jyk7XG59O1xuXG5FbnVtZXJhdG9yLnByb3RvdHlwZS5fZW51bWVyYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gIHZhciBfaW5wdXQgPSB0aGlzLl9pbnB1dDtcblxuICBmb3IgKHZhciBpID0gMDsgdGhpcy5fc3RhdGUgPT09IFBFTkRJTkcgJiYgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5fZWFjaEVudHJ5KF9pbnB1dFtpXSwgaSk7XG4gIH1cbn07XG5cbkVudW1lcmF0b3IucHJvdG90eXBlLl9lYWNoRW50cnkgPSBmdW5jdGlvbiAoZW50cnksIGkpIHtcbiAgdmFyIGMgPSB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yO1xuICB2YXIgcmVzb2x2ZSQkID0gYy5yZXNvbHZlO1xuXG4gIGlmIChyZXNvbHZlJCQgPT09IHJlc29sdmUpIHtcbiAgICB2YXIgX3RoZW4gPSBnZXRUaGVuKGVudHJ5KTtcblxuICAgIGlmIChfdGhlbiA9PT0gdGhlbiAmJiBlbnRyeS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICAgIHRoaXMuX3NldHRsZWRBdChlbnRyeS5fc3RhdGUsIGksIGVudHJ5Ll9yZXN1bHQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIF90aGVuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLl9yZW1haW5pbmctLTtcbiAgICAgIHRoaXMuX3Jlc3VsdFtpXSA9IGVudHJ5O1xuICAgIH0gZWxzZSBpZiAoYyA9PT0gUHJvbWlzZSkge1xuICAgICAgdmFyIHByb21pc2UgPSBuZXcgYyhub29wKTtcbiAgICAgIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgZW50cnksIF90aGVuKTtcbiAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChwcm9taXNlLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KG5ldyBjKGZ1bmN0aW9uIChyZXNvbHZlJCQpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUkJChlbnRyeSk7XG4gICAgICB9KSwgaSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX3dpbGxTZXR0bGVBdChyZXNvbHZlJCQoZW50cnkpLCBpKTtcbiAgfVxufTtcblxuRW51bWVyYXRvci5wcm90b3R5cGUuX3NldHRsZWRBdCA9IGZ1bmN0aW9uIChzdGF0ZSwgaSwgdmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzLnByb21pc2U7XG5cbiAgaWYgKHByb21pc2UuX3N0YXRlID09PSBQRU5ESU5HKSB7XG4gICAgdGhpcy5fcmVtYWluaW5nLS07XG5cbiAgICBpZiAoc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgICBfcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVzdWx0W2ldID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgfVxufTtcblxuRW51bWVyYXRvci5wcm90b3R5cGUuX3dpbGxTZXR0bGVBdCA9IGZ1bmN0aW9uIChwcm9taXNlLCBpKSB7XG4gIHZhciBlbnVtZXJhdG9yID0gdGhpcztcblxuICBzdWJzY3JpYmUocHJvbWlzZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gZW51bWVyYXRvci5fc2V0dGxlZEF0KEZVTEZJTExFRCwgaSwgdmFsdWUpO1xuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgcmV0dXJuIGVudW1lcmF0b3IuX3NldHRsZWRBdChSRUpFQ1RFRCwgaSwgcmVhc29uKTtcbiAgfSk7XG59O1xuXG4vKipcbiAgYFByb21pc2UuYWxsYCBhY2NlcHRzIGFuIGFycmF5IG9mIHByb21pc2VzLCBhbmQgcmV0dXJucyBhIG5ldyBwcm9taXNlIHdoaWNoXG4gIGlzIGZ1bGZpbGxlZCB3aXRoIGFuIGFycmF5IG9mIGZ1bGZpbGxtZW50IHZhbHVlcyBmb3IgdGhlIHBhc3NlZCBwcm9taXNlcywgb3JcbiAgcmVqZWN0ZWQgd2l0aCB0aGUgcmVhc29uIG9mIHRoZSBmaXJzdCBwYXNzZWQgcHJvbWlzZSB0byBiZSByZWplY3RlZC4gSXQgY2FzdHMgYWxsXG4gIGVsZW1lbnRzIG9mIHRoZSBwYXNzZWQgaXRlcmFibGUgdG8gcHJvbWlzZXMgYXMgaXQgcnVucyB0aGlzIGFsZ29yaXRobS5cblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gcmVzb2x2ZSgxKTtcbiAgbGV0IHByb21pc2UyID0gcmVzb2x2ZSgyKTtcbiAgbGV0IHByb21pc2UzID0gcmVzb2x2ZSgzKTtcbiAgbGV0IHByb21pc2VzID0gWyBwcm9taXNlMSwgcHJvbWlzZTIsIHByb21pc2UzIF07XG5cbiAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oYXJyYXkpe1xuICAgIC8vIFRoZSBhcnJheSBoZXJlIHdvdWxkIGJlIFsgMSwgMiwgMyBdO1xuICB9KTtcbiAgYGBgXG5cbiAgSWYgYW55IG9mIHRoZSBgcHJvbWlzZXNgIGdpdmVuIHRvIGBhbGxgIGFyZSByZWplY3RlZCwgdGhlIGZpcnN0IHByb21pc2VcbiAgdGhhdCBpcyByZWplY3RlZCB3aWxsIGJlIGdpdmVuIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSByZXR1cm5lZCBwcm9taXNlcydzXG4gIHJlamVjdGlvbiBoYW5kbGVyLiBGb3IgZXhhbXBsZTpcblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gcmVzb2x2ZSgxKTtcbiAgbGV0IHByb21pc2UyID0gcmVqZWN0KG5ldyBFcnJvcihcIjJcIikpO1xuICBsZXQgcHJvbWlzZTMgPSByZWplY3QobmV3IEVycm9yKFwiM1wiKSk7XG4gIGxldCBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXG4gIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGFycmF5KXtcbiAgICAvLyBDb2RlIGhlcmUgbmV2ZXIgcnVucyBiZWNhdXNlIHRoZXJlIGFyZSByZWplY3RlZCBwcm9taXNlcyFcbiAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAvLyBlcnJvci5tZXNzYWdlID09PSBcIjJcIlxuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCBhbGxcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FycmF5fSBlbnRyaWVzIGFycmF5IG9mIHByb21pc2VzXG4gIEBwYXJhbSB7U3RyaW5nfSBsYWJlbCBvcHRpb25hbCBzdHJpbmcgZm9yIGxhYmVsaW5nIHRoZSBwcm9taXNlLlxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2hlbiBhbGwgYHByb21pc2VzYCBoYXZlIGJlZW5cbiAgZnVsZmlsbGVkLCBvciByZWplY3RlZCBpZiBhbnkgb2YgdGhlbSBiZWNvbWUgcmVqZWN0ZWQuXG4gIEBzdGF0aWNcbiovXG5mdW5jdGlvbiBhbGwoZW50cmllcykge1xuICByZXR1cm4gbmV3IEVudW1lcmF0b3IodGhpcywgZW50cmllcykucHJvbWlzZTtcbn1cblxuLyoqXG4gIGBQcm9taXNlLnJhY2VgIHJldHVybnMgYSBuZXcgcHJvbWlzZSB3aGljaCBpcyBzZXR0bGVkIGluIHRoZSBzYW1lIHdheSBhcyB0aGVcbiAgZmlyc3QgcGFzc2VkIHByb21pc2UgdG8gc2V0dGxlLlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMScpO1xuICAgIH0sIDIwMCk7XG4gIH0pO1xuXG4gIGxldCBwcm9taXNlMiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZSgncHJvbWlzZSAyJyk7XG4gICAgfSwgMTAwKTtcbiAgfSk7XG5cbiAgUHJvbWlzZS5yYWNlKFtwcm9taXNlMSwgcHJvbWlzZTJdKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgLy8gcmVzdWx0ID09PSAncHJvbWlzZSAyJyBiZWNhdXNlIGl0IHdhcyByZXNvbHZlZCBiZWZvcmUgcHJvbWlzZTFcbiAgICAvLyB3YXMgcmVzb2x2ZWQuXG4gIH0pO1xuICBgYGBcblxuICBgUHJvbWlzZS5yYWNlYCBpcyBkZXRlcm1pbmlzdGljIGluIHRoYXQgb25seSB0aGUgc3RhdGUgb2YgdGhlIGZpcnN0XG4gIHNldHRsZWQgcHJvbWlzZSBtYXR0ZXJzLiBGb3IgZXhhbXBsZSwgZXZlbiBpZiBvdGhlciBwcm9taXNlcyBnaXZlbiB0byB0aGVcbiAgYHByb21pc2VzYCBhcnJheSBhcmd1bWVudCBhcmUgcmVzb2x2ZWQsIGJ1dCB0aGUgZmlyc3Qgc2V0dGxlZCBwcm9taXNlIGhhc1xuICBiZWNvbWUgcmVqZWN0ZWQgYmVmb3JlIHRoZSBvdGhlciBwcm9taXNlcyBiZWNhbWUgZnVsZmlsbGVkLCB0aGUgcmV0dXJuZWRcbiAgcHJvbWlzZSB3aWxsIGJlY29tZSByZWplY3RlZDpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZSgncHJvbWlzZSAxJyk7XG4gICAgfSwgMjAwKTtcbiAgfSk7XG5cbiAgbGV0IHByb21pc2UyID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZWplY3QobmV3IEVycm9yKCdwcm9taXNlIDInKSk7XG4gICAgfSwgMTAwKTtcbiAgfSk7XG5cbiAgUHJvbWlzZS5yYWNlKFtwcm9taXNlMSwgcHJvbWlzZTJdKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnNcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ3Byb21pc2UgMicgYmVjYXVzZSBwcm9taXNlIDIgYmVjYW1lIHJlamVjdGVkIGJlZm9yZVxuICAgIC8vIHByb21pc2UgMSBiZWNhbWUgZnVsZmlsbGVkXG4gIH0pO1xuICBgYGBcblxuICBBbiBleGFtcGxlIHJlYWwtd29ybGQgdXNlIGNhc2UgaXMgaW1wbGVtZW50aW5nIHRpbWVvdXRzOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgUHJvbWlzZS5yYWNlKFthamF4KCdmb28uanNvbicpLCB0aW1lb3V0KDUwMDApXSlcbiAgYGBgXG5cbiAgQG1ldGhvZCByYWNlXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBcnJheX0gcHJvbWlzZXMgYXJyYXkgb2YgcHJvbWlzZXMgdG8gb2JzZXJ2ZVxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB3aGljaCBzZXR0bGVzIGluIHRoZSBzYW1lIHdheSBhcyB0aGUgZmlyc3QgcGFzc2VkXG4gIHByb21pc2UgdG8gc2V0dGxlLlxuKi9cbmZ1bmN0aW9uIHJhY2UoZW50cmllcykge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gIGlmICghaXNBcnJheShlbnRyaWVzKSkge1xuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gKF8sIHJlamVjdCkge1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIHJhY2UuJykpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGVudHJpZXMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBDb25zdHJ1Y3Rvci5yZXNvbHZlKGVudHJpZXNbaV0pLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAgYFByb21pc2UucmVqZWN0YCByZXR1cm5zIGEgcHJvbWlzZSByZWplY3RlZCB3aXRoIHRoZSBwYXNzZWQgYHJlYXNvbmAuXG4gIEl0IGlzIHNob3J0aGFuZCBmb3IgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICByZWplY3QobmV3IEVycm9yKCdXSE9PUFMnKSk7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gQ29kZSBoZXJlIGRvZXNuJ3QgcnVuIGJlY2F1c2UgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQhXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdXSE9PUFMnXG4gIH0pO1xuICBgYGBcblxuICBJbnN0ZWFkIG9mIHdyaXRpbmcgdGhlIGFib3ZlLCB5b3VyIGNvZGUgbm93IHNpbXBseSBiZWNvbWVzIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gQ29kZSBoZXJlIGRvZXNuJ3QgcnVuIGJlY2F1c2UgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQhXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdXSE9PUFMnXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIHJlamVjdFxuICBAc3RhdGljXG4gIEBwYXJhbSB7QW55fSByZWFzb24gdmFsdWUgdGhhdCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGguXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHJlamVjdGVkIHdpdGggdGhlIGdpdmVuIGByZWFzb25gLlxuKi9cbmZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcbiAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG4gIF9yZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIG5lZWRzUmVzb2x2ZXIoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYSByZXNvbHZlciBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIHByb21pc2UgY29uc3RydWN0b3InKTtcbn1cblxuZnVuY3Rpb24gbmVlZHNOZXcoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdQcm9taXNlJzogUGxlYXNlIHVzZSB0aGUgJ25ldycgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG59XG5cbi8qKlxuICBQcm9taXNlIG9iamVjdHMgcmVwcmVzZW50IHRoZSBldmVudHVhbCByZXN1bHQgb2YgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbi4gVGhlXG4gIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsIHdoaWNoXG4gIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlIHJlYXNvblxuICB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICBUZXJtaW5vbG9neVxuICAtLS0tLS0tLS0tLVxuXG4gIC0gYHByb21pc2VgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB3aXRoIGEgYHRoZW5gIG1ldGhvZCB3aG9zZSBiZWhhdmlvciBjb25mb3JtcyB0byB0aGlzIHNwZWNpZmljYXRpb24uXG4gIC0gYHRoZW5hYmxlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gdGhhdCBkZWZpbmVzIGEgYHRoZW5gIG1ldGhvZC5cbiAgLSBgdmFsdWVgIGlzIGFueSBsZWdhbCBKYXZhU2NyaXB0IHZhbHVlIChpbmNsdWRpbmcgdW5kZWZpbmVkLCBhIHRoZW5hYmxlLCBvciBhIHByb21pc2UpLlxuICAtIGBleGNlcHRpb25gIGlzIGEgdmFsdWUgdGhhdCBpcyB0aHJvd24gdXNpbmcgdGhlIHRocm93IHN0YXRlbWVudC5cbiAgLSBgcmVhc29uYCBpcyBhIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoeSBhIHByb21pc2Ugd2FzIHJlamVjdGVkLlxuICAtIGBzZXR0bGVkYCB0aGUgZmluYWwgcmVzdGluZyBzdGF0ZSBvZiBhIHByb21pc2UsIGZ1bGZpbGxlZCBvciByZWplY3RlZC5cblxuICBBIHByb21pc2UgY2FuIGJlIGluIG9uZSBvZiB0aHJlZSBzdGF0ZXM6IHBlbmRpbmcsIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQuXG5cbiAgUHJvbWlzZXMgdGhhdCBhcmUgZnVsZmlsbGVkIGhhdmUgYSBmdWxmaWxsbWVudCB2YWx1ZSBhbmQgYXJlIGluIHRoZSBmdWxmaWxsZWRcbiAgc3RhdGUuICBQcm9taXNlcyB0aGF0IGFyZSByZWplY3RlZCBoYXZlIGEgcmVqZWN0aW9uIHJlYXNvbiBhbmQgYXJlIGluIHRoZVxuICByZWplY3RlZCBzdGF0ZS4gIEEgZnVsZmlsbG1lbnQgdmFsdWUgaXMgbmV2ZXIgYSB0aGVuYWJsZS5cblxuICBQcm9taXNlcyBjYW4gYWxzbyBiZSBzYWlkIHRvICpyZXNvbHZlKiBhIHZhbHVlLiAgSWYgdGhpcyB2YWx1ZSBpcyBhbHNvIGFcbiAgcHJvbWlzZSwgdGhlbiB0aGUgb3JpZ2luYWwgcHJvbWlzZSdzIHNldHRsZWQgc3RhdGUgd2lsbCBtYXRjaCB0aGUgdmFsdWUnc1xuICBzZXR0bGVkIHN0YXRlLiAgU28gYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCByZWplY3RzIHdpbGxcbiAgaXRzZWxmIHJlamVjdCwgYW5kIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgZnVsZmlsbHMgd2lsbFxuICBpdHNlbGYgZnVsZmlsbC5cblxuXG4gIEJhc2ljIFVzYWdlOlxuICAtLS0tLS0tLS0tLS1cblxuICBgYGBqc1xuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIC8vIG9uIHN1Y2Nlc3NcbiAgICByZXNvbHZlKHZhbHVlKTtcblxuICAgIC8vIG9uIGZhaWx1cmVcbiAgICByZWplY3QocmVhc29uKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgLy8gb24gcmVqZWN0aW9uXG4gIH0pO1xuICBgYGBcblxuICBBZHZhbmNlZCBVc2FnZTpcbiAgLS0tLS0tLS0tLS0tLS0tXG5cbiAgUHJvbWlzZXMgc2hpbmUgd2hlbiBhYnN0cmFjdGluZyBhd2F5IGFzeW5jaHJvbm91cyBpbnRlcmFjdGlvbnMgc3VjaCBhc1xuICBgWE1MSHR0cFJlcXVlc3Rgcy5cblxuICBgYGBqc1xuICBmdW5jdGlvbiBnZXRKU09OKHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgbGV0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICB4aHIub3BlbignR0VUJywgdXJsKTtcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBoYW5kbGVyO1xuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgeGhyLnNlbmQoKTtcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gdGhpcy5ET05FKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIHJlc29sdmUodGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2dldEpTT046IGAnICsgdXJsICsgJ2AgZmFpbGVkIHdpdGggc3RhdHVzOiBbJyArIHRoaXMuc3RhdHVzICsgJ10nKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0SlNPTignL3Bvc3RzLmpzb24nKS50aGVuKGZ1bmN0aW9uKGpzb24pIHtcbiAgICAvLyBvbiBmdWxmaWxsbWVudFxuICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAvLyBvbiByZWplY3Rpb25cbiAgfSk7XG4gIGBgYFxuXG4gIFVubGlrZSBjYWxsYmFja3MsIHByb21pc2VzIGFyZSBncmVhdCBjb21wb3NhYmxlIHByaW1pdGl2ZXMuXG5cbiAgYGBganNcbiAgUHJvbWlzZS5hbGwoW1xuICAgIGdldEpTT04oJy9wb3N0cycpLFxuICAgIGdldEpTT04oJy9jb21tZW50cycpXG4gIF0pLnRoZW4oZnVuY3Rpb24odmFsdWVzKXtcbiAgICB2YWx1ZXNbMF0gLy8gPT4gcG9zdHNKU09OXG4gICAgdmFsdWVzWzFdIC8vID0+IGNvbW1lbnRzSlNPTlxuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfSk7XG4gIGBgYFxuXG4gIEBjbGFzcyBQcm9taXNlXG4gIEBwYXJhbSB7ZnVuY3Rpb259IHJlc29sdmVyXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQGNvbnN0cnVjdG9yXG4qL1xuZnVuY3Rpb24gUHJvbWlzZShyZXNvbHZlcikge1xuICB0aGlzW1BST01JU0VfSURdID0gbmV4dElkKCk7XG4gIHRoaXMuX3Jlc3VsdCA9IHRoaXMuX3N0YXRlID0gdW5kZWZpbmVkO1xuICB0aGlzLl9zdWJzY3JpYmVycyA9IFtdO1xuXG4gIGlmIChub29wICE9PSByZXNvbHZlcikge1xuICAgIHR5cGVvZiByZXNvbHZlciAhPT0gJ2Z1bmN0aW9uJyAmJiBuZWVkc1Jlc29sdmVyKCk7XG4gICAgdGhpcyBpbnN0YW5jZW9mIFByb21pc2UgPyBpbml0aWFsaXplUHJvbWlzZSh0aGlzLCByZXNvbHZlcikgOiBuZWVkc05ldygpO1xuICB9XG59XG5cblByb21pc2UuYWxsID0gYWxsO1xuUHJvbWlzZS5yYWNlID0gcmFjZTtcblByb21pc2UucmVzb2x2ZSA9IHJlc29sdmU7XG5Qcm9taXNlLnJlamVjdCA9IHJlamVjdDtcblByb21pc2UuX3NldFNjaGVkdWxlciA9IHNldFNjaGVkdWxlcjtcblByb21pc2UuX3NldEFzYXAgPSBzZXRBc2FwO1xuUHJvbWlzZS5fYXNhcCA9IGFzYXA7XG5cblByb21pc2UucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUHJvbWlzZSxcblxuICAvKipcbiAgICBUaGUgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCxcbiAgICB3aGljaCByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZVxuICAgIHJlYXNvbiB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cbiAgXG4gICAgYGBganNcbiAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24odXNlcil7XG4gICAgICAvLyB1c2VyIGlzIGF2YWlsYWJsZVxuICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAvLyB1c2VyIGlzIHVuYXZhaWxhYmxlLCBhbmQgeW91IGFyZSBnaXZlbiB0aGUgcmVhc29uIHdoeVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBDaGFpbmluZ1xuICAgIC0tLS0tLS0tXG4gIFxuICAgIFRoZSByZXR1cm4gdmFsdWUgb2YgYHRoZW5gIGlzIGl0c2VsZiBhIHByb21pc2UuICBUaGlzIHNlY29uZCwgJ2Rvd25zdHJlYW0nXG4gICAgcHJvbWlzZSBpcyByZXNvbHZlZCB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZpcnN0IHByb21pc2UncyBmdWxmaWxsbWVudFxuICAgIG9yIHJlamVjdGlvbiBoYW5kbGVyLCBvciByZWplY3RlZCBpZiB0aGUgaGFuZGxlciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgcmV0dXJuIHVzZXIubmFtZTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICByZXR1cm4gJ2RlZmF1bHQgbmFtZSc7XG4gICAgfSkudGhlbihmdW5jdGlvbiAodXNlck5hbWUpIHtcbiAgICAgIC8vIElmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgdXNlck5hbWVgIHdpbGwgYmUgdGhlIHVzZXIncyBuYW1lLCBvdGhlcndpc2UgaXRcbiAgICAgIC8vIHdpbGwgYmUgYCdkZWZhdWx0IG5hbWUnYFxuICAgIH0pO1xuICBcbiAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknKTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgLy8gbmV2ZXIgcmVhY2hlZFxuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIC8vIGlmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgcmVhc29uYCB3aWxsIGJlICdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScuXG4gICAgICAvLyBJZiBgZmluZFVzZXJgIHJlamVjdGVkLCBgcmVhc29uYCB3aWxsIGJlICdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jy5cbiAgICB9KTtcbiAgICBgYGBcbiAgICBJZiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIGRvZXMgbm90IHNwZWNpZnkgYSByZWplY3Rpb24gaGFuZGxlciwgcmVqZWN0aW9uIHJlYXNvbnMgd2lsbCBiZSBwcm9wYWdhdGVkIGZ1cnRoZXIgZG93bnN0cmVhbS5cbiAgXG4gICAgYGBganNcbiAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgIHRocm93IG5ldyBQZWRhZ29naWNhbEV4Y2VwdGlvbignVXBzdHJlYW0gZXJyb3InKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgLy8gbmV2ZXIgcmVhY2hlZFxuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgLy8gVGhlIGBQZWRnYWdvY2lhbEV4Y2VwdGlvbmAgaXMgcHJvcGFnYXRlZCBhbGwgdGhlIHdheSBkb3duIHRvIGhlcmVcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQXNzaW1pbGF0aW9uXG4gICAgLS0tLS0tLS0tLS0tXG4gIFxuICAgIFNvbWV0aW1lcyB0aGUgdmFsdWUgeW91IHdhbnQgdG8gcHJvcGFnYXRlIHRvIGEgZG93bnN0cmVhbSBwcm9taXNlIGNhbiBvbmx5IGJlXG4gICAgcmV0cmlldmVkIGFzeW5jaHJvbm91c2x5LiBUaGlzIGNhbiBiZSBhY2hpZXZlZCBieSByZXR1cm5pbmcgYSBwcm9taXNlIGluIHRoZVxuICAgIGZ1bGZpbGxtZW50IG9yIHJlamVjdGlvbiBoYW5kbGVyLiBUaGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgdGhlbiBiZSBwZW5kaW5nXG4gICAgdW50aWwgdGhlIHJldHVybmVkIHByb21pc2UgaXMgc2V0dGxlZC4gVGhpcyBpcyBjYWxsZWQgKmFzc2ltaWxhdGlvbiouXG4gIFxuICAgIGBgYGpzXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICByZXR1cm4gZmluZENvbW1lbnRzQnlBdXRob3IodXNlcik7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAgIC8vIFRoZSB1c2VyJ3MgY29tbWVudHMgYXJlIG5vdyBhdmFpbGFibGVcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgSWYgdGhlIGFzc2ltbGlhdGVkIHByb21pc2UgcmVqZWN0cywgdGhlbiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgYWxzbyByZWplY3QuXG4gIFxuICAgIGBgYGpzXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICByZXR1cm4gZmluZENvbW1lbnRzQnlBdXRob3IodXNlcik7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgZnVsZmlsbHMsIHdlJ2xsIGhhdmUgdGhlIHZhbHVlIGhlcmVcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIHJlamVjdHMsIHdlJ2xsIGhhdmUgdGhlIHJlYXNvbiBoZXJlXG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIFNpbXBsZSBFeGFtcGxlXG4gICAgLS0tLS0tLS0tLS0tLS1cbiAgXG4gICAgU3luY2hyb25vdXMgRXhhbXBsZVxuICBcbiAgICBgYGBqYXZhc2NyaXB0XG4gICAgbGV0IHJlc3VsdDtcbiAgXG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGZpbmRSZXN1bHQoKTtcbiAgICAgIC8vIHN1Y2Nlc3NcbiAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH1cbiAgICBgYGBcbiAgXG4gICAgRXJyYmFjayBFeGFtcGxlXG4gIFxuICAgIGBgYGpzXG4gICAgZmluZFJlc3VsdChmdW5jdGlvbihyZXN1bHQsIGVycil7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH1cbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgUHJvbWlzZSBFeGFtcGxlO1xuICBcbiAgICBgYGBqYXZhc2NyaXB0XG4gICAgZmluZFJlc3VsdCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAgIC8vIHN1Y2Nlc3NcbiAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBBZHZhbmNlZCBFeGFtcGxlXG4gICAgLS0tLS0tLS0tLS0tLS1cbiAgXG4gICAgU3luY2hyb25vdXMgRXhhbXBsZVxuICBcbiAgICBgYGBqYXZhc2NyaXB0XG4gICAgbGV0IGF1dGhvciwgYm9va3M7XG4gIFxuICAgIHRyeSB7XG4gICAgICBhdXRob3IgPSBmaW5kQXV0aG9yKCk7XG4gICAgICBib29rcyAgPSBmaW5kQm9va3NCeUF1dGhvcihhdXRob3IpO1xuICAgICAgLy8gc3VjY2Vzc1xuICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAvLyBmYWlsdXJlXG4gICAgfVxuICAgIGBgYFxuICBcbiAgICBFcnJiYWNrIEV4YW1wbGVcbiAgXG4gICAgYGBganNcbiAgXG4gICAgZnVuY3Rpb24gZm91bmRCb29rcyhib29rcykge1xuICBcbiAgICB9XG4gIFxuICAgIGZ1bmN0aW9uIGZhaWx1cmUocmVhc29uKSB7XG4gIFxuICAgIH1cbiAgXG4gICAgZmluZEF1dGhvcihmdW5jdGlvbihhdXRob3IsIGVycil7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmaW5kQm9vb2tzQnlBdXRob3IoYXV0aG9yLCBmdW5jdGlvbihib29rcywgZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm91bmRCb29rcyhib29rcyk7XG4gICAgICAgICAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgZmFpbHVyZShyZWFzb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgfVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBQcm9taXNlIEV4YW1wbGU7XG4gIFxuICAgIGBgYGphdmFzY3JpcHRcbiAgICBmaW5kQXV0aG9yKCkuXG4gICAgICB0aGVuKGZpbmRCb29rc0J5QXV0aG9yKS5cbiAgICAgIHRoZW4oZnVuY3Rpb24oYm9va3Mpe1xuICAgICAgICAvLyBmb3VuZCBib29rc1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBAbWV0aG9kIHRoZW5cbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvbkZ1bGZpbGxlZFxuICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0ZWRcbiAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cbiAgdGhlbjogdGhlbixcblxuICAvKipcbiAgICBgY2F0Y2hgIGlzIHNpbXBseSBzdWdhciBmb3IgYHRoZW4odW5kZWZpbmVkLCBvblJlamVjdGlvbilgIHdoaWNoIG1ha2VzIGl0IHRoZSBzYW1lXG4gICAgYXMgdGhlIGNhdGNoIGJsb2NrIG9mIGEgdHJ5L2NhdGNoIHN0YXRlbWVudC5cbiAgXG4gICAgYGBganNcbiAgICBmdW5jdGlvbiBmaW5kQXV0aG9yKCl7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkbid0IGZpbmQgdGhhdCBhdXRob3InKTtcbiAgICB9XG4gIFxuICAgIC8vIHN5bmNocm9ub3VzXG4gICAgdHJ5IHtcbiAgICAgIGZpbmRBdXRob3IoKTtcbiAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICB9XG4gIFxuICAgIC8vIGFzeW5jIHdpdGggcHJvbWlzZXNcbiAgICBmaW5kQXV0aG9yKCkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIEBtZXRob2QgY2F0Y2hcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGlvblxuICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuICAnY2F0Y2gnOiBmdW5jdGlvbiBfY2F0Y2gob25SZWplY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0aW9uKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gICAgdmFyIGxvY2FsID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGxvY2FsID0gZ2xvYmFsO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGxvY2FsID0gc2VsZjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbG9jYWwgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvbHlmaWxsIGZhaWxlZCBiZWNhdXNlIGdsb2JhbCBvYmplY3QgaXMgdW5hdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFAgPSBsb2NhbC5Qcm9taXNlO1xuXG4gICAgaWYgKFApIHtcbiAgICAgICAgdmFyIHByb21pc2VUb1N0cmluZyA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm9taXNlVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUC5yZXNvbHZlKCkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBzaWxlbnRseSBpZ25vcmVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvbWlzZVRvU3RyaW5nID09PSAnW29iamVjdCBQcm9taXNlXScgJiYgIVAuY2FzdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9jYWwuUHJvbWlzZSA9IFByb21pc2U7XG59XG5cbi8vIFN0cmFuZ2UgY29tcGF0Li5cblByb21pc2UucG9seWZpbGwgPSBwb2x5ZmlsbDtcblByb21pc2UuUHJvbWlzZSA9IFByb21pc2U7XG5cbnJldHVybiBQcm9taXNlO1xuXG59KSkpO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCJfcHJvY2Vzc1wiOjY1fV0sNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4vLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfaGFuZGxlYmFyc1J1bnRpbWUgPSByZXF1aXJlKCcuL2hhbmRsZWJhcnMucnVudGltZScpO1xuXG52YXIgX2hhbmRsZWJhcnNSdW50aW1lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hhbmRsZWJhcnNSdW50aW1lKTtcblxuLy8gQ29tcGlsZXIgaW1wb3J0c1xuXG52YXIgX2hhbmRsZWJhcnNDb21waWxlckFzdCA9IHJlcXVpcmUoJy4vaGFuZGxlYmFycy9jb21waWxlci9hc3QnKTtcblxudmFyIF9oYW5kbGViYXJzQ29tcGlsZXJBc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFuZGxlYmFyc0NvbXBpbGVyQXN0KTtcblxudmFyIF9oYW5kbGViYXJzQ29tcGlsZXJCYXNlID0gcmVxdWlyZSgnLi9oYW5kbGViYXJzL2NvbXBpbGVyL2Jhc2UnKTtcblxudmFyIF9oYW5kbGViYXJzQ29tcGlsZXJDb21waWxlciA9IHJlcXVpcmUoJy4vaGFuZGxlYmFycy9jb21waWxlci9jb21waWxlcicpO1xuXG52YXIgX2hhbmRsZWJhcnNDb21waWxlckphdmFzY3JpcHRDb21waWxlciA9IHJlcXVpcmUoJy4vaGFuZGxlYmFycy9jb21waWxlci9qYXZhc2NyaXB0LWNvbXBpbGVyJyk7XG5cbnZhciBfaGFuZGxlYmFyc0NvbXBpbGVySmF2YXNjcmlwdENvbXBpbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hhbmRsZWJhcnNDb21waWxlckphdmFzY3JpcHRDb21waWxlcik7XG5cbnZhciBfaGFuZGxlYmFyc0NvbXBpbGVyVmlzaXRvciA9IHJlcXVpcmUoJy4vaGFuZGxlYmFycy9jb21waWxlci92aXNpdG9yJyk7XG5cbnZhciBfaGFuZGxlYmFyc0NvbXBpbGVyVmlzaXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oYW5kbGViYXJzQ29tcGlsZXJWaXNpdG9yKTtcblxudmFyIF9oYW5kbGViYXJzTm9Db25mbGljdCA9IHJlcXVpcmUoJy4vaGFuZGxlYmFycy9uby1jb25mbGljdCcpO1xuXG52YXIgX2hhbmRsZWJhcnNOb0NvbmZsaWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hhbmRsZWJhcnNOb0NvbmZsaWN0KTtcblxudmFyIF9jcmVhdGUgPSBfaGFuZGxlYmFyc1J1bnRpbWUyWydkZWZhdWx0J10uY3JlYXRlO1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgaGIgPSBfY3JlYXRlKCk7XG5cbiAgaGIuY29tcGlsZSA9IGZ1bmN0aW9uIChpbnB1dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBfaGFuZGxlYmFyc0NvbXBpbGVyQ29tcGlsZXIuY29tcGlsZShpbnB1dCwgb3B0aW9ucywgaGIpO1xuICB9O1xuICBoYi5wcmVjb21waWxlID0gZnVuY3Rpb24gKGlucHV0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9oYW5kbGViYXJzQ29tcGlsZXJDb21waWxlci5wcmVjb21waWxlKGlucHV0LCBvcHRpb25zLCBoYik7XG4gIH07XG5cbiAgaGIuQVNUID0gX2hhbmRsZWJhcnNDb21waWxlckFzdDJbJ2RlZmF1bHQnXTtcbiAgaGIuQ29tcGlsZXIgPSBfaGFuZGxlYmFyc0NvbXBpbGVyQ29tcGlsZXIuQ29tcGlsZXI7XG4gIGhiLkphdmFTY3JpcHRDb21waWxlciA9IF9oYW5kbGViYXJzQ29tcGlsZXJKYXZhc2NyaXB0Q29tcGlsZXIyWydkZWZhdWx0J107XG4gIGhiLlBhcnNlciA9IF9oYW5kbGViYXJzQ29tcGlsZXJCYXNlLnBhcnNlcjtcbiAgaGIucGFyc2UgPSBfaGFuZGxlYmFyc0NvbXBpbGVyQmFzZS5wYXJzZTtcblxuICByZXR1cm4gaGI7XG59XG5cbnZhciBpbnN0ID0gY3JlYXRlKCk7XG5pbnN0LmNyZWF0ZSA9IGNyZWF0ZTtcblxuX2hhbmRsZWJhcnNOb0NvbmZsaWN0MlsnZGVmYXVsdCddKGluc3QpO1xuXG5pbnN0LlZpc2l0b3IgPSBfaGFuZGxlYmFyc0NvbXBpbGVyVmlzaXRvcjJbJ2RlZmF1bHQnXTtcblxuaW5zdFsnZGVmYXVsdCddID0gaW5zdDtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gaW5zdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbn0se1wiLi9oYW5kbGViYXJzLnJ1bnRpbWVcIjo2LFwiLi9oYW5kbGViYXJzL2NvbXBpbGVyL2FzdFwiOjgsXCIuL2hhbmRsZWJhcnMvY29tcGlsZXIvYmFzZVwiOjksXCIuL2hhbmRsZWJhcnMvY29tcGlsZXIvY29tcGlsZXJcIjoxMSxcIi4vaGFuZGxlYmFycy9jb21waWxlci9qYXZhc2NyaXB0LWNvbXBpbGVyXCI6MTMsXCIuL2hhbmRsZWJhcnMvY29tcGlsZXIvdmlzaXRvclwiOjE2LFwiLi9oYW5kbGViYXJzL25vLWNvbmZsaWN0XCI6MzB9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbi8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLy8gaXN0YW5idWwgaWdub3JlIG5leHRcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09ialsnZGVmYXVsdCddID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxudmFyIF9oYW5kbGViYXJzQmFzZSA9IHJlcXVpcmUoJy4vaGFuZGxlYmFycy9iYXNlJyk7XG5cbnZhciBiYXNlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2hhbmRsZWJhcnNCYXNlKTtcblxuLy8gRWFjaCBvZiB0aGVzZSBhdWdtZW50IHRoZSBIYW5kbGViYXJzIG9iamVjdC4gTm8gbmVlZCB0byBzZXR1cCBoZXJlLlxuLy8gKFRoaXMgaXMgZG9uZSB0byBlYXNpbHkgc2hhcmUgY29kZSBiZXR3ZWVuIGNvbW1vbmpzIGFuZCBicm93c2UgZW52cylcblxudmFyIF9oYW5kbGViYXJzU2FmZVN0cmluZyA9IHJlcXVpcmUoJy4vaGFuZGxlYmFycy9zYWZlLXN0cmluZycpO1xuXG52YXIgX2hhbmRsZWJhcnNTYWZlU3RyaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hhbmRsZWJhcnNTYWZlU3RyaW5nKTtcblxudmFyIF9oYW5kbGViYXJzRXhjZXB0aW9uID0gcmVxdWlyZSgnLi9oYW5kbGViYXJzL2V4Y2VwdGlvbicpO1xuXG52YXIgX2hhbmRsZWJhcnNFeGNlcHRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFuZGxlYmFyc0V4Y2VwdGlvbik7XG5cbnZhciBfaGFuZGxlYmFyc1V0aWxzID0gcmVxdWlyZSgnLi9oYW5kbGViYXJzL3V0aWxzJyk7XG5cbnZhciBVdGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9oYW5kbGViYXJzVXRpbHMpO1xuXG52YXIgX2hhbmRsZWJhcnNSdW50aW1lID0gcmVxdWlyZSgnLi9oYW5kbGViYXJzL3J1bnRpbWUnKTtcblxudmFyIHJ1bnRpbWUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfaGFuZGxlYmFyc1J1bnRpbWUpO1xuXG52YXIgX2hhbmRsZWJhcnNOb0NvbmZsaWN0ID0gcmVxdWlyZSgnLi9oYW5kbGViYXJzL25vLWNvbmZsaWN0Jyk7XG5cbnZhciBfaGFuZGxlYmFyc05vQ29uZmxpY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFuZGxlYmFyc05vQ29uZmxpY3QpO1xuXG4vLyBGb3IgY29tcGF0aWJpbGl0eSBhbmQgdXNhZ2Ugb3V0c2lkZSBvZiBtb2R1bGUgc3lzdGVtcywgbWFrZSB0aGUgSGFuZGxlYmFycyBvYmplY3QgYSBuYW1lc3BhY2VcbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIGhiID0gbmV3IGJhc2UuSGFuZGxlYmFyc0Vudmlyb25tZW50KCk7XG5cbiAgVXRpbHMuZXh0ZW5kKGhiLCBiYXNlKTtcbiAgaGIuU2FmZVN0cmluZyA9IF9oYW5kbGViYXJzU2FmZVN0cmluZzJbJ2RlZmF1bHQnXTtcbiAgaGIuRXhjZXB0aW9uID0gX2hhbmRsZWJhcnNFeGNlcHRpb24yWydkZWZhdWx0J107XG4gIGhiLlV0aWxzID0gVXRpbHM7XG4gIGhiLmVzY2FwZUV4cHJlc3Npb24gPSBVdGlscy5lc2NhcGVFeHByZXNzaW9uO1xuXG4gIGhiLlZNID0gcnVudGltZTtcbiAgaGIudGVtcGxhdGUgPSBmdW5jdGlvbiAoc3BlYykge1xuICAgIHJldHVybiBydW50aW1lLnRlbXBsYXRlKHNwZWMsIGhiKTtcbiAgfTtcblxuICByZXR1cm4gaGI7XG59XG5cbnZhciBpbnN0ID0gY3JlYXRlKCk7XG5pbnN0LmNyZWF0ZSA9IGNyZWF0ZTtcblxuX2hhbmRsZWJhcnNOb0NvbmZsaWN0MlsnZGVmYXVsdCddKGluc3QpO1xuXG5pbnN0WydkZWZhdWx0J10gPSBpbnN0O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBpbnN0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxufSx7XCIuL2hhbmRsZWJhcnMvYmFzZVwiOjcsXCIuL2hhbmRsZWJhcnMvZXhjZXB0aW9uXCI6MjAsXCIuL2hhbmRsZWJhcnMvbm8tY29uZmxpY3RcIjozMCxcIi4vaGFuZGxlYmFycy9ydW50aW1lXCI6MzEsXCIuL2hhbmRsZWJhcnMvc2FmZS1zdHJpbmdcIjozMixcIi4vaGFuZGxlYmFycy91dGlsc1wiOjMzfV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLkhhbmRsZWJhcnNFbnZpcm9ubWVudCA9IEhhbmRsZWJhcnNFbnZpcm9ubWVudDtcbi8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIF9leGNlcHRpb24gPSByZXF1aXJlKCcuL2V4Y2VwdGlvbicpO1xuXG52YXIgX2V4Y2VwdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leGNlcHRpb24pO1xuXG52YXIgX2hlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcblxudmFyIF9kZWNvcmF0b3JzID0gcmVxdWlyZSgnLi9kZWNvcmF0b3JzJyk7XG5cbnZhciBfbG9nZ2VyID0gcmVxdWlyZSgnLi9sb2dnZXInKTtcblxudmFyIF9sb2dnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9nZ2VyKTtcblxudmFyIFZFUlNJT04gPSAnNC4wLjUnO1xuZXhwb3J0cy5WRVJTSU9OID0gVkVSU0lPTjtcbnZhciBDT01QSUxFUl9SRVZJU0lPTiA9IDc7XG5cbmV4cG9ydHMuQ09NUElMRVJfUkVWSVNJT04gPSBDT01QSUxFUl9SRVZJU0lPTjtcbnZhciBSRVZJU0lPTl9DSEFOR0VTID0ge1xuICAxOiAnPD0gMS4wLnJjLjInLCAvLyAxLjAucmMuMiBpcyBhY3R1YWxseSByZXYyIGJ1dCBkb2Vzbid0IHJlcG9ydCBpdFxuICAyOiAnPT0gMS4wLjAtcmMuMycsXG4gIDM6ICc9PSAxLjAuMC1yYy40JyxcbiAgNDogJz09IDEueC54JyxcbiAgNTogJz09IDIuMC4wLWFscGhhLngnLFxuICA2OiAnPj0gMi4wLjAtYmV0YS4xJyxcbiAgNzogJz49IDQuMC4wJ1xufTtcblxuZXhwb3J0cy5SRVZJU0lPTl9DSEFOR0VTID0gUkVWSVNJT05fQ0hBTkdFUztcbnZhciBvYmplY3RUeXBlID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbmZ1bmN0aW9uIEhhbmRsZWJhcnNFbnZpcm9ubWVudChoZWxwZXJzLCBwYXJ0aWFscywgZGVjb3JhdG9ycykge1xuICB0aGlzLmhlbHBlcnMgPSBoZWxwZXJzIHx8IHt9O1xuICB0aGlzLnBhcnRpYWxzID0gcGFydGlhbHMgfHwge307XG4gIHRoaXMuZGVjb3JhdG9ycyA9IGRlY29yYXRvcnMgfHwge307XG5cbiAgX2hlbHBlcnMucmVnaXN0ZXJEZWZhdWx0SGVscGVycyh0aGlzKTtcbiAgX2RlY29yYXRvcnMucmVnaXN0ZXJEZWZhdWx0RGVjb3JhdG9ycyh0aGlzKTtcbn1cblxuSGFuZGxlYmFyc0Vudmlyb25tZW50LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEhhbmRsZWJhcnNFbnZpcm9ubWVudCxcblxuICBsb2dnZXI6IF9sb2dnZXIyWydkZWZhdWx0J10sXG4gIGxvZzogX2xvZ2dlcjJbJ2RlZmF1bHQnXS5sb2csXG5cbiAgcmVnaXN0ZXJIZWxwZXI6IGZ1bmN0aW9uIHJlZ2lzdGVySGVscGVyKG5hbWUsIGZuKSB7XG4gICAgaWYgKF91dGlscy50b1N0cmluZy5jYWxsKG5hbWUpID09PSBvYmplY3RUeXBlKSB7XG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ0FyZyBub3Qgc3VwcG9ydGVkIHdpdGggbXVsdGlwbGUgaGVscGVycycpO1xuICAgICAgfVxuICAgICAgX3V0aWxzLmV4dGVuZCh0aGlzLmhlbHBlcnMsIG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlbHBlcnNbbmFtZV0gPSBmbjtcbiAgICB9XG4gIH0sXG4gIHVucmVnaXN0ZXJIZWxwZXI6IGZ1bmN0aW9uIHVucmVnaXN0ZXJIZWxwZXIobmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLmhlbHBlcnNbbmFtZV07XG4gIH0sXG5cbiAgcmVnaXN0ZXJQYXJ0aWFsOiBmdW5jdGlvbiByZWdpc3RlclBhcnRpYWwobmFtZSwgcGFydGlhbCkge1xuICAgIGlmIChfdXRpbHMudG9TdHJpbmcuY2FsbChuYW1lKSA9PT0gb2JqZWN0VHlwZSkge1xuICAgICAgX3V0aWxzLmV4dGVuZCh0aGlzLnBhcnRpYWxzLCBuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBwYXJ0aWFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnQXR0ZW1wdGluZyB0byByZWdpc3RlciBhIHBhcnRpYWwgY2FsbGVkIFwiJyArIG5hbWUgKyAnXCIgYXMgdW5kZWZpbmVkJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnBhcnRpYWxzW25hbWVdID0gcGFydGlhbDtcbiAgICB9XG4gIH0sXG4gIHVucmVnaXN0ZXJQYXJ0aWFsOiBmdW5jdGlvbiB1bnJlZ2lzdGVyUGFydGlhbChuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMucGFydGlhbHNbbmFtZV07XG4gIH0sXG5cbiAgcmVnaXN0ZXJEZWNvcmF0b3I6IGZ1bmN0aW9uIHJlZ2lzdGVyRGVjb3JhdG9yKG5hbWUsIGZuKSB7XG4gICAgaWYgKF91dGlscy50b1N0cmluZy5jYWxsKG5hbWUpID09PSBvYmplY3RUeXBlKSB7XG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ0FyZyBub3Qgc3VwcG9ydGVkIHdpdGggbXVsdGlwbGUgZGVjb3JhdG9ycycpO1xuICAgICAgfVxuICAgICAgX3V0aWxzLmV4dGVuZCh0aGlzLmRlY29yYXRvcnMsIG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlY29yYXRvcnNbbmFtZV0gPSBmbjtcbiAgICB9XG4gIH0sXG4gIHVucmVnaXN0ZXJEZWNvcmF0b3I6IGZ1bmN0aW9uIHVucmVnaXN0ZXJEZWNvcmF0b3IobmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLmRlY29yYXRvcnNbbmFtZV07XG4gIH1cbn07XG5cbnZhciBsb2cgPSBfbG9nZ2VyMlsnZGVmYXVsdCddLmxvZztcblxuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmNyZWF0ZUZyYW1lID0gX3V0aWxzLmNyZWF0ZUZyYW1lO1xuZXhwb3J0cy5sb2dnZXIgPSBfbG9nZ2VyMlsnZGVmYXVsdCddO1xuXG5cbn0se1wiLi9kZWNvcmF0b3JzXCI6MTgsXCIuL2V4Y2VwdGlvblwiOjIwLFwiLi9oZWxwZXJzXCI6MjEsXCIuL2xvZ2dlclwiOjI5LFwiLi91dGlsc1wiOjMzfV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgQVNUID0ge1xuICAvLyBQdWJsaWMgQVBJIHVzZWQgdG8gZXZhbHVhdGUgZGVyaXZlZCBhdHRyaWJ1dGVzIHJlZ2FyZGluZyBBU1Qgbm9kZXNcbiAgaGVscGVyczoge1xuICAgIC8vIGEgbXVzdGFjaGUgaXMgZGVmaW5pdGVseSBhIGhlbHBlciBpZjpcbiAgICAvLyAqIGl0IGlzIGFuIGVsaWdpYmxlIGhlbHBlciwgYW5kXG4gICAgLy8gKiBpdCBoYXMgYXQgbGVhc3Qgb25lIHBhcmFtZXRlciBvciBoYXNoIHNlZ21lbnRcbiAgICBoZWxwZXJFeHByZXNzaW9uOiBmdW5jdGlvbiBoZWxwZXJFeHByZXNzaW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdTdWJFeHByZXNzaW9uJyB8fCAobm9kZS50eXBlID09PSAnTXVzdGFjaGVTdGF0ZW1lbnQnIHx8IG5vZGUudHlwZSA9PT0gJ0Jsb2NrU3RhdGVtZW50JykgJiYgISEobm9kZS5wYXJhbXMgJiYgbm9kZS5wYXJhbXMubGVuZ3RoIHx8IG5vZGUuaGFzaCk7XG4gICAgfSxcblxuICAgIHNjb3BlZElkOiBmdW5jdGlvbiBzY29wZWRJZChwYXRoKSB7XG4gICAgICByZXR1cm4gKC9eXFwufHRoaXNcXGIvLnRlc3QocGF0aC5vcmlnaW5hbClcbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8vIGFuIElEIGlzIHNpbXBsZSBpZiBpdCBvbmx5IGhhcyBvbmUgcGFydCwgYW5kIHRoYXQgcGFydCBpcyBub3RcbiAgICAvLyBgLi5gIG9yIGB0aGlzYC5cbiAgICBzaW1wbGVJZDogZnVuY3Rpb24gc2ltcGxlSWQocGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGgucGFydHMubGVuZ3RoID09PSAxICYmICFBU1QuaGVscGVycy5zY29wZWRJZChwYXRoKSAmJiAhcGF0aC5kZXB0aDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIE11c3QgYmUgZXhwb3J0ZWQgYXMgYW4gb2JqZWN0IHJhdGhlciB0aGFuIHRoZSByb290IG9mIHRoZSBtb2R1bGUgYXMgdGhlIGppc29uIGxleGVyXG4vLyBtdXN0IG1vZGlmeSB0aGUgb2JqZWN0IHRvIG9wZXJhdGUgcHJvcGVybHkuXG5leHBvcnRzWydkZWZhdWx0J10gPSBBU1Q7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG59LHt9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbi8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmpbJ2RlZmF1bHQnXSA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbi8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9wYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcicpO1xuXG52YXIgX3BhcnNlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJzZXIpO1xuXG52YXIgX3doaXRlc3BhY2VDb250cm9sID0gcmVxdWlyZSgnLi93aGl0ZXNwYWNlLWNvbnRyb2wnKTtcblxudmFyIF93aGl0ZXNwYWNlQ29udHJvbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93aGl0ZXNwYWNlQ29udHJvbCk7XG5cbnZhciBfaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xuXG52YXIgSGVscGVycyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9oZWxwZXJzKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmV4cG9ydHMucGFyc2VyID0gX3BhcnNlcjJbJ2RlZmF1bHQnXTtcblxudmFyIHl5ID0ge307XG5fdXRpbHMuZXh0ZW5kKHl5LCBIZWxwZXJzKTtcblxuZnVuY3Rpb24gcGFyc2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgLy8gSnVzdCByZXR1cm4gaWYgYW4gYWxyZWFkeS1jb21waWxlZCBBU1Qgd2FzIHBhc3NlZCBpbi5cbiAgaWYgKGlucHV0LnR5cGUgPT09ICdQcm9ncmFtJykge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuXG4gIF9wYXJzZXIyWydkZWZhdWx0J10ueXkgPSB5eTtcblxuICAvLyBBbHRlcmluZyB0aGUgc2hhcmVkIG9iamVjdCBoZXJlLCBidXQgdGhpcyBpcyBvayBhcyBwYXJzZXIgaXMgYSBzeW5jIG9wZXJhdGlvblxuICB5eS5sb2NJbmZvID0gZnVuY3Rpb24gKGxvY0luZm8pIHtcbiAgICByZXR1cm4gbmV3IHl5LlNvdXJjZUxvY2F0aW9uKG9wdGlvbnMgJiYgb3B0aW9ucy5zcmNOYW1lLCBsb2NJbmZvKTtcbiAgfTtcblxuICB2YXIgc3RyaXAgPSBuZXcgX3doaXRlc3BhY2VDb250cm9sMlsnZGVmYXVsdCddKG9wdGlvbnMpO1xuICByZXR1cm4gc3RyaXAuYWNjZXB0KF9wYXJzZXIyWydkZWZhdWx0J10ucGFyc2UoaW5wdXQpKTtcbn1cblxuXG59LHtcIi4uL3V0aWxzXCI6MzMsXCIuL2hlbHBlcnNcIjoxMixcIi4vcGFyc2VyXCI6MTQsXCIuL3doaXRlc3BhY2UtY29udHJvbFwiOjE3fV0sMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyogZ2xvYmFsIGRlZmluZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxudmFyIFNvdXJjZU5vZGUgPSB1bmRlZmluZWQ7XG5cbnRyeSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nIHx8ICFkZWZpbmUuYW1kKSB7XG4gICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCB0aGlzIGluIEFNRCBlbnZpcm9ubWVudHMuIEZvciB0aGVzZSBlbnZpcm9ubWVudHMsIHdlIGFzdXNtZSB0aGF0XG4gICAgLy8gdGhleSBhcmUgcnVubmluZyBvbiB0aGUgYnJvd3NlciBhbmQgdGh1cyBoYXZlIG5vIG5lZWQgZm9yIHRoZSBzb3VyY2UtbWFwIGxpYnJhcnkuXG4gICAgdmFyIFNvdXJjZU1hcCA9IHJlcXVpcmUoJ3NvdXJjZS1tYXAnKTtcbiAgICBTb3VyY2VOb2RlID0gU291cmNlTWFwLlNvdXJjZU5vZGU7XG4gIH1cbn0gY2F0Y2ggKGVycikge31cbi8qIE5PUCAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWY6IHRlc3RlZCBidXQgbm90IGNvdmVyZWQgaW4gaXN0YW5idWwgZHVlIHRvIGRpc3QgYnVpbGQgICovXG5pZiAoIVNvdXJjZU5vZGUpIHtcbiAgU291cmNlTm9kZSA9IGZ1bmN0aW9uIChsaW5lLCBjb2x1bW4sIHNyY0ZpbGUsIGNodW5rcykge1xuICAgIHRoaXMuc3JjID0gJyc7XG4gICAgaWYgKGNodW5rcykge1xuICAgICAgdGhpcy5hZGQoY2h1bmtzKTtcbiAgICB9XG4gIH07XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlID0ge1xuICAgIGFkZDogZnVuY3Rpb24gYWRkKGNodW5rcykge1xuICAgICAgaWYgKF91dGlscy5pc0FycmF5KGNodW5rcykpIHtcbiAgICAgICAgY2h1bmtzID0gY2h1bmtzLmpvaW4oJycpO1xuICAgICAgfVxuICAgICAgdGhpcy5zcmMgKz0gY2h1bmtzO1xuICAgIH0sXG4gICAgcHJlcGVuZDogZnVuY3Rpb24gcHJlcGVuZChjaHVua3MpIHtcbiAgICAgIGlmIChfdXRpbHMuaXNBcnJheShjaHVua3MpKSB7XG4gICAgICAgIGNodW5rcyA9IGNodW5rcy5qb2luKCcnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3JjID0gY2h1bmtzICsgdGhpcy5zcmM7XG4gICAgfSxcbiAgICB0b1N0cmluZ1dpdGhTb3VyY2VNYXA6IGZ1bmN0aW9uIHRvU3RyaW5nV2l0aFNvdXJjZU1hcCgpIHtcbiAgICAgIHJldHVybiB7IGNvZGU6IHRoaXMudG9TdHJpbmcoKSB9O1xuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3JjO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY2FzdENodW5rKGNodW5rLCBjb2RlR2VuLCBsb2MpIHtcbiAgaWYgKF91dGlscy5pc0FycmF5KGNodW5rKSkge1xuICAgIHZhciByZXQgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaHVuay5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcmV0LnB1c2goY29kZUdlbi53cmFwKGNodW5rW2ldLCBsb2MpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgPT09ICdib29sZWFuJyB8fCB0eXBlb2YgY2h1bmsgPT09ICdudW1iZXInKSB7XG4gICAgLy8gSGFuZGxlIHByaW1pdGl2ZXMgdGhhdCB0aGUgU291cmNlTm9kZSB3aWxsIHRocm93IHVwIG9uXG4gICAgcmV0dXJuIGNodW5rICsgJyc7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG5mdW5jdGlvbiBDb2RlR2VuKHNyY0ZpbGUpIHtcbiAgdGhpcy5zcmNGaWxlID0gc3JjRmlsZTtcbiAgdGhpcy5zb3VyY2UgPSBbXTtcbn1cblxuQ29kZUdlbi5wcm90b3R5cGUgPSB7XG4gIGlzRW1wdHk6IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuICF0aGlzLnNvdXJjZS5sZW5ndGg7XG4gIH0sXG4gIHByZXBlbmQ6IGZ1bmN0aW9uIHByZXBlbmQoc291cmNlLCBsb2MpIHtcbiAgICB0aGlzLnNvdXJjZS51bnNoaWZ0KHRoaXMud3JhcChzb3VyY2UsIGxvYykpO1xuICB9LFxuICBwdXNoOiBmdW5jdGlvbiBwdXNoKHNvdXJjZSwgbG9jKSB7XG4gICAgdGhpcy5zb3VyY2UucHVzaCh0aGlzLndyYXAoc291cmNlLCBsb2MpKTtcbiAgfSxcblxuICBtZXJnZTogZnVuY3Rpb24gbWVyZ2UoKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXMuZW1wdHkoKTtcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIHNvdXJjZS5hZGQoWycgICcsIGxpbmUsICdcXG4nXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfSxcblxuICBlYWNoOiBmdW5jdGlvbiBlYWNoKGl0ZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5zb3VyY2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGl0ZXIodGhpcy5zb3VyY2VbaV0pO1xuICAgIH1cbiAgfSxcblxuICBlbXB0eTogZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgdmFyIGxvYyA9IHRoaXMuY3VycmVudExvY2F0aW9uIHx8IHsgc3RhcnQ6IHt9IH07XG4gICAgcmV0dXJuIG5ldyBTb3VyY2VOb2RlKGxvYy5zdGFydC5saW5lLCBsb2Muc3RhcnQuY29sdW1uLCB0aGlzLnNyY0ZpbGUpO1xuICB9LFxuICB3cmFwOiBmdW5jdGlvbiB3cmFwKGNodW5rKSB7XG4gICAgdmFyIGxvYyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHRoaXMuY3VycmVudExvY2F0aW9uIHx8IHsgc3RhcnQ6IHt9IH0gOiBhcmd1bWVudHNbMV07XG5cbiAgICBpZiAoY2h1bmsgaW5zdGFuY2VvZiBTb3VyY2VOb2RlKSB7XG4gICAgICByZXR1cm4gY2h1bms7XG4gICAgfVxuXG4gICAgY2h1bmsgPSBjYXN0Q2h1bmsoY2h1bmssIHRoaXMsIGxvYyk7XG5cbiAgICByZXR1cm4gbmV3IFNvdXJjZU5vZGUobG9jLnN0YXJ0LmxpbmUsIGxvYy5zdGFydC5jb2x1bW4sIHRoaXMuc3JjRmlsZSwgY2h1bmspO1xuICB9LFxuXG4gIGZ1bmN0aW9uQ2FsbDogZnVuY3Rpb24gZnVuY3Rpb25DYWxsKGZuLCB0eXBlLCBwYXJhbXMpIHtcbiAgICBwYXJhbXMgPSB0aGlzLmdlbmVyYXRlTGlzdChwYXJhbXMpO1xuICAgIHJldHVybiB0aGlzLndyYXAoW2ZuLCB0eXBlID8gJy4nICsgdHlwZSArICcoJyA6ICcoJywgcGFyYW1zLCAnKSddKTtcbiAgfSxcblxuICBxdW90ZWRTdHJpbmc6IGZ1bmN0aW9uIHF1b3RlZFN0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gJ1wiJyArIChzdHIgKyAnJykucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykucmVwbGFjZSgvXFxuL2csICdcXFxcbicpLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKS5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKSAvLyBQZXIgRWNtYS0yNjIgNy4zICsgNy44LjRcbiAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxcXHUyMDI5JykgKyAnXCInO1xuICB9LFxuXG4gIG9iamVjdExpdGVyYWw6IGZ1bmN0aW9uIG9iamVjdExpdGVyYWwob2JqKSB7XG4gICAgdmFyIHBhaXJzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gY2FzdENodW5rKG9ialtrZXldLCB0aGlzKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHBhaXJzLnB1c2goW3RoaXMucXVvdGVkU3RyaW5nKGtleSksICc6JywgdmFsdWVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXQgPSB0aGlzLmdlbmVyYXRlTGlzdChwYWlycyk7XG4gICAgcmV0LnByZXBlbmQoJ3snKTtcbiAgICByZXQuYWRkKCd9Jyk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICBnZW5lcmF0ZUxpc3Q6IGZ1bmN0aW9uIGdlbmVyYXRlTGlzdChlbnRyaWVzKSB7XG4gICAgdmFyIHJldCA9IHRoaXMuZW1wdHkoKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbnRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoaSkge1xuICAgICAgICByZXQuYWRkKCcsJyk7XG4gICAgICB9XG5cbiAgICAgIHJldC5hZGQoY2FzdENodW5rKGVudHJpZXNbaV0sIHRoaXMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIGdlbmVyYXRlQXJyYXk6IGZ1bmN0aW9uIGdlbmVyYXRlQXJyYXkoZW50cmllcykge1xuICAgIHZhciByZXQgPSB0aGlzLmdlbmVyYXRlTGlzdChlbnRyaWVzKTtcbiAgICByZXQucHJlcGVuZCgnWycpO1xuICAgIHJldC5hZGQoJ10nKTtcblxuICAgIHJldHVybiByZXQ7XG4gIH1cbn07XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IENvZGVHZW47XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG59LHtcIi4uL3V0aWxzXCI6MzMsXCJzb3VyY2UtbWFwXCI6NDZ9XSwxMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwICovXG5cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuQ29tcGlsZXIgPSBDb21waWxlcjtcbmV4cG9ydHMucHJlY29tcGlsZSA9IHByZWNvbXBpbGU7XG5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlO1xuLy8gaXN0YW5idWwgaWdub3JlIG5leHRcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX2V4Y2VwdGlvbiA9IHJlcXVpcmUoJy4uL2V4Y2VwdGlvbicpO1xuXG52YXIgX2V4Y2VwdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leGNlcHRpb24pO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxudmFyIF9hc3QgPSByZXF1aXJlKCcuL2FzdCcpO1xuXG52YXIgX2FzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3QpO1xuXG52YXIgc2xpY2UgPSBbXS5zbGljZTtcblxuZnVuY3Rpb24gQ29tcGlsZXIoKSB7fVxuXG4vLyB0aGUgZm91bmRIZWxwZXIgcmVnaXN0ZXIgd2lsbCBkaXNhbWJpZ3VhdGUgaGVscGVyIGxvb2t1cCBmcm9tIGZpbmRpbmcgYVxuLy8gZnVuY3Rpb24gaW4gYSBjb250ZXh0LiBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgbXVzdGFjaGUgY29tcGF0aWJpbGl0eSwgd2hpY2hcbi8vIHJlcXVpcmVzIHRoYXQgY29udGV4dCBmdW5jdGlvbnMgaW4gYmxvY2tzIGFyZSBldmFsdWF0ZWQgYnkgYmxvY2tIZWxwZXJNaXNzaW5nLFxuLy8gYW5kIHRoZW4gcHJvY2VlZCBhcyBpZiB0aGUgcmVzdWx0aW5nIHZhbHVlIHdhcyBwcm92aWRlZCB0byBibG9ja0hlbHBlck1pc3NpbmcuXG5cbkNvbXBpbGVyLnByb3RvdHlwZSA9IHtcbiAgY29tcGlsZXI6IENvbXBpbGVyLFxuXG4gIGVxdWFsczogZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgdmFyIGxlbiA9IHRoaXMub3Bjb2Rlcy5sZW5ndGg7XG4gICAgaWYgKG90aGVyLm9wY29kZXMubGVuZ3RoICE9PSBsZW4pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgb3Bjb2RlID0gdGhpcy5vcGNvZGVzW2ldLFxuICAgICAgICAgIG90aGVyT3Bjb2RlID0gb3RoZXIub3Bjb2Rlc1tpXTtcbiAgICAgIGlmIChvcGNvZGUub3Bjb2RlICE9PSBvdGhlck9wY29kZS5vcGNvZGUgfHwgIWFyZ0VxdWFscyhvcGNvZGUuYXJncywgb3RoZXJPcGNvZGUuYXJncykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdlIGtub3cgdGhhdCBsZW5ndGggaXMgdGhlIHNhbWUgYmV0d2VlbiB0aGUgdHdvIGFycmF5cyBiZWNhdXNlIHRoZXkgYXJlIGRpcmVjdGx5IHRpZWRcbiAgICAvLyB0byB0aGUgb3Bjb2RlIGJlaGF2aW9yIGFib3ZlLlxuICAgIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy5jaGlsZHJlbltpXS5lcXVhbHMob3RoZXIuY2hpbGRyZW5baV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBndWlkOiAwLFxuXG4gIGNvbXBpbGU6IGZ1bmN0aW9uIGNvbXBpbGUocHJvZ3JhbSwgb3B0aW9ucykge1xuICAgIHRoaXMuc291cmNlTm9kZSA9IFtdO1xuICAgIHRoaXMub3Bjb2RlcyA9IFtdO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuc3RyaW5nUGFyYW1zID0gb3B0aW9ucy5zdHJpbmdQYXJhbXM7XG4gICAgdGhpcy50cmFja0lkcyA9IG9wdGlvbnMudHJhY2tJZHM7XG5cbiAgICBvcHRpb25zLmJsb2NrUGFyYW1zID0gb3B0aW9ucy5ibG9ja1BhcmFtcyB8fCBbXTtcblxuICAgIC8vIFRoZXNlIGNoYW5nZXMgd2lsbCBwcm9wYWdhdGUgdG8gdGhlIG90aGVyIGNvbXBpbGVyIGNvbXBvbmVudHNcbiAgICB2YXIga25vd25IZWxwZXJzID0gb3B0aW9ucy5rbm93bkhlbHBlcnM7XG4gICAgb3B0aW9ucy5rbm93bkhlbHBlcnMgPSB7XG4gICAgICAnaGVscGVyTWlzc2luZyc6IHRydWUsXG4gICAgICAnYmxvY2tIZWxwZXJNaXNzaW5nJzogdHJ1ZSxcbiAgICAgICdlYWNoJzogdHJ1ZSxcbiAgICAgICdpZic6IHRydWUsXG4gICAgICAndW5sZXNzJzogdHJ1ZSxcbiAgICAgICd3aXRoJzogdHJ1ZSxcbiAgICAgICdsb2cnOiB0cnVlLFxuICAgICAgJ2xvb2t1cCc6IHRydWVcbiAgICB9O1xuICAgIGlmIChrbm93bkhlbHBlcnMpIHtcbiAgICAgIGZvciAodmFyIF9uYW1lIGluIGtub3duSGVscGVycykge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoX25hbWUgaW4ga25vd25IZWxwZXJzKSB7XG4gICAgICAgICAgb3B0aW9ucy5rbm93bkhlbHBlcnNbX25hbWVdID0ga25vd25IZWxwZXJzW19uYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFjY2VwdChwcm9ncmFtKTtcbiAgfSxcblxuICBjb21waWxlUHJvZ3JhbTogZnVuY3Rpb24gY29tcGlsZVByb2dyYW0ocHJvZ3JhbSkge1xuICAgIHZhciBjaGlsZENvbXBpbGVyID0gbmV3IHRoaXMuY29tcGlsZXIoKSxcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG4gICAgcmVzdWx0ID0gY2hpbGRDb21waWxlci5jb21waWxlKHByb2dyYW0sIHRoaXMub3B0aW9ucyksXG4gICAgICAgIGd1aWQgPSB0aGlzLmd1aWQrKztcblxuICAgIHRoaXMudXNlUGFydGlhbCA9IHRoaXMudXNlUGFydGlhbCB8fCByZXN1bHQudXNlUGFydGlhbDtcblxuICAgIHRoaXMuY2hpbGRyZW5bZ3VpZF0gPSByZXN1bHQ7XG4gICAgdGhpcy51c2VEZXB0aHMgPSB0aGlzLnVzZURlcHRocyB8fCByZXN1bHQudXNlRGVwdGhzO1xuXG4gICAgcmV0dXJuIGd1aWQ7XG4gIH0sXG5cbiAgYWNjZXB0OiBmdW5jdGlvbiBhY2NlcHQobm9kZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBTYW5pdHkgY29kZSAqL1xuICAgIGlmICghdGhpc1tub2RlLnR5cGVdKSB7XG4gICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnVW5rbm93biB0eXBlOiAnICsgbm9kZS50eXBlLCBub2RlKTtcbiAgICB9XG5cbiAgICB0aGlzLnNvdXJjZU5vZGUudW5zaGlmdChub2RlKTtcbiAgICB2YXIgcmV0ID0gdGhpc1tub2RlLnR5cGVdKG5vZGUpO1xuICAgIHRoaXMuc291cmNlTm9kZS5zaGlmdCgpO1xuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgUHJvZ3JhbTogZnVuY3Rpb24gUHJvZ3JhbShwcm9ncmFtKSB7XG4gICAgdGhpcy5vcHRpb25zLmJsb2NrUGFyYW1zLnVuc2hpZnQocHJvZ3JhbS5ibG9ja1BhcmFtcyk7XG5cbiAgICB2YXIgYm9keSA9IHByb2dyYW0uYm9keSxcbiAgICAgICAgYm9keUxlbmd0aCA9IGJvZHkubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9keUxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmFjY2VwdChib2R5W2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMuYmxvY2tQYXJhbXMuc2hpZnQoKTtcblxuICAgIHRoaXMuaXNTaW1wbGUgPSBib2R5TGVuZ3RoID09PSAxO1xuICAgIHRoaXMuYmxvY2tQYXJhbXMgPSBwcm9ncmFtLmJsb2NrUGFyYW1zID8gcHJvZ3JhbS5ibG9ja1BhcmFtcy5sZW5ndGggOiAwO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgQmxvY2tTdGF0ZW1lbnQ6IGZ1bmN0aW9uIEJsb2NrU3RhdGVtZW50KGJsb2NrKSB7XG4gICAgdHJhbnNmb3JtTGl0ZXJhbFRvUGF0aChibG9jayk7XG5cbiAgICB2YXIgcHJvZ3JhbSA9IGJsb2NrLnByb2dyYW0sXG4gICAgICAgIGludmVyc2UgPSBibG9jay5pbnZlcnNlO1xuXG4gICAgcHJvZ3JhbSA9IHByb2dyYW0gJiYgdGhpcy5jb21waWxlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICBpbnZlcnNlID0gaW52ZXJzZSAmJiB0aGlzLmNvbXBpbGVQcm9ncmFtKGludmVyc2UpO1xuXG4gICAgdmFyIHR5cGUgPSB0aGlzLmNsYXNzaWZ5U2V4cHIoYmxvY2spO1xuXG4gICAgaWYgKHR5cGUgPT09ICdoZWxwZXInKSB7XG4gICAgICB0aGlzLmhlbHBlclNleHByKGJsb2NrLCBwcm9ncmFtLCBpbnZlcnNlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzaW1wbGUnKSB7XG4gICAgICB0aGlzLnNpbXBsZVNleHByKGJsb2NrKTtcblxuICAgICAgLy8gbm93IHRoYXQgdGhlIHNpbXBsZSBtdXN0YWNoZSBpcyByZXNvbHZlZCwgd2UgbmVlZCB0b1xuICAgICAgLy8gZXZhbHVhdGUgaXQgYnkgZXhlY3V0aW5nIGBibG9ja0hlbHBlck1pc3NpbmdgXG4gICAgICB0aGlzLm9wY29kZSgncHVzaFByb2dyYW0nLCBwcm9ncmFtKTtcbiAgICAgIHRoaXMub3Bjb2RlKCdwdXNoUHJvZ3JhbScsIGludmVyc2UpO1xuICAgICAgdGhpcy5vcGNvZGUoJ2VtcHR5SGFzaCcpO1xuICAgICAgdGhpcy5vcGNvZGUoJ2Jsb2NrVmFsdWUnLCBibG9jay5wYXRoLm9yaWdpbmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hbWJpZ3VvdXNTZXhwcihibG9jaywgcHJvZ3JhbSwgaW52ZXJzZSk7XG5cbiAgICAgIC8vIG5vdyB0aGF0IHRoZSBzaW1wbGUgbXVzdGFjaGUgaXMgcmVzb2x2ZWQsIHdlIG5lZWQgdG9cbiAgICAgIC8vIGV2YWx1YXRlIGl0IGJ5IGV4ZWN1dGluZyBgYmxvY2tIZWxwZXJNaXNzaW5nYFxuICAgICAgdGhpcy5vcGNvZGUoJ3B1c2hQcm9ncmFtJywgcHJvZ3JhbSk7XG4gICAgICB0aGlzLm9wY29kZSgncHVzaFByb2dyYW0nLCBpbnZlcnNlKTtcbiAgICAgIHRoaXMub3Bjb2RlKCdlbXB0eUhhc2gnKTtcbiAgICAgIHRoaXMub3Bjb2RlKCdhbWJpZ3VvdXNCbG9ja1ZhbHVlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5vcGNvZGUoJ2FwcGVuZCcpO1xuICB9LFxuXG4gIERlY29yYXRvckJsb2NrOiBmdW5jdGlvbiBEZWNvcmF0b3JCbG9jayhkZWNvcmF0b3IpIHtcbiAgICB2YXIgcHJvZ3JhbSA9IGRlY29yYXRvci5wcm9ncmFtICYmIHRoaXMuY29tcGlsZVByb2dyYW0oZGVjb3JhdG9yLnByb2dyYW0pO1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLnNldHVwRnVsbE11c3RhY2hlUGFyYW1zKGRlY29yYXRvciwgcHJvZ3JhbSwgdW5kZWZpbmVkKSxcbiAgICAgICAgcGF0aCA9IGRlY29yYXRvci5wYXRoO1xuXG4gICAgdGhpcy51c2VEZWNvcmF0b3JzID0gdHJ1ZTtcbiAgICB0aGlzLm9wY29kZSgncmVnaXN0ZXJEZWNvcmF0b3InLCBwYXJhbXMubGVuZ3RoLCBwYXRoLm9yaWdpbmFsKTtcbiAgfSxcblxuICBQYXJ0aWFsU3RhdGVtZW50OiBmdW5jdGlvbiBQYXJ0aWFsU3RhdGVtZW50KHBhcnRpYWwpIHtcbiAgICB0aGlzLnVzZVBhcnRpYWwgPSB0cnVlO1xuXG4gICAgdmFyIHByb2dyYW0gPSBwYXJ0aWFsLnByb2dyYW07XG4gICAgaWYgKHByb2dyYW0pIHtcbiAgICAgIHByb2dyYW0gPSB0aGlzLmNvbXBpbGVQcm9ncmFtKHBhcnRpYWwucHJvZ3JhbSk7XG4gICAgfVxuXG4gICAgdmFyIHBhcmFtcyA9IHBhcnRpYWwucGFyYW1zO1xuICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ1Vuc3VwcG9ydGVkIG51bWJlciBvZiBwYXJ0aWFsIGFyZ3VtZW50czogJyArIHBhcmFtcy5sZW5ndGgsIHBhcnRpYWwpO1xuICAgIH0gZWxzZSBpZiAoIXBhcmFtcy5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXhwbGljaXRQYXJ0aWFsQ29udGV4dCkge1xuICAgICAgICB0aGlzLm9wY29kZSgncHVzaExpdGVyYWwnLCAndW5kZWZpbmVkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXMucHVzaCh7IHR5cGU6ICdQYXRoRXhwcmVzc2lvbicsIHBhcnRzOiBbXSwgZGVwdGg6IDAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHBhcnRpYWxOYW1lID0gcGFydGlhbC5uYW1lLm9yaWdpbmFsLFxuICAgICAgICBpc0R5bmFtaWMgPSBwYXJ0aWFsLm5hbWUudHlwZSA9PT0gJ1N1YkV4cHJlc3Npb24nO1xuICAgIGlmIChpc0R5bmFtaWMpIHtcbiAgICAgIHRoaXMuYWNjZXB0KHBhcnRpYWwubmFtZSk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXR1cEZ1bGxNdXN0YWNoZVBhcmFtcyhwYXJ0aWFsLCBwcm9ncmFtLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgdmFyIGluZGVudCA9IHBhcnRpYWwuaW5kZW50IHx8ICcnO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucHJldmVudEluZGVudCAmJiBpbmRlbnQpIHtcbiAgICAgIHRoaXMub3Bjb2RlKCdhcHBlbmRDb250ZW50JywgaW5kZW50KTtcbiAgICAgIGluZGVudCA9ICcnO1xuICAgIH1cblxuICAgIHRoaXMub3Bjb2RlKCdpbnZva2VQYXJ0aWFsJywgaXNEeW5hbWljLCBwYXJ0aWFsTmFtZSwgaW5kZW50KTtcbiAgICB0aGlzLm9wY29kZSgnYXBwZW5kJyk7XG4gIH0sXG4gIFBhcnRpYWxCbG9ja1N0YXRlbWVudDogZnVuY3Rpb24gUGFydGlhbEJsb2NrU3RhdGVtZW50KHBhcnRpYWxCbG9jaykge1xuICAgIHRoaXMuUGFydGlhbFN0YXRlbWVudChwYXJ0aWFsQmxvY2spO1xuICB9LFxuXG4gIE11c3RhY2hlU3RhdGVtZW50OiBmdW5jdGlvbiBNdXN0YWNoZVN0YXRlbWVudChtdXN0YWNoZSkge1xuICAgIHRoaXMuU3ViRXhwcmVzc2lvbihtdXN0YWNoZSk7XG5cbiAgICBpZiAobXVzdGFjaGUuZXNjYXBlZCAmJiAhdGhpcy5vcHRpb25zLm5vRXNjYXBlKSB7XG4gICAgICB0aGlzLm9wY29kZSgnYXBwZW5kRXNjYXBlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wY29kZSgnYXBwZW5kJyk7XG4gICAgfVxuICB9LFxuICBEZWNvcmF0b3I6IGZ1bmN0aW9uIERlY29yYXRvcihkZWNvcmF0b3IpIHtcbiAgICB0aGlzLkRlY29yYXRvckJsb2NrKGRlY29yYXRvcik7XG4gIH0sXG5cbiAgQ29udGVudFN0YXRlbWVudDogZnVuY3Rpb24gQ29udGVudFN0YXRlbWVudChjb250ZW50KSB7XG4gICAgaWYgKGNvbnRlbnQudmFsdWUpIHtcbiAgICAgIHRoaXMub3Bjb2RlKCdhcHBlbmRDb250ZW50JywgY29udGVudC52YWx1ZSk7XG4gICAgfVxuICB9LFxuXG4gIENvbW1lbnRTdGF0ZW1lbnQ6IGZ1bmN0aW9uIENvbW1lbnRTdGF0ZW1lbnQoKSB7fSxcblxuICBTdWJFeHByZXNzaW9uOiBmdW5jdGlvbiBTdWJFeHByZXNzaW9uKHNleHByKSB7XG4gICAgdHJhbnNmb3JtTGl0ZXJhbFRvUGF0aChzZXhwcik7XG4gICAgdmFyIHR5cGUgPSB0aGlzLmNsYXNzaWZ5U2V4cHIoc2V4cHIpO1xuXG4gICAgaWYgKHR5cGUgPT09ICdzaW1wbGUnKSB7XG4gICAgICB0aGlzLnNpbXBsZVNleHByKHNleHByKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdoZWxwZXInKSB7XG4gICAgICB0aGlzLmhlbHBlclNleHByKHNleHByKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hbWJpZ3VvdXNTZXhwcihzZXhwcik7XG4gICAgfVxuICB9LFxuICBhbWJpZ3VvdXNTZXhwcjogZnVuY3Rpb24gYW1iaWd1b3VzU2V4cHIoc2V4cHIsIHByb2dyYW0sIGludmVyc2UpIHtcbiAgICB2YXIgcGF0aCA9IHNleHByLnBhdGgsXG4gICAgICAgIG5hbWUgPSBwYXRoLnBhcnRzWzBdLFxuICAgICAgICBpc0Jsb2NrID0gcHJvZ3JhbSAhPSBudWxsIHx8IGludmVyc2UgIT0gbnVsbDtcblxuICAgIHRoaXMub3Bjb2RlKCdnZXRDb250ZXh0JywgcGF0aC5kZXB0aCk7XG5cbiAgICB0aGlzLm9wY29kZSgncHVzaFByb2dyYW0nLCBwcm9ncmFtKTtcbiAgICB0aGlzLm9wY29kZSgncHVzaFByb2dyYW0nLCBpbnZlcnNlKTtcblxuICAgIHBhdGguc3RyaWN0ID0gdHJ1ZTtcbiAgICB0aGlzLmFjY2VwdChwYXRoKTtcblxuICAgIHRoaXMub3Bjb2RlKCdpbnZva2VBbWJpZ3VvdXMnLCBuYW1lLCBpc0Jsb2NrKTtcbiAgfSxcblxuICBzaW1wbGVTZXhwcjogZnVuY3Rpb24gc2ltcGxlU2V4cHIoc2V4cHIpIHtcbiAgICB2YXIgcGF0aCA9IHNleHByLnBhdGg7XG4gICAgcGF0aC5zdHJpY3QgPSB0cnVlO1xuICAgIHRoaXMuYWNjZXB0KHBhdGgpO1xuICAgIHRoaXMub3Bjb2RlKCdyZXNvbHZlUG9zc2libGVMYW1iZGEnKTtcbiAgfSxcblxuICBoZWxwZXJTZXhwcjogZnVuY3Rpb24gaGVscGVyU2V4cHIoc2V4cHIsIHByb2dyYW0sIGludmVyc2UpIHtcbiAgICB2YXIgcGFyYW1zID0gdGhpcy5zZXR1cEZ1bGxNdXN0YWNoZVBhcmFtcyhzZXhwciwgcHJvZ3JhbSwgaW52ZXJzZSksXG4gICAgICAgIHBhdGggPSBzZXhwci5wYXRoLFxuICAgICAgICBuYW1lID0gcGF0aC5wYXJ0c1swXTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMua25vd25IZWxwZXJzW25hbWVdKSB7XG4gICAgICB0aGlzLm9wY29kZSgnaW52b2tlS25vd25IZWxwZXInLCBwYXJhbXMubGVuZ3RoLCBuYW1lKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5rbm93bkhlbHBlcnNPbmx5KSB7XG4gICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnWW91IHNwZWNpZmllZCBrbm93bkhlbHBlcnNPbmx5LCBidXQgdXNlZCB0aGUgdW5rbm93biBoZWxwZXIgJyArIG5hbWUsIHNleHByKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aC5zdHJpY3QgPSB0cnVlO1xuICAgICAgcGF0aC5mYWxzeSA9IHRydWU7XG5cbiAgICAgIHRoaXMuYWNjZXB0KHBhdGgpO1xuICAgICAgdGhpcy5vcGNvZGUoJ2ludm9rZUhlbHBlcicsIHBhcmFtcy5sZW5ndGgsIHBhdGgub3JpZ2luYWwsIF9hc3QyWydkZWZhdWx0J10uaGVscGVycy5zaW1wbGVJZChwYXRoKSk7XG4gICAgfVxuICB9LFxuXG4gIFBhdGhFeHByZXNzaW9uOiBmdW5jdGlvbiBQYXRoRXhwcmVzc2lvbihwYXRoKSB7XG4gICAgdGhpcy5hZGREZXB0aChwYXRoLmRlcHRoKTtcbiAgICB0aGlzLm9wY29kZSgnZ2V0Q29udGV4dCcsIHBhdGguZGVwdGgpO1xuXG4gICAgdmFyIG5hbWUgPSBwYXRoLnBhcnRzWzBdLFxuICAgICAgICBzY29wZWQgPSBfYXN0MlsnZGVmYXVsdCddLmhlbHBlcnMuc2NvcGVkSWQocGF0aCksXG4gICAgICAgIGJsb2NrUGFyYW1JZCA9ICFwYXRoLmRlcHRoICYmICFzY29wZWQgJiYgdGhpcy5ibG9ja1BhcmFtSW5kZXgobmFtZSk7XG5cbiAgICBpZiAoYmxvY2tQYXJhbUlkKSB7XG4gICAgICB0aGlzLm9wY29kZSgnbG9va3VwQmxvY2tQYXJhbScsIGJsb2NrUGFyYW1JZCwgcGF0aC5wYXJ0cyk7XG4gICAgfSBlbHNlIGlmICghbmFtZSkge1xuICAgICAgLy8gQ29udGV4dCByZWZlcmVuY2UsIGkuZS4gYHt7Zm9vIC59fWAgb3IgYHt7Zm9vIC4ufX1gXG4gICAgICB0aGlzLm9wY29kZSgncHVzaENvbnRleHQnKTtcbiAgICB9IGVsc2UgaWYgKHBhdGguZGF0YSkge1xuICAgICAgdGhpcy5vcHRpb25zLmRhdGEgPSB0cnVlO1xuICAgICAgdGhpcy5vcGNvZGUoJ2xvb2t1cERhdGEnLCBwYXRoLmRlcHRoLCBwYXRoLnBhcnRzLCBwYXRoLnN0cmljdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3Bjb2RlKCdsb29rdXBPbkNvbnRleHQnLCBwYXRoLnBhcnRzLCBwYXRoLmZhbHN5LCBwYXRoLnN0cmljdCwgc2NvcGVkKTtcbiAgICB9XG4gIH0sXG5cbiAgU3RyaW5nTGl0ZXJhbDogZnVuY3Rpb24gU3RyaW5nTGl0ZXJhbChzdHJpbmcpIHtcbiAgICB0aGlzLm9wY29kZSgncHVzaFN0cmluZycsIHN0cmluZy52YWx1ZSk7XG4gIH0sXG5cbiAgTnVtYmVyTGl0ZXJhbDogZnVuY3Rpb24gTnVtYmVyTGl0ZXJhbChudW1iZXIpIHtcbiAgICB0aGlzLm9wY29kZSgncHVzaExpdGVyYWwnLCBudW1iZXIudmFsdWUpO1xuICB9LFxuXG4gIEJvb2xlYW5MaXRlcmFsOiBmdW5jdGlvbiBCb29sZWFuTGl0ZXJhbChib29sKSB7XG4gICAgdGhpcy5vcGNvZGUoJ3B1c2hMaXRlcmFsJywgYm9vbC52YWx1ZSk7XG4gIH0sXG5cbiAgVW5kZWZpbmVkTGl0ZXJhbDogZnVuY3Rpb24gVW5kZWZpbmVkTGl0ZXJhbCgpIHtcbiAgICB0aGlzLm9wY29kZSgncHVzaExpdGVyYWwnLCAndW5kZWZpbmVkJyk7XG4gIH0sXG5cbiAgTnVsbExpdGVyYWw6IGZ1bmN0aW9uIE51bGxMaXRlcmFsKCkge1xuICAgIHRoaXMub3Bjb2RlKCdwdXNoTGl0ZXJhbCcsICdudWxsJyk7XG4gIH0sXG5cbiAgSGFzaDogZnVuY3Rpb24gSGFzaChoYXNoKSB7XG4gICAgdmFyIHBhaXJzID0gaGFzaC5wYWlycyxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGwgPSBwYWlycy5sZW5ndGg7XG5cbiAgICB0aGlzLm9wY29kZSgncHVzaEhhc2gnKTtcblxuICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0aGlzLnB1c2hQYXJhbShwYWlyc1tpXS52YWx1ZSk7XG4gICAgfVxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMub3Bjb2RlKCdhc3NpZ25Ub0hhc2gnLCBwYWlyc1tpXS5rZXkpO1xuICAgIH1cbiAgICB0aGlzLm9wY29kZSgncG9wSGFzaCcpO1xuICB9LFxuXG4gIC8vIEhFTFBFUlNcbiAgb3Bjb2RlOiBmdW5jdGlvbiBvcGNvZGUobmFtZSkge1xuICAgIHRoaXMub3Bjb2Rlcy5wdXNoKHsgb3Bjb2RlOiBuYW1lLCBhcmdzOiBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIGxvYzogdGhpcy5zb3VyY2VOb2RlWzBdLmxvYyB9KTtcbiAgfSxcblxuICBhZGREZXB0aDogZnVuY3Rpb24gYWRkRGVwdGgoZGVwdGgpIHtcbiAgICBpZiAoIWRlcHRoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy51c2VEZXB0aHMgPSB0cnVlO1xuICB9LFxuXG4gIGNsYXNzaWZ5U2V4cHI6IGZ1bmN0aW9uIGNsYXNzaWZ5U2V4cHIoc2V4cHIpIHtcbiAgICB2YXIgaXNTaW1wbGUgPSBfYXN0MlsnZGVmYXVsdCddLmhlbHBlcnMuc2ltcGxlSWQoc2V4cHIucGF0aCk7XG5cbiAgICB2YXIgaXNCbG9ja1BhcmFtID0gaXNTaW1wbGUgJiYgISF0aGlzLmJsb2NrUGFyYW1JbmRleChzZXhwci5wYXRoLnBhcnRzWzBdKTtcblxuICAgIC8vIGEgbXVzdGFjaGUgaXMgYW4gZWxpZ2libGUgaGVscGVyIGlmOlxuICAgIC8vICogaXRzIGlkIGlzIHNpbXBsZSAoYSBzaW5nbGUgcGFydCwgbm90IGB0aGlzYCBvciBgLi5gKVxuICAgIHZhciBpc0hlbHBlciA9ICFpc0Jsb2NrUGFyYW0gJiYgX2FzdDJbJ2RlZmF1bHQnXS5oZWxwZXJzLmhlbHBlckV4cHJlc3Npb24oc2V4cHIpO1xuXG4gICAgLy8gaWYgYSBtdXN0YWNoZSBpcyBhbiBlbGlnaWJsZSBoZWxwZXIgYnV0IG5vdCBhIGRlZmluaXRlXG4gICAgLy8gaGVscGVyLCBpdCBpcyBhbWJpZ3VvdXMsIGFuZCB3aWxsIGJlIHJlc29sdmVkIGluIGEgbGF0ZXJcbiAgICAvLyBwYXNzIG9yIGF0IHJ1bnRpbWUuXG4gICAgdmFyIGlzRWxpZ2libGUgPSAhaXNCbG9ja1BhcmFtICYmIChpc0hlbHBlciB8fCBpc1NpbXBsZSk7XG5cbiAgICAvLyBpZiBhbWJpZ3VvdXMsIHdlIGNhbiBwb3NzaWJseSByZXNvbHZlIHRoZSBhbWJpZ3VpdHkgbm93XG4gICAgLy8gQW4gZWxpZ2libGUgaGVscGVyIGlzIG9uZSB0aGF0IGRvZXMgbm90IGhhdmUgYSBjb21wbGV4IHBhdGgsIGkuZS4gYHRoaXMuZm9vYCwgYC4uL2Zvb2AgZXRjLlxuICAgIGlmIChpc0VsaWdpYmxlICYmICFpc0hlbHBlcikge1xuICAgICAgdmFyIF9uYW1lMiA9IHNleHByLnBhdGgucGFydHNbMF0sXG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgaWYgKG9wdGlvbnMua25vd25IZWxwZXJzW19uYW1lMl0pIHtcbiAgICAgICAgaXNIZWxwZXIgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmtub3duSGVscGVyc09ubHkpIHtcbiAgICAgICAgaXNFbGlnaWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0hlbHBlcikge1xuICAgICAgcmV0dXJuICdoZWxwZXInO1xuICAgIH0gZWxzZSBpZiAoaXNFbGlnaWJsZSkge1xuICAgICAgcmV0dXJuICdhbWJpZ3VvdXMnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ3NpbXBsZSc7XG4gICAgfVxuICB9LFxuXG4gIHB1c2hQYXJhbXM6IGZ1bmN0aW9uIHB1c2hQYXJhbXMocGFyYW1zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXJhbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0aGlzLnB1c2hQYXJhbShwYXJhbXNbaV0pO1xuICAgIH1cbiAgfSxcblxuICBwdXNoUGFyYW06IGZ1bmN0aW9uIHB1c2hQYXJhbSh2YWwpIHtcbiAgICB2YXIgdmFsdWUgPSB2YWwudmFsdWUgIT0gbnVsbCA/IHZhbC52YWx1ZSA6IHZhbC5vcmlnaW5hbCB8fCAnJztcblxuICAgIGlmICh0aGlzLnN0cmluZ1BhcmFtcykge1xuICAgICAgaWYgKHZhbHVlLnJlcGxhY2UpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9eKFxcLj9cXC5cXC8pKi9nLCAnJykucmVwbGFjZSgvXFwvL2csICcuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWwuZGVwdGgpIHtcbiAgICAgICAgdGhpcy5hZGREZXB0aCh2YWwuZGVwdGgpO1xuICAgICAgfVxuICAgICAgdGhpcy5vcGNvZGUoJ2dldENvbnRleHQnLCB2YWwuZGVwdGggfHwgMCk7XG4gICAgICB0aGlzLm9wY29kZSgncHVzaFN0cmluZ1BhcmFtJywgdmFsdWUsIHZhbC50eXBlKTtcblxuICAgICAgaWYgKHZhbC50eXBlID09PSAnU3ViRXhwcmVzc2lvbicpIHtcbiAgICAgICAgLy8gU3ViRXhwcmVzc2lvbnMgZ2V0IGV2YWx1YXRlZCBhbmQgcGFzc2VkIGluXG4gICAgICAgIC8vIGluIHN0cmluZyBwYXJhbXMgbW9kZS5cbiAgICAgICAgdGhpcy5hY2NlcHQodmFsKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMudHJhY2tJZHMpIHtcbiAgICAgICAgdmFyIGJsb2NrUGFyYW1JbmRleCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHZhbC5wYXJ0cyAmJiAhX2FzdDJbJ2RlZmF1bHQnXS5oZWxwZXJzLnNjb3BlZElkKHZhbCkgJiYgIXZhbC5kZXB0aCkge1xuICAgICAgICAgIGJsb2NrUGFyYW1JbmRleCA9IHRoaXMuYmxvY2tQYXJhbUluZGV4KHZhbC5wYXJ0c1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsb2NrUGFyYW1JbmRleCkge1xuICAgICAgICAgIHZhciBibG9ja1BhcmFtQ2hpbGQgPSB2YWwucGFydHMuc2xpY2UoMSkuam9pbignLicpO1xuICAgICAgICAgIHRoaXMub3Bjb2RlKCdwdXNoSWQnLCAnQmxvY2tQYXJhbScsIGJsb2NrUGFyYW1JbmRleCwgYmxvY2tQYXJhbUNoaWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbC5vcmlnaW5hbCB8fCB2YWx1ZTtcbiAgICAgICAgICBpZiAodmFsdWUucmVwbGFjZSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9edGhpcyg/OlxcLnwkKS8sICcnKS5yZXBsYWNlKC9eXFwuXFwvLywgJycpLnJlcGxhY2UoL15cXC4kLywgJycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMub3Bjb2RlKCdwdXNoSWQnLCB2YWwudHlwZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmFjY2VwdCh2YWwpO1xuICAgIH1cbiAgfSxcblxuICBzZXR1cEZ1bGxNdXN0YWNoZVBhcmFtczogZnVuY3Rpb24gc2V0dXBGdWxsTXVzdGFjaGVQYXJhbXMoc2V4cHIsIHByb2dyYW0sIGludmVyc2UsIG9taXRFbXB0eSkge1xuICAgIHZhciBwYXJhbXMgPSBzZXhwci5wYXJhbXM7XG4gICAgdGhpcy5wdXNoUGFyYW1zKHBhcmFtcyk7XG5cbiAgICB0aGlzLm9wY29kZSgncHVzaFByb2dyYW0nLCBwcm9ncmFtKTtcbiAgICB0aGlzLm9wY29kZSgncHVzaFByb2dyYW0nLCBpbnZlcnNlKTtcblxuICAgIGlmIChzZXhwci5oYXNoKSB7XG4gICAgICB0aGlzLmFjY2VwdChzZXhwci5oYXNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcGNvZGUoJ2VtcHR5SGFzaCcsIG9taXRFbXB0eSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfSxcblxuICBibG9ja1BhcmFtSW5kZXg6IGZ1bmN0aW9uIGJsb2NrUGFyYW1JbmRleChuYW1lKSB7XG4gICAgZm9yICh2YXIgZGVwdGggPSAwLCBsZW4gPSB0aGlzLm9wdGlvbnMuYmxvY2tQYXJhbXMubGVuZ3RoOyBkZXB0aCA8IGxlbjsgZGVwdGgrKykge1xuICAgICAgdmFyIGJsb2NrUGFyYW1zID0gdGhpcy5vcHRpb25zLmJsb2NrUGFyYW1zW2RlcHRoXSxcbiAgICAgICAgICBwYXJhbSA9IGJsb2NrUGFyYW1zICYmIF91dGlscy5pbmRleE9mKGJsb2NrUGFyYW1zLCBuYW1lKTtcbiAgICAgIGlmIChibG9ja1BhcmFtcyAmJiBwYXJhbSA+PSAwKSB7XG4gICAgICAgIHJldHVybiBbZGVwdGgsIHBhcmFtXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHByZWNvbXBpbGUoaW5wdXQsIG9wdGlvbnMsIGVudikge1xuICBpZiAoaW5wdXQgPT0gbnVsbCB8fCB0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnICYmIGlucHV0LnR5cGUgIT09ICdQcm9ncmFtJykge1xuICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdZb3UgbXVzdCBwYXNzIGEgc3RyaW5nIG9yIEhhbmRsZWJhcnMgQVNUIHRvIEhhbmRsZWJhcnMucHJlY29tcGlsZS4gWW91IHBhc3NlZCAnICsgaW5wdXQpO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmICghKCdkYXRhJyBpbiBvcHRpb25zKSkge1xuICAgIG9wdGlvbnMuZGF0YSA9IHRydWU7XG4gIH1cbiAgaWYgKG9wdGlvbnMuY29tcGF0KSB7XG4gICAgb3B0aW9ucy51c2VEZXB0aHMgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGFzdCA9IGVudi5wYXJzZShpbnB1dCwgb3B0aW9ucyksXG4gICAgICBlbnZpcm9ubWVudCA9IG5ldyBlbnYuQ29tcGlsZXIoKS5jb21waWxlKGFzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBuZXcgZW52LkphdmFTY3JpcHRDb21waWxlcigpLmNvbXBpbGUoZW52aXJvbm1lbnQsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBjb21waWxlKGlucHV0LCBvcHRpb25zLCBlbnYpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkgb3B0aW9ucyA9IHt9O1xuXG4gIGlmIChpbnB1dCA9PSBudWxsIHx8IHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycgJiYgaW5wdXQudHlwZSAhPT0gJ1Byb2dyYW0nKSB7XG4gICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ1lvdSBtdXN0IHBhc3MgYSBzdHJpbmcgb3IgSGFuZGxlYmFycyBBU1QgdG8gSGFuZGxlYmFycy5jb21waWxlLiBZb3UgcGFzc2VkICcgKyBpbnB1dCk7XG4gIH1cblxuICBpZiAoISgnZGF0YScgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLmRhdGEgPSB0cnVlO1xuICB9XG4gIGlmIChvcHRpb25zLmNvbXBhdCkge1xuICAgIG9wdGlvbnMudXNlRGVwdGhzID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBjb21waWxlZCA9IHVuZGVmaW5lZDtcblxuICBmdW5jdGlvbiBjb21waWxlSW5wdXQoKSB7XG4gICAgdmFyIGFzdCA9IGVudi5wYXJzZShpbnB1dCwgb3B0aW9ucyksXG4gICAgICAgIGVudmlyb25tZW50ID0gbmV3IGVudi5Db21waWxlcigpLmNvbXBpbGUoYXN0LCBvcHRpb25zKSxcbiAgICAgICAgdGVtcGxhdGVTcGVjID0gbmV3IGVudi5KYXZhU2NyaXB0Q29tcGlsZXIoKS5jb21waWxlKGVudmlyb25tZW50LCBvcHRpb25zLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIHJldHVybiBlbnYudGVtcGxhdGUodGVtcGxhdGVTcGVjKTtcbiAgfVxuXG4gIC8vIFRlbXBsYXRlIGlzIG9ubHkgY29tcGlsZWQgb24gZmlyc3QgdXNlIGFuZCBjYWNoZWQgYWZ0ZXIgdGhhdCBwb2ludC5cbiAgZnVuY3Rpb24gcmV0KGNvbnRleHQsIGV4ZWNPcHRpb25zKSB7XG4gICAgaWYgKCFjb21waWxlZCkge1xuICAgICAgY29tcGlsZWQgPSBjb21waWxlSW5wdXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBpbGVkLmNhbGwodGhpcywgY29udGV4dCwgZXhlY09wdGlvbnMpO1xuICB9XG4gIHJldC5fc2V0dXAgPSBmdW5jdGlvbiAoc2V0dXBPcHRpb25zKSB7XG4gICAgaWYgKCFjb21waWxlZCkge1xuICAgICAgY29tcGlsZWQgPSBjb21waWxlSW5wdXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBpbGVkLl9zZXR1cChzZXR1cE9wdGlvbnMpO1xuICB9O1xuICByZXQuX2NoaWxkID0gZnVuY3Rpb24gKGksIGRhdGEsIGJsb2NrUGFyYW1zLCBkZXB0aHMpIHtcbiAgICBpZiAoIWNvbXBpbGVkKSB7XG4gICAgICBjb21waWxlZCA9IGNvbXBpbGVJbnB1dCgpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcGlsZWQuX2NoaWxkKGksIGRhdGEsIGJsb2NrUGFyYW1zLCBkZXB0aHMpO1xuICB9O1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBhcmdFcXVhbHMoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKF91dGlscy5pc0FycmF5KGEpICYmIF91dGlscy5pc0FycmF5KGIpICYmIGEubGVuZ3RoID09PSBiLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFhcmdFcXVhbHMoYVtpXSwgYltpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1MaXRlcmFsVG9QYXRoKHNleHByKSB7XG4gIGlmICghc2V4cHIucGF0aC5wYXJ0cykge1xuICAgIHZhciBsaXRlcmFsID0gc2V4cHIucGF0aDtcbiAgICAvLyBDYXN0aW5nIHRvIHN0cmluZyBoZXJlIHRvIG1ha2UgZmFsc2UgYW5kIDAgbGl0ZXJhbCB2YWx1ZXMgcGxheSBuaWNlbHkgd2l0aCB0aGUgcmVzdFxuICAgIC8vIG9mIHRoZSBzeXN0ZW0uXG4gICAgc2V4cHIucGF0aCA9IHtcbiAgICAgIHR5cGU6ICdQYXRoRXhwcmVzc2lvbicsXG4gICAgICBkYXRhOiBmYWxzZSxcbiAgICAgIGRlcHRoOiAwLFxuICAgICAgcGFydHM6IFtsaXRlcmFsLm9yaWdpbmFsICsgJyddLFxuICAgICAgb3JpZ2luYWw6IGxpdGVyYWwub3JpZ2luYWwgKyAnJyxcbiAgICAgIGxvYzogbGl0ZXJhbC5sb2NcbiAgICB9O1xuICB9XG59XG5cblxufSx7XCIuLi9leGNlcHRpb25cIjoyMCxcIi4uL3V0aWxzXCI6MzMsXCIuL2FzdFwiOjh9XSwxMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLlNvdXJjZUxvY2F0aW9uID0gU291cmNlTG9jYXRpb247XG5leHBvcnRzLmlkID0gaWQ7XG5leHBvcnRzLnN0cmlwRmxhZ3MgPSBzdHJpcEZsYWdzO1xuZXhwb3J0cy5zdHJpcENvbW1lbnQgPSBzdHJpcENvbW1lbnQ7XG5leHBvcnRzLnByZXBhcmVQYXRoID0gcHJlcGFyZVBhdGg7XG5leHBvcnRzLnByZXBhcmVNdXN0YWNoZSA9IHByZXBhcmVNdXN0YWNoZTtcbmV4cG9ydHMucHJlcGFyZVJhd0Jsb2NrID0gcHJlcGFyZVJhd0Jsb2NrO1xuZXhwb3J0cy5wcmVwYXJlQmxvY2sgPSBwcmVwYXJlQmxvY2s7XG5leHBvcnRzLnByZXBhcmVQcm9ncmFtID0gcHJlcGFyZVByb2dyYW07XG5leHBvcnRzLnByZXBhcmVQYXJ0aWFsQmxvY2sgPSBwcmVwYXJlUGFydGlhbEJsb2NrO1xuLy8gaXN0YW5idWwgaWdub3JlIG5leHRcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX2V4Y2VwdGlvbiA9IHJlcXVpcmUoJy4uL2V4Y2VwdGlvbicpO1xuXG52YXIgX2V4Y2VwdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leGNlcHRpb24pO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUNsb3NlKG9wZW4sIGNsb3NlKSB7XG4gIGNsb3NlID0gY2xvc2UucGF0aCA/IGNsb3NlLnBhdGgub3JpZ2luYWwgOiBjbG9zZTtcblxuICBpZiAob3Blbi5wYXRoLm9yaWdpbmFsICE9PSBjbG9zZSkge1xuICAgIHZhciBlcnJvck5vZGUgPSB7IGxvYzogb3Blbi5wYXRoLmxvYyB9O1xuXG4gICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10ob3Blbi5wYXRoLm9yaWdpbmFsICsgXCIgZG9lc24ndCBtYXRjaCBcIiArIGNsb3NlLCBlcnJvck5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIFNvdXJjZUxvY2F0aW9uKHNvdXJjZSwgbG9jSW5mbykge1xuICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgdGhpcy5zdGFydCA9IHtcbiAgICBsaW5lOiBsb2NJbmZvLmZpcnN0X2xpbmUsXG4gICAgY29sdW1uOiBsb2NJbmZvLmZpcnN0X2NvbHVtblxuICB9O1xuICB0aGlzLmVuZCA9IHtcbiAgICBsaW5lOiBsb2NJbmZvLmxhc3RfbGluZSxcbiAgICBjb2x1bW46IGxvY0luZm8ubGFzdF9jb2x1bW5cbiAgfTtcbn1cblxuZnVuY3Rpb24gaWQodG9rZW4pIHtcbiAgaWYgKC9eXFxbLipcXF0kLy50ZXN0KHRva2VuKSkge1xuICAgIHJldHVybiB0b2tlbi5zdWJzdHIoMSwgdG9rZW4ubGVuZ3RoIC0gMik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0cmlwRmxhZ3Mob3BlbiwgY2xvc2UpIHtcbiAgcmV0dXJuIHtcbiAgICBvcGVuOiBvcGVuLmNoYXJBdCgyKSA9PT0gJ34nLFxuICAgIGNsb3NlOiBjbG9zZS5jaGFyQXQoY2xvc2UubGVuZ3RoIC0gMykgPT09ICd+J1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHJpcENvbW1lbnQoY29tbWVudCkge1xuICByZXR1cm4gY29tbWVudC5yZXBsYWNlKC9eXFx7XFx7fj9cXCEtPy0/LywgJycpLnJlcGxhY2UoLy0/LT9+P1xcfVxcfSQvLCAnJyk7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVQYXRoKGRhdGEsIHBhcnRzLCBsb2MpIHtcbiAgbG9jID0gdGhpcy5sb2NJbmZvKGxvYyk7XG5cbiAgdmFyIG9yaWdpbmFsID0gZGF0YSA/ICdAJyA6ICcnLFxuICAgICAgZGlnID0gW10sXG4gICAgICBkZXB0aCA9IDAsXG4gICAgICBkZXB0aFN0cmluZyA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIHBhcnQgPSBwYXJ0c1tpXS5wYXJ0LFxuXG4gICAgLy8gSWYgd2UgaGF2ZSBbXSBzeW50YXggdGhlbiB3ZSBkbyBub3QgdHJlYXQgcGF0aCByZWZlcmVuY2VzIGFzIG9wZXJhdG9ycyxcbiAgICAvLyBpLmUuIGZvby5bdGhpc10gcmVzb2x2ZXMgdG8gYXBwcm94aW1hdGVseSBjb250ZXh0LmZvb1sndGhpcyddXG4gICAgaXNMaXRlcmFsID0gcGFydHNbaV0ub3JpZ2luYWwgIT09IHBhcnQ7XG4gICAgb3JpZ2luYWwgKz0gKHBhcnRzW2ldLnNlcGFyYXRvciB8fCAnJykgKyBwYXJ0O1xuXG4gICAgaWYgKCFpc0xpdGVyYWwgJiYgKHBhcnQgPT09ICcuLicgfHwgcGFydCA9PT0gJy4nIHx8IHBhcnQgPT09ICd0aGlzJykpIHtcbiAgICAgIGlmIChkaWcubGVuZ3RoID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnSW52YWxpZCBwYXRoOiAnICsgb3JpZ2luYWwsIHsgbG9jOiBsb2MgfSk7XG4gICAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgICAgZGVwdGhTdHJpbmcgKz0gJy4uLyc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpZy5wdXNoKHBhcnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ1BhdGhFeHByZXNzaW9uJyxcbiAgICBkYXRhOiBkYXRhLFxuICAgIGRlcHRoOiBkZXB0aCxcbiAgICBwYXJ0czogZGlnLFxuICAgIG9yaWdpbmFsOiBvcmlnaW5hbCxcbiAgICBsb2M6IGxvY1xuICB9O1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlTXVzdGFjaGUocGF0aCwgcGFyYW1zLCBoYXNoLCBvcGVuLCBzdHJpcCwgbG9jSW5mbykge1xuICAvLyBNdXN0IHVzZSBjaGFyQXQgdG8gc3VwcG9ydCBJRSBwcmUtMTBcbiAgdmFyIGVzY2FwZUZsYWcgPSBvcGVuLmNoYXJBdCgzKSB8fCBvcGVuLmNoYXJBdCgyKSxcbiAgICAgIGVzY2FwZWQgPSBlc2NhcGVGbGFnICE9PSAneycgJiYgZXNjYXBlRmxhZyAhPT0gJyYnO1xuXG4gIHZhciBkZWNvcmF0b3IgPSAvXFwqLy50ZXN0KG9wZW4pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGRlY29yYXRvciA/ICdEZWNvcmF0b3InIDogJ011c3RhY2hlU3RhdGVtZW50JyxcbiAgICBwYXRoOiBwYXRoLFxuICAgIHBhcmFtczogcGFyYW1zLFxuICAgIGhhc2g6IGhhc2gsXG4gICAgZXNjYXBlZDogZXNjYXBlZCxcbiAgICBzdHJpcDogc3RyaXAsXG4gICAgbG9jOiB0aGlzLmxvY0luZm8obG9jSW5mbylcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVJhd0Jsb2NrKG9wZW5SYXdCbG9jaywgY29udGVudHMsIGNsb3NlLCBsb2NJbmZvKSB7XG4gIHZhbGlkYXRlQ2xvc2Uob3BlblJhd0Jsb2NrLCBjbG9zZSk7XG5cbiAgbG9jSW5mbyA9IHRoaXMubG9jSW5mbyhsb2NJbmZvKTtcbiAgdmFyIHByb2dyYW0gPSB7XG4gICAgdHlwZTogJ1Byb2dyYW0nLFxuICAgIGJvZHk6IGNvbnRlbnRzLFxuICAgIHN0cmlwOiB7fSxcbiAgICBsb2M6IGxvY0luZm9cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCbG9ja1N0YXRlbWVudCcsXG4gICAgcGF0aDogb3BlblJhd0Jsb2NrLnBhdGgsXG4gICAgcGFyYW1zOiBvcGVuUmF3QmxvY2sucGFyYW1zLFxuICAgIGhhc2g6IG9wZW5SYXdCbG9jay5oYXNoLFxuICAgIHByb2dyYW06IHByb2dyYW0sXG4gICAgb3BlblN0cmlwOiB7fSxcbiAgICBpbnZlcnNlU3RyaXA6IHt9LFxuICAgIGNsb3NlU3RyaXA6IHt9LFxuICAgIGxvYzogbG9jSW5mb1xuICB9O1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlQmxvY2sob3BlbkJsb2NrLCBwcm9ncmFtLCBpbnZlcnNlQW5kUHJvZ3JhbSwgY2xvc2UsIGludmVydGVkLCBsb2NJbmZvKSB7XG4gIGlmIChjbG9zZSAmJiBjbG9zZS5wYXRoKSB7XG4gICAgdmFsaWRhdGVDbG9zZShvcGVuQmxvY2ssIGNsb3NlKTtcbiAgfVxuXG4gIHZhciBkZWNvcmF0b3IgPSAvXFwqLy50ZXN0KG9wZW5CbG9jay5vcGVuKTtcblxuICBwcm9ncmFtLmJsb2NrUGFyYW1zID0gb3BlbkJsb2NrLmJsb2NrUGFyYW1zO1xuXG4gIHZhciBpbnZlcnNlID0gdW5kZWZpbmVkLFxuICAgICAgaW52ZXJzZVN0cmlwID0gdW5kZWZpbmVkO1xuXG4gIGlmIChpbnZlcnNlQW5kUHJvZ3JhbSkge1xuICAgIGlmIChkZWNvcmF0b3IpIHtcbiAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdVbmV4cGVjdGVkIGludmVyc2UgYmxvY2sgb24gZGVjb3JhdG9yJywgaW52ZXJzZUFuZFByb2dyYW0pO1xuICAgIH1cblxuICAgIGlmIChpbnZlcnNlQW5kUHJvZ3JhbS5jaGFpbikge1xuICAgICAgaW52ZXJzZUFuZFByb2dyYW0ucHJvZ3JhbS5ib2R5WzBdLmNsb3NlU3RyaXAgPSBjbG9zZS5zdHJpcDtcbiAgICB9XG5cbiAgICBpbnZlcnNlU3RyaXAgPSBpbnZlcnNlQW5kUHJvZ3JhbS5zdHJpcDtcbiAgICBpbnZlcnNlID0gaW52ZXJzZUFuZFByb2dyYW0ucHJvZ3JhbTtcbiAgfVxuXG4gIGlmIChpbnZlcnRlZCkge1xuICAgIGludmVydGVkID0gaW52ZXJzZTtcbiAgICBpbnZlcnNlID0gcHJvZ3JhbTtcbiAgICBwcm9ncmFtID0gaW52ZXJ0ZWQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IGRlY29yYXRvciA/ICdEZWNvcmF0b3JCbG9jaycgOiAnQmxvY2tTdGF0ZW1lbnQnLFxuICAgIHBhdGg6IG9wZW5CbG9jay5wYXRoLFxuICAgIHBhcmFtczogb3BlbkJsb2NrLnBhcmFtcyxcbiAgICBoYXNoOiBvcGVuQmxvY2suaGFzaCxcbiAgICBwcm9ncmFtOiBwcm9ncmFtLFxuICAgIGludmVyc2U6IGludmVyc2UsXG4gICAgb3BlblN0cmlwOiBvcGVuQmxvY2suc3RyaXAsXG4gICAgaW52ZXJzZVN0cmlwOiBpbnZlcnNlU3RyaXAsXG4gICAgY2xvc2VTdHJpcDogY2xvc2UgJiYgY2xvc2Uuc3RyaXAsXG4gICAgbG9jOiB0aGlzLmxvY0luZm8obG9jSW5mbylcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVByb2dyYW0oc3RhdGVtZW50cywgbG9jKSB7XG4gIGlmICghbG9jICYmIHN0YXRlbWVudHMubGVuZ3RoKSB7XG4gICAgdmFyIGZpcnN0TG9jID0gc3RhdGVtZW50c1swXS5sb2MsXG4gICAgICAgIGxhc3RMb2MgPSBzdGF0ZW1lbnRzW3N0YXRlbWVudHMubGVuZ3RoIC0gMV0ubG9jO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoZmlyc3RMb2MgJiYgbGFzdExvYykge1xuICAgICAgbG9jID0ge1xuICAgICAgICBzb3VyY2U6IGZpcnN0TG9jLnNvdXJjZSxcbiAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICBsaW5lOiBmaXJzdExvYy5zdGFydC5saW5lLFxuICAgICAgICAgIGNvbHVtbjogZmlyc3RMb2Muc3RhcnQuY29sdW1uXG4gICAgICAgIH0sXG4gICAgICAgIGVuZDoge1xuICAgICAgICAgIGxpbmU6IGxhc3RMb2MuZW5kLmxpbmUsXG4gICAgICAgICAgY29sdW1uOiBsYXN0TG9jLmVuZC5jb2x1bW5cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdQcm9ncmFtJyxcbiAgICBib2R5OiBzdGF0ZW1lbnRzLFxuICAgIHN0cmlwOiB7fSxcbiAgICBsb2M6IGxvY1xuICB9O1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlUGFydGlhbEJsb2NrKG9wZW4sIHByb2dyYW0sIGNsb3NlLCBsb2NJbmZvKSB7XG4gIHZhbGlkYXRlQ2xvc2Uob3BlbiwgY2xvc2UpO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ1BhcnRpYWxCbG9ja1N0YXRlbWVudCcsXG4gICAgbmFtZTogb3Blbi5wYXRoLFxuICAgIHBhcmFtczogb3Blbi5wYXJhbXMsXG4gICAgaGFzaDogb3Blbi5oYXNoLFxuICAgIHByb2dyYW06IHByb2dyYW0sXG4gICAgb3BlblN0cmlwOiBvcGVuLnN0cmlwLFxuICAgIGNsb3NlU3RyaXA6IGNsb3NlICYmIGNsb3NlLnN0cmlwLFxuICAgIGxvYzogdGhpcy5sb2NJbmZvKGxvY0luZm8pXG4gIH07XG59XG5cblxufSx7XCIuLi9leGNlcHRpb25cIjoyMH1dLDEzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbi8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9iYXNlID0gcmVxdWlyZSgnLi4vYmFzZScpO1xuXG52YXIgX2V4Y2VwdGlvbiA9IHJlcXVpcmUoJy4uL2V4Y2VwdGlvbicpO1xuXG52YXIgX2V4Y2VwdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leGNlcHRpb24pO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxudmFyIF9jb2RlR2VuID0gcmVxdWlyZSgnLi9jb2RlLWdlbicpO1xuXG52YXIgX2NvZGVHZW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29kZUdlbik7XG5cbmZ1bmN0aW9uIExpdGVyYWwodmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBKYXZhU2NyaXB0Q29tcGlsZXIoKSB7fVxuXG5KYXZhU2NyaXB0Q29tcGlsZXIucHJvdG90eXBlID0ge1xuICAvLyBQVUJMSUMgQVBJOiBZb3UgY2FuIG92ZXJyaWRlIHRoZXNlIG1ldGhvZHMgaW4gYSBzdWJjbGFzcyB0byBwcm92aWRlXG4gIC8vIGFsdGVybmF0aXZlIGNvbXBpbGVkIGZvcm1zIGZvciBuYW1lIGxvb2t1cCBhbmQgYnVmZmVyaW5nIHNlbWFudGljc1xuICBuYW1lTG9va3VwOiBmdW5jdGlvbiBuYW1lTG9va3VwKHBhcmVudCwgbmFtZSAvKiAsIHR5cGUqLykge1xuICAgIGlmIChKYXZhU2NyaXB0Q29tcGlsZXIuaXNWYWxpZEphdmFTY3JpcHRWYXJpYWJsZU5hbWUobmFtZSkpIHtcbiAgICAgIHJldHVybiBbcGFyZW50LCAnLicsIG5hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW3BhcmVudCwgJ1snLCBKU09OLnN0cmluZ2lmeShuYW1lKSwgJ10nXTtcbiAgICB9XG4gIH0sXG4gIGRlcHRoZWRMb29rdXA6IGZ1bmN0aW9uIGRlcHRoZWRMb29rdXAobmFtZSkge1xuICAgIHJldHVybiBbdGhpcy5hbGlhc2FibGUoJ2NvbnRhaW5lci5sb29rdXAnKSwgJyhkZXB0aHMsIFwiJywgbmFtZSwgJ1wiKSddO1xuICB9LFxuXG4gIGNvbXBpbGVySW5mbzogZnVuY3Rpb24gY29tcGlsZXJJbmZvKCkge1xuICAgIHZhciByZXZpc2lvbiA9IF9iYXNlLkNPTVBJTEVSX1JFVklTSU9OLFxuICAgICAgICB2ZXJzaW9ucyA9IF9iYXNlLlJFVklTSU9OX0NIQU5HRVNbcmV2aXNpb25dO1xuICAgIHJldHVybiBbcmV2aXNpb24sIHZlcnNpb25zXTtcbiAgfSxcblxuICBhcHBlbmRUb0J1ZmZlcjogZnVuY3Rpb24gYXBwZW5kVG9CdWZmZXIoc291cmNlLCBsb2NhdGlvbiwgZXhwbGljaXQpIHtcbiAgICAvLyBGb3JjZSBhIHNvdXJjZSBhcyB0aGlzIHNpbXBsaWZpZXMgdGhlIG1lcmdlIGxvZ2ljLlxuICAgIGlmICghX3V0aWxzLmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgc291cmNlID0gW3NvdXJjZV07XG4gICAgfVxuICAgIHNvdXJjZSA9IHRoaXMuc291cmNlLndyYXAoc291cmNlLCBsb2NhdGlvbik7XG5cbiAgICBpZiAodGhpcy5lbnZpcm9ubWVudC5pc1NpbXBsZSkge1xuICAgICAgcmV0dXJuIFsncmV0dXJuICcsIHNvdXJjZSwgJzsnXTtcbiAgICB9IGVsc2UgaWYgKGV4cGxpY2l0KSB7XG4gICAgICAvLyBUaGlzIGlzIGEgY2FzZSB3aGVyZSB0aGUgYnVmZmVyIG9wZXJhdGlvbiBvY2N1cnMgYXMgYSBjaGlsZCBvZiBhbm90aGVyXG4gICAgICAvLyBjb25zdHJ1Y3QsIGdlbmVyYWxseSBicmFjZXMuIFdlIGhhdmUgdG8gZXhwbGljaXRseSBvdXRwdXQgdGhlc2UgYnVmZmVyXG4gICAgICAvLyBvcGVyYXRpb25zIHRvIGVuc3VyZSB0aGF0IHRoZSBlbWl0dGVkIGNvZGUgZ29lcyBpbiB0aGUgY29ycmVjdCBsb2NhdGlvbi5cbiAgICAgIHJldHVybiBbJ2J1ZmZlciArPSAnLCBzb3VyY2UsICc7J107XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvdXJjZS5hcHBlbmRUb0J1ZmZlciA9IHRydWU7XG4gICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cbiAgfSxcblxuICBpbml0aWFsaXplQnVmZmVyOiBmdW5jdGlvbiBpbml0aWFsaXplQnVmZmVyKCkge1xuICAgIHJldHVybiB0aGlzLnF1b3RlZFN0cmluZygnJyk7XG4gIH0sXG4gIC8vIEVORCBQVUJMSUMgQVBJXG5cbiAgY29tcGlsZTogZnVuY3Rpb24gY29tcGlsZShlbnZpcm9ubWVudCwgb3B0aW9ucywgY29udGV4dCwgYXNPYmplY3QpIHtcbiAgICB0aGlzLmVudmlyb25tZW50ID0gZW52aXJvbm1lbnQ7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnN0cmluZ1BhcmFtcyA9IHRoaXMub3B0aW9ucy5zdHJpbmdQYXJhbXM7XG4gICAgdGhpcy50cmFja0lkcyA9IHRoaXMub3B0aW9ucy50cmFja0lkcztcbiAgICB0aGlzLnByZWNvbXBpbGUgPSAhYXNPYmplY3Q7XG5cbiAgICB0aGlzLm5hbWUgPSB0aGlzLmVudmlyb25tZW50Lm5hbWU7XG4gICAgdGhpcy5pc0NoaWxkID0gISFjb250ZXh0O1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQgfHwge1xuICAgICAgZGVjb3JhdG9yczogW10sXG4gICAgICBwcm9ncmFtczogW10sXG4gICAgICBlbnZpcm9ubWVudHM6IFtdXG4gICAgfTtcblxuICAgIHRoaXMucHJlYW1ibGUoKTtcblxuICAgIHRoaXMuc3RhY2tTbG90ID0gMDtcbiAgICB0aGlzLnN0YWNrVmFycyA9IFtdO1xuICAgIHRoaXMuYWxpYXNlcyA9IHt9O1xuICAgIHRoaXMucmVnaXN0ZXJzID0geyBsaXN0OiBbXSB9O1xuICAgIHRoaXMuaGFzaGVzID0gW107XG4gICAgdGhpcy5jb21waWxlU3RhY2sgPSBbXTtcbiAgICB0aGlzLmlubGluZVN0YWNrID0gW107XG4gICAgdGhpcy5ibG9ja1BhcmFtcyA9IFtdO1xuXG4gICAgdGhpcy5jb21waWxlQ2hpbGRyZW4oZW52aXJvbm1lbnQsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy51c2VEZXB0aHMgPSB0aGlzLnVzZURlcHRocyB8fCBlbnZpcm9ubWVudC51c2VEZXB0aHMgfHwgZW52aXJvbm1lbnQudXNlRGVjb3JhdG9ycyB8fCB0aGlzLm9wdGlvbnMuY29tcGF0O1xuICAgIHRoaXMudXNlQmxvY2tQYXJhbXMgPSB0aGlzLnVzZUJsb2NrUGFyYW1zIHx8IGVudmlyb25tZW50LnVzZUJsb2NrUGFyYW1zO1xuXG4gICAgdmFyIG9wY29kZXMgPSBlbnZpcm9ubWVudC5vcGNvZGVzLFxuICAgICAgICBvcGNvZGUgPSB1bmRlZmluZWQsXG4gICAgICAgIGZpcnN0TG9jID0gdW5kZWZpbmVkLFxuICAgICAgICBpID0gdW5kZWZpbmVkLFxuICAgICAgICBsID0gdW5kZWZpbmVkO1xuXG4gICAgZm9yIChpID0gMCwgbCA9IG9wY29kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBvcGNvZGUgPSBvcGNvZGVzW2ldO1xuXG4gICAgICB0aGlzLnNvdXJjZS5jdXJyZW50TG9jYXRpb24gPSBvcGNvZGUubG9jO1xuICAgICAgZmlyc3RMb2MgPSBmaXJzdExvYyB8fCBvcGNvZGUubG9jO1xuICAgICAgdGhpc1tvcGNvZGUub3Bjb2RlXS5hcHBseSh0aGlzLCBvcGNvZGUuYXJncyk7XG4gICAgfVxuXG4gICAgLy8gRmx1c2ggYW55IHRyYWlsaW5nIGNvbnRlbnQgdGhhdCBtaWdodCBiZSBwZW5kaW5nLlxuICAgIHRoaXMuc291cmNlLmN1cnJlbnRMb2NhdGlvbiA9IGZpcnN0TG9jO1xuICAgIHRoaXMucHVzaFNvdXJjZSgnJyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0aGlzLnN0YWNrU2xvdCB8fCB0aGlzLmlubGluZVN0YWNrLmxlbmd0aCB8fCB0aGlzLmNvbXBpbGVTdGFjay5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdDb21waWxlIGNvbXBsZXRlZCB3aXRoIGNvbnRlbnQgbGVmdCBvbiBzdGFjaycpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5kZWNvcmF0b3JzLmlzRW1wdHkoKSkge1xuICAgICAgdGhpcy51c2VEZWNvcmF0b3JzID0gdHJ1ZTtcblxuICAgICAgdGhpcy5kZWNvcmF0b3JzLnByZXBlbmQoJ3ZhciBkZWNvcmF0b3JzID0gY29udGFpbmVyLmRlY29yYXRvcnM7XFxuJyk7XG4gICAgICB0aGlzLmRlY29yYXRvcnMucHVzaCgncmV0dXJuIGZuOycpO1xuXG4gICAgICBpZiAoYXNPYmplY3QpIHtcbiAgICAgICAgdGhpcy5kZWNvcmF0b3JzID0gRnVuY3Rpb24uYXBwbHkodGhpcywgWydmbicsICdwcm9wcycsICdjb250YWluZXInLCAnZGVwdGgwJywgJ2RhdGEnLCAnYmxvY2tQYXJhbXMnLCAnZGVwdGhzJywgdGhpcy5kZWNvcmF0b3JzLm1lcmdlKCldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVjb3JhdG9ycy5wcmVwZW5kKCdmdW5jdGlvbihmbiwgcHJvcHMsIGNvbnRhaW5lciwgZGVwdGgwLCBkYXRhLCBibG9ja1BhcmFtcywgZGVwdGhzKSB7XFxuJyk7XG4gICAgICAgIHRoaXMuZGVjb3JhdG9ycy5wdXNoKCd9XFxuJyk7XG4gICAgICAgIHRoaXMuZGVjb3JhdG9ycyA9IHRoaXMuZGVjb3JhdG9ycy5tZXJnZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlY29yYXRvcnMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIGZuID0gdGhpcy5jcmVhdGVGdW5jdGlvbkNvbnRleHQoYXNPYmplY3QpO1xuICAgIGlmICghdGhpcy5pc0NoaWxkKSB7XG4gICAgICB2YXIgcmV0ID0ge1xuICAgICAgICBjb21waWxlcjogdGhpcy5jb21waWxlckluZm8oKSxcbiAgICAgICAgbWFpbjogZm5cbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLmRlY29yYXRvcnMpIHtcbiAgICAgICAgcmV0Lm1haW5fZCA9IHRoaXMuZGVjb3JhdG9yczsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICAgICAgcmV0LnVzZURlY29yYXRvcnMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2NvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICB2YXIgcHJvZ3JhbXMgPSBfY29udGV4dC5wcm9ncmFtcztcbiAgICAgIHZhciBkZWNvcmF0b3JzID0gX2NvbnRleHQuZGVjb3JhdG9ycztcblxuICAgICAgZm9yIChpID0gMCwgbCA9IHByb2dyYW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAocHJvZ3JhbXNbaV0pIHtcbiAgICAgICAgICByZXRbaV0gPSBwcm9ncmFtc1tpXTtcbiAgICAgICAgICBpZiAoZGVjb3JhdG9yc1tpXSkge1xuICAgICAgICAgICAgcmV0W2kgKyAnX2QnXSA9IGRlY29yYXRvcnNbaV07XG4gICAgICAgICAgICByZXQudXNlRGVjb3JhdG9ycyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmVudmlyb25tZW50LnVzZVBhcnRpYWwpIHtcbiAgICAgICAgcmV0LnVzZVBhcnRpYWwgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kYXRhKSB7XG4gICAgICAgIHJldC51c2VEYXRhID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnVzZURlcHRocykge1xuICAgICAgICByZXQudXNlRGVwdGhzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnVzZUJsb2NrUGFyYW1zKSB7XG4gICAgICAgIHJldC51c2VCbG9ja1BhcmFtcyA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNvbXBhdCkge1xuICAgICAgICByZXQuY29tcGF0ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhc09iamVjdCkge1xuICAgICAgICByZXQuY29tcGlsZXIgPSBKU09OLnN0cmluZ2lmeShyZXQuY29tcGlsZXIpO1xuXG4gICAgICAgIHRoaXMuc291cmNlLmN1cnJlbnRMb2NhdGlvbiA9IHsgc3RhcnQ6IHsgbGluZTogMSwgY29sdW1uOiAwIH0gfTtcbiAgICAgICAgcmV0ID0gdGhpcy5vYmplY3RMaXRlcmFsKHJldCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc3JjTmFtZSkge1xuICAgICAgICAgIHJldCA9IHJldC50b1N0cmluZ1dpdGhTb3VyY2VNYXAoeyBmaWxlOiBvcHRpb25zLmRlc3ROYW1lIH0pO1xuICAgICAgICAgIHJldC5tYXAgPSByZXQubWFwICYmIHJldC5tYXAudG9TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQgPSByZXQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0LmNvbXBpbGVyT3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZuO1xuICAgIH1cbiAgfSxcblxuICBwcmVhbWJsZTogZnVuY3Rpb24gcHJlYW1ibGUoKSB7XG4gICAgLy8gdHJhY2sgdGhlIGxhc3QgY29udGV4dCBwdXNoZWQgaW50byBwbGFjZSB0byBhbGxvdyBza2lwcGluZyB0aGVcbiAgICAvLyBnZXRDb250ZXh0IG9wY29kZSB3aGVuIGl0IHdvdWxkIGJlIGEgbm9vcFxuICAgIHRoaXMubGFzdENvbnRleHQgPSAwO1xuICAgIHRoaXMuc291cmNlID0gbmV3IF9jb2RlR2VuMlsnZGVmYXVsdCddKHRoaXMub3B0aW9ucy5zcmNOYW1lKTtcbiAgICB0aGlzLmRlY29yYXRvcnMgPSBuZXcgX2NvZGVHZW4yWydkZWZhdWx0J10odGhpcy5vcHRpb25zLnNyY05hbWUpO1xuICB9LFxuXG4gIGNyZWF0ZUZ1bmN0aW9uQ29udGV4dDogZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25Db250ZXh0KGFzT2JqZWN0KSB7XG4gICAgdmFyIHZhckRlY2xhcmF0aW9ucyA9ICcnO1xuXG4gICAgdmFyIGxvY2FscyA9IHRoaXMuc3RhY2tWYXJzLmNvbmNhdCh0aGlzLnJlZ2lzdGVycy5saXN0KTtcbiAgICBpZiAobG9jYWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhckRlY2xhcmF0aW9ucyArPSAnLCAnICsgbG9jYWxzLmpvaW4oJywgJyk7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgbWluaW1pemVyIGFsaWFzIG1hcHBpbmdzXG4gICAgLy9cbiAgICAvLyBXaGVuIHVzaW5nIHRydWUgU291cmNlTm9kZXMsIHRoaXMgd2lsbCB1cGRhdGUgYWxsIHJlZmVyZW5jZXMgdG8gdGhlIGdpdmVuIGFsaWFzXG4gICAgLy8gYXMgdGhlIHNvdXJjZSBub2RlcyBhcmUgcmV1c2VkIGluIHNpdHUuIEZvciB0aGUgbm9uLXNvdXJjZSBub2RlIGNvbXBpbGF0aW9uIG1vZGUsXG4gICAgLy8gYWxpYXNlcyB3aWxsIG5vdCBiZSB1c2VkLCBidXQgdGhpcyBjYXNlIGlzIGFscmVhZHkgYmVpbmcgcnVuIG9uIHRoZSBjbGllbnQgYW5kXG4gICAgLy8gd2UgYXJlbid0IGNvbmNlcm4gYWJvdXQgbWluaW1pemluZyB0aGUgdGVtcGxhdGUgc2l6ZS5cbiAgICB2YXIgYWxpYXNDb3VudCA9IDA7XG4gICAgZm9yICh2YXIgYWxpYXMgaW4gdGhpcy5hbGlhc2VzKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGd1YXJkLWZvci1pblxuICAgICAgdmFyIG5vZGUgPSB0aGlzLmFsaWFzZXNbYWxpYXNdO1xuXG4gICAgICBpZiAodGhpcy5hbGlhc2VzLmhhc093blByb3BlcnR5KGFsaWFzKSAmJiBub2RlLmNoaWxkcmVuICYmIG5vZGUucmVmZXJlbmNlQ291bnQgPiAxKSB7XG4gICAgICAgIHZhckRlY2xhcmF0aW9ucyArPSAnLCBhbGlhcycgKyArK2FsaWFzQ291bnQgKyAnPScgKyBhbGlhcztcbiAgICAgICAgbm9kZS5jaGlsZHJlblswXSA9ICdhbGlhcycgKyBhbGlhc0NvdW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwYXJhbXMgPSBbJ2NvbnRhaW5lcicsICdkZXB0aDAnLCAnaGVscGVycycsICdwYXJ0aWFscycsICdkYXRhJ107XG5cbiAgICBpZiAodGhpcy51c2VCbG9ja1BhcmFtcyB8fCB0aGlzLnVzZURlcHRocykge1xuICAgICAgcGFyYW1zLnB1c2goJ2Jsb2NrUGFyYW1zJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLnVzZURlcHRocykge1xuICAgICAgcGFyYW1zLnB1c2goJ2RlcHRocycpO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYSBzZWNvbmQgcGFzcyBvdmVyIHRoZSBvdXRwdXQgdG8gbWVyZ2UgY29udGVudCB3aGVuIHBvc3NpYmxlXG4gICAgdmFyIHNvdXJjZSA9IHRoaXMubWVyZ2VTb3VyY2UodmFyRGVjbGFyYXRpb25zKTtcblxuICAgIGlmIChhc09iamVjdCkge1xuICAgICAgcGFyYW1zLnB1c2goc291cmNlKTtcblxuICAgICAgcmV0dXJuIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIHBhcmFtcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS53cmFwKFsnZnVuY3Rpb24oJywgcGFyYW1zLmpvaW4oJywnKSwgJykge1xcbiAgJywgc291cmNlLCAnfSddKTtcbiAgICB9XG4gIH0sXG4gIG1lcmdlU291cmNlOiBmdW5jdGlvbiBtZXJnZVNvdXJjZSh2YXJEZWNsYXJhdGlvbnMpIHtcbiAgICB2YXIgaXNTaW1wbGUgPSB0aGlzLmVudmlyb25tZW50LmlzU2ltcGxlLFxuICAgICAgICBhcHBlbmRPbmx5ID0gIXRoaXMuZm9yY2VCdWZmZXIsXG4gICAgICAgIGFwcGVuZEZpcnN0ID0gdW5kZWZpbmVkLFxuICAgICAgICBzb3VyY2VTZWVuID0gdW5kZWZpbmVkLFxuICAgICAgICBidWZmZXJTdGFydCA9IHVuZGVmaW5lZCxcbiAgICAgICAgYnVmZmVyRW5kID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc291cmNlLmVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGlmIChsaW5lLmFwcGVuZFRvQnVmZmVyKSB7XG4gICAgICAgIGlmIChidWZmZXJTdGFydCkge1xuICAgICAgICAgIGxpbmUucHJlcGVuZCgnICArICcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1ZmZlclN0YXJ0ID0gbGluZTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXJFbmQgPSBsaW5lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGJ1ZmZlclN0YXJ0KSB7XG4gICAgICAgICAgaWYgKCFzb3VyY2VTZWVuKSB7XG4gICAgICAgICAgICBhcHBlbmRGaXJzdCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZlclN0YXJ0LnByZXBlbmQoJ2J1ZmZlciArPSAnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnVmZmVyRW5kLmFkZCgnOycpO1xuICAgICAgICAgIGJ1ZmZlclN0YXJ0ID0gYnVmZmVyRW5kID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgc291cmNlU2VlbiA9IHRydWU7XG4gICAgICAgIGlmICghaXNTaW1wbGUpIHtcbiAgICAgICAgICBhcHBlbmRPbmx5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChhcHBlbmRPbmx5KSB7XG4gICAgICBpZiAoYnVmZmVyU3RhcnQpIHtcbiAgICAgICAgYnVmZmVyU3RhcnQucHJlcGVuZCgncmV0dXJuICcpO1xuICAgICAgICBidWZmZXJFbmQuYWRkKCc7Jyk7XG4gICAgICB9IGVsc2UgaWYgKCFzb3VyY2VTZWVuKSB7XG4gICAgICAgIHRoaXMuc291cmNlLnB1c2goJ3JldHVybiBcIlwiOycpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXJEZWNsYXJhdGlvbnMgKz0gJywgYnVmZmVyID0gJyArIChhcHBlbmRGaXJzdCA/ICcnIDogdGhpcy5pbml0aWFsaXplQnVmZmVyKCkpO1xuXG4gICAgICBpZiAoYnVmZmVyU3RhcnQpIHtcbiAgICAgICAgYnVmZmVyU3RhcnQucHJlcGVuZCgncmV0dXJuIGJ1ZmZlciArICcpO1xuICAgICAgICBidWZmZXJFbmQuYWRkKCc7Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNvdXJjZS5wdXNoKCdyZXR1cm4gYnVmZmVyOycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2YXJEZWNsYXJhdGlvbnMpIHtcbiAgICAgIHRoaXMuc291cmNlLnByZXBlbmQoJ3ZhciAnICsgdmFyRGVjbGFyYXRpb25zLnN1YnN0cmluZygyKSArIChhcHBlbmRGaXJzdCA/ICcnIDogJztcXG4nKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc291cmNlLm1lcmdlKCk7XG4gIH0sXG5cbiAgLy8gW2Jsb2NrVmFsdWVdXG4gIC8vXG4gIC8vIE9uIHN0YWNrLCBiZWZvcmU6IGhhc2gsIGludmVyc2UsIHByb2dyYW0sIHZhbHVlXG4gIC8vIE9uIHN0YWNrLCBhZnRlcjogcmV0dXJuIHZhbHVlIG9mIGJsb2NrSGVscGVyTWlzc2luZ1xuICAvL1xuICAvLyBUaGUgcHVycG9zZSBvZiB0aGlzIG9wY29kZSBpcyB0byB0YWtlIGEgYmxvY2sgb2YgdGhlIGZvcm1cbiAgLy8gYHt7I3RoaXMuZm9vfX0uLi57ey90aGlzLmZvb319YCwgcmVzb2x2ZSB0aGUgdmFsdWUgb2YgYGZvb2AsIGFuZFxuICAvLyByZXBsYWNlIGl0IG9uIHRoZSBzdGFjayB3aXRoIHRoZSByZXN1bHQgb2YgcHJvcGVybHlcbiAgLy8gaW52b2tpbmcgYmxvY2tIZWxwZXJNaXNzaW5nLlxuICBibG9ja1ZhbHVlOiBmdW5jdGlvbiBibG9ja1ZhbHVlKG5hbWUpIHtcbiAgICB2YXIgYmxvY2tIZWxwZXJNaXNzaW5nID0gdGhpcy5hbGlhc2FibGUoJ2hlbHBlcnMuYmxvY2tIZWxwZXJNaXNzaW5nJyksXG4gICAgICAgIHBhcmFtcyA9IFt0aGlzLmNvbnRleHROYW1lKDApXTtcbiAgICB0aGlzLnNldHVwSGVscGVyQXJncyhuYW1lLCAwLCBwYXJhbXMpO1xuXG4gICAgdmFyIGJsb2NrTmFtZSA9IHRoaXMucG9wU3RhY2soKTtcbiAgICBwYXJhbXMuc3BsaWNlKDEsIDAsIGJsb2NrTmFtZSk7XG5cbiAgICB0aGlzLnB1c2godGhpcy5zb3VyY2UuZnVuY3Rpb25DYWxsKGJsb2NrSGVscGVyTWlzc2luZywgJ2NhbGwnLCBwYXJhbXMpKTtcbiAgfSxcblxuICAvLyBbYW1iaWd1b3VzQmxvY2tWYWx1ZV1cbiAgLy9cbiAgLy8gT24gc3RhY2ssIGJlZm9yZTogaGFzaCwgaW52ZXJzZSwgcHJvZ3JhbSwgdmFsdWVcbiAgLy8gQ29tcGlsZXIgdmFsdWUsIGJlZm9yZTogbGFzdEhlbHBlcj12YWx1ZSBvZiBsYXN0IGZvdW5kIGhlbHBlciwgaWYgYW55XG4gIC8vIE9uIHN0YWNrLCBhZnRlciwgaWYgbm8gbGFzdEhlbHBlcjogc2FtZSBhcyBbYmxvY2tWYWx1ZV1cbiAgLy8gT24gc3RhY2ssIGFmdGVyLCBpZiBsYXN0SGVscGVyOiB2YWx1ZVxuICBhbWJpZ3VvdXNCbG9ja1ZhbHVlOiBmdW5jdGlvbiBhbWJpZ3VvdXNCbG9ja1ZhbHVlKCkge1xuICAgIC8vIFdlJ3JlIGJlaW5nIGEgYml0IGNoZWVreSBhbmQgcmV1c2luZyB0aGUgb3B0aW9ucyB2YWx1ZSBmcm9tIHRoZSBwcmlvciBleGVjXG4gICAgdmFyIGJsb2NrSGVscGVyTWlzc2luZyA9IHRoaXMuYWxpYXNhYmxlKCdoZWxwZXJzLmJsb2NrSGVscGVyTWlzc2luZycpLFxuICAgICAgICBwYXJhbXMgPSBbdGhpcy5jb250ZXh0TmFtZSgwKV07XG4gICAgdGhpcy5zZXR1cEhlbHBlckFyZ3MoJycsIDAsIHBhcmFtcywgdHJ1ZSk7XG5cbiAgICB0aGlzLmZsdXNoSW5saW5lKCk7XG5cbiAgICB2YXIgY3VycmVudCA9IHRoaXMudG9wU3RhY2soKTtcbiAgICBwYXJhbXMuc3BsaWNlKDEsIDAsIGN1cnJlbnQpO1xuXG4gICAgdGhpcy5wdXNoU291cmNlKFsnaWYgKCEnLCB0aGlzLmxhc3RIZWxwZXIsICcpIHsgJywgY3VycmVudCwgJyA9ICcsIHRoaXMuc291cmNlLmZ1bmN0aW9uQ2FsbChibG9ja0hlbHBlck1pc3NpbmcsICdjYWxsJywgcGFyYW1zKSwgJ30nXSk7XG4gIH0sXG5cbiAgLy8gW2FwcGVuZENvbnRlbnRdXG4gIC8vXG4gIC8vIE9uIHN0YWNrLCBiZWZvcmU6IC4uLlxuICAvLyBPbiBzdGFjaywgYWZ0ZXI6IC4uLlxuICAvL1xuICAvLyBBcHBlbmRzIHRoZSBzdHJpbmcgdmFsdWUgb2YgYGNvbnRlbnRgIHRvIHRoZSBjdXJyZW50IGJ1ZmZlclxuICBhcHBlbmRDb250ZW50OiBmdW5jdGlvbiBhcHBlbmRDb250ZW50KGNvbnRlbnQpIHtcbiAgICBpZiAodGhpcy5wZW5kaW5nQ29udGVudCkge1xuICAgICAgY29udGVudCA9IHRoaXMucGVuZGluZ0NvbnRlbnQgKyBjb250ZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBlbmRpbmdMb2NhdGlvbiA9IHRoaXMuc291cmNlLmN1cnJlbnRMb2NhdGlvbjtcbiAgICB9XG5cbiAgICB0aGlzLnBlbmRpbmdDb250ZW50ID0gY29udGVudDtcbiAgfSxcblxuICAvLyBbYXBwZW5kXVxuICAvL1xuICAvLyBPbiBzdGFjaywgYmVmb3JlOiB2YWx1ZSwgLi4uXG4gIC8vIE9uIHN0YWNrLCBhZnRlcjogLi4uXG4gIC8vXG4gIC8vIENvZXJjZXMgYHZhbHVlYCB0byBhIFN0cmluZyBhbmQgYXBwZW5kcyBpdCB0byB0aGUgY3VycmVudCBidWZmZXIuXG4gIC8vXG4gIC8vIElmIGB2YWx1ZWAgaXMgdHJ1dGh5LCBvciAwLCBpdCBpcyBjb2VyY2VkIGludG8gYSBzdHJpbmcgYW5kIGFwcGVuZGVkXG4gIC8vIE90aGVyd2lzZSwgdGhlIGVtcHR5IHN0cmluZyBpcyBhcHBlbmRlZFxuICBhcHBlbmQ6IGZ1bmN0aW9uIGFwcGVuZCgpIHtcbiAgICBpZiAodGhpcy5pc0lubGluZSgpKSB7XG4gICAgICB0aGlzLnJlcGxhY2VTdGFjayhmdW5jdGlvbiAoY3VycmVudCkge1xuICAgICAgICByZXR1cm4gWycgIT0gbnVsbCA/ICcsIGN1cnJlbnQsICcgOiBcIlwiJ107XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5wdXNoU291cmNlKHRoaXMuYXBwZW5kVG9CdWZmZXIodGhpcy5wb3BTdGFjaygpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsb2NhbCA9IHRoaXMucG9wU3RhY2soKTtcbiAgICAgIHRoaXMucHVzaFNvdXJjZShbJ2lmICgnLCBsb2NhbCwgJyAhPSBudWxsKSB7ICcsIHRoaXMuYXBwZW5kVG9CdWZmZXIobG9jYWwsIHVuZGVmaW5lZCwgdHJ1ZSksICcgfSddKTtcbiAgICAgIGlmICh0aGlzLmVudmlyb25tZW50LmlzU2ltcGxlKSB7XG4gICAgICAgIHRoaXMucHVzaFNvdXJjZShbJ2Vsc2UgeyAnLCB0aGlzLmFwcGVuZFRvQnVmZmVyKFwiJydcIiwgdW5kZWZpbmVkLCB0cnVlKSwgJyB9J10pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvLyBbYXBwZW5kRXNjYXBlZF1cbiAgLy9cbiAgLy8gT24gc3RhY2ssIGJlZm9yZTogdmFsdWUsIC4uLlxuICAvLyBPbiBzdGFjaywgYWZ0ZXI6IC4uLlxuICAvL1xuICAvLyBFc2NhcGUgYHZhbHVlYCBhbmQgYXBwZW5kIGl0IHRvIHRoZSBidWZmZXJcbiAgYXBwZW5kRXNjYXBlZDogZnVuY3Rpb24gYXBwZW5kRXNjYXBlZCgpIHtcbiAgICB0aGlzLnB1c2hTb3VyY2UodGhpcy5hcHBlbmRUb0J1ZmZlcihbdGhpcy5hbGlhc2FibGUoJ2NvbnRhaW5lci5lc2NhcGVFeHByZXNzaW9uJyksICcoJywgdGhpcy5wb3BTdGFjaygpLCAnKSddKSk7XG4gIH0sXG5cbiAgLy8gW2dldENvbnRleHRdXG4gIC8vXG4gIC8vIE9uIHN0YWNrLCBiZWZvcmU6IC4uLlxuICAvLyBPbiBzdGFjaywgYWZ0ZXI6IC4uLlxuICAvLyBDb21waWxlciB2YWx1ZSwgYWZ0ZXI6IGxhc3RDb250ZXh0PWRlcHRoXG4gIC8vXG4gIC8vIFNldCB0aGUgdmFsdWUgb2YgdGhlIGBsYXN0Q29udGV4dGAgY29tcGlsZXIgdmFsdWUgdG8gdGhlIGRlcHRoXG4gIGdldENvbnRleHQ6IGZ1bmN0aW9uIGdldENvbnRleHQoZGVwdGgpIHtcbiAgICB0aGlzLmxhc3RDb250ZXh0ID0gZGVwdGg7XG4gIH0sXG5cbiAgLy8gW3B1c2hDb250ZXh0XVxuICAvL1xuICAvLyBPbiBzdGFjaywgYmVmb3JlOiAuLi5cbiAgLy8gT24gc3RhY2ssIGFmdGVyOiBjdXJyZW50Q29udGV4dCwgLi4uXG4gIC8vXG4gIC8vIFB1c2hlcyB0aGUgdmFsdWUgb2YgdGhlIGN1cnJlbnQgY29udGV4dCBvbnRvIHRoZSBzdGFjay5cbiAgcHVzaENvbnRleHQ6IGZ1bmN0aW9uIHB1c2hDb250ZXh0KCkge1xuICAgIHRoaXMucHVzaFN0YWNrTGl0ZXJhbCh0aGlzLmNvbnRleHROYW1lKHRoaXMubGFzdENvbnRleHQpKTtcbiAgfSxcblxuICAvLyBbbG9va3VwT25Db250ZXh0XVxuICAvL1xuICAvLyBPbiBzdGFjaywgYmVmb3JlOiAuLi5cbiAgLy8gT24gc3RhY2ssIGFmdGVyOiBjdXJyZW50Q29udGV4dFtuYW1lXSwgLi4uXG4gIC8vXG4gIC8vIExvb2tzIHVwIHRoZSB2YWx1ZSBvZiBgbmFtZWAgb24gdGhlIGN1cnJlbnQgY29udGV4dCBhbmQgcHVzaGVzXG4gIC8vIGl0IG9udG8gdGhlIHN0YWNrLlxuICBsb29rdXBPbkNvbnRleHQ6IGZ1bmN0aW9uIGxvb2t1cE9uQ29udGV4dChwYXJ0cywgZmFsc3ksIHN0cmljdCwgc2NvcGVkKSB7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgaWYgKCFzY29wZWQgJiYgdGhpcy5vcHRpb25zLmNvbXBhdCAmJiAhdGhpcy5sYXN0Q29udGV4dCkge1xuICAgICAgLy8gVGhlIGRlcHRoZWQgcXVlcnkgaXMgZXhwZWN0ZWQgdG8gaGFuZGxlIHRoZSB1bmRlZmluZWQgbG9naWMgZm9yIHRoZSByb290IGxldmVsIHRoYXRcbiAgICAgIC8vIGlzIGltcGxlbWVudGVkIGJlbG93LCBzbyB3ZSBldmFsdWF0ZSB0aGF0IGRpcmVjdGx5IGluIGNvbXBhdCBtb2RlXG4gICAgICB0aGlzLnB1c2godGhpcy5kZXB0aGVkTG9va3VwKHBhcnRzW2krK10pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXNoQ29udGV4dCgpO1xuICAgIH1cblxuICAgIHRoaXMucmVzb2x2ZVBhdGgoJ2NvbnRleHQnLCBwYXJ0cywgaSwgZmFsc3ksIHN0cmljdCk7XG4gIH0sXG5cbiAgLy8gW2xvb2t1cEJsb2NrUGFyYW1dXG4gIC8vXG4gIC8vIE9uIHN0YWNrLCBiZWZvcmU6IC4uLlxuICAvLyBPbiBzdGFjaywgYWZ0ZXI6IGJsb2NrUGFyYW1bbmFtZV0sIC4uLlxuICAvL1xuICAvLyBMb29rcyB1cCB0aGUgdmFsdWUgb2YgYHBhcnRzYCBvbiB0aGUgZ2l2ZW4gYmxvY2sgcGFyYW0gYW5kIHB1c2hlc1xuICAvLyBpdCBvbnRvIHRoZSBzdGFjay5cbiAgbG9va3VwQmxvY2tQYXJhbTogZnVuY3Rpb24gbG9va3VwQmxvY2tQYXJhbShibG9ja1BhcmFtSWQsIHBhcnRzKSB7XG4gICAgdGhpcy51c2VCbG9ja1BhcmFtcyA9IHRydWU7XG5cbiAgICB0aGlzLnB1c2goWydibG9ja1BhcmFtc1snLCBibG9ja1BhcmFtSWRbMF0sICddWycsIGJsb2NrUGFyYW1JZFsxXSwgJ10nXSk7XG4gICAgdGhpcy5yZXNvbHZlUGF0aCgnY29udGV4dCcsIHBhcnRzLCAxKTtcbiAgfSxcblxuICAvLyBbbG9va3VwRGF0YV1cbiAgLy9cbiAgLy8gT24gc3RhY2ssIGJlZm9yZTogLi4uXG4gIC8vIE9uIHN0YWNrLCBhZnRlcjogZGF0YSwgLi4uXG4gIC8vXG4gIC8vIFB1c2ggdGhlIGRhdGEgbG9va3VwIG9wZXJhdG9yXG4gIGxvb2t1cERhdGE6IGZ1bmN0aW9uIGxvb2t1cERhdGEoZGVwdGgsIHBhcnRzLCBzdHJpY3QpIHtcbiAgICBpZiAoIWRlcHRoKSB7XG4gICAgICB0aGlzLnB1c2hTdGFja0xpdGVyYWwoJ2RhdGEnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXNoU3RhY2tMaXRlcmFsKCdjb250YWluZXIuZGF0YShkYXRhLCAnICsgZGVwdGggKyAnKScpO1xuICAgIH1cblxuICAgIHRoaXMucmVzb2x2ZVBhdGgoJ2RhdGEnLCBwYXJ0cywgMCwgdHJ1ZSwgc3RyaWN0KTtcbiAgfSxcblxuICByZXNvbHZlUGF0aDogZnVuY3Rpb24gcmVzb2x2ZVBhdGgodHlwZSwgcGFydHMsIGksIGZhbHN5LCBzdHJpY3QpIHtcbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuc3RyaWN0IHx8IHRoaXMub3B0aW9ucy5hc3N1bWVPYmplY3RzKSB7XG4gICAgICB0aGlzLnB1c2goc3RyaWN0TG9va3VwKHRoaXMub3B0aW9ucy5zdHJpY3QgJiYgc3RyaWN0LCB0aGlzLCBwYXJ0cywgdHlwZSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsZW4gPSBwYXJ0cy5sZW5ndGg7XG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tbG9vcC1mdW5jICovXG4gICAgICB0aGlzLnJlcGxhY2VTdGFjayhmdW5jdGlvbiAoY3VycmVudCkge1xuICAgICAgICB2YXIgbG9va3VwID0gX3RoaXMubmFtZUxvb2t1cChjdXJyZW50LCBwYXJ0c1tpXSwgdHlwZSk7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gZW5zdXJlIHRoYXQgemVybyBhbmQgZmFsc2UgYXJlIGhhbmRsZWQgcHJvcGVybHkgaWYgdGhlIGNvbnRleHQgKGZhbHN5IGZsYWcpXG4gICAgICAgIC8vIG5lZWRzIHRvIGhhdmUgdGhlIHNwZWNpYWwgaGFuZGxpbmcgZm9yIHRoZXNlIHZhbHVlcy5cbiAgICAgICAgaWYgKCFmYWxzeSkge1xuICAgICAgICAgIHJldHVybiBbJyAhPSBudWxsID8gJywgbG9va3VwLCAnIDogJywgY3VycmVudF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIGNhbiB1c2UgZ2VuZXJpYyBmYWxzeSBoYW5kbGluZ1xuICAgICAgICAgIHJldHVybiBbJyAmJiAnLCBsb29rdXBdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG4gICAgfVxuICB9LFxuXG4gIC8vIFtyZXNvbHZlUG9zc2libGVMYW1iZGFdXG4gIC8vXG4gIC8vIE9uIHN0YWNrLCBiZWZvcmU6IHZhbHVlLCAuLi5cbiAgLy8gT24gc3RhY2ssIGFmdGVyOiByZXNvbHZlZCB2YWx1ZSwgLi4uXG4gIC8vXG4gIC8vIElmIHRoZSBgdmFsdWVgIGlzIGEgbGFtYmRhLCByZXBsYWNlIGl0IG9uIHRoZSBzdGFjayBieVxuICAvLyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBsYW1iZGFcbiAgcmVzb2x2ZVBvc3NpYmxlTGFtYmRhOiBmdW5jdGlvbiByZXNvbHZlUG9zc2libGVMYW1iZGEoKSB7XG4gICAgdGhpcy5wdXNoKFt0aGlzLmFsaWFzYWJsZSgnY29udGFpbmVyLmxhbWJkYScpLCAnKCcsIHRoaXMucG9wU3RhY2soKSwgJywgJywgdGhpcy5jb250ZXh0TmFtZSgwKSwgJyknXSk7XG4gIH0sXG5cbiAgLy8gW3B1c2hTdHJpbmdQYXJhbV1cbiAgLy9cbiAgLy8gT24gc3RhY2ssIGJlZm9yZTogLi4uXG4gIC8vIE9uIHN0YWNrLCBhZnRlcjogc3RyaW5nLCBjdXJyZW50Q29udGV4dCwgLi4uXG4gIC8vXG4gIC8vIFRoaXMgb3Bjb2RlIGlzIGRlc2lnbmVkIGZvciB1c2UgaW4gc3RyaW5nIG1vZGUsIHdoaWNoXG4gIC8vIHByb3ZpZGVzIHRoZSBzdHJpbmcgdmFsdWUgb2YgYSBwYXJhbWV0ZXIgYWxvbmcgd2l0aCBpdHNcbiAgLy8gZGVwdGggcmF0aGVyIHRoYW4gcmVzb2x2aW5nIGl0IGltbWVkaWF0ZWx5LlxuICBwdXNoU3RyaW5nUGFyYW06IGZ1bmN0aW9uIHB1c2hTdHJpbmdQYXJhbShzdHJpbmcsIHR5cGUpIHtcbiAgICB0aGlzLnB1c2hDb250ZXh0KCk7XG4gICAgdGhpcy5wdXNoU3RyaW5nKHR5cGUpO1xuXG4gICAgLy8gSWYgaXQncyBhIHN1YmV4cHJlc3Npb24sIHRoZSBzdHJpbmcgcmVzdWx0XG4gICAgLy8gd2lsbCBiZSBwdXNoZWQgYWZ0ZXIgdGhpcyBvcGNvZGUuXG4gICAgaWYgKHR5cGUgIT09ICdTdWJFeHByZXNzaW9uJykge1xuICAgICAgaWYgKHR5cGVvZiBzdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMucHVzaFN0cmluZyhzdHJpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wdXNoU3RhY2tMaXRlcmFsKHN0cmluZyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGVtcHR5SGFzaDogZnVuY3Rpb24gZW1wdHlIYXNoKG9taXRFbXB0eSkge1xuICAgIGlmICh0aGlzLnRyYWNrSWRzKSB7XG4gICAgICB0aGlzLnB1c2goJ3t9Jyk7IC8vIGhhc2hJZHNcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RyaW5nUGFyYW1zKSB7XG4gICAgICB0aGlzLnB1c2goJ3t9Jyk7IC8vIGhhc2hDb250ZXh0c1xuICAgICAgdGhpcy5wdXNoKCd7fScpOyAvLyBoYXNoVHlwZXNcbiAgICB9XG4gICAgdGhpcy5wdXNoU3RhY2tMaXRlcmFsKG9taXRFbXB0eSA/ICd1bmRlZmluZWQnIDogJ3t9Jyk7XG4gIH0sXG4gIHB1c2hIYXNoOiBmdW5jdGlvbiBwdXNoSGFzaCgpIHtcbiAgICBpZiAodGhpcy5oYXNoKSB7XG4gICAgICB0aGlzLmhhc2hlcy5wdXNoKHRoaXMuaGFzaCk7XG4gICAgfVxuICAgIHRoaXMuaGFzaCA9IHsgdmFsdWVzOiBbXSwgdHlwZXM6IFtdLCBjb250ZXh0czogW10sIGlkczogW10gfTtcbiAgfSxcbiAgcG9wSGFzaDogZnVuY3Rpb24gcG9wSGFzaCgpIHtcbiAgICB2YXIgaGFzaCA9IHRoaXMuaGFzaDtcbiAgICB0aGlzLmhhc2ggPSB0aGlzLmhhc2hlcy5wb3AoKTtcblxuICAgIGlmICh0aGlzLnRyYWNrSWRzKSB7XG4gICAgICB0aGlzLnB1c2godGhpcy5vYmplY3RMaXRlcmFsKGhhc2guaWRzKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0cmluZ1BhcmFtcykge1xuICAgICAgdGhpcy5wdXNoKHRoaXMub2JqZWN0TGl0ZXJhbChoYXNoLmNvbnRleHRzKSk7XG4gICAgICB0aGlzLnB1c2godGhpcy5vYmplY3RMaXRlcmFsKGhhc2gudHlwZXMpKTtcbiAgICB9XG5cbiAgICB0aGlzLnB1c2godGhpcy5vYmplY3RMaXRlcmFsKGhhc2gudmFsdWVzKSk7XG4gIH0sXG5cbiAgLy8gW3B1c2hTdHJpbmddXG4gIC8vXG4gIC8vIE9uIHN0YWNrLCBiZWZvcmU6IC4uLlxuICAvLyBPbiBzdGFjaywgYWZ0ZXI6IHF1b3RlZFN0cmluZyhzdHJpbmcpLCAuLi5cbiAgLy9cbiAgLy8gUHVzaCBhIHF1b3RlZCB2ZXJzaW9uIG9mIGBzdHJpbmdgIG9udG8gdGhlIHN0YWNrXG4gIHB1c2hTdHJpbmc6IGZ1bmN0aW9uIHB1c2hTdHJpbmcoc3RyaW5nKSB7XG4gICAgdGhpcy5wdXNoU3RhY2tMaXRlcmFsKHRoaXMucXVvdGVkU3RyaW5nKHN0cmluZykpO1xuICB9LFxuXG4gIC8vIFtwdXNoTGl0ZXJhbF1cbiAgLy9cbiAgLy8gT24gc3RhY2ssIGJlZm9yZTogLi4uXG4gIC8vIE9uIHN0YWNrLCBhZnRlcjogdmFsdWUsIC4uLlxuICAvL1xuICAvLyBQdXNoZXMgYSB2YWx1ZSBvbnRvIHRoZSBzdGFjay4gVGhpcyBvcGVyYXRpb24gcHJldmVudHNcbiAgLy8gdGhlIGNvbXBpbGVyIGZyb20gY3JlYXRpbmcgYSB0ZW1wb3JhcnkgdmFyaWFibGUgdG8gaG9sZFxuICAvLyBpdC5cbiAgcHVzaExpdGVyYWw6IGZ1bmN0aW9uIHB1c2hMaXRlcmFsKHZhbHVlKSB7XG4gICAgdGhpcy5wdXNoU3RhY2tMaXRlcmFsKHZhbHVlKTtcbiAgfSxcblxuICAvLyBbcHVzaFByb2dyYW1dXG4gIC8vXG4gIC8vIE9uIHN0YWNrLCBiZWZvcmU6IC4uLlxuICAvLyBPbiBzdGFjaywgYWZ0ZXI6IHByb2dyYW0oZ3VpZCksIC4uLlxuICAvL1xuICAvLyBQdXNoIGEgcHJvZ3JhbSBleHByZXNzaW9uIG9udG8gdGhlIHN0YWNrLiBUaGlzIHRha2VzXG4gIC8vIGEgY29tcGlsZS10aW1lIGd1aWQgYW5kIGNvbnZlcnRzIGl0IGludG8gYSBydW50aW1lLWFjY2Vzc2libGVcbiAgLy8gZXhwcmVzc2lvbi5cbiAgcHVzaFByb2dyYW06IGZ1bmN0aW9uIHB1c2hQcm9ncmFtKGd1aWQpIHtcbiAgICBpZiAoZ3VpZCAhPSBudWxsKSB7XG4gICAgICB0aGlzLnB1c2hTdGFja0xpdGVyYWwodGhpcy5wcm9ncmFtRXhwcmVzc2lvbihndWlkKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHVzaFN0YWNrTGl0ZXJhbChudWxsKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gW3JlZ2lzdGVyRGVjb3JhdG9yXVxuICAvL1xuICAvLyBPbiBzdGFjaywgYmVmb3JlOiBoYXNoLCBwcm9ncmFtLCBwYXJhbXMuLi4sIC4uLlxuICAvLyBPbiBzdGFjaywgYWZ0ZXI6IC4uLlxuICAvL1xuICAvLyBQb3BzIG9mZiB0aGUgZGVjb3JhdG9yJ3MgcGFyYW1ldGVycywgaW52b2tlcyB0aGUgZGVjb3JhdG9yLFxuICAvLyBhbmQgaW5zZXJ0cyB0aGUgZGVjb3JhdG9yIGludG8gdGhlIGRlY29yYXRvcnMgbGlzdC5cbiAgcmVnaXN0ZXJEZWNvcmF0b3I6IGZ1bmN0aW9uIHJlZ2lzdGVyRGVjb3JhdG9yKHBhcmFtU2l6ZSwgbmFtZSkge1xuICAgIHZhciBmb3VuZERlY29yYXRvciA9IHRoaXMubmFtZUxvb2t1cCgnZGVjb3JhdG9ycycsIG5hbWUsICdkZWNvcmF0b3InKSxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMuc2V0dXBIZWxwZXJBcmdzKG5hbWUsIHBhcmFtU2l6ZSk7XG5cbiAgICB0aGlzLmRlY29yYXRvcnMucHVzaChbJ2ZuID0gJywgdGhpcy5kZWNvcmF0b3JzLmZ1bmN0aW9uQ2FsbChmb3VuZERlY29yYXRvciwgJycsIFsnZm4nLCAncHJvcHMnLCAnY29udGFpbmVyJywgb3B0aW9uc10pLCAnIHx8IGZuOyddKTtcbiAgfSxcblxuICAvLyBbaW52b2tlSGVscGVyXVxuICAvL1xuICAvLyBPbiBzdGFjaywgYmVmb3JlOiBoYXNoLCBpbnZlcnNlLCBwcm9ncmFtLCBwYXJhbXMuLi4sIC4uLlxuICAvLyBPbiBzdGFjaywgYWZ0ZXI6IHJlc3VsdCBvZiBoZWxwZXIgaW52b2NhdGlvblxuICAvL1xuICAvLyBQb3BzIG9mZiB0aGUgaGVscGVyJ3MgcGFyYW1ldGVycywgaW52b2tlcyB0aGUgaGVscGVyLFxuICAvLyBhbmQgcHVzaGVzIHRoZSBoZWxwZXIncyByZXR1cm4gdmFsdWUgb250byB0aGUgc3RhY2suXG4gIC8vXG4gIC8vIElmIHRoZSBoZWxwZXIgaXMgbm90IGZvdW5kLCBgaGVscGVyTWlzc2luZ2AgaXMgY2FsbGVkLlxuICBpbnZva2VIZWxwZXI6IGZ1bmN0aW9uIGludm9rZUhlbHBlcihwYXJhbVNpemUsIG5hbWUsIGlzU2ltcGxlKSB7XG4gICAgdmFyIG5vbkhlbHBlciA9IHRoaXMucG9wU3RhY2soKSxcbiAgICAgICAgaGVscGVyID0gdGhpcy5zZXR1cEhlbHBlcihwYXJhbVNpemUsIG5hbWUpLFxuICAgICAgICBzaW1wbGUgPSBpc1NpbXBsZSA/IFtoZWxwZXIubmFtZSwgJyB8fCAnXSA6ICcnO1xuXG4gICAgdmFyIGxvb2t1cCA9IFsnKCddLmNvbmNhdChzaW1wbGUsIG5vbkhlbHBlcik7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICBsb29rdXAucHVzaCgnIHx8ICcsIHRoaXMuYWxpYXNhYmxlKCdoZWxwZXJzLmhlbHBlck1pc3NpbmcnKSk7XG4gICAgfVxuICAgIGxvb2t1cC5wdXNoKCcpJyk7XG5cbiAgICB0aGlzLnB1c2godGhpcy5zb3VyY2UuZnVuY3Rpb25DYWxsKGxvb2t1cCwgJ2NhbGwnLCBoZWxwZXIuY2FsbFBhcmFtcykpO1xuICB9LFxuXG4gIC8vIFtpbnZva2VLbm93bkhlbHBlcl1cbiAgLy9cbiAgLy8gT24gc3RhY2ssIGJlZm9yZTogaGFzaCwgaW52ZXJzZSwgcHJvZ3JhbSwgcGFyYW1zLi4uLCAuLi5cbiAgLy8gT24gc3RhY2ssIGFmdGVyOiByZXN1bHQgb2YgaGVscGVyIGludm9jYXRpb25cbiAgLy9cbiAgLy8gVGhpcyBvcGVyYXRpb24gaXMgdXNlZCB3aGVuIHRoZSBoZWxwZXIgaXMga25vd24gdG8gZXhpc3QsXG4gIC8vIHNvIGEgYGhlbHBlck1pc3NpbmdgIGZhbGxiYWNrIGlzIG5vdCByZXF1aXJlZC5cbiAgaW52b2tlS25vd25IZWxwZXI6IGZ1bmN0aW9uIGludm9rZUtub3duSGVscGVyKHBhcmFtU2l6ZSwgbmFtZSkge1xuICAgIHZhciBoZWxwZXIgPSB0aGlzLnNldHVwSGVscGVyKHBhcmFtU2l6ZSwgbmFtZSk7XG4gICAgdGhpcy5wdXNoKHRoaXMuc291cmNlLmZ1bmN0aW9uQ2FsbChoZWxwZXIubmFtZSwgJ2NhbGwnLCBoZWxwZXIuY2FsbFBhcmFtcykpO1xuICB9LFxuXG4gIC8vIFtpbnZva2VBbWJpZ3VvdXNdXG4gIC8vXG4gIC8vIE9uIHN0YWNrLCBiZWZvcmU6IGhhc2gsIGludmVyc2UsIHByb2dyYW0sIHBhcmFtcy4uLiwgLi4uXG4gIC8vIE9uIHN0YWNrLCBhZnRlcjogcmVzdWx0IG9mIGRpc2FtYmlndWF0aW9uXG4gIC8vXG4gIC8vIFRoaXMgb3BlcmF0aW9uIGlzIHVzZWQgd2hlbiBhbiBleHByZXNzaW9uIGxpa2UgYHt7Zm9vfX1gXG4gIC8vIGlzIHByb3ZpZGVkLCBidXQgd2UgZG9uJ3Qga25vdyBhdCBjb21waWxlLXRpbWUgd2hldGhlciBpdFxuICAvLyBpcyBhIGhlbHBlciBvciBhIHBhdGguXG4gIC8vXG4gIC8vIFRoaXMgb3BlcmF0aW9uIGVtaXRzIG1vcmUgY29kZSB0aGFuIHRoZSBvdGhlciBvcHRpb25zLFxuICAvLyBhbmQgY2FuIGJlIGF2b2lkZWQgYnkgcGFzc2luZyB0aGUgYGtub3duSGVscGVyc2AgYW5kXG4gIC8vIGBrbm93bkhlbHBlcnNPbmx5YCBmbGFncyBhdCBjb21waWxlLXRpbWUuXG4gIGludm9rZUFtYmlndW91czogZnVuY3Rpb24gaW52b2tlQW1iaWd1b3VzKG5hbWUsIGhlbHBlckNhbGwpIHtcbiAgICB0aGlzLnVzZVJlZ2lzdGVyKCdoZWxwZXInKTtcblxuICAgIHZhciBub25IZWxwZXIgPSB0aGlzLnBvcFN0YWNrKCk7XG5cbiAgICB0aGlzLmVtcHR5SGFzaCgpO1xuICAgIHZhciBoZWxwZXIgPSB0aGlzLnNldHVwSGVscGVyKDAsIG5hbWUsIGhlbHBlckNhbGwpO1xuXG4gICAgdmFyIGhlbHBlck5hbWUgPSB0aGlzLmxhc3RIZWxwZXIgPSB0aGlzLm5hbWVMb29rdXAoJ2hlbHBlcnMnLCBuYW1lLCAnaGVscGVyJyk7XG5cbiAgICB2YXIgbG9va3VwID0gWycoJywgJyhoZWxwZXIgPSAnLCBoZWxwZXJOYW1lLCAnIHx8ICcsIG5vbkhlbHBlciwgJyknXTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgIGxvb2t1cFswXSA9ICcoaGVscGVyID0gJztcbiAgICAgIGxvb2t1cC5wdXNoKCcgIT0gbnVsbCA/IGhlbHBlciA6ICcsIHRoaXMuYWxpYXNhYmxlKCdoZWxwZXJzLmhlbHBlck1pc3NpbmcnKSk7XG4gICAgfVxuXG4gICAgdGhpcy5wdXNoKFsnKCcsIGxvb2t1cCwgaGVscGVyLnBhcmFtc0luaXQgPyBbJyksKCcsIGhlbHBlci5wYXJhbXNJbml0XSA6IFtdLCAnKSwnLCAnKHR5cGVvZiBoZWxwZXIgPT09ICcsIHRoaXMuYWxpYXNhYmxlKCdcImZ1bmN0aW9uXCInKSwgJyA/ICcsIHRoaXMuc291cmNlLmZ1bmN0aW9uQ2FsbCgnaGVscGVyJywgJ2NhbGwnLCBoZWxwZXIuY2FsbFBhcmFtcyksICcgOiBoZWxwZXIpKSddKTtcbiAgfSxcblxuICAvLyBbaW52b2tlUGFydGlhbF1cbiAgLy9cbiAgLy8gT24gc3RhY2ssIGJlZm9yZTogY29udGV4dCwgLi4uXG4gIC8vIE9uIHN0YWNrIGFmdGVyOiByZXN1bHQgb2YgcGFydGlhbCBpbnZvY2F0aW9uXG4gIC8vXG4gIC8vIFRoaXMgb3BlcmF0aW9uIHBvcHMgb2ZmIGEgY29udGV4dCwgaW52b2tlcyBhIHBhcnRpYWwgd2l0aCB0aGF0IGNvbnRleHQsXG4gIC8vIGFuZCBwdXNoZXMgdGhlIHJlc3VsdCBvZiB0aGUgaW52b2NhdGlvbiBiYWNrLlxuICBpbnZva2VQYXJ0aWFsOiBmdW5jdGlvbiBpbnZva2VQYXJ0aWFsKGlzRHluYW1pYywgbmFtZSwgaW5kZW50KSB7XG4gICAgdmFyIHBhcmFtcyA9IFtdLFxuICAgICAgICBvcHRpb25zID0gdGhpcy5zZXR1cFBhcmFtcyhuYW1lLCAxLCBwYXJhbXMpO1xuXG4gICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgbmFtZSA9IHRoaXMucG9wU3RhY2soKTtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLm5hbWU7XG4gICAgfVxuXG4gICAgaWYgKGluZGVudCkge1xuICAgICAgb3B0aW9ucy5pbmRlbnQgPSBKU09OLnN0cmluZ2lmeShpbmRlbnQpO1xuICAgIH1cbiAgICBvcHRpb25zLmhlbHBlcnMgPSAnaGVscGVycyc7XG4gICAgb3B0aW9ucy5wYXJ0aWFscyA9ICdwYXJ0aWFscyc7XG4gICAgb3B0aW9ucy5kZWNvcmF0b3JzID0gJ2NvbnRhaW5lci5kZWNvcmF0b3JzJztcblxuICAgIGlmICghaXNEeW5hbWljKSB7XG4gICAgICBwYXJhbXMudW5zaGlmdCh0aGlzLm5hbWVMb29rdXAoJ3BhcnRpYWxzJywgbmFtZSwgJ3BhcnRpYWwnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmFtcy51bnNoaWZ0KG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuY29tcGF0KSB7XG4gICAgICBvcHRpb25zLmRlcHRocyA9ICdkZXB0aHMnO1xuICAgIH1cbiAgICBvcHRpb25zID0gdGhpcy5vYmplY3RMaXRlcmFsKG9wdGlvbnMpO1xuICAgIHBhcmFtcy5wdXNoKG9wdGlvbnMpO1xuXG4gICAgdGhpcy5wdXNoKHRoaXMuc291cmNlLmZ1bmN0aW9uQ2FsbCgnY29udGFpbmVyLmludm9rZVBhcnRpYWwnLCAnJywgcGFyYW1zKSk7XG4gIH0sXG5cbiAgLy8gW2Fzc2lnblRvSGFzaF1cbiAgLy9cbiAgLy8gT24gc3RhY2ssIGJlZm9yZTogdmFsdWUsIC4uLiwgaGFzaCwgLi4uXG4gIC8vIE9uIHN0YWNrLCBhZnRlcjogLi4uLCBoYXNoLCAuLi5cbiAgLy9cbiAgLy8gUG9wcyBhIHZhbHVlIG9mZiB0aGUgc3RhY2sgYW5kIGFzc2lnbnMgaXQgdG8gdGhlIGN1cnJlbnQgaGFzaFxuICBhc3NpZ25Ub0hhc2g6IGZ1bmN0aW9uIGFzc2lnblRvSGFzaChrZXkpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnBvcFN0YWNrKCksXG4gICAgICAgIGNvbnRleHQgPSB1bmRlZmluZWQsXG4gICAgICAgIHR5cGUgPSB1bmRlZmluZWQsXG4gICAgICAgIGlkID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKHRoaXMudHJhY2tJZHMpIHtcbiAgICAgIGlkID0gdGhpcy5wb3BTdGFjaygpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdHJpbmdQYXJhbXMpIHtcbiAgICAgIHR5cGUgPSB0aGlzLnBvcFN0YWNrKCk7XG4gICAgICBjb250ZXh0ID0gdGhpcy5wb3BTdGFjaygpO1xuICAgIH1cblxuICAgIHZhciBoYXNoID0gdGhpcy5oYXNoO1xuICAgIGlmIChjb250ZXh0KSB7XG4gICAgICBoYXNoLmNvbnRleHRzW2tleV0gPSBjb250ZXh0O1xuICAgIH1cbiAgICBpZiAodHlwZSkge1xuICAgICAgaGFzaC50eXBlc1trZXldID0gdHlwZTtcbiAgICB9XG4gICAgaWYgKGlkKSB7XG4gICAgICBoYXNoLmlkc1trZXldID0gaWQ7XG4gICAgfVxuICAgIGhhc2gudmFsdWVzW2tleV0gPSB2YWx1ZTtcbiAgfSxcblxuICBwdXNoSWQ6IGZ1bmN0aW9uIHB1c2hJZCh0eXBlLCBuYW1lLCBjaGlsZCkge1xuICAgIGlmICh0eXBlID09PSAnQmxvY2tQYXJhbScpIHtcbiAgICAgIHRoaXMucHVzaFN0YWNrTGl0ZXJhbCgnYmxvY2tQYXJhbXNbJyArIG5hbWVbMF0gKyAnXS5wYXRoWycgKyBuYW1lWzFdICsgJ10nICsgKGNoaWxkID8gJyArICcgKyBKU09OLnN0cmluZ2lmeSgnLicgKyBjaGlsZCkgOiAnJykpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1BhdGhFeHByZXNzaW9uJykge1xuICAgICAgdGhpcy5wdXNoU3RyaW5nKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1N1YkV4cHJlc3Npb24nKSB7XG4gICAgICB0aGlzLnB1c2hTdGFja0xpdGVyYWwoJ3RydWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXNoU3RhY2tMaXRlcmFsKCdudWxsJyk7XG4gICAgfVxuICB9LFxuXG4gIC8vIEhFTFBFUlNcblxuICBjb21waWxlcjogSmF2YVNjcmlwdENvbXBpbGVyLFxuXG4gIGNvbXBpbGVDaGlsZHJlbjogZnVuY3Rpb24gY29tcGlsZUNoaWxkcmVuKGVudmlyb25tZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gZW52aXJvbm1lbnQuY2hpbGRyZW4sXG4gICAgICAgIGNoaWxkID0gdW5kZWZpbmVkLFxuICAgICAgICBjb21waWxlciA9IHVuZGVmaW5lZDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgY29tcGlsZXIgPSBuZXcgdGhpcy5jb21waWxlcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcblxuICAgICAgdmFyIGV4aXN0aW5nID0gdGhpcy5tYXRjaEV4aXN0aW5nUHJvZ3JhbShjaGlsZCk7XG5cbiAgICAgIGlmIChleGlzdGluZyA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5wcm9ncmFtcy5wdXNoKCcnKTsgLy8gUGxhY2Vob2xkZXIgdG8gcHJldmVudCBuYW1lIGNvbmZsaWN0cyBmb3IgbmVzdGVkIGNoaWxkcmVuXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuY29udGV4dC5wcm9ncmFtcy5sZW5ndGg7XG4gICAgICAgIGNoaWxkLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIGNoaWxkLm5hbWUgPSAncHJvZ3JhbScgKyBpbmRleDtcbiAgICAgICAgdGhpcy5jb250ZXh0LnByb2dyYW1zW2luZGV4XSA9IGNvbXBpbGVyLmNvbXBpbGUoY2hpbGQsIG9wdGlvbnMsIHRoaXMuY29udGV4dCwgIXRoaXMucHJlY29tcGlsZSk7XG4gICAgICAgIHRoaXMuY29udGV4dC5kZWNvcmF0b3JzW2luZGV4XSA9IGNvbXBpbGVyLmRlY29yYXRvcnM7XG4gICAgICAgIHRoaXMuY29udGV4dC5lbnZpcm9ubWVudHNbaW5kZXhdID0gY2hpbGQ7XG5cbiAgICAgICAgdGhpcy51c2VEZXB0aHMgPSB0aGlzLnVzZURlcHRocyB8fCBjb21waWxlci51c2VEZXB0aHM7XG4gICAgICAgIHRoaXMudXNlQmxvY2tQYXJhbXMgPSB0aGlzLnVzZUJsb2NrUGFyYW1zIHx8IGNvbXBpbGVyLnVzZUJsb2NrUGFyYW1zO1xuICAgICAgICBjaGlsZC51c2VEZXB0aHMgPSB0aGlzLnVzZURlcHRocztcbiAgICAgICAgY2hpbGQudXNlQmxvY2tQYXJhbXMgPSB0aGlzLnVzZUJsb2NrUGFyYW1zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGQuaW5kZXggPSBleGlzdGluZy5pbmRleDtcbiAgICAgICAgY2hpbGQubmFtZSA9ICdwcm9ncmFtJyArIGV4aXN0aW5nLmluZGV4O1xuXG4gICAgICAgIHRoaXMudXNlRGVwdGhzID0gdGhpcy51c2VEZXB0aHMgfHwgZXhpc3RpbmcudXNlRGVwdGhzO1xuICAgICAgICB0aGlzLnVzZUJsb2NrUGFyYW1zID0gdGhpcy51c2VCbG9ja1BhcmFtcyB8fCBleGlzdGluZy51c2VCbG9ja1BhcmFtcztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1hdGNoRXhpc3RpbmdQcm9ncmFtOiBmdW5jdGlvbiBtYXRjaEV4aXN0aW5nUHJvZ3JhbShjaGlsZCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNvbnRleHQuZW52aXJvbm1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgZW52aXJvbm1lbnQgPSB0aGlzLmNvbnRleHQuZW52aXJvbm1lbnRzW2ldO1xuICAgICAgaWYgKGVudmlyb25tZW50ICYmIGVudmlyb25tZW50LmVxdWFscyhjaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50O1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBwcm9ncmFtRXhwcmVzc2lvbjogZnVuY3Rpb24gcHJvZ3JhbUV4cHJlc3Npb24oZ3VpZCkge1xuICAgIHZhciBjaGlsZCA9IHRoaXMuZW52aXJvbm1lbnQuY2hpbGRyZW5bZ3VpZF0sXG4gICAgICAgIHByb2dyYW1QYXJhbXMgPSBbY2hpbGQuaW5kZXgsICdkYXRhJywgY2hpbGQuYmxvY2tQYXJhbXNdO1xuXG4gICAgaWYgKHRoaXMudXNlQmxvY2tQYXJhbXMgfHwgdGhpcy51c2VEZXB0aHMpIHtcbiAgICAgIHByb2dyYW1QYXJhbXMucHVzaCgnYmxvY2tQYXJhbXMnKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudXNlRGVwdGhzKSB7XG4gICAgICBwcm9ncmFtUGFyYW1zLnB1c2goJ2RlcHRocycpO1xuICAgIH1cblxuICAgIHJldHVybiAnY29udGFpbmVyLnByb2dyYW0oJyArIHByb2dyYW1QYXJhbXMuam9pbignLCAnKSArICcpJztcbiAgfSxcblxuICB1c2VSZWdpc3RlcjogZnVuY3Rpb24gdXNlUmVnaXN0ZXIobmFtZSkge1xuICAgIGlmICghdGhpcy5yZWdpc3RlcnNbbmFtZV0pIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVnaXN0ZXJzLmxpc3QucHVzaChuYW1lKTtcbiAgICB9XG4gIH0sXG5cbiAgcHVzaDogZnVuY3Rpb24gcHVzaChleHByKSB7XG4gICAgaWYgKCEoZXhwciBpbnN0YW5jZW9mIExpdGVyYWwpKSB7XG4gICAgICBleHByID0gdGhpcy5zb3VyY2Uud3JhcChleHByKTtcbiAgICB9XG5cbiAgICB0aGlzLmlubGluZVN0YWNrLnB1c2goZXhwcik7XG4gICAgcmV0dXJuIGV4cHI7XG4gIH0sXG5cbiAgcHVzaFN0YWNrTGl0ZXJhbDogZnVuY3Rpb24gcHVzaFN0YWNrTGl0ZXJhbChpdGVtKSB7XG4gICAgdGhpcy5wdXNoKG5ldyBMaXRlcmFsKGl0ZW0pKTtcbiAgfSxcblxuICBwdXNoU291cmNlOiBmdW5jdGlvbiBwdXNoU291cmNlKHNvdXJjZSkge1xuICAgIGlmICh0aGlzLnBlbmRpbmdDb250ZW50KSB7XG4gICAgICB0aGlzLnNvdXJjZS5wdXNoKHRoaXMuYXBwZW5kVG9CdWZmZXIodGhpcy5zb3VyY2UucXVvdGVkU3RyaW5nKHRoaXMucGVuZGluZ0NvbnRlbnQpLCB0aGlzLnBlbmRpbmdMb2NhdGlvbikpO1xuICAgICAgdGhpcy5wZW5kaW5nQ29udGVudCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlKSB7XG4gICAgICB0aGlzLnNvdXJjZS5wdXNoKHNvdXJjZSk7XG4gICAgfVxuICB9LFxuXG4gIHJlcGxhY2VTdGFjazogZnVuY3Rpb24gcmVwbGFjZVN0YWNrKGNhbGxiYWNrKSB7XG4gICAgdmFyIHByZWZpeCA9IFsnKCddLFxuICAgICAgICBzdGFjayA9IHVuZGVmaW5lZCxcbiAgICAgICAgY3JlYXRlZFN0YWNrID0gdW5kZWZpbmVkLFxuICAgICAgICB1c2VkTGl0ZXJhbCA9IHVuZGVmaW5lZDtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKCF0aGlzLmlzSW5saW5lKCkpIHtcbiAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdyZXBsYWNlU3RhY2sgb24gbm9uLWlubGluZScpO1xuICAgIH1cblxuICAgIC8vIFdlIHdhbnQgdG8gbWVyZ2UgdGhlIGlubGluZSBzdGF0ZW1lbnQgaW50byB0aGUgcmVwbGFjZW1lbnQgc3RhdGVtZW50IHZpYSAnLCdcbiAgICB2YXIgdG9wID0gdGhpcy5wb3BTdGFjayh0cnVlKTtcblxuICAgIGlmICh0b3AgaW5zdGFuY2VvZiBMaXRlcmFsKSB7XG4gICAgICAvLyBMaXRlcmFscyBkbyBub3QgbmVlZCB0byBiZSBpbmxpbmVkXG4gICAgICBzdGFjayA9IFt0b3AudmFsdWVdO1xuICAgICAgcHJlZml4ID0gWycoJywgc3RhY2tdO1xuICAgICAgdXNlZExpdGVyYWwgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBHZXQgb3IgY3JlYXRlIHRoZSBjdXJyZW50IHN0YWNrIG5hbWUgZm9yIHVzZSBieSB0aGUgaW5saW5lXG4gICAgICBjcmVhdGVkU3RhY2sgPSB0cnVlO1xuICAgICAgdmFyIF9uYW1lID0gdGhpcy5pbmNyU3RhY2soKTtcblxuICAgICAgcHJlZml4ID0gWycoKCcsIHRoaXMucHVzaChfbmFtZSksICcgPSAnLCB0b3AsICcpJ107XG4gICAgICBzdGFjayA9IHRoaXMudG9wU3RhY2soKTtcbiAgICB9XG5cbiAgICB2YXIgaXRlbSA9IGNhbGxiYWNrLmNhbGwodGhpcywgc3RhY2spO1xuXG4gICAgaWYgKCF1c2VkTGl0ZXJhbCkge1xuICAgICAgdGhpcy5wb3BTdGFjaygpO1xuICAgIH1cbiAgICBpZiAoY3JlYXRlZFN0YWNrKSB7XG4gICAgICB0aGlzLnN0YWNrU2xvdC0tO1xuICAgIH1cbiAgICB0aGlzLnB1c2gocHJlZml4LmNvbmNhdChpdGVtLCAnKScpKTtcbiAgfSxcblxuICBpbmNyU3RhY2s6IGZ1bmN0aW9uIGluY3JTdGFjaygpIHtcbiAgICB0aGlzLnN0YWNrU2xvdCsrO1xuICAgIGlmICh0aGlzLnN0YWNrU2xvdCA+IHRoaXMuc3RhY2tWYXJzLmxlbmd0aCkge1xuICAgICAgdGhpcy5zdGFja1ZhcnMucHVzaCgnc3RhY2snICsgdGhpcy5zdGFja1Nsb3QpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50b3BTdGFja05hbWUoKTtcbiAgfSxcbiAgdG9wU3RhY2tOYW1lOiBmdW5jdGlvbiB0b3BTdGFja05hbWUoKSB7XG4gICAgcmV0dXJuICdzdGFjaycgKyB0aGlzLnN0YWNrU2xvdDtcbiAgfSxcbiAgZmx1c2hJbmxpbmU6IGZ1bmN0aW9uIGZsdXNoSW5saW5lKCkge1xuICAgIHZhciBpbmxpbmVTdGFjayA9IHRoaXMuaW5saW5lU3RhY2s7XG4gICAgdGhpcy5pbmxpbmVTdGFjayA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpbmxpbmVTdGFjay5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGVudHJ5ID0gaW5saW5lU3RhY2tbaV07XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChlbnRyeSBpbnN0YW5jZW9mIExpdGVyYWwpIHtcbiAgICAgICAgdGhpcy5jb21waWxlU3RhY2sucHVzaChlbnRyeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLmluY3JTdGFjaygpO1xuICAgICAgICB0aGlzLnB1c2hTb3VyY2UoW3N0YWNrLCAnID0gJywgZW50cnksICc7J10pO1xuICAgICAgICB0aGlzLmNvbXBpbGVTdGFjay5wdXNoKHN0YWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGlzSW5saW5lOiBmdW5jdGlvbiBpc0lubGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbmxpbmVTdGFjay5sZW5ndGg7XG4gIH0sXG5cbiAgcG9wU3RhY2s6IGZ1bmN0aW9uIHBvcFN0YWNrKHdyYXBwZWQpIHtcbiAgICB2YXIgaW5saW5lID0gdGhpcy5pc0lubGluZSgpLFxuICAgICAgICBpdGVtID0gKGlubGluZSA/IHRoaXMuaW5saW5lU3RhY2sgOiB0aGlzLmNvbXBpbGVTdGFjaykucG9wKCk7XG5cbiAgICBpZiAoIXdyYXBwZWQgJiYgaXRlbSBpbnN0YW5jZW9mIExpdGVyYWwpIHtcbiAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWlubGluZSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBpZiAoIXRoaXMuc3RhY2tTbG90KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ0ludmFsaWQgc3RhY2sgcG9wJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFja1Nsb3QtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgfSxcblxuICB0b3BTdGFjazogZnVuY3Rpb24gdG9wU3RhY2soKSB7XG4gICAgdmFyIHN0YWNrID0gdGhpcy5pc0lubGluZSgpID8gdGhpcy5pbmxpbmVTdGFjayA6IHRoaXMuY29tcGlsZVN0YWNrLFxuICAgICAgICBpdGVtID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIExpdGVyYWwpIHtcbiAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG4gIH0sXG5cbiAgY29udGV4dE5hbWU6IGZ1bmN0aW9uIGNvbnRleHROYW1lKGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy51c2VEZXB0aHMgJiYgY29udGV4dCkge1xuICAgICAgcmV0dXJuICdkZXB0aHNbJyArIGNvbnRleHQgKyAnXSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnZGVwdGgnICsgY29udGV4dDtcbiAgICB9XG4gIH0sXG5cbiAgcXVvdGVkU3RyaW5nOiBmdW5jdGlvbiBxdW90ZWRTdHJpbmcoc3RyKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlLnF1b3RlZFN0cmluZyhzdHIpO1xuICB9LFxuXG4gIG9iamVjdExpdGVyYWw6IGZ1bmN0aW9uIG9iamVjdExpdGVyYWwob2JqKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlLm9iamVjdExpdGVyYWwob2JqKTtcbiAgfSxcblxuICBhbGlhc2FibGU6IGZ1bmN0aW9uIGFsaWFzYWJsZShuYW1lKSB7XG4gICAgdmFyIHJldCA9IHRoaXMuYWxpYXNlc1tuYW1lXTtcbiAgICBpZiAocmV0KSB7XG4gICAgICByZXQucmVmZXJlbmNlQ291bnQrKztcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgcmV0ID0gdGhpcy5hbGlhc2VzW25hbWVdID0gdGhpcy5zb3VyY2Uud3JhcChuYW1lKTtcbiAgICByZXQuYWxpYXNhYmxlID0gdHJ1ZTtcbiAgICByZXQucmVmZXJlbmNlQ291bnQgPSAxO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICBzZXR1cEhlbHBlcjogZnVuY3Rpb24gc2V0dXBIZWxwZXIocGFyYW1TaXplLCBuYW1lLCBibG9ja0hlbHBlcikge1xuICAgIHZhciBwYXJhbXMgPSBbXSxcbiAgICAgICAgcGFyYW1zSW5pdCA9IHRoaXMuc2V0dXBIZWxwZXJBcmdzKG5hbWUsIHBhcmFtU2l6ZSwgcGFyYW1zLCBibG9ja0hlbHBlcik7XG4gICAgdmFyIGZvdW5kSGVscGVyID0gdGhpcy5uYW1lTG9va3VwKCdoZWxwZXJzJywgbmFtZSwgJ2hlbHBlcicpLFxuICAgICAgICBjYWxsQ29udGV4dCA9IHRoaXMuYWxpYXNhYmxlKHRoaXMuY29udGV4dE5hbWUoMCkgKyAnICE9IG51bGwgPyAnICsgdGhpcy5jb250ZXh0TmFtZSgwKSArICcgOiB7fScpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgcGFyYW1zSW5pdDogcGFyYW1zSW5pdCxcbiAgICAgIG5hbWU6IGZvdW5kSGVscGVyLFxuICAgICAgY2FsbFBhcmFtczogW2NhbGxDb250ZXh0XS5jb25jYXQocGFyYW1zKVxuICAgIH07XG4gIH0sXG5cbiAgc2V0dXBQYXJhbXM6IGZ1bmN0aW9uIHNldHVwUGFyYW1zKGhlbHBlciwgcGFyYW1TaXplLCBwYXJhbXMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHt9LFxuICAgICAgICBjb250ZXh0cyA9IFtdLFxuICAgICAgICB0eXBlcyA9IFtdLFxuICAgICAgICBpZHMgPSBbXSxcbiAgICAgICAgb2JqZWN0QXJncyA9ICFwYXJhbXMsXG4gICAgICAgIHBhcmFtID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKG9iamVjdEFyZ3MpIHtcbiAgICAgIHBhcmFtcyA9IFtdO1xuICAgIH1cblxuICAgIG9wdGlvbnMubmFtZSA9IHRoaXMucXVvdGVkU3RyaW5nKGhlbHBlcik7XG4gICAgb3B0aW9ucy5oYXNoID0gdGhpcy5wb3BTdGFjaygpO1xuXG4gICAgaWYgKHRoaXMudHJhY2tJZHMpIHtcbiAgICAgIG9wdGlvbnMuaGFzaElkcyA9IHRoaXMucG9wU3RhY2soKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RyaW5nUGFyYW1zKSB7XG4gICAgICBvcHRpb25zLmhhc2hUeXBlcyA9IHRoaXMucG9wU3RhY2soKTtcbiAgICAgIG9wdGlvbnMuaGFzaENvbnRleHRzID0gdGhpcy5wb3BTdGFjaygpO1xuICAgIH1cblxuICAgIHZhciBpbnZlcnNlID0gdGhpcy5wb3BTdGFjaygpLFxuICAgICAgICBwcm9ncmFtID0gdGhpcy5wb3BTdGFjaygpO1xuXG4gICAgLy8gQXZvaWQgc2V0dGluZyBmbiBhbmQgaW52ZXJzZSBpZiBuZWl0aGVyIGFyZSBzZXQuIFRoaXMgYWxsb3dzXG4gICAgLy8gaGVscGVycyB0byBkbyBhIGNoZWNrIGZvciBgaWYgKG9wdGlvbnMuZm4pYFxuICAgIGlmIChwcm9ncmFtIHx8IGludmVyc2UpIHtcbiAgICAgIG9wdGlvbnMuZm4gPSBwcm9ncmFtIHx8ICdjb250YWluZXIubm9vcCc7XG4gICAgICBvcHRpb25zLmludmVyc2UgPSBpbnZlcnNlIHx8ICdjb250YWluZXIubm9vcCc7XG4gICAgfVxuXG4gICAgLy8gVGhlIHBhcmFtZXRlcnMgZ28gb24gdG8gdGhlIHN0YWNrIGluIG9yZGVyIChtYWtpbmcgc3VyZSB0aGF0IHRoZXkgYXJlIGV2YWx1YXRlZCBpbiBvcmRlcilcbiAgICAvLyBzbyB3ZSBuZWVkIHRvIHBvcCB0aGVtIG9mZiB0aGUgc3RhY2sgaW4gcmV2ZXJzZSBvcmRlclxuICAgIHZhciBpID0gcGFyYW1TaXplO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHBhcmFtID0gdGhpcy5wb3BTdGFjaygpO1xuICAgICAgcGFyYW1zW2ldID0gcGFyYW07XG5cbiAgICAgIGlmICh0aGlzLnRyYWNrSWRzKSB7XG4gICAgICAgIGlkc1tpXSA9IHRoaXMucG9wU3RhY2soKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0cmluZ1BhcmFtcykge1xuICAgICAgICB0eXBlc1tpXSA9IHRoaXMucG9wU3RhY2soKTtcbiAgICAgICAgY29udGV4dHNbaV0gPSB0aGlzLnBvcFN0YWNrKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9iamVjdEFyZ3MpIHtcbiAgICAgIG9wdGlvbnMuYXJncyA9IHRoaXMuc291cmNlLmdlbmVyYXRlQXJyYXkocGFyYW1zKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50cmFja0lkcykge1xuICAgICAgb3B0aW9ucy5pZHMgPSB0aGlzLnNvdXJjZS5nZW5lcmF0ZUFycmF5KGlkcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0cmluZ1BhcmFtcykge1xuICAgICAgb3B0aW9ucy50eXBlcyA9IHRoaXMuc291cmNlLmdlbmVyYXRlQXJyYXkodHlwZXMpO1xuICAgICAgb3B0aW9ucy5jb250ZXh0cyA9IHRoaXMuc291cmNlLmdlbmVyYXRlQXJyYXkoY29udGV4dHMpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZGF0YSkge1xuICAgICAgb3B0aW9ucy5kYXRhID0gJ2RhdGEnO1xuICAgIH1cbiAgICBpZiAodGhpcy51c2VCbG9ja1BhcmFtcykge1xuICAgICAgb3B0aW9ucy5ibG9ja1BhcmFtcyA9ICdibG9ja1BhcmFtcyc7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9LFxuXG4gIHNldHVwSGVscGVyQXJnczogZnVuY3Rpb24gc2V0dXBIZWxwZXJBcmdzKGhlbHBlciwgcGFyYW1TaXplLCBwYXJhbXMsIHVzZVJlZ2lzdGVyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLnNldHVwUGFyYW1zKGhlbHBlciwgcGFyYW1TaXplLCBwYXJhbXMpO1xuICAgIG9wdGlvbnMgPSB0aGlzLm9iamVjdExpdGVyYWwob3B0aW9ucyk7XG4gICAgaWYgKHVzZVJlZ2lzdGVyKSB7XG4gICAgICB0aGlzLnVzZVJlZ2lzdGVyKCdvcHRpb25zJyk7XG4gICAgICBwYXJhbXMucHVzaCgnb3B0aW9ucycpO1xuICAgICAgcmV0dXJuIFsnb3B0aW9ucz0nLCBvcHRpb25zXTtcbiAgICB9IGVsc2UgaWYgKHBhcmFtcykge1xuICAgICAgcGFyYW1zLnB1c2gob3B0aW9ucyk7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgfVxufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlc2VydmVkV29yZHMgPSAoJ2JyZWFrIGVsc2UgbmV3IHZhcicgKyAnIGNhc2UgZmluYWxseSByZXR1cm4gdm9pZCcgKyAnIGNhdGNoIGZvciBzd2l0Y2ggd2hpbGUnICsgJyBjb250aW51ZSBmdW5jdGlvbiB0aGlzIHdpdGgnICsgJyBkZWZhdWx0IGlmIHRocm93JyArICcgZGVsZXRlIGluIHRyeScgKyAnIGRvIGluc3RhbmNlb2YgdHlwZW9mJyArICcgYWJzdHJhY3QgZW51bSBpbnQgc2hvcnQnICsgJyBib29sZWFuIGV4cG9ydCBpbnRlcmZhY2Ugc3RhdGljJyArICcgYnl0ZSBleHRlbmRzIGxvbmcgc3VwZXInICsgJyBjaGFyIGZpbmFsIG5hdGl2ZSBzeW5jaHJvbml6ZWQnICsgJyBjbGFzcyBmbG9hdCBwYWNrYWdlIHRocm93cycgKyAnIGNvbnN0IGdvdG8gcHJpdmF0ZSB0cmFuc2llbnQnICsgJyBkZWJ1Z2dlciBpbXBsZW1lbnRzIHByb3RlY3RlZCB2b2xhdGlsZScgKyAnIGRvdWJsZSBpbXBvcnQgcHVibGljIGxldCB5aWVsZCBhd2FpdCcgKyAnIG51bGwgdHJ1ZSBmYWxzZScpLnNwbGl0KCcgJyk7XG5cbiAgdmFyIGNvbXBpbGVyV29yZHMgPSBKYXZhU2NyaXB0Q29tcGlsZXIuUkVTRVJWRURfV09SRFMgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IHJlc2VydmVkV29yZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29tcGlsZXJXb3Jkc1tyZXNlcnZlZFdvcmRzW2ldXSA9IHRydWU7XG4gIH1cbn0pKCk7XG5cbkphdmFTY3JpcHRDb21waWxlci5pc1ZhbGlkSmF2YVNjcmlwdFZhcmlhYmxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiAhSmF2YVNjcmlwdENvbXBpbGVyLlJFU0VSVkVEX1dPUkRTW25hbWVdICYmIC9eW2EtekEtWl8kXVswLTlhLXpBLVpfJF0qJC8udGVzdChuYW1lKTtcbn07XG5cbmZ1bmN0aW9uIHN0cmljdExvb2t1cChyZXF1aXJlVGVybWluYWwsIGNvbXBpbGVyLCBwYXJ0cywgdHlwZSkge1xuICB2YXIgc3RhY2sgPSBjb21waWxlci5wb3BTdGFjaygpLFxuICAgICAgaSA9IDAsXG4gICAgICBsZW4gPSBwYXJ0cy5sZW5ndGg7XG4gIGlmIChyZXF1aXJlVGVybWluYWwpIHtcbiAgICBsZW4tLTtcbiAgfVxuXG4gIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBzdGFjayA9IGNvbXBpbGVyLm5hbWVMb29rdXAoc3RhY2ssIHBhcnRzW2ldLCB0eXBlKTtcbiAgfVxuXG4gIGlmIChyZXF1aXJlVGVybWluYWwpIHtcbiAgICByZXR1cm4gW2NvbXBpbGVyLmFsaWFzYWJsZSgnY29udGFpbmVyLnN0cmljdCcpLCAnKCcsIHN0YWNrLCAnLCAnLCBjb21waWxlci5xdW90ZWRTdHJpbmcocGFydHNbaV0pLCAnKSddO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdGFjaztcbiAgfVxufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBKYXZhU2NyaXB0Q29tcGlsZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG59LHtcIi4uL2Jhc2VcIjo3LFwiLi4vZXhjZXB0aW9uXCI6MjAsXCIuLi91dGlsc1wiOjMzLFwiLi9jb2RlLWdlblwiOjEwfV0sMTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qIEppc29uIGdlbmVyYXRlZCBwYXJzZXIgKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgaGFuZGxlYmFycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcnNlciA9IHsgdHJhY2U6IGZ1bmN0aW9uIHRyYWNlKCkge30sXG4gICAgICAgIHl5OiB7fSxcbiAgICAgICAgc3ltYm9sc186IHsgXCJlcnJvclwiOiAyLCBcInJvb3RcIjogMywgXCJwcm9ncmFtXCI6IDQsIFwiRU9GXCI6IDUsIFwicHJvZ3JhbV9yZXBldGl0aW9uMFwiOiA2LCBcInN0YXRlbWVudFwiOiA3LCBcIm11c3RhY2hlXCI6IDgsIFwiYmxvY2tcIjogOSwgXCJyYXdCbG9ja1wiOiAxMCwgXCJwYXJ0aWFsXCI6IDExLCBcInBhcnRpYWxCbG9ja1wiOiAxMiwgXCJjb250ZW50XCI6IDEzLCBcIkNPTU1FTlRcIjogMTQsIFwiQ09OVEVOVFwiOiAxNSwgXCJvcGVuUmF3QmxvY2tcIjogMTYsIFwicmF3QmxvY2tfcmVwZXRpdGlvbl9wbHVzMFwiOiAxNywgXCJFTkRfUkFXX0JMT0NLXCI6IDE4LCBcIk9QRU5fUkFXX0JMT0NLXCI6IDE5LCBcImhlbHBlck5hbWVcIjogMjAsIFwib3BlblJhd0Jsb2NrX3JlcGV0aXRpb24wXCI6IDIxLCBcIm9wZW5SYXdCbG9ja19vcHRpb24wXCI6IDIyLCBcIkNMT1NFX1JBV19CTE9DS1wiOiAyMywgXCJvcGVuQmxvY2tcIjogMjQsIFwiYmxvY2tfb3B0aW9uMFwiOiAyNSwgXCJjbG9zZUJsb2NrXCI6IDI2LCBcIm9wZW5JbnZlcnNlXCI6IDI3LCBcImJsb2NrX29wdGlvbjFcIjogMjgsIFwiT1BFTl9CTE9DS1wiOiAyOSwgXCJvcGVuQmxvY2tfcmVwZXRpdGlvbjBcIjogMzAsIFwib3BlbkJsb2NrX29wdGlvbjBcIjogMzEsIFwib3BlbkJsb2NrX29wdGlvbjFcIjogMzIsIFwiQ0xPU0VcIjogMzMsIFwiT1BFTl9JTlZFUlNFXCI6IDM0LCBcIm9wZW5JbnZlcnNlX3JlcGV0aXRpb24wXCI6IDM1LCBcIm9wZW5JbnZlcnNlX29wdGlvbjBcIjogMzYsIFwib3BlbkludmVyc2Vfb3B0aW9uMVwiOiAzNywgXCJvcGVuSW52ZXJzZUNoYWluXCI6IDM4LCBcIk9QRU5fSU5WRVJTRV9DSEFJTlwiOiAzOSwgXCJvcGVuSW52ZXJzZUNoYWluX3JlcGV0aXRpb24wXCI6IDQwLCBcIm9wZW5JbnZlcnNlQ2hhaW5fb3B0aW9uMFwiOiA0MSwgXCJvcGVuSW52ZXJzZUNoYWluX29wdGlvbjFcIjogNDIsIFwiaW52ZXJzZUFuZFByb2dyYW1cIjogNDMsIFwiSU5WRVJTRVwiOiA0NCwgXCJpbnZlcnNlQ2hhaW5cIjogNDUsIFwiaW52ZXJzZUNoYWluX29wdGlvbjBcIjogNDYsIFwiT1BFTl9FTkRCTE9DS1wiOiA0NywgXCJPUEVOXCI6IDQ4LCBcIm11c3RhY2hlX3JlcGV0aXRpb24wXCI6IDQ5LCBcIm11c3RhY2hlX29wdGlvbjBcIjogNTAsIFwiT1BFTl9VTkVTQ0FQRURcIjogNTEsIFwibXVzdGFjaGVfcmVwZXRpdGlvbjFcIjogNTIsIFwibXVzdGFjaGVfb3B0aW9uMVwiOiA1MywgXCJDTE9TRV9VTkVTQ0FQRURcIjogNTQsIFwiT1BFTl9QQVJUSUFMXCI6IDU1LCBcInBhcnRpYWxOYW1lXCI6IDU2LCBcInBhcnRpYWxfcmVwZXRpdGlvbjBcIjogNTcsIFwicGFydGlhbF9vcHRpb24wXCI6IDU4LCBcIm9wZW5QYXJ0aWFsQmxvY2tcIjogNTksIFwiT1BFTl9QQVJUSUFMX0JMT0NLXCI6IDYwLCBcIm9wZW5QYXJ0aWFsQmxvY2tfcmVwZXRpdGlvbjBcIjogNjEsIFwib3BlblBhcnRpYWxCbG9ja19vcHRpb24wXCI6IDYyLCBcInBhcmFtXCI6IDYzLCBcInNleHByXCI6IDY0LCBcIk9QRU5fU0VYUFJcIjogNjUsIFwic2V4cHJfcmVwZXRpdGlvbjBcIjogNjYsIFwic2V4cHJfb3B0aW9uMFwiOiA2NywgXCJDTE9TRV9TRVhQUlwiOiA2OCwgXCJoYXNoXCI6IDY5LCBcImhhc2hfcmVwZXRpdGlvbl9wbHVzMFwiOiA3MCwgXCJoYXNoU2VnbWVudFwiOiA3MSwgXCJJRFwiOiA3MiwgXCJFUVVBTFNcIjogNzMsIFwiYmxvY2tQYXJhbXNcIjogNzQsIFwiT1BFTl9CTE9DS19QQVJBTVNcIjogNzUsIFwiYmxvY2tQYXJhbXNfcmVwZXRpdGlvbl9wbHVzMFwiOiA3NiwgXCJDTE9TRV9CTE9DS19QQVJBTVNcIjogNzcsIFwicGF0aFwiOiA3OCwgXCJkYXRhTmFtZVwiOiA3OSwgXCJTVFJJTkdcIjogODAsIFwiTlVNQkVSXCI6IDgxLCBcIkJPT0xFQU5cIjogODIsIFwiVU5ERUZJTkVEXCI6IDgzLCBcIk5VTExcIjogODQsIFwiREFUQVwiOiA4NSwgXCJwYXRoU2VnbWVudHNcIjogODYsIFwiU0VQXCI6IDg3LCBcIiRhY2NlcHRcIjogMCwgXCIkZW5kXCI6IDEgfSxcbiAgICAgICAgdGVybWluYWxzXzogeyAyOiBcImVycm9yXCIsIDU6IFwiRU9GXCIsIDE0OiBcIkNPTU1FTlRcIiwgMTU6IFwiQ09OVEVOVFwiLCAxODogXCJFTkRfUkFXX0JMT0NLXCIsIDE5OiBcIk9QRU5fUkFXX0JMT0NLXCIsIDIzOiBcIkNMT1NFX1JBV19CTE9DS1wiLCAyOTogXCJPUEVOX0JMT0NLXCIsIDMzOiBcIkNMT1NFXCIsIDM0OiBcIk9QRU5fSU5WRVJTRVwiLCAzOTogXCJPUEVOX0lOVkVSU0VfQ0hBSU5cIiwgNDQ6IFwiSU5WRVJTRVwiLCA0NzogXCJPUEVOX0VOREJMT0NLXCIsIDQ4OiBcIk9QRU5cIiwgNTE6IFwiT1BFTl9VTkVTQ0FQRURcIiwgNTQ6IFwiQ0xPU0VfVU5FU0NBUEVEXCIsIDU1OiBcIk9QRU5fUEFSVElBTFwiLCA2MDogXCJPUEVOX1BBUlRJQUxfQkxPQ0tcIiwgNjU6IFwiT1BFTl9TRVhQUlwiLCA2ODogXCJDTE9TRV9TRVhQUlwiLCA3MjogXCJJRFwiLCA3MzogXCJFUVVBTFNcIiwgNzU6IFwiT1BFTl9CTE9DS19QQVJBTVNcIiwgNzc6IFwiQ0xPU0VfQkxPQ0tfUEFSQU1TXCIsIDgwOiBcIlNUUklOR1wiLCA4MTogXCJOVU1CRVJcIiwgODI6IFwiQk9PTEVBTlwiLCA4MzogXCJVTkRFRklORURcIiwgODQ6IFwiTlVMTFwiLCA4NTogXCJEQVRBXCIsIDg3OiBcIlNFUFwiIH0sXG4gICAgICAgIHByb2R1Y3Rpb25zXzogWzAsIFszLCAyXSwgWzQsIDFdLCBbNywgMV0sIFs3LCAxXSwgWzcsIDFdLCBbNywgMV0sIFs3LCAxXSwgWzcsIDFdLCBbNywgMV0sIFsxMywgMV0sIFsxMCwgM10sIFsxNiwgNV0sIFs5LCA0XSwgWzksIDRdLCBbMjQsIDZdLCBbMjcsIDZdLCBbMzgsIDZdLCBbNDMsIDJdLCBbNDUsIDNdLCBbNDUsIDFdLCBbMjYsIDNdLCBbOCwgNV0sIFs4LCA1XSwgWzExLCA1XSwgWzEyLCAzXSwgWzU5LCA1XSwgWzYzLCAxXSwgWzYzLCAxXSwgWzY0LCA1XSwgWzY5LCAxXSwgWzcxLCAzXSwgWzc0LCAzXSwgWzIwLCAxXSwgWzIwLCAxXSwgWzIwLCAxXSwgWzIwLCAxXSwgWzIwLCAxXSwgWzIwLCAxXSwgWzIwLCAxXSwgWzU2LCAxXSwgWzU2LCAxXSwgWzc5LCAyXSwgWzc4LCAxXSwgWzg2LCAzXSwgWzg2LCAxXSwgWzYsIDBdLCBbNiwgMl0sIFsxNywgMV0sIFsxNywgMl0sIFsyMSwgMF0sIFsyMSwgMl0sIFsyMiwgMF0sIFsyMiwgMV0sIFsyNSwgMF0sIFsyNSwgMV0sIFsyOCwgMF0sIFsyOCwgMV0sIFszMCwgMF0sIFszMCwgMl0sIFszMSwgMF0sIFszMSwgMV0sIFszMiwgMF0sIFszMiwgMV0sIFszNSwgMF0sIFszNSwgMl0sIFszNiwgMF0sIFszNiwgMV0sIFszNywgMF0sIFszNywgMV0sIFs0MCwgMF0sIFs0MCwgMl0sIFs0MSwgMF0sIFs0MSwgMV0sIFs0MiwgMF0sIFs0MiwgMV0sIFs0NiwgMF0sIFs0NiwgMV0sIFs0OSwgMF0sIFs0OSwgMl0sIFs1MCwgMF0sIFs1MCwgMV0sIFs1MiwgMF0sIFs1MiwgMl0sIFs1MywgMF0sIFs1MywgMV0sIFs1NywgMF0sIFs1NywgMl0sIFs1OCwgMF0sIFs1OCwgMV0sIFs2MSwgMF0sIFs2MSwgMl0sIFs2MiwgMF0sIFs2MiwgMV0sIFs2NiwgMF0sIFs2NiwgMl0sIFs2NywgMF0sIFs2NywgMV0sIFs3MCwgMV0sIFs3MCwgMl0sIFs3NiwgMV0sIFs3NiwgMl1dLFxuICAgICAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBhbm9ueW1vdXMoeXl0ZXh0LCB5eWxlbmcsIHl5bGluZW5vLCB5eSwgeXlzdGF0ZSwgJCQsIF8kXG4gICAgICAgIC8qKi8pIHtcblxuICAgICAgICAgICAgdmFyICQwID0gJCQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHN3aXRjaCAoeXlzdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQkWyQwIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geXkucHJlcGFyZVByb2dyYW0oJCRbJDBdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSAkJFskMF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gJCRbJDBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9ICQkWyQwXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSAkJFskMF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gJCRbJDBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9ICQkWyQwXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ29tbWVudFN0YXRlbWVudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogeXkuc3RyaXBDb21tZW50KCQkWyQwXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpcDogeXkuc3RyaXBGbGFncygkJFskMF0sICQkWyQwXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2M6IHl5LmxvY0luZm8odGhpcy5fJClcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ29udGVudFN0YXRlbWVudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbDogJCRbJDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICQkWyQwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYzogeXkubG9jSW5mbyh0aGlzLl8kKVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHl5LnByZXBhcmVSYXdCbG9jaygkJFskMCAtIDJdLCAkJFskMCAtIDFdLCAkJFskMF0sIHRoaXMuXyQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7IHBhdGg6ICQkWyQwIC0gM10sIHBhcmFtczogJCRbJDAgLSAyXSwgaGFzaDogJCRbJDAgLSAxXSB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB5eS5wcmVwYXJlQmxvY2soJCRbJDAgLSAzXSwgJCRbJDAgLSAyXSwgJCRbJDAgLSAxXSwgJCRbJDBdLCBmYWxzZSwgdGhpcy5fJCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHl5LnByZXBhcmVCbG9jaygkJFskMCAtIDNdLCAkJFskMCAtIDJdLCAkJFskMCAtIDFdLCAkJFskMF0sIHRydWUsIHRoaXMuXyQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7IG9wZW46ICQkWyQwIC0gNV0sIHBhdGg6ICQkWyQwIC0gNF0sIHBhcmFtczogJCRbJDAgLSAzXSwgaGFzaDogJCRbJDAgLSAyXSwgYmxvY2tQYXJhbXM6ICQkWyQwIC0gMV0sIHN0cmlwOiB5eS5zdHJpcEZsYWdzKCQkWyQwIC0gNV0sICQkWyQwXSkgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geyBwYXRoOiAkJFskMCAtIDRdLCBwYXJhbXM6ICQkWyQwIC0gM10sIGhhc2g6ICQkWyQwIC0gMl0sIGJsb2NrUGFyYW1zOiAkJFskMCAtIDFdLCBzdHJpcDogeXkuc3RyaXBGbGFncygkJFskMCAtIDVdLCAkJFskMF0pIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHsgcGF0aDogJCRbJDAgLSA0XSwgcGFyYW1zOiAkJFskMCAtIDNdLCBoYXNoOiAkJFskMCAtIDJdLCBibG9ja1BhcmFtczogJCRbJDAgLSAxXSwgc3RyaXA6IHl5LnN0cmlwRmxhZ3MoJCRbJDAgLSA1XSwgJCRbJDBdKSB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7IHN0cmlwOiB5eS5zdHJpcEZsYWdzKCQkWyQwIC0gMV0sICQkWyQwIC0gMV0pLCBwcm9ncmFtOiAkJFskMF0gfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGludmVyc2UgPSB5eS5wcmVwYXJlQmxvY2soJCRbJDAgLSAyXSwgJCRbJDAgLSAxXSwgJCRbJDBdLCAkJFskMF0sIGZhbHNlLCB0aGlzLl8kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyYW0gPSB5eS5wcmVwYXJlUHJvZ3JhbShbaW52ZXJzZV0sICQkWyQwIC0gMV0ubG9jKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbS5jaGFpbmVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7IHN0cmlwOiAkJFskMCAtIDJdLnN0cmlwLCBwcm9ncmFtOiBwcm9ncmFtLCBjaGFpbjogdHJ1ZSB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9ICQkWyQwXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geyBwYXRoOiAkJFskMCAtIDFdLCBzdHJpcDogeXkuc3RyaXBGbGFncygkJFskMCAtIDJdLCAkJFskMF0pIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHl5LnByZXBhcmVNdXN0YWNoZSgkJFskMCAtIDNdLCAkJFskMCAtIDJdLCAkJFskMCAtIDFdLCAkJFskMCAtIDRdLCB5eS5zdHJpcEZsYWdzKCQkWyQwIC0gNF0sICQkWyQwXSksIHRoaXMuXyQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB5eS5wcmVwYXJlTXVzdGFjaGUoJCRbJDAgLSAzXSwgJCRbJDAgLSAyXSwgJCRbJDAgLSAxXSwgJCRbJDAgLSA0XSwgeXkuc3RyaXBGbGFncygkJFskMCAtIDRdLCAkJFskMF0pLCB0aGlzLl8kKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1BhcnRpYWxTdGF0ZW1lbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJCRbJDAgLSAzXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogJCRbJDAgLSAyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc2g6ICQkWyQwIC0gMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaXA6IHl5LnN0cmlwRmxhZ3MoJCRbJDAgLSA0XSwgJCRbJDBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYzogeXkubG9jSW5mbyh0aGlzLl8kKVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHl5LnByZXBhcmVQYXJ0aWFsQmxvY2soJCRbJDAgLSAyXSwgJCRbJDAgLSAxXSwgJCRbJDBdLCB0aGlzLl8kKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geyBwYXRoOiAkJFskMCAtIDNdLCBwYXJhbXM6ICQkWyQwIC0gMl0sIGhhc2g6ICQkWyQwIC0gMV0sIHN0cmlwOiB5eS5zdHJpcEZsYWdzKCQkWyQwIC0gNF0sICQkWyQwXSkgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gJCRbJDBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI4OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSAkJFskMF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTdWJFeHByZXNzaW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6ICQkWyQwIC0gM10sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6ICQkWyQwIC0gMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiAkJFskMCAtIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jOiB5eS5sb2NJbmZvKHRoaXMuXyQpXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzMDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geyB0eXBlOiAnSGFzaCcsIHBhaXJzOiAkJFskMF0sIGxvYzogeXkubG9jSW5mbyh0aGlzLl8kKSB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDMxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7IHR5cGU6ICdIYXNoUGFpcicsIGtleTogeXkuaWQoJCRbJDAgLSAyXSksIHZhbHVlOiAkJFskMF0sIGxvYzogeXkubG9jSW5mbyh0aGlzLl8kKSB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB5eS5pZCgkJFskMCAtIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzMzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gJCRbJDBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSAkJFskMF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHsgdHlwZTogJ1N0cmluZ0xpdGVyYWwnLCB2YWx1ZTogJCRbJDBdLCBvcmlnaW5hbDogJCRbJDBdLCBsb2M6IHl5LmxvY0luZm8odGhpcy5fJCkgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzNjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geyB0eXBlOiAnTnVtYmVyTGl0ZXJhbCcsIHZhbHVlOiBOdW1iZXIoJCRbJDBdKSwgb3JpZ2luYWw6IE51bWJlcigkJFskMF0pLCBsb2M6IHl5LmxvY0luZm8odGhpcy5fJCkgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geyB0eXBlOiAnQm9vbGVhbkxpdGVyYWwnLCB2YWx1ZTogJCRbJDBdID09PSAndHJ1ZScsIG9yaWdpbmFsOiAkJFskMF0gPT09ICd0cnVlJywgbG9jOiB5eS5sb2NJbmZvKHRoaXMuXyQpIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHsgdHlwZTogJ1VuZGVmaW5lZExpdGVyYWwnLCBvcmlnaW5hbDogdW5kZWZpbmVkLCB2YWx1ZTogdW5kZWZpbmVkLCBsb2M6IHl5LmxvY0luZm8odGhpcy5fJCkgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geyB0eXBlOiAnTnVsbExpdGVyYWwnLCBvcmlnaW5hbDogbnVsbCwgdmFsdWU6IG51bGwsIGxvYzogeXkubG9jSW5mbyh0aGlzLl8kKSB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSAkJFskMF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9ICQkWyQwXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0MjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geXkucHJlcGFyZVBhdGgodHJ1ZSwgJCRbJDBdLCB0aGlzLl8kKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0MzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geXkucHJlcGFyZVBhdGgoZmFsc2UsICQkWyQwXSwgdGhpcy5fJCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDQ6XG4gICAgICAgICAgICAgICAgICAgICQkWyQwIC0gMl0ucHVzaCh7IHBhcnQ6IHl5LmlkKCQkWyQwXSksIG9yaWdpbmFsOiAkJFskMF0sIHNlcGFyYXRvcjogJCRbJDAgLSAxXSB9KTt0aGlzLiQgPSAkJFskMCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ1OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSBbeyBwYXJ0OiB5eS5pZCgkJFskMF0pLCBvcmlnaW5hbDogJCRbJDBdIH1dO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ2OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0NzpcbiAgICAgICAgICAgICAgICAgICAgJCRbJDAgLSAxXS5wdXNoKCQkWyQwXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDg6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IFskJFskMF1dO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ5OlxuICAgICAgICAgICAgICAgICAgICAkJFskMCAtIDFdLnB1c2goJCRbJDBdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1MDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gW107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTE6XG4gICAgICAgICAgICAgICAgICAgICQkWyQwIC0gMV0ucHVzaCgkJFskMF0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU4OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OTpcbiAgICAgICAgICAgICAgICAgICAgJCRbJDAgLSAxXS5wdXNoKCQkWyQwXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY1OlxuICAgICAgICAgICAgICAgICAgICAkJFskMCAtIDFdLnB1c2goJCRbJDBdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3MDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gW107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzE6XG4gICAgICAgICAgICAgICAgICAgICQkWyQwIC0gMV0ucHVzaCgkJFskMF0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc4OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OTpcbiAgICAgICAgICAgICAgICAgICAgJCRbJDAgLSAxXS5wdXNoKCQkWyQwXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDgzOlxuICAgICAgICAgICAgICAgICAgICAkJFskMCAtIDFdLnB1c2goJCRbJDBdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA4NjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gW107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODc6XG4gICAgICAgICAgICAgICAgICAgICQkWyQwIC0gMV0ucHVzaCgkJFskMF0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDkwOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA5MTpcbiAgICAgICAgICAgICAgICAgICAgJCRbJDAgLSAxXS5wdXNoKCQkWyQwXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgOTQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDk1OlxuICAgICAgICAgICAgICAgICAgICAkJFskMCAtIDFdLnB1c2goJCRbJDBdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA5ODpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gWyQkWyQwXV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgOTk6XG4gICAgICAgICAgICAgICAgICAgICQkWyQwIC0gMV0ucHVzaCgkJFskMF0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEwMDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gWyQkWyQwXV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTAxOlxuICAgICAgICAgICAgICAgICAgICAkJFskMCAtIDFdLnB1c2goJCRbJDBdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRhYmxlOiBbeyAzOiAxLCA0OiAyLCA1OiBbMiwgNDZdLCA2OiAzLCAxNDogWzIsIDQ2XSwgMTU6IFsyLCA0Nl0sIDE5OiBbMiwgNDZdLCAyOTogWzIsIDQ2XSwgMzQ6IFsyLCA0Nl0sIDQ4OiBbMiwgNDZdLCA1MTogWzIsIDQ2XSwgNTU6IFsyLCA0Nl0sIDYwOiBbMiwgNDZdIH0sIHsgMTogWzNdIH0sIHsgNTogWzEsIDRdIH0sIHsgNTogWzIsIDJdLCA3OiA1LCA4OiA2LCA5OiA3LCAxMDogOCwgMTE6IDksIDEyOiAxMCwgMTM6IDExLCAxNDogWzEsIDEyXSwgMTU6IFsxLCAyMF0sIDE2OiAxNywgMTk6IFsxLCAyM10sIDI0OiAxNSwgMjc6IDE2LCAyOTogWzEsIDIxXSwgMzQ6IFsxLCAyMl0sIDM5OiBbMiwgMl0sIDQ0OiBbMiwgMl0sIDQ3OiBbMiwgMl0sIDQ4OiBbMSwgMTNdLCA1MTogWzEsIDE0XSwgNTU6IFsxLCAxOF0sIDU5OiAxOSwgNjA6IFsxLCAyNF0gfSwgeyAxOiBbMiwgMV0gfSwgeyA1OiBbMiwgNDddLCAxNDogWzIsIDQ3XSwgMTU6IFsyLCA0N10sIDE5OiBbMiwgNDddLCAyOTogWzIsIDQ3XSwgMzQ6IFsyLCA0N10sIDM5OiBbMiwgNDddLCA0NDogWzIsIDQ3XSwgNDc6IFsyLCA0N10sIDQ4OiBbMiwgNDddLCA1MTogWzIsIDQ3XSwgNTU6IFsyLCA0N10sIDYwOiBbMiwgNDddIH0sIHsgNTogWzIsIDNdLCAxNDogWzIsIDNdLCAxNTogWzIsIDNdLCAxOTogWzIsIDNdLCAyOTogWzIsIDNdLCAzNDogWzIsIDNdLCAzOTogWzIsIDNdLCA0NDogWzIsIDNdLCA0NzogWzIsIDNdLCA0ODogWzIsIDNdLCA1MTogWzIsIDNdLCA1NTogWzIsIDNdLCA2MDogWzIsIDNdIH0sIHsgNTogWzIsIDRdLCAxNDogWzIsIDRdLCAxNTogWzIsIDRdLCAxOTogWzIsIDRdLCAyOTogWzIsIDRdLCAzNDogWzIsIDRdLCAzOTogWzIsIDRdLCA0NDogWzIsIDRdLCA0NzogWzIsIDRdLCA0ODogWzIsIDRdLCA1MTogWzIsIDRdLCA1NTogWzIsIDRdLCA2MDogWzIsIDRdIH0sIHsgNTogWzIsIDVdLCAxNDogWzIsIDVdLCAxNTogWzIsIDVdLCAxOTogWzIsIDVdLCAyOTogWzIsIDVdLCAzNDogWzIsIDVdLCAzOTogWzIsIDVdLCA0NDogWzIsIDVdLCA0NzogWzIsIDVdLCA0ODogWzIsIDVdLCA1MTogWzIsIDVdLCA1NTogWzIsIDVdLCA2MDogWzIsIDVdIH0sIHsgNTogWzIsIDZdLCAxNDogWzIsIDZdLCAxNTogWzIsIDZdLCAxOTogWzIsIDZdLCAyOTogWzIsIDZdLCAzNDogWzIsIDZdLCAzOTogWzIsIDZdLCA0NDogWzIsIDZdLCA0NzogWzIsIDZdLCA0ODogWzIsIDZdLCA1MTogWzIsIDZdLCA1NTogWzIsIDZdLCA2MDogWzIsIDZdIH0sIHsgNTogWzIsIDddLCAxNDogWzIsIDddLCAxNTogWzIsIDddLCAxOTogWzIsIDddLCAyOTogWzIsIDddLCAzNDogWzIsIDddLCAzOTogWzIsIDddLCA0NDogWzIsIDddLCA0NzogWzIsIDddLCA0ODogWzIsIDddLCA1MTogWzIsIDddLCA1NTogWzIsIDddLCA2MDogWzIsIDddIH0sIHsgNTogWzIsIDhdLCAxNDogWzIsIDhdLCAxNTogWzIsIDhdLCAxOTogWzIsIDhdLCAyOTogWzIsIDhdLCAzNDogWzIsIDhdLCAzOTogWzIsIDhdLCA0NDogWzIsIDhdLCA0NzogWzIsIDhdLCA0ODogWzIsIDhdLCA1MTogWzIsIDhdLCA1NTogWzIsIDhdLCA2MDogWzIsIDhdIH0sIHsgNTogWzIsIDldLCAxNDogWzIsIDldLCAxNTogWzIsIDldLCAxOTogWzIsIDldLCAyOTogWzIsIDldLCAzNDogWzIsIDldLCAzOTogWzIsIDldLCA0NDogWzIsIDldLCA0NzogWzIsIDldLCA0ODogWzIsIDldLCA1MTogWzIsIDldLCA1NTogWzIsIDldLCA2MDogWzIsIDldIH0sIHsgMjA6IDI1LCA3MjogWzEsIDM1XSwgNzg6IDI2LCA3OTogMjcsIDgwOiBbMSwgMjhdLCA4MTogWzEsIDI5XSwgODI6IFsxLCAzMF0sIDgzOiBbMSwgMzFdLCA4NDogWzEsIDMyXSwgODU6IFsxLCAzNF0sIDg2OiAzMyB9LCB7IDIwOiAzNiwgNzI6IFsxLCAzNV0sIDc4OiAyNiwgNzk6IDI3LCA4MDogWzEsIDI4XSwgODE6IFsxLCAyOV0sIDgyOiBbMSwgMzBdLCA4MzogWzEsIDMxXSwgODQ6IFsxLCAzMl0sIDg1OiBbMSwgMzRdLCA4NjogMzMgfSwgeyA0OiAzNywgNjogMywgMTQ6IFsyLCA0Nl0sIDE1OiBbMiwgNDZdLCAxOTogWzIsIDQ2XSwgMjk6IFsyLCA0Nl0sIDM0OiBbMiwgNDZdLCAzOTogWzIsIDQ2XSwgNDQ6IFsyLCA0Nl0sIDQ3OiBbMiwgNDZdLCA0ODogWzIsIDQ2XSwgNTE6IFsyLCA0Nl0sIDU1OiBbMiwgNDZdLCA2MDogWzIsIDQ2XSB9LCB7IDQ6IDM4LCA2OiAzLCAxNDogWzIsIDQ2XSwgMTU6IFsyLCA0Nl0sIDE5OiBbMiwgNDZdLCAyOTogWzIsIDQ2XSwgMzQ6IFsyLCA0Nl0sIDQ0OiBbMiwgNDZdLCA0NzogWzIsIDQ2XSwgNDg6IFsyLCA0Nl0sIDUxOiBbMiwgNDZdLCA1NTogWzIsIDQ2XSwgNjA6IFsyLCA0Nl0gfSwgeyAxMzogNDAsIDE1OiBbMSwgMjBdLCAxNzogMzkgfSwgeyAyMDogNDIsIDU2OiA0MSwgNjQ6IDQzLCA2NTogWzEsIDQ0XSwgNzI6IFsxLCAzNV0sIDc4OiAyNiwgNzk6IDI3LCA4MDogWzEsIDI4XSwgODE6IFsxLCAyOV0sIDgyOiBbMSwgMzBdLCA4MzogWzEsIDMxXSwgODQ6IFsxLCAzMl0sIDg1OiBbMSwgMzRdLCA4NjogMzMgfSwgeyA0OiA0NSwgNjogMywgMTQ6IFsyLCA0Nl0sIDE1OiBbMiwgNDZdLCAxOTogWzIsIDQ2XSwgMjk6IFsyLCA0Nl0sIDM0OiBbMiwgNDZdLCA0NzogWzIsIDQ2XSwgNDg6IFsyLCA0Nl0sIDUxOiBbMiwgNDZdLCA1NTogWzIsIDQ2XSwgNjA6IFsyLCA0Nl0gfSwgeyA1OiBbMiwgMTBdLCAxNDogWzIsIDEwXSwgMTU6IFsyLCAxMF0sIDE4OiBbMiwgMTBdLCAxOTogWzIsIDEwXSwgMjk6IFsyLCAxMF0sIDM0OiBbMiwgMTBdLCAzOTogWzIsIDEwXSwgNDQ6IFsyLCAxMF0sIDQ3OiBbMiwgMTBdLCA0ODogWzIsIDEwXSwgNTE6IFsyLCAxMF0sIDU1OiBbMiwgMTBdLCA2MDogWzIsIDEwXSB9LCB7IDIwOiA0NiwgNzI6IFsxLCAzNV0sIDc4OiAyNiwgNzk6IDI3LCA4MDogWzEsIDI4XSwgODE6IFsxLCAyOV0sIDgyOiBbMSwgMzBdLCA4MzogWzEsIDMxXSwgODQ6IFsxLCAzMl0sIDg1OiBbMSwgMzRdLCA4NjogMzMgfSwgeyAyMDogNDcsIDcyOiBbMSwgMzVdLCA3ODogMjYsIDc5OiAyNywgODA6IFsxLCAyOF0sIDgxOiBbMSwgMjldLCA4MjogWzEsIDMwXSwgODM6IFsxLCAzMV0sIDg0OiBbMSwgMzJdLCA4NTogWzEsIDM0XSwgODY6IDMzIH0sIHsgMjA6IDQ4LCA3MjogWzEsIDM1XSwgNzg6IDI2LCA3OTogMjcsIDgwOiBbMSwgMjhdLCA4MTogWzEsIDI5XSwgODI6IFsxLCAzMF0sIDgzOiBbMSwgMzFdLCA4NDogWzEsIDMyXSwgODU6IFsxLCAzNF0sIDg2OiAzMyB9LCB7IDIwOiA0MiwgNTY6IDQ5LCA2NDogNDMsIDY1OiBbMSwgNDRdLCA3MjogWzEsIDM1XSwgNzg6IDI2LCA3OTogMjcsIDgwOiBbMSwgMjhdLCA4MTogWzEsIDI5XSwgODI6IFsxLCAzMF0sIDgzOiBbMSwgMzFdLCA4NDogWzEsIDMyXSwgODU6IFsxLCAzNF0sIDg2OiAzMyB9LCB7IDMzOiBbMiwgNzhdLCA0OTogNTAsIDY1OiBbMiwgNzhdLCA3MjogWzIsIDc4XSwgODA6IFsyLCA3OF0sIDgxOiBbMiwgNzhdLCA4MjogWzIsIDc4XSwgODM6IFsyLCA3OF0sIDg0OiBbMiwgNzhdLCA4NTogWzIsIDc4XSB9LCB7IDIzOiBbMiwgMzNdLCAzMzogWzIsIDMzXSwgNTQ6IFsyLCAzM10sIDY1OiBbMiwgMzNdLCA2ODogWzIsIDMzXSwgNzI6IFsyLCAzM10sIDc1OiBbMiwgMzNdLCA4MDogWzIsIDMzXSwgODE6IFsyLCAzM10sIDgyOiBbMiwgMzNdLCA4MzogWzIsIDMzXSwgODQ6IFsyLCAzM10sIDg1OiBbMiwgMzNdIH0sIHsgMjM6IFsyLCAzNF0sIDMzOiBbMiwgMzRdLCA1NDogWzIsIDM0XSwgNjU6IFsyLCAzNF0sIDY4OiBbMiwgMzRdLCA3MjogWzIsIDM0XSwgNzU6IFsyLCAzNF0sIDgwOiBbMiwgMzRdLCA4MTogWzIsIDM0XSwgODI6IFsyLCAzNF0sIDgzOiBbMiwgMzRdLCA4NDogWzIsIDM0XSwgODU6IFsyLCAzNF0gfSwgeyAyMzogWzIsIDM1XSwgMzM6IFsyLCAzNV0sIDU0OiBbMiwgMzVdLCA2NTogWzIsIDM1XSwgNjg6IFsyLCAzNV0sIDcyOiBbMiwgMzVdLCA3NTogWzIsIDM1XSwgODA6IFsyLCAzNV0sIDgxOiBbMiwgMzVdLCA4MjogWzIsIDM1XSwgODM6IFsyLCAzNV0sIDg0OiBbMiwgMzVdLCA4NTogWzIsIDM1XSB9LCB7IDIzOiBbMiwgMzZdLCAzMzogWzIsIDM2XSwgNTQ6IFsyLCAzNl0sIDY1OiBbMiwgMzZdLCA2ODogWzIsIDM2XSwgNzI6IFsyLCAzNl0sIDc1OiBbMiwgMzZdLCA4MDogWzIsIDM2XSwgODE6IFsyLCAzNl0sIDgyOiBbMiwgMzZdLCA4MzogWzIsIDM2XSwgODQ6IFsyLCAzNl0sIDg1OiBbMiwgMzZdIH0sIHsgMjM6IFsyLCAzN10sIDMzOiBbMiwgMzddLCA1NDogWzIsIDM3XSwgNjU6IFsyLCAzN10sIDY4OiBbMiwgMzddLCA3MjogWzIsIDM3XSwgNzU6IFsyLCAzN10sIDgwOiBbMiwgMzddLCA4MTogWzIsIDM3XSwgODI6IFsyLCAzN10sIDgzOiBbMiwgMzddLCA4NDogWzIsIDM3XSwgODU6IFsyLCAzN10gfSwgeyAyMzogWzIsIDM4XSwgMzM6IFsyLCAzOF0sIDU0OiBbMiwgMzhdLCA2NTogWzIsIDM4XSwgNjg6IFsyLCAzOF0sIDcyOiBbMiwgMzhdLCA3NTogWzIsIDM4XSwgODA6IFsyLCAzOF0sIDgxOiBbMiwgMzhdLCA4MjogWzIsIDM4XSwgODM6IFsyLCAzOF0sIDg0OiBbMiwgMzhdLCA4NTogWzIsIDM4XSB9LCB7IDIzOiBbMiwgMzldLCAzMzogWzIsIDM5XSwgNTQ6IFsyLCAzOV0sIDY1OiBbMiwgMzldLCA2ODogWzIsIDM5XSwgNzI6IFsyLCAzOV0sIDc1OiBbMiwgMzldLCA4MDogWzIsIDM5XSwgODE6IFsyLCAzOV0sIDgyOiBbMiwgMzldLCA4MzogWzIsIDM5XSwgODQ6IFsyLCAzOV0sIDg1OiBbMiwgMzldIH0sIHsgMjM6IFsyLCA0M10sIDMzOiBbMiwgNDNdLCA1NDogWzIsIDQzXSwgNjU6IFsyLCA0M10sIDY4OiBbMiwgNDNdLCA3MjogWzIsIDQzXSwgNzU6IFsyLCA0M10sIDgwOiBbMiwgNDNdLCA4MTogWzIsIDQzXSwgODI6IFsyLCA0M10sIDgzOiBbMiwgNDNdLCA4NDogWzIsIDQzXSwgODU6IFsyLCA0M10sIDg3OiBbMSwgNTFdIH0sIHsgNzI6IFsxLCAzNV0sIDg2OiA1MiB9LCB7IDIzOiBbMiwgNDVdLCAzMzogWzIsIDQ1XSwgNTQ6IFsyLCA0NV0sIDY1OiBbMiwgNDVdLCA2ODogWzIsIDQ1XSwgNzI6IFsyLCA0NV0sIDc1OiBbMiwgNDVdLCA4MDogWzIsIDQ1XSwgODE6IFsyLCA0NV0sIDgyOiBbMiwgNDVdLCA4MzogWzIsIDQ1XSwgODQ6IFsyLCA0NV0sIDg1OiBbMiwgNDVdLCA4NzogWzIsIDQ1XSB9LCB7IDUyOiA1MywgNTQ6IFsyLCA4Ml0sIDY1OiBbMiwgODJdLCA3MjogWzIsIDgyXSwgODA6IFsyLCA4Ml0sIDgxOiBbMiwgODJdLCA4MjogWzIsIDgyXSwgODM6IFsyLCA4Ml0sIDg0OiBbMiwgODJdLCA4NTogWzIsIDgyXSB9LCB7IDI1OiA1NCwgMzg6IDU2LCAzOTogWzEsIDU4XSwgNDM6IDU3LCA0NDogWzEsIDU5XSwgNDU6IDU1LCA0NzogWzIsIDU0XSB9LCB7IDI4OiA2MCwgNDM6IDYxLCA0NDogWzEsIDU5XSwgNDc6IFsyLCA1Nl0gfSwgeyAxMzogNjMsIDE1OiBbMSwgMjBdLCAxODogWzEsIDYyXSB9LCB7IDE1OiBbMiwgNDhdLCAxODogWzIsIDQ4XSB9LCB7IDMzOiBbMiwgODZdLCA1NzogNjQsIDY1OiBbMiwgODZdLCA3MjogWzIsIDg2XSwgODA6IFsyLCA4Nl0sIDgxOiBbMiwgODZdLCA4MjogWzIsIDg2XSwgODM6IFsyLCA4Nl0sIDg0OiBbMiwgODZdLCA4NTogWzIsIDg2XSB9LCB7IDMzOiBbMiwgNDBdLCA2NTogWzIsIDQwXSwgNzI6IFsyLCA0MF0sIDgwOiBbMiwgNDBdLCA4MTogWzIsIDQwXSwgODI6IFsyLCA0MF0sIDgzOiBbMiwgNDBdLCA4NDogWzIsIDQwXSwgODU6IFsyLCA0MF0gfSwgeyAzMzogWzIsIDQxXSwgNjU6IFsyLCA0MV0sIDcyOiBbMiwgNDFdLCA4MDogWzIsIDQxXSwgODE6IFsyLCA0MV0sIDgyOiBbMiwgNDFdLCA4MzogWzIsIDQxXSwgODQ6IFsyLCA0MV0sIDg1OiBbMiwgNDFdIH0sIHsgMjA6IDY1LCA3MjogWzEsIDM1XSwgNzg6IDI2LCA3OTogMjcsIDgwOiBbMSwgMjhdLCA4MTogWzEsIDI5XSwgODI6IFsxLCAzMF0sIDgzOiBbMSwgMzFdLCA4NDogWzEsIDMyXSwgODU6IFsxLCAzNF0sIDg2OiAzMyB9LCB7IDI2OiA2NiwgNDc6IFsxLCA2N10gfSwgeyAzMDogNjgsIDMzOiBbMiwgNThdLCA2NTogWzIsIDU4XSwgNzI6IFsyLCA1OF0sIDc1OiBbMiwgNThdLCA4MDogWzIsIDU4XSwgODE6IFsyLCA1OF0sIDgyOiBbMiwgNThdLCA4MzogWzIsIDU4XSwgODQ6IFsyLCA1OF0sIDg1OiBbMiwgNThdIH0sIHsgMzM6IFsyLCA2NF0sIDM1OiA2OSwgNjU6IFsyLCA2NF0sIDcyOiBbMiwgNjRdLCA3NTogWzIsIDY0XSwgODA6IFsyLCA2NF0sIDgxOiBbMiwgNjRdLCA4MjogWzIsIDY0XSwgODM6IFsyLCA2NF0sIDg0OiBbMiwgNjRdLCA4NTogWzIsIDY0XSB9LCB7IDIxOiA3MCwgMjM6IFsyLCA1MF0sIDY1OiBbMiwgNTBdLCA3MjogWzIsIDUwXSwgODA6IFsyLCA1MF0sIDgxOiBbMiwgNTBdLCA4MjogWzIsIDUwXSwgODM6IFsyLCA1MF0sIDg0OiBbMiwgNTBdLCA4NTogWzIsIDUwXSB9LCB7IDMzOiBbMiwgOTBdLCA2MTogNzEsIDY1OiBbMiwgOTBdLCA3MjogWzIsIDkwXSwgODA6IFsyLCA5MF0sIDgxOiBbMiwgOTBdLCA4MjogWzIsIDkwXSwgODM6IFsyLCA5MF0sIDg0OiBbMiwgOTBdLCA4NTogWzIsIDkwXSB9LCB7IDIwOiA3NSwgMzM6IFsyLCA4MF0sIDUwOiA3MiwgNjM6IDczLCA2NDogNzYsIDY1OiBbMSwgNDRdLCA2OTogNzQsIDcwOiA3NywgNzE6IDc4LCA3MjogWzEsIDc5XSwgNzg6IDI2LCA3OTogMjcsIDgwOiBbMSwgMjhdLCA4MTogWzEsIDI5XSwgODI6IFsxLCAzMF0sIDgzOiBbMSwgMzFdLCA4NDogWzEsIDMyXSwgODU6IFsxLCAzNF0sIDg2OiAzMyB9LCB7IDcyOiBbMSwgODBdIH0sIHsgMjM6IFsyLCA0Ml0sIDMzOiBbMiwgNDJdLCA1NDogWzIsIDQyXSwgNjU6IFsyLCA0Ml0sIDY4OiBbMiwgNDJdLCA3MjogWzIsIDQyXSwgNzU6IFsyLCA0Ml0sIDgwOiBbMiwgNDJdLCA4MTogWzIsIDQyXSwgODI6IFsyLCA0Ml0sIDgzOiBbMiwgNDJdLCA4NDogWzIsIDQyXSwgODU6IFsyLCA0Ml0sIDg3OiBbMSwgNTFdIH0sIHsgMjA6IDc1LCA1MzogODEsIDU0OiBbMiwgODRdLCA2MzogODIsIDY0OiA3NiwgNjU6IFsxLCA0NF0sIDY5OiA4MywgNzA6IDc3LCA3MTogNzgsIDcyOiBbMSwgNzldLCA3ODogMjYsIDc5OiAyNywgODA6IFsxLCAyOF0sIDgxOiBbMSwgMjldLCA4MjogWzEsIDMwXSwgODM6IFsxLCAzMV0sIDg0OiBbMSwgMzJdLCA4NTogWzEsIDM0XSwgODY6IDMzIH0sIHsgMjY6IDg0LCA0NzogWzEsIDY3XSB9LCB7IDQ3OiBbMiwgNTVdIH0sIHsgNDogODUsIDY6IDMsIDE0OiBbMiwgNDZdLCAxNTogWzIsIDQ2XSwgMTk6IFsyLCA0Nl0sIDI5OiBbMiwgNDZdLCAzNDogWzIsIDQ2XSwgMzk6IFsyLCA0Nl0sIDQ0OiBbMiwgNDZdLCA0NzogWzIsIDQ2XSwgNDg6IFsyLCA0Nl0sIDUxOiBbMiwgNDZdLCA1NTogWzIsIDQ2XSwgNjA6IFsyLCA0Nl0gfSwgeyA0NzogWzIsIDIwXSB9LCB7IDIwOiA4NiwgNzI6IFsxLCAzNV0sIDc4OiAyNiwgNzk6IDI3LCA4MDogWzEsIDI4XSwgODE6IFsxLCAyOV0sIDgyOiBbMSwgMzBdLCA4MzogWzEsIDMxXSwgODQ6IFsxLCAzMl0sIDg1OiBbMSwgMzRdLCA4NjogMzMgfSwgeyA0OiA4NywgNjogMywgMTQ6IFsyLCA0Nl0sIDE1OiBbMiwgNDZdLCAxOTogWzIsIDQ2XSwgMjk6IFsyLCA0Nl0sIDM0OiBbMiwgNDZdLCA0NzogWzIsIDQ2XSwgNDg6IFsyLCA0Nl0sIDUxOiBbMiwgNDZdLCA1NTogWzIsIDQ2XSwgNjA6IFsyLCA0Nl0gfSwgeyAyNjogODgsIDQ3OiBbMSwgNjddIH0sIHsgNDc6IFsyLCA1N10gfSwgeyA1OiBbMiwgMTFdLCAxNDogWzIsIDExXSwgMTU6IFsyLCAxMV0sIDE5OiBbMiwgMTFdLCAyOTogWzIsIDExXSwgMzQ6IFsyLCAxMV0sIDM5OiBbMiwgMTFdLCA0NDogWzIsIDExXSwgNDc6IFsyLCAxMV0sIDQ4OiBbMiwgMTFdLCA1MTogWzIsIDExXSwgNTU6IFsyLCAxMV0sIDYwOiBbMiwgMTFdIH0sIHsgMTU6IFsyLCA0OV0sIDE4OiBbMiwgNDldIH0sIHsgMjA6IDc1LCAzMzogWzIsIDg4XSwgNTg6IDg5LCA2MzogOTAsIDY0OiA3NiwgNjU6IFsxLCA0NF0sIDY5OiA5MSwgNzA6IDc3LCA3MTogNzgsIDcyOiBbMSwgNzldLCA3ODogMjYsIDc5OiAyNywgODA6IFsxLCAyOF0sIDgxOiBbMSwgMjldLCA4MjogWzEsIDMwXSwgODM6IFsxLCAzMV0sIDg0OiBbMSwgMzJdLCA4NTogWzEsIDM0XSwgODY6IDMzIH0sIHsgNjU6IFsyLCA5NF0sIDY2OiA5MiwgNjg6IFsyLCA5NF0sIDcyOiBbMiwgOTRdLCA4MDogWzIsIDk0XSwgODE6IFsyLCA5NF0sIDgyOiBbMiwgOTRdLCA4MzogWzIsIDk0XSwgODQ6IFsyLCA5NF0sIDg1OiBbMiwgOTRdIH0sIHsgNTogWzIsIDI1XSwgMTQ6IFsyLCAyNV0sIDE1OiBbMiwgMjVdLCAxOTogWzIsIDI1XSwgMjk6IFsyLCAyNV0sIDM0OiBbMiwgMjVdLCAzOTogWzIsIDI1XSwgNDQ6IFsyLCAyNV0sIDQ3OiBbMiwgMjVdLCA0ODogWzIsIDI1XSwgNTE6IFsyLCAyNV0sIDU1OiBbMiwgMjVdLCA2MDogWzIsIDI1XSB9LCB7IDIwOiA5MywgNzI6IFsxLCAzNV0sIDc4OiAyNiwgNzk6IDI3LCA4MDogWzEsIDI4XSwgODE6IFsxLCAyOV0sIDgyOiBbMSwgMzBdLCA4MzogWzEsIDMxXSwgODQ6IFsxLCAzMl0sIDg1OiBbMSwgMzRdLCA4NjogMzMgfSwgeyAyMDogNzUsIDMxOiA5NCwgMzM6IFsyLCA2MF0sIDYzOiA5NSwgNjQ6IDc2LCA2NTogWzEsIDQ0XSwgNjk6IDk2LCA3MDogNzcsIDcxOiA3OCwgNzI6IFsxLCA3OV0sIDc1OiBbMiwgNjBdLCA3ODogMjYsIDc5OiAyNywgODA6IFsxLCAyOF0sIDgxOiBbMSwgMjldLCA4MjogWzEsIDMwXSwgODM6IFsxLCAzMV0sIDg0OiBbMSwgMzJdLCA4NTogWzEsIDM0XSwgODY6IDMzIH0sIHsgMjA6IDc1LCAzMzogWzIsIDY2XSwgMzY6IDk3LCA2MzogOTgsIDY0OiA3NiwgNjU6IFsxLCA0NF0sIDY5OiA5OSwgNzA6IDc3LCA3MTogNzgsIDcyOiBbMSwgNzldLCA3NTogWzIsIDY2XSwgNzg6IDI2LCA3OTogMjcsIDgwOiBbMSwgMjhdLCA4MTogWzEsIDI5XSwgODI6IFsxLCAzMF0sIDgzOiBbMSwgMzFdLCA4NDogWzEsIDMyXSwgODU6IFsxLCAzNF0sIDg2OiAzMyB9LCB7IDIwOiA3NSwgMjI6IDEwMCwgMjM6IFsyLCA1Ml0sIDYzOiAxMDEsIDY0OiA3NiwgNjU6IFsxLCA0NF0sIDY5OiAxMDIsIDcwOiA3NywgNzE6IDc4LCA3MjogWzEsIDc5XSwgNzg6IDI2LCA3OTogMjcsIDgwOiBbMSwgMjhdLCA4MTogWzEsIDI5XSwgODI6IFsxLCAzMF0sIDgzOiBbMSwgMzFdLCA4NDogWzEsIDMyXSwgODU6IFsxLCAzNF0sIDg2OiAzMyB9LCB7IDIwOiA3NSwgMzM6IFsyLCA5Ml0sIDYyOiAxMDMsIDYzOiAxMDQsIDY0OiA3NiwgNjU6IFsxLCA0NF0sIDY5OiAxMDUsIDcwOiA3NywgNzE6IDc4LCA3MjogWzEsIDc5XSwgNzg6IDI2LCA3OTogMjcsIDgwOiBbMSwgMjhdLCA4MTogWzEsIDI5XSwgODI6IFsxLCAzMF0sIDgzOiBbMSwgMzFdLCA4NDogWzEsIDMyXSwgODU6IFsxLCAzNF0sIDg2OiAzMyB9LCB7IDMzOiBbMSwgMTA2XSB9LCB7IDMzOiBbMiwgNzldLCA2NTogWzIsIDc5XSwgNzI6IFsyLCA3OV0sIDgwOiBbMiwgNzldLCA4MTogWzIsIDc5XSwgODI6IFsyLCA3OV0sIDgzOiBbMiwgNzldLCA4NDogWzIsIDc5XSwgODU6IFsyLCA3OV0gfSwgeyAzMzogWzIsIDgxXSB9LCB7IDIzOiBbMiwgMjddLCAzMzogWzIsIDI3XSwgNTQ6IFsyLCAyN10sIDY1OiBbMiwgMjddLCA2ODogWzIsIDI3XSwgNzI6IFsyLCAyN10sIDc1OiBbMiwgMjddLCA4MDogWzIsIDI3XSwgODE6IFsyLCAyN10sIDgyOiBbMiwgMjddLCA4MzogWzIsIDI3XSwgODQ6IFsyLCAyN10sIDg1OiBbMiwgMjddIH0sIHsgMjM6IFsyLCAyOF0sIDMzOiBbMiwgMjhdLCA1NDogWzIsIDI4XSwgNjU6IFsyLCAyOF0sIDY4OiBbMiwgMjhdLCA3MjogWzIsIDI4XSwgNzU6IFsyLCAyOF0sIDgwOiBbMiwgMjhdLCA4MTogWzIsIDI4XSwgODI6IFsyLCAyOF0sIDgzOiBbMiwgMjhdLCA4NDogWzIsIDI4XSwgODU6IFsyLCAyOF0gfSwgeyAyMzogWzIsIDMwXSwgMzM6IFsyLCAzMF0sIDU0OiBbMiwgMzBdLCA2ODogWzIsIDMwXSwgNzE6IDEwNywgNzI6IFsxLCAxMDhdLCA3NTogWzIsIDMwXSB9LCB7IDIzOiBbMiwgOThdLCAzMzogWzIsIDk4XSwgNTQ6IFsyLCA5OF0sIDY4OiBbMiwgOThdLCA3MjogWzIsIDk4XSwgNzU6IFsyLCA5OF0gfSwgeyAyMzogWzIsIDQ1XSwgMzM6IFsyLCA0NV0sIDU0OiBbMiwgNDVdLCA2NTogWzIsIDQ1XSwgNjg6IFsyLCA0NV0sIDcyOiBbMiwgNDVdLCA3MzogWzEsIDEwOV0sIDc1OiBbMiwgNDVdLCA4MDogWzIsIDQ1XSwgODE6IFsyLCA0NV0sIDgyOiBbMiwgNDVdLCA4MzogWzIsIDQ1XSwgODQ6IFsyLCA0NV0sIDg1OiBbMiwgNDVdLCA4NzogWzIsIDQ1XSB9LCB7IDIzOiBbMiwgNDRdLCAzMzogWzIsIDQ0XSwgNTQ6IFsyLCA0NF0sIDY1OiBbMiwgNDRdLCA2ODogWzIsIDQ0XSwgNzI6IFsyLCA0NF0sIDc1OiBbMiwgNDRdLCA4MDogWzIsIDQ0XSwgODE6IFsyLCA0NF0sIDgyOiBbMiwgNDRdLCA4MzogWzIsIDQ0XSwgODQ6IFsyLCA0NF0sIDg1OiBbMiwgNDRdLCA4NzogWzIsIDQ0XSB9LCB7IDU0OiBbMSwgMTEwXSB9LCB7IDU0OiBbMiwgODNdLCA2NTogWzIsIDgzXSwgNzI6IFsyLCA4M10sIDgwOiBbMiwgODNdLCA4MTogWzIsIDgzXSwgODI6IFsyLCA4M10sIDgzOiBbMiwgODNdLCA4NDogWzIsIDgzXSwgODU6IFsyLCA4M10gfSwgeyA1NDogWzIsIDg1XSB9LCB7IDU6IFsyLCAxM10sIDE0OiBbMiwgMTNdLCAxNTogWzIsIDEzXSwgMTk6IFsyLCAxM10sIDI5OiBbMiwgMTNdLCAzNDogWzIsIDEzXSwgMzk6IFsyLCAxM10sIDQ0OiBbMiwgMTNdLCA0NzogWzIsIDEzXSwgNDg6IFsyLCAxM10sIDUxOiBbMiwgMTNdLCA1NTogWzIsIDEzXSwgNjA6IFsyLCAxM10gfSwgeyAzODogNTYsIDM5OiBbMSwgNThdLCA0MzogNTcsIDQ0OiBbMSwgNTldLCA0NTogMTEyLCA0NjogMTExLCA0NzogWzIsIDc2XSB9LCB7IDMzOiBbMiwgNzBdLCA0MDogMTEzLCA2NTogWzIsIDcwXSwgNzI6IFsyLCA3MF0sIDc1OiBbMiwgNzBdLCA4MDogWzIsIDcwXSwgODE6IFsyLCA3MF0sIDgyOiBbMiwgNzBdLCA4MzogWzIsIDcwXSwgODQ6IFsyLCA3MF0sIDg1OiBbMiwgNzBdIH0sIHsgNDc6IFsyLCAxOF0gfSwgeyA1OiBbMiwgMTRdLCAxNDogWzIsIDE0XSwgMTU6IFsyLCAxNF0sIDE5OiBbMiwgMTRdLCAyOTogWzIsIDE0XSwgMzQ6IFsyLCAxNF0sIDM5OiBbMiwgMTRdLCA0NDogWzIsIDE0XSwgNDc6IFsyLCAxNF0sIDQ4OiBbMiwgMTRdLCA1MTogWzIsIDE0XSwgNTU6IFsyLCAxNF0sIDYwOiBbMiwgMTRdIH0sIHsgMzM6IFsxLCAxMTRdIH0sIHsgMzM6IFsyLCA4N10sIDY1OiBbMiwgODddLCA3MjogWzIsIDg3XSwgODA6IFsyLCA4N10sIDgxOiBbMiwgODddLCA4MjogWzIsIDg3XSwgODM6IFsyLCA4N10sIDg0OiBbMiwgODddLCA4NTogWzIsIDg3XSB9LCB7IDMzOiBbMiwgODldIH0sIHsgMjA6IDc1LCA2MzogMTE2LCA2NDogNzYsIDY1OiBbMSwgNDRdLCA2NzogMTE1LCA2ODogWzIsIDk2XSwgNjk6IDExNywgNzA6IDc3LCA3MTogNzgsIDcyOiBbMSwgNzldLCA3ODogMjYsIDc5OiAyNywgODA6IFsxLCAyOF0sIDgxOiBbMSwgMjldLCA4MjogWzEsIDMwXSwgODM6IFsxLCAzMV0sIDg0OiBbMSwgMzJdLCA4NTogWzEsIDM0XSwgODY6IDMzIH0sIHsgMzM6IFsxLCAxMThdIH0sIHsgMzI6IDExOSwgMzM6IFsyLCA2Ml0sIDc0OiAxMjAsIDc1OiBbMSwgMTIxXSB9LCB7IDMzOiBbMiwgNTldLCA2NTogWzIsIDU5XSwgNzI6IFsyLCA1OV0sIDc1OiBbMiwgNTldLCA4MDogWzIsIDU5XSwgODE6IFsyLCA1OV0sIDgyOiBbMiwgNTldLCA4MzogWzIsIDU5XSwgODQ6IFsyLCA1OV0sIDg1OiBbMiwgNTldIH0sIHsgMzM6IFsyLCA2MV0sIDc1OiBbMiwgNjFdIH0sIHsgMzM6IFsyLCA2OF0sIDM3OiAxMjIsIDc0OiAxMjMsIDc1OiBbMSwgMTIxXSB9LCB7IDMzOiBbMiwgNjVdLCA2NTogWzIsIDY1XSwgNzI6IFsyLCA2NV0sIDc1OiBbMiwgNjVdLCA4MDogWzIsIDY1XSwgODE6IFsyLCA2NV0sIDgyOiBbMiwgNjVdLCA4MzogWzIsIDY1XSwgODQ6IFsyLCA2NV0sIDg1OiBbMiwgNjVdIH0sIHsgMzM6IFsyLCA2N10sIDc1OiBbMiwgNjddIH0sIHsgMjM6IFsxLCAxMjRdIH0sIHsgMjM6IFsyLCA1MV0sIDY1OiBbMiwgNTFdLCA3MjogWzIsIDUxXSwgODA6IFsyLCA1MV0sIDgxOiBbMiwgNTFdLCA4MjogWzIsIDUxXSwgODM6IFsyLCA1MV0sIDg0OiBbMiwgNTFdLCA4NTogWzIsIDUxXSB9LCB7IDIzOiBbMiwgNTNdIH0sIHsgMzM6IFsxLCAxMjVdIH0sIHsgMzM6IFsyLCA5MV0sIDY1OiBbMiwgOTFdLCA3MjogWzIsIDkxXSwgODA6IFsyLCA5MV0sIDgxOiBbMiwgOTFdLCA4MjogWzIsIDkxXSwgODM6IFsyLCA5MV0sIDg0OiBbMiwgOTFdLCA4NTogWzIsIDkxXSB9LCB7IDMzOiBbMiwgOTNdIH0sIHsgNTogWzIsIDIyXSwgMTQ6IFsyLCAyMl0sIDE1OiBbMiwgMjJdLCAxOTogWzIsIDIyXSwgMjk6IFsyLCAyMl0sIDM0OiBbMiwgMjJdLCAzOTogWzIsIDIyXSwgNDQ6IFsyLCAyMl0sIDQ3OiBbMiwgMjJdLCA0ODogWzIsIDIyXSwgNTE6IFsyLCAyMl0sIDU1OiBbMiwgMjJdLCA2MDogWzIsIDIyXSB9LCB7IDIzOiBbMiwgOTldLCAzMzogWzIsIDk5XSwgNTQ6IFsyLCA5OV0sIDY4OiBbMiwgOTldLCA3MjogWzIsIDk5XSwgNzU6IFsyLCA5OV0gfSwgeyA3MzogWzEsIDEwOV0gfSwgeyAyMDogNzUsIDYzOiAxMjYsIDY0OiA3NiwgNjU6IFsxLCA0NF0sIDcyOiBbMSwgMzVdLCA3ODogMjYsIDc5OiAyNywgODA6IFsxLCAyOF0sIDgxOiBbMSwgMjldLCA4MjogWzEsIDMwXSwgODM6IFsxLCAzMV0sIDg0OiBbMSwgMzJdLCA4NTogWzEsIDM0XSwgODY6IDMzIH0sIHsgNTogWzIsIDIzXSwgMTQ6IFsyLCAyM10sIDE1OiBbMiwgMjNdLCAxOTogWzIsIDIzXSwgMjk6IFsyLCAyM10sIDM0OiBbMiwgMjNdLCAzOTogWzIsIDIzXSwgNDQ6IFsyLCAyM10sIDQ3OiBbMiwgMjNdLCA0ODogWzIsIDIzXSwgNTE6IFsyLCAyM10sIDU1OiBbMiwgMjNdLCA2MDogWzIsIDIzXSB9LCB7IDQ3OiBbMiwgMTldIH0sIHsgNDc6IFsyLCA3N10gfSwgeyAyMDogNzUsIDMzOiBbMiwgNzJdLCA0MTogMTI3LCA2MzogMTI4LCA2NDogNzYsIDY1OiBbMSwgNDRdLCA2OTogMTI5LCA3MDogNzcsIDcxOiA3OCwgNzI6IFsxLCA3OV0sIDc1OiBbMiwgNzJdLCA3ODogMjYsIDc5OiAyNywgODA6IFsxLCAyOF0sIDgxOiBbMSwgMjldLCA4MjogWzEsIDMwXSwgODM6IFsxLCAzMV0sIDg0OiBbMSwgMzJdLCA4NTogWzEsIDM0XSwgODY6IDMzIH0sIHsgNTogWzIsIDI0XSwgMTQ6IFsyLCAyNF0sIDE1OiBbMiwgMjRdLCAxOTogWzIsIDI0XSwgMjk6IFsyLCAyNF0sIDM0OiBbMiwgMjRdLCAzOTogWzIsIDI0XSwgNDQ6IFsyLCAyNF0sIDQ3OiBbMiwgMjRdLCA0ODogWzIsIDI0XSwgNTE6IFsyLCAyNF0sIDU1OiBbMiwgMjRdLCA2MDogWzIsIDI0XSB9LCB7IDY4OiBbMSwgMTMwXSB9LCB7IDY1OiBbMiwgOTVdLCA2ODogWzIsIDk1XSwgNzI6IFsyLCA5NV0sIDgwOiBbMiwgOTVdLCA4MTogWzIsIDk1XSwgODI6IFsyLCA5NV0sIDgzOiBbMiwgOTVdLCA4NDogWzIsIDk1XSwgODU6IFsyLCA5NV0gfSwgeyA2ODogWzIsIDk3XSB9LCB7IDU6IFsyLCAyMV0sIDE0OiBbMiwgMjFdLCAxNTogWzIsIDIxXSwgMTk6IFsyLCAyMV0sIDI5OiBbMiwgMjFdLCAzNDogWzIsIDIxXSwgMzk6IFsyLCAyMV0sIDQ0OiBbMiwgMjFdLCA0NzogWzIsIDIxXSwgNDg6IFsyLCAyMV0sIDUxOiBbMiwgMjFdLCA1NTogWzIsIDIxXSwgNjA6IFsyLCAyMV0gfSwgeyAzMzogWzEsIDEzMV0gfSwgeyAzMzogWzIsIDYzXSB9LCB7IDcyOiBbMSwgMTMzXSwgNzY6IDEzMiB9LCB7IDMzOiBbMSwgMTM0XSB9LCB7IDMzOiBbMiwgNjldIH0sIHsgMTU6IFsyLCAxMl0gfSwgeyAxNDogWzIsIDI2XSwgMTU6IFsyLCAyNl0sIDE5OiBbMiwgMjZdLCAyOTogWzIsIDI2XSwgMzQ6IFsyLCAyNl0sIDQ3OiBbMiwgMjZdLCA0ODogWzIsIDI2XSwgNTE6IFsyLCAyNl0sIDU1OiBbMiwgMjZdLCA2MDogWzIsIDI2XSB9LCB7IDIzOiBbMiwgMzFdLCAzMzogWzIsIDMxXSwgNTQ6IFsyLCAzMV0sIDY4OiBbMiwgMzFdLCA3MjogWzIsIDMxXSwgNzU6IFsyLCAzMV0gfSwgeyAzMzogWzIsIDc0XSwgNDI6IDEzNSwgNzQ6IDEzNiwgNzU6IFsxLCAxMjFdIH0sIHsgMzM6IFsyLCA3MV0sIDY1OiBbMiwgNzFdLCA3MjogWzIsIDcxXSwgNzU6IFsyLCA3MV0sIDgwOiBbMiwgNzFdLCA4MTogWzIsIDcxXSwgODI6IFsyLCA3MV0sIDgzOiBbMiwgNzFdLCA4NDogWzIsIDcxXSwgODU6IFsyLCA3MV0gfSwgeyAzMzogWzIsIDczXSwgNzU6IFsyLCA3M10gfSwgeyAyMzogWzIsIDI5XSwgMzM6IFsyLCAyOV0sIDU0OiBbMiwgMjldLCA2NTogWzIsIDI5XSwgNjg6IFsyLCAyOV0sIDcyOiBbMiwgMjldLCA3NTogWzIsIDI5XSwgODA6IFsyLCAyOV0sIDgxOiBbMiwgMjldLCA4MjogWzIsIDI5XSwgODM6IFsyLCAyOV0sIDg0OiBbMiwgMjldLCA4NTogWzIsIDI5XSB9LCB7IDE0OiBbMiwgMTVdLCAxNTogWzIsIDE1XSwgMTk6IFsyLCAxNV0sIDI5OiBbMiwgMTVdLCAzNDogWzIsIDE1XSwgMzk6IFsyLCAxNV0sIDQ0OiBbMiwgMTVdLCA0NzogWzIsIDE1XSwgNDg6IFsyLCAxNV0sIDUxOiBbMiwgMTVdLCA1NTogWzIsIDE1XSwgNjA6IFsyLCAxNV0gfSwgeyA3MjogWzEsIDEzOF0sIDc3OiBbMSwgMTM3XSB9LCB7IDcyOiBbMiwgMTAwXSwgNzc6IFsyLCAxMDBdIH0sIHsgMTQ6IFsyLCAxNl0sIDE1OiBbMiwgMTZdLCAxOTogWzIsIDE2XSwgMjk6IFsyLCAxNl0sIDM0OiBbMiwgMTZdLCA0NDogWzIsIDE2XSwgNDc6IFsyLCAxNl0sIDQ4OiBbMiwgMTZdLCA1MTogWzIsIDE2XSwgNTU6IFsyLCAxNl0sIDYwOiBbMiwgMTZdIH0sIHsgMzM6IFsxLCAxMzldIH0sIHsgMzM6IFsyLCA3NV0gfSwgeyAzMzogWzIsIDMyXSB9LCB7IDcyOiBbMiwgMTAxXSwgNzc6IFsyLCAxMDFdIH0sIHsgMTQ6IFsyLCAxN10sIDE1OiBbMiwgMTddLCAxOTogWzIsIDE3XSwgMjk6IFsyLCAxN10sIDM0OiBbMiwgMTddLCAzOTogWzIsIDE3XSwgNDQ6IFsyLCAxN10sIDQ3OiBbMiwgMTddLCA0ODogWzIsIDE3XSwgNTE6IFsyLCAxN10sIDU1OiBbMiwgMTddLCA2MDogWzIsIDE3XSB9XSxcbiAgICAgICAgZGVmYXVsdEFjdGlvbnM6IHsgNDogWzIsIDFdLCA1NTogWzIsIDU1XSwgNTc6IFsyLCAyMF0sIDYxOiBbMiwgNTddLCA3NDogWzIsIDgxXSwgODM6IFsyLCA4NV0sIDg3OiBbMiwgMThdLCA5MTogWzIsIDg5XSwgMTAyOiBbMiwgNTNdLCAxMDU6IFsyLCA5M10sIDExMTogWzIsIDE5XSwgMTEyOiBbMiwgNzddLCAxMTc6IFsyLCA5N10sIDEyMDogWzIsIDYzXSwgMTIzOiBbMiwgNjldLCAxMjQ6IFsyLCAxMl0sIDEzNjogWzIsIDc1XSwgMTM3OiBbMiwgMzJdIH0sXG4gICAgICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uIHBhcnNlRXJyb3Ioc3RyLCBoYXNoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyKTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICAgICAgc3RhY2sgPSBbMF0sXG4gICAgICAgICAgICAgICAgdnN0YWNrID0gW251bGxdLFxuICAgICAgICAgICAgICAgIGxzdGFjayA9IFtdLFxuICAgICAgICAgICAgICAgIHRhYmxlID0gdGhpcy50YWJsZSxcbiAgICAgICAgICAgICAgICB5eXRleHQgPSBcIlwiLFxuICAgICAgICAgICAgICAgIHl5bGluZW5vID0gMCxcbiAgICAgICAgICAgICAgICB5eWxlbmcgPSAwLFxuICAgICAgICAgICAgICAgIHJlY292ZXJpbmcgPSAwLFxuICAgICAgICAgICAgICAgIFRFUlJPUiA9IDIsXG4gICAgICAgICAgICAgICAgRU9GID0gMTtcbiAgICAgICAgICAgIHRoaXMubGV4ZXIuc2V0SW5wdXQoaW5wdXQpO1xuICAgICAgICAgICAgdGhpcy5sZXhlci55eSA9IHRoaXMueXk7XG4gICAgICAgICAgICB0aGlzLnl5LmxleGVyID0gdGhpcy5sZXhlcjtcbiAgICAgICAgICAgIHRoaXMueXkucGFyc2VyID0gdGhpcztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5sZXhlci55eWxsb2MgPT0gXCJ1bmRlZmluZWRcIikgdGhpcy5sZXhlci55eWxsb2MgPSB7fTtcbiAgICAgICAgICAgIHZhciB5eWxvYyA9IHRoaXMubGV4ZXIueXlsbG9jO1xuICAgICAgICAgICAgbHN0YWNrLnB1c2goeXlsb2MpO1xuICAgICAgICAgICAgdmFyIHJhbmdlcyA9IHRoaXMubGV4ZXIub3B0aW9ucyAmJiB0aGlzLmxleGVyLm9wdGlvbnMucmFuZ2VzO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnl5LnBhcnNlRXJyb3IgPT09IFwiZnVuY3Rpb25cIikgdGhpcy5wYXJzZUVycm9yID0gdGhpcy55eS5wYXJzZUVycm9yO1xuICAgICAgICAgICAgZnVuY3Rpb24gcG9wU3RhY2sobikge1xuICAgICAgICAgICAgICAgIHN0YWNrLmxlbmd0aCA9IHN0YWNrLmxlbmd0aCAtIDIgKiBuO1xuICAgICAgICAgICAgICAgIHZzdGFjay5sZW5ndGggPSB2c3RhY2subGVuZ3RoIC0gbjtcbiAgICAgICAgICAgICAgICBsc3RhY2subGVuZ3RoID0gbHN0YWNrLmxlbmd0aCAtIG47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBsZXgoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICAgICAgICAgIHRva2VuID0gc2VsZi5sZXhlci5sZXgoKSB8fCAxO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW4gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBzZWxmLnN5bWJvbHNfW3Rva2VuXSB8fCB0b2tlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN5bWJvbCxcbiAgICAgICAgICAgICAgICBwcmVFcnJvclN5bWJvbCxcbiAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICAgICAgYSxcbiAgICAgICAgICAgICAgICByLFxuICAgICAgICAgICAgICAgIHl5dmFsID0ge30sXG4gICAgICAgICAgICAgICAgcCxcbiAgICAgICAgICAgICAgICBsZW4sXG4gICAgICAgICAgICAgICAgbmV3U3RhdGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVmYXVsdEFjdGlvbnNbc3RhdGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbiA9IHRoaXMuZGVmYXVsdEFjdGlvbnNbc3RhdGVdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzeW1ib2wgPT09IG51bGwgfHwgdHlwZW9mIHN5bWJvbCA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhY3Rpb24gPSB0YWJsZVtzdGF0ZV0gJiYgdGFibGVbc3RhdGVdW3N5bWJvbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSBcInVuZGVmaW5lZFwiIHx8ICFhY3Rpb24ubGVuZ3RoIHx8ICFhY3Rpb25bMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVyclN0ciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVjb3ZlcmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocCBpbiB0YWJsZVtzdGF0ZV0pIGlmICh0aGlzLnRlcm1pbmFsc19bcF0gJiYgcCA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZC5wdXNoKFwiJ1wiICsgdGhpcy50ZXJtaW5hbHNfW3BdICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGV4ZXIuc2hvd1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyU3RyID0gXCJQYXJzZSBlcnJvciBvbiBsaW5lIFwiICsgKHl5bGluZW5vICsgMSkgKyBcIjpcXG5cIiArIHRoaXMubGV4ZXIuc2hvd1Bvc2l0aW9uKCkgKyBcIlxcbkV4cGVjdGluZyBcIiArIGV4cGVjdGVkLmpvaW4oXCIsIFwiKSArIFwiLCBnb3QgJ1wiICsgKHRoaXMudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCkgKyBcIidcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyU3RyID0gXCJQYXJzZSBlcnJvciBvbiBsaW5lIFwiICsgKHl5bGluZW5vICsgMSkgKyBcIjogVW5leHBlY3RlZCBcIiArIChzeW1ib2wgPT0gMSA/IFwiZW5kIG9mIGlucHV0XCIgOiBcIidcIiArICh0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wpICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZUVycm9yKGVyclN0ciwgeyB0ZXh0OiB0aGlzLmxleGVyLm1hdGNoLCB0b2tlbjogdGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sLCBsaW5lOiB0aGlzLmxleGVyLnl5bGluZW5vLCBsb2M6IHl5bG9jLCBleHBlY3RlZDogZXhwZWN0ZWQgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvblswXSBpbnN0YW5jZW9mIEFycmF5ICYmIGFjdGlvbi5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcnNlIEVycm9yOiBtdWx0aXBsZSBhY3Rpb25zIHBvc3NpYmxlIGF0IHN0YXRlOiBcIiArIHN0YXRlICsgXCIsIHRva2VuOiBcIiArIHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYWN0aW9uWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goc3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZzdGFjay5wdXNoKHRoaXMubGV4ZXIueXl0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxzdGFjay5wdXNoKHRoaXMubGV4ZXIueXlsbG9jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goYWN0aW9uWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXByZUVycm9yU3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeXlsZW5nID0gdGhpcy5sZXhlci55eWxlbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeXl0ZXh0ID0gdGhpcy5sZXhlci55eXRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeXlsaW5lbm8gPSB0aGlzLmxleGVyLnl5bGluZW5vO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHl5bG9jID0gdGhpcy5sZXhlci55eWxsb2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY292ZXJpbmcgPiAwKSByZWNvdmVyaW5nLS07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IHByZUVycm9yU3ltYm9sO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZUVycm9yU3ltYm9sID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW4gPSB0aGlzLnByb2R1Y3Rpb25zX1thY3Rpb25bMV1dWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeXl2YWwuJCA9IHZzdGFja1t2c3RhY2subGVuZ3RoIC0gbGVuXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHl5dmFsLl8kID0geyBmaXJzdF9saW5lOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLmZpcnN0X2xpbmUsIGxhc3RfbGluZTogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAxXS5sYXN0X2xpbmUsIGZpcnN0X2NvbHVtbjogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAobGVuIHx8IDEpXS5maXJzdF9jb2x1bW4sIGxhc3RfY29sdW1uOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLmxhc3RfY29sdW1uIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeXl2YWwuXyQucmFuZ2UgPSBbbHN0YWNrW2xzdGFjay5sZW5ndGggLSAobGVuIHx8IDEpXS5yYW5nZVswXSwgbHN0YWNrW2xzdGFjay5sZW5ndGggLSAxXS5yYW5nZVsxXV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByID0gdGhpcy5wZXJmb3JtQWN0aW9uLmNhbGwoeXl2YWwsIHl5dGV4dCwgeXlsZW5nLCB5eWxpbmVubywgdGhpcy55eSwgYWN0aW9uWzFdLCB2c3RhY2ssIGxzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjayA9IHN0YWNrLnNsaWNlKDAsIC0xICogbGVuICogMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdnN0YWNrID0gdnN0YWNrLnNsaWNlKDAsIC0xICogbGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsc3RhY2sgPSBsc3RhY2suc2xpY2UoMCwgLTEgKiBsZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh0aGlzLnByb2R1Y3Rpb25zX1thY3Rpb25bMV1dWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZzdGFjay5wdXNoKHl5dmFsLiQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbHN0YWNrLnB1c2goeXl2YWwuXyQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgPSB0YWJsZVtzdGFja1tzdGFjay5sZW5ndGggLSAyXV1bc3RhY2tbc3RhY2subGVuZ3RoIC0gMV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChuZXdTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qIEppc29uIGdlbmVyYXRlZCBsZXhlciAqL1xuICAgIHZhciBsZXhlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsZXhlciA9IHsgRU9GOiAxLFxuICAgICAgICAgICAgcGFyc2VFcnJvcjogZnVuY3Rpb24gcGFyc2VFcnJvcihzdHIsIGhhc2gpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy55eS5wYXJzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55eS5wYXJzZXIucGFyc2VFcnJvcihzdHIsIGhhc2gpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzdHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRJbnB1dDogZnVuY3Rpb24gc2V0SW5wdXQoaW5wdXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuICAgICAgICAgICAgICAgIHRoaXMuX21vcmUgPSB0aGlzLl9sZXNzID0gdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy55eWxpbmVubyA9IHRoaXMueXlsZW5nID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnl5dGV4dCA9IHRoaXMubWF0Y2hlZCA9IHRoaXMubWF0Y2ggPSAnJztcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmRpdGlvblN0YWNrID0gWydJTklUSUFMJ107XG4gICAgICAgICAgICAgICAgdGhpcy55eWxsb2MgPSB7IGZpcnN0X2xpbmU6IDEsIGZpcnN0X2NvbHVtbjogMCwgbGFzdF9saW5lOiAxLCBsYXN0X2NvbHVtbjogMCB9O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB0aGlzLnl5bGxvYy5yYW5nZSA9IFswLCAwXTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uIGlucHV0KCkge1xuICAgICAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuX2lucHV0WzBdO1xuICAgICAgICAgICAgICAgIHRoaXMueXl0ZXh0ICs9IGNoO1xuICAgICAgICAgICAgICAgIHRoaXMueXlsZW5nKys7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoICs9IGNoO1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlZCArPSBjaDtcbiAgICAgICAgICAgICAgICB2YXIgbGluZXMgPSBjaC5tYXRjaCgvKD86XFxyXFxuP3xcXG4pLiovZyk7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueXlsaW5lbm8rKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9saW5lKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHRoaXMueXlsbG9jLnJhbmdlWzFdKys7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dCA9IHRoaXMuX2lucHV0LnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnB1dDogZnVuY3Rpb24gdW5wdXQoY2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gY2gubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lcyA9IGNoLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dCA9IGNoICsgdGhpcy5faW5wdXQ7XG4gICAgICAgICAgICAgICAgdGhpcy55eXRleHQgPSB0aGlzLnl5dGV4dC5zdWJzdHIoMCwgdGhpcy55eXRleHQubGVuZ3RoIC0gbGVuIC0gMSk7XG4gICAgICAgICAgICAgICAgLy90aGlzLnl5bGVuZyAtPSBsZW47XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXQgLT0gbGVuO1xuICAgICAgICAgICAgICAgIHZhciBvbGRMaW5lcyA9IHRoaXMubWF0Y2guc3BsaXQoLyg/Olxcclxcbj98XFxuKS9nKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoID0gdGhpcy5tYXRjaC5zdWJzdHIoMCwgdGhpcy5tYXRjaC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZWQgPSB0aGlzLm1hdGNoZWQuc3Vic3RyKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSAxKTtcblxuICAgICAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggLSAxKSB0aGlzLnl5bGluZW5vIC09IGxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSB0aGlzLnl5bGxvYy5yYW5nZTtcblxuICAgICAgICAgICAgICAgIHRoaXMueXlsbG9jID0geyBmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5maXJzdF9saW5lLFxuICAgICAgICAgICAgICAgICAgICBsYXN0X2xpbmU6IHRoaXMueXlsaW5lbm8gKyAxLFxuICAgICAgICAgICAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgbGFzdF9jb2x1bW46IGxpbmVzID8gKGxpbmVzLmxlbmd0aCA9PT0gb2xkTGluZXMubGVuZ3RoID8gdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uIDogMCkgKyBvbGRMaW5lc1tvbGRMaW5lcy5sZW5ndGggLSBsaW5lcy5sZW5ndGhdLmxlbmd0aCAtIGxpbmVzWzBdLmxlbmd0aCA6IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbiAtIGxlblxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZSA9IFtyWzBdLCByWzBdICsgdGhpcy55eWxlbmcgLSBsZW5dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb3JlOiBmdW5jdGlvbiBtb3JlKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vcmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlc3M6IGZ1bmN0aW9uIGxlc3Mobikge1xuICAgICAgICAgICAgICAgIHRoaXMudW5wdXQodGhpcy5tYXRjaC5zbGljZShuKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFzdElucHV0OiBmdW5jdGlvbiBwYXN0SW5wdXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhc3QgPSB0aGlzLm1hdGNoZWQuc3Vic3RyKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSB0aGlzLm1hdGNoLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChwYXN0Lmxlbmd0aCA+IDIwID8gJy4uLicgOiAnJykgKyBwYXN0LnN1YnN0cigtMjApLnJlcGxhY2UoL1xcbi9nLCBcIlwiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGNvbWluZ0lucHV0OiBmdW5jdGlvbiB1cGNvbWluZ0lucHV0KCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5tYXRjaDtcbiAgICAgICAgICAgICAgICBpZiAobmV4dC5sZW5ndGggPCAyMCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0ICs9IHRoaXMuX2lucHV0LnN1YnN0cigwLCAyMCAtIG5leHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIChuZXh0LnN1YnN0cigwLCAyMCkgKyAobmV4dC5sZW5ndGggPiAyMCA/ICcuLi4nIDogJycpKS5yZXBsYWNlKC9cXG4vZywgXCJcIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2hvd1Bvc2l0aW9uOiBmdW5jdGlvbiBzaG93UG9zaXRpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZSA9IHRoaXMucGFzdElucHV0KCk7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBuZXcgQXJyYXkocHJlLmxlbmd0aCArIDEpLmpvaW4oXCItXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmUgKyB0aGlzLnVwY29taW5nSW5wdXQoKSArIFwiXFxuXCIgKyBjICsgXCJeXCI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkVPRjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pbnB1dCkgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIHZhciB0b2tlbiwgbWF0Y2gsIHRlbXBNYXRjaCwgaW5kZXgsIGNvbCwgbGluZXM7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9tb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueXl0ZXh0ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2ggPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy5fY3VycmVudFJ1bGVzKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wTWF0Y2ggPSB0aGlzLl9pbnB1dC5tYXRjaCh0aGlzLnJ1bGVzW3J1bGVzW2ldXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wTWF0Y2ggJiYgKCFtYXRjaCB8fCB0ZW1wTWF0Y2hbMF0ubGVuZ3RoID4gbWF0Y2hbMF0ubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSB0ZW1wTWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5mbGV4KSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZXMgPSBtYXRjaFswXS5tYXRjaCgvKD86XFxyXFxuP3xcXG4pLiovZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lcykgdGhpcy55eWxpbmVubyArPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueXlsbG9jID0geyBmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5sYXN0X2xpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0X2xpbmU6IHRoaXMueXlsaW5lbm8gKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RfY29sdW1uOiBsaW5lcyA/IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aCAtIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLm1hdGNoKC9cXHI/XFxuPy8pWzBdLmxlbmd0aCA6IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uICsgbWF0Y2hbMF0ubGVuZ3RoIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueXl0ZXh0ICs9IG1hdGNoWzBdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoICs9IG1hdGNoWzBdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXMgPSBtYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55eWxlbmcgPSB0aGlzLnl5dGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZSA9IFt0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKz0gdGhpcy55eWxlbmddO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21vcmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZShtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZWQgKz0gbWF0Y2hbMF07XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5wZXJmb3JtQWN0aW9uLmNhbGwodGhpcywgdGhpcy55eSwgdGhpcywgcnVsZXNbaW5kZXhdLCB0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kb25lICYmIHRoaXMuX2lucHV0KSB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuKSByZXR1cm4gdG9rZW47ZWxzZSByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbnB1dCA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5FT0Y7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFcnJvcignTGV4aWNhbCBlcnJvciBvbiBsaW5lICcgKyAodGhpcy55eWxpbmVubyArIDEpICsgJy4gVW5yZWNvZ25pemVkIHRleHQuXFxuJyArIHRoaXMuc2hvd1Bvc2l0aW9uKCksIHsgdGV4dDogXCJcIiwgdG9rZW46IG51bGwsIGxpbmU6IHRoaXMueXlsaW5lbm8gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxleDogZnVuY3Rpb24gbGV4KCkge1xuICAgICAgICAgICAgICAgIHZhciByID0gdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sZXgoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmVnaW46IGZ1bmN0aW9uIGJlZ2luKGNvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2sucHVzaChjb25kaXRpb24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvcFN0YXRlOiBmdW5jdGlvbiBwb3BTdGF0ZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFjay5wb3AoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfY3VycmVudFJ1bGVzOiBmdW5jdGlvbiBfY3VycmVudFJ1bGVzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbnNbdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdXS5ydWxlcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b3BTdGF0ZTogZnVuY3Rpb24gdG9wU3RhdGUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAyXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwdXNoU3RhdGU6IGZ1bmN0aW9uIGJlZ2luKGNvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuYmVnaW4oY29uZGl0aW9uKTtcbiAgICAgICAgICAgIH0gfTtcbiAgICAgICAgbGV4ZXIub3B0aW9ucyA9IHt9O1xuICAgICAgICBsZXhlci5wZXJmb3JtQWN0aW9uID0gZnVuY3Rpb24gYW5vbnltb3VzKHl5LCB5eV8sICRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMsIFlZX1NUQVJUXG4gICAgICAgIC8qKi8pIHtcblxuICAgICAgICAgICAgZnVuY3Rpb24gc3RyaXAoc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5eV8ueXl0ZXh0ID0geXlfLnl5dGV4dC5zdWJzdHIoc3RhcnQsIHl5Xy55eWxlbmcgLSBlbmQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgWVlTVEFURSA9IFlZX1NUQVJUO1xuICAgICAgICAgICAgc3dpdGNoICgkYXZvaWRpbmdfbmFtZV9jb2xsaXNpb25zKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBpZiAoeXlfLnl5dGV4dC5zbGljZSgtMikgPT09IFwiXFxcXFxcXFxcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaXAoMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJlZ2luKFwibXVcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoeXlfLnl5dGV4dC5zbGljZSgtMSkgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpcCgwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmVnaW4oXCJlbXVcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJlZ2luKFwibXVcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHl5Xy55eXRleHQpIHJldHVybiAxNTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxNTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxNTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmVnaW4oJ3JhdycpO3JldHVybiAxNTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNob3VsZCBiZSB1c2luZyBgdGhpcy50b3BTdGF0ZSgpYCBiZWxvdywgYnV0IGl0IGN1cnJlbnRseVxuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIHRoZSBzZWNvbmQgdG9wIGluc3RlYWQgb2YgdGhlIGZpcnN0IHRvcC4gT3BlbmVkIGFuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzc3VlIGFib3V0IGl0IGF0IGh0dHBzOi8vZ2l0aHViLmNvbS96YWFjaC9qaXNvbi9pc3N1ZXMvMjkxXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV0gPT09ICdyYXcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5eV8ueXl0ZXh0ID0geXlfLnl5dGV4dC5zdWJzdHIoNSwgeXlfLnl5bGVuZyAtIDkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdFTkRfUkFXX0JMT0NLJztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE1O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE0O1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDY1O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA2ODtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iZWdpbigncmF3Jyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAyMztcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gNTU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA2MDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDI5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gNDc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtyZXR1cm4gNDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtyZXR1cm4gNDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAzNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDM5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gNTE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA0ODtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnB1dCh5eV8ueXl0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJlZ2luKCdjb20nKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxNDtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gNDg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA3MztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDcyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gNzI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA4NztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyODpcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIHdoaXRlc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO3JldHVybiA1NDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzMDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO3JldHVybiAzMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzMTpcbiAgICAgICAgICAgICAgICAgICAgeXlfLnl5dGV4dCA9IHN0cmlwKDEsIDIpLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKTtyZXR1cm4gODA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICAgICAgICAgIHl5Xy55eXRleHQgPSBzdHJpcCgxLCAyKS5yZXBsYWNlKC9cXFxcJy9nLCBcIidcIik7cmV0dXJuIDgwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDMzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gODU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA4MjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzNTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDgyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM2OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gODM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA4NDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDgxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gNzU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA3NztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0MTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDcyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQyOlxuICAgICAgICAgICAgICAgICAgICB5eV8ueXl0ZXh0ID0geXlfLnl5dGV4dC5yZXBsYWNlKC9cXFxcKFtcXFxcXFxdXSkvZywgJyQxJyk7cmV0dXJuIDcyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ0lOVkFMSUQnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxleGVyLnJ1bGVzID0gWy9eKD86W15cXHgwMF0qPyg/PShcXHtcXHspKSkvLCAvXig/OlteXFx4MDBdKykvLCAvXig/OlteXFx4MDBdezIsfT8oPz0oXFx7XFx7fFxcXFxcXHtcXHt8XFxcXFxcXFxcXHtcXHt8JCkpKS8sIC9eKD86XFx7XFx7XFx7XFx7KD89W15cXC9dKSkvLCAvXig/Olxce1xce1xce1xce1xcL1teXFxzIVwiIyUtLFxcLlxcLzstPkBcXFstXFxeYFxcey1+XSsoPz1bPX1cXHNcXC8uXSlcXH1cXH1cXH1cXH0pLywgL14oPzpbXlxceDAwXSo/KD89KFxce1xce1xce1xceykpKS8sIC9eKD86W1xcc1xcU10qPy0tKH4pP1xcfVxcfSkvLCAvXig/OlxcKCkvLCAvXig/OlxcKSkvLCAvXig/Olxce1xce1xce1xceykvLCAvXig/OlxcfVxcfVxcfVxcfSkvLCAvXig/Olxce1xceyh+KT8+KS8sIC9eKD86XFx7XFx7KH4pPyM+KS8sIC9eKD86XFx7XFx7KH4pPyNcXCo/KS8sIC9eKD86XFx7XFx7KH4pP1xcLykvLCAvXig/Olxce1xceyh+KT9cXF5cXHMqKH4pP1xcfVxcfSkvLCAvXig/Olxce1xceyh+KT9cXHMqZWxzZVxccyoofik/XFx9XFx9KS8sIC9eKD86XFx7XFx7KH4pP1xcXikvLCAvXig/Olxce1xceyh+KT9cXHMqZWxzZVxcYikvLCAvXig/Olxce1xceyh+KT9cXHspLywgL14oPzpcXHtcXHsofik/JikvLCAvXig/Olxce1xceyh+KT8hLS0pLywgL14oPzpcXHtcXHsofik/IVtcXHNcXFNdKj9cXH1cXH0pLywgL14oPzpcXHtcXHsofik/XFwqPykvLCAvXig/Oj0pLywgL14oPzpcXC5cXC4pLywgL14oPzpcXC4oPz0oWz1+fVxcc1xcLy4pfF0pKSkvLCAvXig/OltcXC8uXSkvLCAvXig/OlxccyspLywgL14oPzpcXH0ofik/XFx9XFx9KS8sIC9eKD86KH4pP1xcfVxcfSkvLCAvXig/OlwiKFxcXFxbXCJdfFteXCJdKSpcIikvLCAvXig/OicoXFxcXFsnXXxbXiddKSonKS8sIC9eKD86QCkvLCAvXig/OnRydWUoPz0oW359XFxzKV0pKSkvLCAvXig/OmZhbHNlKD89KFt+fVxccyldKSkpLywgL14oPzp1bmRlZmluZWQoPz0oW359XFxzKV0pKSkvLCAvXig/Om51bGwoPz0oW359XFxzKV0pKSkvLCAvXig/Oi0/WzAtOV0rKD86XFwuWzAtOV0rKT8oPz0oW359XFxzKV0pKSkvLCAvXig/OmFzXFxzK1xcfCkvLCAvXig/OlxcfCkvLCAvXig/OihbXlxccyFcIiMlLSxcXC5cXC87LT5AXFxbLVxcXmBcXHstfl0rKD89KFs9fn1cXHNcXC8uKXxdKSkpKS8sIC9eKD86XFxbKFxcXFxcXF18W15cXF1dKSpcXF0pLywgL14oPzouKS8sIC9eKD86JCkvXTtcbiAgICAgICAgbGV4ZXIuY29uZGl0aW9ucyA9IHsgXCJtdVwiOiB7IFwicnVsZXNcIjogWzcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsIDE2LCAxNywgMTgsIDE5LCAyMCwgMjEsIDIyLCAyMywgMjQsIDI1LCAyNiwgMjcsIDI4LCAyOSwgMzAsIDMxLCAzMiwgMzMsIDM0LCAzNSwgMzYsIDM3LCAzOCwgMzksIDQwLCA0MSwgNDIsIDQzLCA0NF0sIFwiaW5jbHVzaXZlXCI6IGZhbHNlIH0sIFwiZW11XCI6IHsgXCJydWxlc1wiOiBbMl0sIFwiaW5jbHVzaXZlXCI6IGZhbHNlIH0sIFwiY29tXCI6IHsgXCJydWxlc1wiOiBbNl0sIFwiaW5jbHVzaXZlXCI6IGZhbHNlIH0sIFwicmF3XCI6IHsgXCJydWxlc1wiOiBbMywgNCwgNV0sIFwiaW5jbHVzaXZlXCI6IGZhbHNlIH0sIFwiSU5JVElBTFwiOiB7IFwicnVsZXNcIjogWzAsIDEsIDQ0XSwgXCJpbmNsdXNpdmVcIjogdHJ1ZSB9IH07XG4gICAgICAgIHJldHVybiBsZXhlcjtcbiAgICB9KSgpO1xuICAgIHBhcnNlci5sZXhlciA9IGxleGVyO1xuICAgIGZ1bmN0aW9uIFBhcnNlcigpIHtcbiAgICAgICAgdGhpcy55eSA9IHt9O1xuICAgIH1QYXJzZXIucHJvdG90eXBlID0gcGFyc2VyO3BhcnNlci5QYXJzZXIgPSBQYXJzZXI7XG4gICAgcmV0dXJuIG5ldyBQYXJzZXIoKTtcbn0pKCk7ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGhhbmRsZWJhcnM7XG5cblxufSx7fV0sMTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyogZXNsaW50LWRpc2FibGUgbmV3LWNhcCAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5wcmludCA9IHByaW50O1xuZXhwb3J0cy5QcmludFZpc2l0b3IgPSBQcmludFZpc2l0b3I7XG4vLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfdmlzaXRvciA9IHJlcXVpcmUoJy4vdmlzaXRvcicpO1xuXG52YXIgX3Zpc2l0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmlzaXRvcik7XG5cbmZ1bmN0aW9uIHByaW50KGFzdCkge1xuICByZXR1cm4gbmV3IFByaW50VmlzaXRvcigpLmFjY2VwdChhc3QpO1xufVxuXG5mdW5jdGlvbiBQcmludFZpc2l0b3IoKSB7XG4gIHRoaXMucGFkZGluZyA9IDA7XG59XG5cblByaW50VmlzaXRvci5wcm90b3R5cGUgPSBuZXcgX3Zpc2l0b3IyWydkZWZhdWx0J10oKTtcblxuUHJpbnRWaXNpdG9yLnByb3RvdHlwZS5wYWQgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHZhciBvdXQgPSAnJztcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMucGFkZGluZzsgaSA8IGw7IGkrKykge1xuICAgIG91dCArPSAnICAnO1xuICB9XG5cbiAgb3V0ICs9IHN0cmluZyArICdcXG4nO1xuICByZXR1cm4gb3V0O1xufTtcblxuUHJpbnRWaXNpdG9yLnByb3RvdHlwZS5Qcm9ncmFtID0gZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgdmFyIG91dCA9ICcnLFxuICAgICAgYm9keSA9IHByb2dyYW0uYm9keSxcbiAgICAgIGkgPSB1bmRlZmluZWQsXG4gICAgICBsID0gdW5kZWZpbmVkO1xuXG4gIGlmIChwcm9ncmFtLmJsb2NrUGFyYW1zKSB7XG4gICAgdmFyIGJsb2NrUGFyYW1zID0gJ0JMT0NLIFBBUkFNUzogWyc7XG4gICAgZm9yIChpID0gMCwgbCA9IHByb2dyYW0uYmxvY2tQYXJhbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBibG9ja1BhcmFtcyArPSAnICcgKyBwcm9ncmFtLmJsb2NrUGFyYW1zW2ldO1xuICAgIH1cbiAgICBibG9ja1BhcmFtcyArPSAnIF0nO1xuICAgIG91dCArPSB0aGlzLnBhZChibG9ja1BhcmFtcyk7XG4gIH1cblxuICBmb3IgKGkgPSAwLCBsID0gYm9keS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvdXQgKz0gdGhpcy5hY2NlcHQoYm9keVtpXSk7XG4gIH1cblxuICB0aGlzLnBhZGRpbmctLTtcblxuICByZXR1cm4gb3V0O1xufTtcblxuUHJpbnRWaXNpdG9yLnByb3RvdHlwZS5NdXN0YWNoZVN0YXRlbWVudCA9IGZ1bmN0aW9uIChtdXN0YWNoZSkge1xuICByZXR1cm4gdGhpcy5wYWQoJ3t7ICcgKyB0aGlzLlN1YkV4cHJlc3Npb24obXVzdGFjaGUpICsgJyB9fScpO1xufTtcblByaW50VmlzaXRvci5wcm90b3R5cGUuRGVjb3JhdG9yID0gZnVuY3Rpb24gKG11c3RhY2hlKSB7XG4gIHJldHVybiB0aGlzLnBhZCgne3sgRElSRUNUSVZFICcgKyB0aGlzLlN1YkV4cHJlc3Npb24obXVzdGFjaGUpICsgJyB9fScpO1xufTtcblxuUHJpbnRWaXNpdG9yLnByb3RvdHlwZS5CbG9ja1N0YXRlbWVudCA9IFByaW50VmlzaXRvci5wcm90b3R5cGUuRGVjb3JhdG9yQmxvY2sgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgdmFyIG91dCA9ICcnO1xuXG4gIG91dCArPSB0aGlzLnBhZCgoYmxvY2sudHlwZSA9PT0gJ0RlY29yYXRvckJsb2NrJyA/ICdESVJFQ1RJVkUgJyA6ICcnKSArICdCTE9DSzonKTtcbiAgdGhpcy5wYWRkaW5nKys7XG4gIG91dCArPSB0aGlzLnBhZCh0aGlzLlN1YkV4cHJlc3Npb24oYmxvY2spKTtcbiAgaWYgKGJsb2NrLnByb2dyYW0pIHtcbiAgICBvdXQgKz0gdGhpcy5wYWQoJ1BST0dSQU06Jyk7XG4gICAgdGhpcy5wYWRkaW5nKys7XG4gICAgb3V0ICs9IHRoaXMuYWNjZXB0KGJsb2NrLnByb2dyYW0pO1xuICAgIHRoaXMucGFkZGluZy0tO1xuICB9XG4gIGlmIChibG9jay5pbnZlcnNlKSB7XG4gICAgaWYgKGJsb2NrLnByb2dyYW0pIHtcbiAgICAgIHRoaXMucGFkZGluZysrO1xuICAgIH1cbiAgICBvdXQgKz0gdGhpcy5wYWQoJ3t7Xn19Jyk7XG4gICAgdGhpcy5wYWRkaW5nKys7XG4gICAgb3V0ICs9IHRoaXMuYWNjZXB0KGJsb2NrLmludmVyc2UpO1xuICAgIHRoaXMucGFkZGluZy0tO1xuICAgIGlmIChibG9jay5wcm9ncmFtKSB7XG4gICAgICB0aGlzLnBhZGRpbmctLTtcbiAgICB9XG4gIH1cbiAgdGhpcy5wYWRkaW5nLS07XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cblByaW50VmlzaXRvci5wcm90b3R5cGUuUGFydGlhbFN0YXRlbWVudCA9IGZ1bmN0aW9uIChwYXJ0aWFsKSB7XG4gIHZhciBjb250ZW50ID0gJ1BBUlRJQUw6JyArIHBhcnRpYWwubmFtZS5vcmlnaW5hbDtcbiAgaWYgKHBhcnRpYWwucGFyYW1zWzBdKSB7XG4gICAgY29udGVudCArPSAnICcgKyB0aGlzLmFjY2VwdChwYXJ0aWFsLnBhcmFtc1swXSk7XG4gIH1cbiAgaWYgKHBhcnRpYWwuaGFzaCkge1xuICAgIGNvbnRlbnQgKz0gJyAnICsgdGhpcy5hY2NlcHQocGFydGlhbC5oYXNoKTtcbiAgfVxuICByZXR1cm4gdGhpcy5wYWQoJ3t7PiAnICsgY29udGVudCArICcgfX0nKTtcbn07XG5QcmludFZpc2l0b3IucHJvdG90eXBlLlBhcnRpYWxCbG9ja1N0YXRlbWVudCA9IGZ1bmN0aW9uIChwYXJ0aWFsKSB7XG4gIHZhciBjb250ZW50ID0gJ1BBUlRJQUwgQkxPQ0s6JyArIHBhcnRpYWwubmFtZS5vcmlnaW5hbDtcbiAgaWYgKHBhcnRpYWwucGFyYW1zWzBdKSB7XG4gICAgY29udGVudCArPSAnICcgKyB0aGlzLmFjY2VwdChwYXJ0aWFsLnBhcmFtc1swXSk7XG4gIH1cbiAgaWYgKHBhcnRpYWwuaGFzaCkge1xuICAgIGNvbnRlbnQgKz0gJyAnICsgdGhpcy5hY2NlcHQocGFydGlhbC5oYXNoKTtcbiAgfVxuXG4gIGNvbnRlbnQgKz0gJyAnICsgdGhpcy5wYWQoJ1BST0dSQU06Jyk7XG4gIHRoaXMucGFkZGluZysrO1xuICBjb250ZW50ICs9IHRoaXMuYWNjZXB0KHBhcnRpYWwucHJvZ3JhbSk7XG4gIHRoaXMucGFkZGluZy0tO1xuXG4gIHJldHVybiB0aGlzLnBhZCgne3s+ICcgKyBjb250ZW50ICsgJyB9fScpO1xufTtcblxuUHJpbnRWaXNpdG9yLnByb3RvdHlwZS5Db250ZW50U3RhdGVtZW50ID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgcmV0dXJuIHRoaXMucGFkKFwiQ09OVEVOVFsgJ1wiICsgY29udGVudC52YWx1ZSArIFwiJyBdXCIpO1xufTtcblxuUHJpbnRWaXNpdG9yLnByb3RvdHlwZS5Db21tZW50U3RhdGVtZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQpIHtcbiAgcmV0dXJuIHRoaXMucGFkKFwie3shICdcIiArIGNvbW1lbnQudmFsdWUgKyBcIicgfX1cIik7XG59O1xuXG5QcmludFZpc2l0b3IucHJvdG90eXBlLlN1YkV4cHJlc3Npb24gPSBmdW5jdGlvbiAoc2V4cHIpIHtcbiAgdmFyIHBhcmFtcyA9IHNleHByLnBhcmFtcyxcbiAgICAgIHBhcmFtU3RyaW5ncyA9IFtdLFxuICAgICAgaGFzaCA9IHVuZGVmaW5lZDtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhcmFtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBwYXJhbVN0cmluZ3MucHVzaCh0aGlzLmFjY2VwdChwYXJhbXNbaV0pKTtcbiAgfVxuXG4gIHBhcmFtcyA9ICdbJyArIHBhcmFtU3RyaW5ncy5qb2luKCcsICcpICsgJ10nO1xuXG4gIGhhc2ggPSBzZXhwci5oYXNoID8gJyAnICsgdGhpcy5hY2NlcHQoc2V4cHIuaGFzaCkgOiAnJztcblxuICByZXR1cm4gdGhpcy5hY2NlcHQoc2V4cHIucGF0aCkgKyAnICcgKyBwYXJhbXMgKyBoYXNoO1xufTtcblxuUHJpbnRWaXNpdG9yLnByb3RvdHlwZS5QYXRoRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChpZCkge1xuICB2YXIgcGF0aCA9IGlkLnBhcnRzLmpvaW4oJy8nKTtcbiAgcmV0dXJuIChpZC5kYXRhID8gJ0AnIDogJycpICsgJ1BBVEg6JyArIHBhdGg7XG59O1xuXG5QcmludFZpc2l0b3IucHJvdG90eXBlLlN0cmluZ0xpdGVyYWwgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHJldHVybiAnXCInICsgc3RyaW5nLnZhbHVlICsgJ1wiJztcbn07XG5cblByaW50VmlzaXRvci5wcm90b3R5cGUuTnVtYmVyTGl0ZXJhbCA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgcmV0dXJuICdOVU1CRVJ7JyArIG51bWJlci52YWx1ZSArICd9Jztcbn07XG5cblByaW50VmlzaXRvci5wcm90b3R5cGUuQm9vbGVhbkxpdGVyYWwgPSBmdW5jdGlvbiAoYm9vbCkge1xuICByZXR1cm4gJ0JPT0xFQU57JyArIGJvb2wudmFsdWUgKyAnfSc7XG59O1xuXG5QcmludFZpc2l0b3IucHJvdG90eXBlLlVuZGVmaW5lZExpdGVyYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAnVU5ERUZJTkVEJztcbn07XG5cblByaW50VmlzaXRvci5wcm90b3R5cGUuTnVsbExpdGVyYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAnTlVMTCc7XG59O1xuXG5QcmludFZpc2l0b3IucHJvdG90eXBlLkhhc2ggPSBmdW5jdGlvbiAoaGFzaCkge1xuICB2YXIgcGFpcnMgPSBoYXNoLnBhaXJzLFxuICAgICAgam9pbmVkUGFpcnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGpvaW5lZFBhaXJzLnB1c2godGhpcy5hY2NlcHQocGFpcnNbaV0pKTtcbiAgfVxuXG4gIHJldHVybiAnSEFTSHsnICsgam9pbmVkUGFpcnMuam9pbignLCAnKSArICd9Jztcbn07XG5QcmludFZpc2l0b3IucHJvdG90eXBlLkhhc2hQYWlyID0gZnVuY3Rpb24gKHBhaXIpIHtcbiAgcmV0dXJuIHBhaXIua2V5ICsgJz0nICsgdGhpcy5hY2NlcHQocGFpci52YWx1ZSk7XG59O1xuLyogZXNsaW50LWVuYWJsZSBuZXctY2FwICovXG5cblxufSx7XCIuL3Zpc2l0b3JcIjoxNn1dLDE2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbi8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9leGNlcHRpb24gPSByZXF1aXJlKCcuLi9leGNlcHRpb24nKTtcblxudmFyIF9leGNlcHRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXhjZXB0aW9uKTtcblxuZnVuY3Rpb24gVmlzaXRvcigpIHtcbiAgdGhpcy5wYXJlbnRzID0gW107XG59XG5cblZpc2l0b3IucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVmlzaXRvcixcbiAgbXV0YXRpbmc6IGZhbHNlLFxuXG4gIC8vIFZpc2l0cyBhIGdpdmVuIHZhbHVlLiBJZiBtdXRhdGluZywgd2lsbCByZXBsYWNlIHRoZSB2YWx1ZSBpZiBuZWNlc3NhcnkuXG4gIGFjY2VwdEtleTogZnVuY3Rpb24gYWNjZXB0S2V5KG5vZGUsIG5hbWUpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmFjY2VwdChub2RlW25hbWVdKTtcbiAgICBpZiAodGhpcy5tdXRhdGluZykge1xuICAgICAgLy8gSGFja3kgc2FuaXR5IGNoZWNrOiBUaGlzIG1heSBoYXZlIGEgZmV3IGZhbHNlIHBvc2l0aXZlcyBmb3IgdHlwZSBmb3IgdGhlIGhlbHBlclxuICAgICAgLy8gbWV0aG9kcyBidXQgd2lsbCBnZW5lcmFsbHkgZG8gdGhlIHJpZ2h0IHRoaW5nIHdpdGhvdXQgYSBsb3Qgb2Ygb3ZlcmhlYWQuXG4gICAgICBpZiAodmFsdWUgJiYgIVZpc2l0b3IucHJvdG90eXBlW3ZhbHVlLnR5cGVdKSB7XG4gICAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdVbmV4cGVjdGVkIG5vZGUgdHlwZSBcIicgKyB2YWx1ZS50eXBlICsgJ1wiIGZvdW5kIHdoZW4gYWNjZXB0aW5nICcgKyBuYW1lICsgJyBvbiAnICsgbm9kZS50eXBlKTtcbiAgICAgIH1cbiAgICAgIG5vZGVbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gUGVyZm9ybXMgYW4gYWNjZXB0IG9wZXJhdGlvbiB3aXRoIGFkZGVkIHNhbml0eSBjaGVjayB0byBlbnN1cmVcbiAgLy8gcmVxdWlyZWQga2V5cyBhcmUgbm90IHJlbW92ZWQuXG4gIGFjY2VwdFJlcXVpcmVkOiBmdW5jdGlvbiBhY2NlcHRSZXF1aXJlZChub2RlLCBuYW1lKSB7XG4gICAgdGhpcy5hY2NlcHRLZXkobm9kZSwgbmFtZSk7XG5cbiAgICBpZiAoIW5vZGVbbmFtZV0pIHtcbiAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKG5vZGUudHlwZSArICcgcmVxdWlyZXMgJyArIG5hbWUpO1xuICAgIH1cbiAgfSxcblxuICAvLyBUcmF2ZXJzZXMgYSBnaXZlbiBhcnJheS4gSWYgbXV0YXRpbmcsIGVtcHR5IHJlc3Buc2VzIHdpbGwgYmUgcmVtb3ZlZFxuICAvLyBmb3IgY2hpbGQgZWxlbWVudHMuXG4gIGFjY2VwdEFycmF5OiBmdW5jdGlvbiBhY2NlcHRBcnJheShhcnJheSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0aGlzLmFjY2VwdEtleShhcnJheSwgaSk7XG5cbiAgICAgIGlmICghYXJyYXlbaV0pIHtcbiAgICAgICAgYXJyYXkuc3BsaWNlKGksIDEpO1xuICAgICAgICBpLS07XG4gICAgICAgIGwtLTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgYWNjZXB0OiBmdW5jdGlvbiBhY2NlcHQob2JqZWN0KSB7XG4gICAgaWYgKCFvYmplY3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogU2FuaXR5IGNvZGUgKi9cbiAgICBpZiAoIXRoaXNbb2JqZWN0LnR5cGVdKSB7XG4gICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnVW5rbm93biB0eXBlOiAnICsgb2JqZWN0LnR5cGUsIG9iamVjdCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY3VycmVudCkge1xuICAgICAgdGhpcy5wYXJlbnRzLnVuc2hpZnQodGhpcy5jdXJyZW50KTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50ID0gb2JqZWN0O1xuXG4gICAgdmFyIHJldCA9IHRoaXNbb2JqZWN0LnR5cGVdKG9iamVjdCk7XG5cbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLnBhcmVudHMuc2hpZnQoKTtcblxuICAgIGlmICghdGhpcy5tdXRhdGluZyB8fCByZXQpIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSBlbHNlIGlmIChyZXQgIT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgfSxcblxuICBQcm9ncmFtOiBmdW5jdGlvbiBQcm9ncmFtKHByb2dyYW0pIHtcbiAgICB0aGlzLmFjY2VwdEFycmF5KHByb2dyYW0uYm9keSk7XG4gIH0sXG5cbiAgTXVzdGFjaGVTdGF0ZW1lbnQ6IHZpc2l0U3ViRXhwcmVzc2lvbixcbiAgRGVjb3JhdG9yOiB2aXNpdFN1YkV4cHJlc3Npb24sXG5cbiAgQmxvY2tTdGF0ZW1lbnQ6IHZpc2l0QmxvY2ssXG4gIERlY29yYXRvckJsb2NrOiB2aXNpdEJsb2NrLFxuXG4gIFBhcnRpYWxTdGF0ZW1lbnQ6IHZpc2l0UGFydGlhbCxcbiAgUGFydGlhbEJsb2NrU3RhdGVtZW50OiBmdW5jdGlvbiBQYXJ0aWFsQmxvY2tTdGF0ZW1lbnQocGFydGlhbCkge1xuICAgIHZpc2l0UGFydGlhbC5jYWxsKHRoaXMsIHBhcnRpYWwpO1xuXG4gICAgdGhpcy5hY2NlcHRLZXkocGFydGlhbCwgJ3Byb2dyYW0nKTtcbiAgfSxcblxuICBDb250ZW50U3RhdGVtZW50OiBmdW5jdGlvbiBDb250ZW50U3RhdGVtZW50KCkgLyogY29udGVudCAqL3t9LFxuICBDb21tZW50U3RhdGVtZW50OiBmdW5jdGlvbiBDb21tZW50U3RhdGVtZW50KCkgLyogY29tbWVudCAqL3t9LFxuXG4gIFN1YkV4cHJlc3Npb246IHZpc2l0U3ViRXhwcmVzc2lvbixcblxuICBQYXRoRXhwcmVzc2lvbjogZnVuY3Rpb24gUGF0aEV4cHJlc3Npb24oKSAvKiBwYXRoICove30sXG5cbiAgU3RyaW5nTGl0ZXJhbDogZnVuY3Rpb24gU3RyaW5nTGl0ZXJhbCgpIC8qIHN0cmluZyAqL3t9LFxuICBOdW1iZXJMaXRlcmFsOiBmdW5jdGlvbiBOdW1iZXJMaXRlcmFsKCkgLyogbnVtYmVyICove30sXG4gIEJvb2xlYW5MaXRlcmFsOiBmdW5jdGlvbiBCb29sZWFuTGl0ZXJhbCgpIC8qIGJvb2wgKi97fSxcbiAgVW5kZWZpbmVkTGl0ZXJhbDogZnVuY3Rpb24gVW5kZWZpbmVkTGl0ZXJhbCgpIC8qIGxpdGVyYWwgKi97fSxcbiAgTnVsbExpdGVyYWw6IGZ1bmN0aW9uIE51bGxMaXRlcmFsKCkgLyogbGl0ZXJhbCAqL3t9LFxuXG4gIEhhc2g6IGZ1bmN0aW9uIEhhc2goaGFzaCkge1xuICAgIHRoaXMuYWNjZXB0QXJyYXkoaGFzaC5wYWlycyk7XG4gIH0sXG4gIEhhc2hQYWlyOiBmdW5jdGlvbiBIYXNoUGFpcihwYWlyKSB7XG4gICAgdGhpcy5hY2NlcHRSZXF1aXJlZChwYWlyLCAndmFsdWUnKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdmlzaXRTdWJFeHByZXNzaW9uKG11c3RhY2hlKSB7XG4gIHRoaXMuYWNjZXB0UmVxdWlyZWQobXVzdGFjaGUsICdwYXRoJyk7XG4gIHRoaXMuYWNjZXB0QXJyYXkobXVzdGFjaGUucGFyYW1zKTtcbiAgdGhpcy5hY2NlcHRLZXkobXVzdGFjaGUsICdoYXNoJyk7XG59XG5mdW5jdGlvbiB2aXNpdEJsb2NrKGJsb2NrKSB7XG4gIHZpc2l0U3ViRXhwcmVzc2lvbi5jYWxsKHRoaXMsIGJsb2NrKTtcblxuICB0aGlzLmFjY2VwdEtleShibG9jaywgJ3Byb2dyYW0nKTtcbiAgdGhpcy5hY2NlcHRLZXkoYmxvY2ssICdpbnZlcnNlJyk7XG59XG5mdW5jdGlvbiB2aXNpdFBhcnRpYWwocGFydGlhbCkge1xuICB0aGlzLmFjY2VwdFJlcXVpcmVkKHBhcnRpYWwsICduYW1lJyk7XG4gIHRoaXMuYWNjZXB0QXJyYXkocGFydGlhbC5wYXJhbXMpO1xuICB0aGlzLmFjY2VwdEtleShwYXJ0aWFsLCAnaGFzaCcpO1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBWaXNpdG9yO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxufSx7XCIuLi9leGNlcHRpb25cIjoyMH1dLDE3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbi8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF92aXNpdG9yID0gcmVxdWlyZSgnLi92aXNpdG9yJyk7XG5cbnZhciBfdmlzaXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92aXNpdG9yKTtcblxuZnVuY3Rpb24gV2hpdGVzcGFjZUNvbnRyb2woKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbn1cbldoaXRlc3BhY2VDb250cm9sLnByb3RvdHlwZSA9IG5ldyBfdmlzaXRvcjJbJ2RlZmF1bHQnXSgpO1xuXG5XaGl0ZXNwYWNlQ29udHJvbC5wcm90b3R5cGUuUHJvZ3JhbSA9IGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gIHZhciBkb1N0YW5kYWxvbmUgPSAhdGhpcy5vcHRpb25zLmlnbm9yZVN0YW5kYWxvbmU7XG5cbiAgdmFyIGlzUm9vdCA9ICF0aGlzLmlzUm9vdFNlZW47XG4gIHRoaXMuaXNSb290U2VlbiA9IHRydWU7XG5cbiAgdmFyIGJvZHkgPSBwcm9ncmFtLmJvZHk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYm9keS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY3VycmVudCA9IGJvZHlbaV0sXG4gICAgICAgIHN0cmlwID0gdGhpcy5hY2NlcHQoY3VycmVudCk7XG5cbiAgICBpZiAoIXN0cmlwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgX2lzUHJldldoaXRlc3BhY2UgPSBpc1ByZXZXaGl0ZXNwYWNlKGJvZHksIGksIGlzUm9vdCksXG4gICAgICAgIF9pc05leHRXaGl0ZXNwYWNlID0gaXNOZXh0V2hpdGVzcGFjZShib2R5LCBpLCBpc1Jvb3QpLFxuICAgICAgICBvcGVuU3RhbmRhbG9uZSA9IHN0cmlwLm9wZW5TdGFuZGFsb25lICYmIF9pc1ByZXZXaGl0ZXNwYWNlLFxuICAgICAgICBjbG9zZVN0YW5kYWxvbmUgPSBzdHJpcC5jbG9zZVN0YW5kYWxvbmUgJiYgX2lzTmV4dFdoaXRlc3BhY2UsXG4gICAgICAgIGlubGluZVN0YW5kYWxvbmUgPSBzdHJpcC5pbmxpbmVTdGFuZGFsb25lICYmIF9pc1ByZXZXaGl0ZXNwYWNlICYmIF9pc05leHRXaGl0ZXNwYWNlO1xuXG4gICAgaWYgKHN0cmlwLmNsb3NlKSB7XG4gICAgICBvbWl0UmlnaHQoYm9keSwgaSwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChzdHJpcC5vcGVuKSB7XG4gICAgICBvbWl0TGVmdChib2R5LCBpLCB0cnVlKTtcbiAgICB9XG5cbiAgICBpZiAoZG9TdGFuZGFsb25lICYmIGlubGluZVN0YW5kYWxvbmUpIHtcbiAgICAgIG9taXRSaWdodChib2R5LCBpKTtcblxuICAgICAgaWYgKG9taXRMZWZ0KGJvZHksIGkpKSB7XG4gICAgICAgIC8vIElmIHdlIGFyZSBvbiBhIHN0YW5kYWxvbmUgbm9kZSwgc2F2ZSB0aGUgaW5kZW50IGluZm8gZm9yIHBhcnRpYWxzXG4gICAgICAgIGlmIChjdXJyZW50LnR5cGUgPT09ICdQYXJ0aWFsU3RhdGVtZW50Jykge1xuICAgICAgICAgIC8vIFB1bGwgb3V0IHRoZSB3aGl0ZXNwYWNlIGZyb20gdGhlIGZpbmFsIGxpbmVcbiAgICAgICAgICBjdXJyZW50LmluZGVudCA9IC8oWyBcXHRdKyQpLy5leGVjKGJvZHlbaSAtIDFdLm9yaWdpbmFsKVsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZG9TdGFuZGFsb25lICYmIG9wZW5TdGFuZGFsb25lKSB7XG4gICAgICBvbWl0UmlnaHQoKGN1cnJlbnQucHJvZ3JhbSB8fCBjdXJyZW50LmludmVyc2UpLmJvZHkpO1xuXG4gICAgICAvLyBTdHJpcCBvdXQgdGhlIHByZXZpb3VzIGNvbnRlbnQgbm9kZSBpZiBpdCdzIHdoaXRlc3BhY2Ugb25seVxuICAgICAgb21pdExlZnQoYm9keSwgaSk7XG4gICAgfVxuICAgIGlmIChkb1N0YW5kYWxvbmUgJiYgY2xvc2VTdGFuZGFsb25lKSB7XG4gICAgICAvLyBBbHdheXMgc3RyaXAgdGhlIG5leHQgbm9kZVxuICAgICAgb21pdFJpZ2h0KGJvZHksIGkpO1xuXG4gICAgICBvbWl0TGVmdCgoY3VycmVudC5pbnZlcnNlIHx8IGN1cnJlbnQucHJvZ3JhbSkuYm9keSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByb2dyYW07XG59O1xuXG5XaGl0ZXNwYWNlQ29udHJvbC5wcm90b3R5cGUuQmxvY2tTdGF0ZW1lbnQgPSBXaGl0ZXNwYWNlQ29udHJvbC5wcm90b3R5cGUuRGVjb3JhdG9yQmxvY2sgPSBXaGl0ZXNwYWNlQ29udHJvbC5wcm90b3R5cGUuUGFydGlhbEJsb2NrU3RhdGVtZW50ID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gIHRoaXMuYWNjZXB0KGJsb2NrLnByb2dyYW0pO1xuICB0aGlzLmFjY2VwdChibG9jay5pbnZlcnNlKTtcblxuICAvLyBGaW5kIHRoZSBpbnZlcnNlIHByb2dyYW0gdGhhdCBpcyBpbnZvbGVkIHdpdGggd2hpdGVzcGFjZSBzdHJpcHBpbmcuXG4gIHZhciBwcm9ncmFtID0gYmxvY2sucHJvZ3JhbSB8fCBibG9jay5pbnZlcnNlLFxuICAgICAgaW52ZXJzZSA9IGJsb2NrLnByb2dyYW0gJiYgYmxvY2suaW52ZXJzZSxcbiAgICAgIGZpcnN0SW52ZXJzZSA9IGludmVyc2UsXG4gICAgICBsYXN0SW52ZXJzZSA9IGludmVyc2U7XG5cbiAgaWYgKGludmVyc2UgJiYgaW52ZXJzZS5jaGFpbmVkKSB7XG4gICAgZmlyc3RJbnZlcnNlID0gaW52ZXJzZS5ib2R5WzBdLnByb2dyYW07XG5cbiAgICAvLyBXYWxrIHRoZSBpbnZlcnNlIGNoYWluIHRvIGZpbmQgdGhlIGxhc3QgaW52ZXJzZSB0aGF0IGlzIGFjdHVhbGx5IGluIHRoZSBjaGFpbi5cbiAgICB3aGlsZSAobGFzdEludmVyc2UuY2hhaW5lZCkge1xuICAgICAgbGFzdEludmVyc2UgPSBsYXN0SW52ZXJzZS5ib2R5W2xhc3RJbnZlcnNlLmJvZHkubGVuZ3RoIC0gMV0ucHJvZ3JhbTtcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyaXAgPSB7XG4gICAgb3BlbjogYmxvY2sub3BlblN0cmlwLm9wZW4sXG4gICAgY2xvc2U6IGJsb2NrLmNsb3NlU3RyaXAuY2xvc2UsXG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIHN0YW5kYWxvbmUgY2FuZGlhY3kuIEJhc2ljYWxseSBmbGFnIG91ciBjb250ZW50IGFzIGJlaW5nIHBvc3NpYmx5IHN0YW5kYWxvbmVcbiAgICAvLyBzbyBvdXIgcGFyZW50IGNhbiBkZXRlcm1pbmUgaWYgd2UgYWN0dWFsbHkgYXJlIHN0YW5kYWxvbmVcbiAgICBvcGVuU3RhbmRhbG9uZTogaXNOZXh0V2hpdGVzcGFjZShwcm9ncmFtLmJvZHkpLFxuICAgIGNsb3NlU3RhbmRhbG9uZTogaXNQcmV2V2hpdGVzcGFjZSgoZmlyc3RJbnZlcnNlIHx8IHByb2dyYW0pLmJvZHkpXG4gIH07XG5cbiAgaWYgKGJsb2NrLm9wZW5TdHJpcC5jbG9zZSkge1xuICAgIG9taXRSaWdodChwcm9ncmFtLmJvZHksIG51bGwsIHRydWUpO1xuICB9XG5cbiAgaWYgKGludmVyc2UpIHtcbiAgICB2YXIgaW52ZXJzZVN0cmlwID0gYmxvY2suaW52ZXJzZVN0cmlwO1xuXG4gICAgaWYgKGludmVyc2VTdHJpcC5vcGVuKSB7XG4gICAgICBvbWl0TGVmdChwcm9ncmFtLmJvZHksIG51bGwsIHRydWUpO1xuICAgIH1cblxuICAgIGlmIChpbnZlcnNlU3RyaXAuY2xvc2UpIHtcbiAgICAgIG9taXRSaWdodChmaXJzdEludmVyc2UuYm9keSwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChibG9jay5jbG9zZVN0cmlwLm9wZW4pIHtcbiAgICAgIG9taXRMZWZ0KGxhc3RJbnZlcnNlLmJvZHksIG51bGwsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIEZpbmQgc3RhbmRhbG9uZSBlbHNlIHN0YXRtZW50c1xuICAgIGlmICghdGhpcy5vcHRpb25zLmlnbm9yZVN0YW5kYWxvbmUgJiYgaXNQcmV2V2hpdGVzcGFjZShwcm9ncmFtLmJvZHkpICYmIGlzTmV4dFdoaXRlc3BhY2UoZmlyc3RJbnZlcnNlLmJvZHkpKSB7XG4gICAgICBvbWl0TGVmdChwcm9ncmFtLmJvZHkpO1xuICAgICAgb21pdFJpZ2h0KGZpcnN0SW52ZXJzZS5ib2R5KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYmxvY2suY2xvc2VTdHJpcC5vcGVuKSB7XG4gICAgb21pdExlZnQocHJvZ3JhbS5ib2R5LCBudWxsLCB0cnVlKTtcbiAgfVxuXG4gIHJldHVybiBzdHJpcDtcbn07XG5cbldoaXRlc3BhY2VDb250cm9sLnByb3RvdHlwZS5EZWNvcmF0b3IgPSBXaGl0ZXNwYWNlQ29udHJvbC5wcm90b3R5cGUuTXVzdGFjaGVTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobXVzdGFjaGUpIHtcbiAgcmV0dXJuIG11c3RhY2hlLnN0cmlwO1xufTtcblxuV2hpdGVzcGFjZUNvbnRyb2wucHJvdG90eXBlLlBhcnRpYWxTdGF0ZW1lbnQgPSBXaGl0ZXNwYWNlQ29udHJvbC5wcm90b3R5cGUuQ29tbWVudFN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHZhciBzdHJpcCA9IG5vZGUuc3RyaXAgfHwge307XG4gIHJldHVybiB7XG4gICAgaW5saW5lU3RhbmRhbG9uZTogdHJ1ZSxcbiAgICBvcGVuOiBzdHJpcC5vcGVuLFxuICAgIGNsb3NlOiBzdHJpcC5jbG9zZVxuICB9O1xufTtcblxuZnVuY3Rpb24gaXNQcmV2V2hpdGVzcGFjZShib2R5LCBpLCBpc1Jvb3QpIHtcbiAgaWYgKGkgPT09IHVuZGVmaW5lZCkge1xuICAgIGkgPSBib2R5Lmxlbmd0aDtcbiAgfVxuXG4gIC8vIE5vZGVzIHRoYXQgZW5kIHdpdGggbmV3bGluZXMgYXJlIGNvbnNpZGVyZWQgd2hpdGVzcGFjZSAoYnV0IGFyZSBzcGVjaWFsXG4gIC8vIGNhc2VkIGZvciBzdHJpcCBvcGVyYXRpb25zKVxuICB2YXIgcHJldiA9IGJvZHlbaSAtIDFdLFxuICAgICAgc2libGluZyA9IGJvZHlbaSAtIDJdO1xuICBpZiAoIXByZXYpIHtcbiAgICByZXR1cm4gaXNSb290O1xuICB9XG5cbiAgaWYgKHByZXYudHlwZSA9PT0gJ0NvbnRlbnRTdGF0ZW1lbnQnKSB7XG4gICAgcmV0dXJuIChzaWJsaW5nIHx8ICFpc1Jvb3QgPyAvXFxyP1xcblxccyo/JC8gOiAvKF58XFxyP1xcbilcXHMqPyQvKS50ZXN0KHByZXYub3JpZ2luYWwpO1xuICB9XG59XG5mdW5jdGlvbiBpc05leHRXaGl0ZXNwYWNlKGJvZHksIGksIGlzUm9vdCkge1xuICBpZiAoaSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaSA9IC0xO1xuICB9XG5cbiAgdmFyIG5leHQgPSBib2R5W2kgKyAxXSxcbiAgICAgIHNpYmxpbmcgPSBib2R5W2kgKyAyXTtcbiAgaWYgKCFuZXh0KSB7XG4gICAgcmV0dXJuIGlzUm9vdDtcbiAgfVxuXG4gIGlmIChuZXh0LnR5cGUgPT09ICdDb250ZW50U3RhdGVtZW50Jykge1xuICAgIHJldHVybiAoc2libGluZyB8fCAhaXNSb290ID8gL15cXHMqP1xccj9cXG4vIDogL15cXHMqPyhcXHI/XFxufCQpLykudGVzdChuZXh0Lm9yaWdpbmFsKTtcbiAgfVxufVxuXG4vLyBNYXJrcyB0aGUgbm9kZSB0byB0aGUgcmlnaHQgb2YgdGhlIHBvc2l0aW9uIGFzIG9taXR0ZWQuXG4vLyBJLmUuIHt7Zm9vfX0nICcgd2lsbCBtYXJrIHRoZSAnICcgbm9kZSBhcyBvbWl0dGVkLlxuLy9cbi8vIElmIGkgaXMgdW5kZWZpbmVkLCB0aGVuIHRoZSBmaXJzdCBjaGlsZCB3aWxsIGJlIG1hcmtlZCBhcyBzdWNoLlxuLy9cbi8vIElmIG11bGl0cGxlIGlzIHRydXRoeSB0aGVuIGFsbCB3aGl0ZXNwYWNlIHdpbGwgYmUgc3RyaXBwZWQgb3V0IHVudGlsIG5vbi13aGl0ZXNwYWNlXG4vLyBjb250ZW50IGlzIG1ldC5cbmZ1bmN0aW9uIG9taXRSaWdodChib2R5LCBpLCBtdWx0aXBsZSkge1xuICB2YXIgY3VycmVudCA9IGJvZHlbaSA9PSBudWxsID8gMCA6IGkgKyAxXTtcbiAgaWYgKCFjdXJyZW50IHx8IGN1cnJlbnQudHlwZSAhPT0gJ0NvbnRlbnRTdGF0ZW1lbnQnIHx8ICFtdWx0aXBsZSAmJiBjdXJyZW50LnJpZ2h0U3RyaXBwZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgb3JpZ2luYWwgPSBjdXJyZW50LnZhbHVlO1xuICBjdXJyZW50LnZhbHVlID0gY3VycmVudC52YWx1ZS5yZXBsYWNlKG11bHRpcGxlID8gL15cXHMrLyA6IC9eWyBcXHRdKlxccj9cXG4/LywgJycpO1xuICBjdXJyZW50LnJpZ2h0U3RyaXBwZWQgPSBjdXJyZW50LnZhbHVlICE9PSBvcmlnaW5hbDtcbn1cblxuLy8gTWFya3MgdGhlIG5vZGUgdG8gdGhlIGxlZnQgb2YgdGhlIHBvc2l0aW9uIGFzIG9taXR0ZWQuXG4vLyBJLmUuICcgJ3t7Zm9vfX0gd2lsbCBtYXJrIHRoZSAnICcgbm9kZSBhcyBvbWl0dGVkLlxuLy9cbi8vIElmIGkgaXMgdW5kZWZpbmVkIHRoZW4gdGhlIGxhc3QgY2hpbGQgd2lsbCBiZSBtYXJrZWQgYXMgc3VjaC5cbi8vXG4vLyBJZiBtdWxpdHBsZSBpcyB0cnV0aHkgdGhlbiBhbGwgd2hpdGVzcGFjZSB3aWxsIGJlIHN0cmlwcGVkIG91dCB1bnRpbCBub24td2hpdGVzcGFjZVxuLy8gY29udGVudCBpcyBtZXQuXG5mdW5jdGlvbiBvbWl0TGVmdChib2R5LCBpLCBtdWx0aXBsZSkge1xuICB2YXIgY3VycmVudCA9IGJvZHlbaSA9PSBudWxsID8gYm9keS5sZW5ndGggLSAxIDogaSAtIDFdO1xuICBpZiAoIWN1cnJlbnQgfHwgY3VycmVudC50eXBlICE9PSAnQ29udGVudFN0YXRlbWVudCcgfHwgIW11bHRpcGxlICYmIGN1cnJlbnQubGVmdFN0cmlwcGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gV2Ugb21pdCB0aGUgbGFzdCBub2RlIGlmIGl0J3Mgd2hpdGVzcGFjZSBvbmx5IGFuZCBub3QgcHJlY2VlZGVkIGJ5IGEgbm9uLWNvbnRlbnQgbm9kZS5cbiAgdmFyIG9yaWdpbmFsID0gY3VycmVudC52YWx1ZTtcbiAgY3VycmVudC52YWx1ZSA9IGN1cnJlbnQudmFsdWUucmVwbGFjZShtdWx0aXBsZSA/IC9cXHMrJC8gOiAvWyBcXHRdKyQvLCAnJyk7XG4gIGN1cnJlbnQubGVmdFN0cmlwcGVkID0gY3VycmVudC52YWx1ZSAhPT0gb3JpZ2luYWw7XG4gIHJldHVybiBjdXJyZW50LmxlZnRTdHJpcHBlZDtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gV2hpdGVzcGFjZUNvbnRyb2w7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG59LHtcIi4vdmlzaXRvclwiOjE2fV0sMTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5yZWdpc3RlckRlZmF1bHREZWNvcmF0b3JzID0gcmVnaXN0ZXJEZWZhdWx0RGVjb3JhdG9ycztcbi8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9kZWNvcmF0b3JzSW5saW5lID0gcmVxdWlyZSgnLi9kZWNvcmF0b3JzL2lubGluZScpO1xuXG52YXIgX2RlY29yYXRvcnNJbmxpbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVjb3JhdG9yc0lubGluZSk7XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdERlY29yYXRvcnMoaW5zdGFuY2UpIHtcbiAgX2RlY29yYXRvcnNJbmxpbmUyWydkZWZhdWx0J10oaW5zdGFuY2UpO1xufVxuXG5cbn0se1wiLi9kZWNvcmF0b3JzL2lubGluZVwiOjE5fV0sMTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnJlZ2lzdGVyRGVjb3JhdG9yKCdpbmxpbmUnLCBmdW5jdGlvbiAoZm4sIHByb3BzLCBjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgICB2YXIgcmV0ID0gZm47XG4gICAgaWYgKCFwcm9wcy5wYXJ0aWFscykge1xuICAgICAgcHJvcHMucGFydGlhbHMgPSB7fTtcbiAgICAgIHJldCA9IGZ1bmN0aW9uIChjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBwYXJ0aWFscyBzdGFjayBmcmFtZSBwcmlvciB0byBleGVjLlxuICAgICAgICB2YXIgb3JpZ2luYWwgPSBjb250YWluZXIucGFydGlhbHM7XG4gICAgICAgIGNvbnRhaW5lci5wYXJ0aWFscyA9IF91dGlscy5leHRlbmQoe30sIG9yaWdpbmFsLCBwcm9wcy5wYXJ0aWFscyk7XG4gICAgICAgIHZhciByZXQgPSBmbihjb250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgY29udGFpbmVyLnBhcnRpYWxzID0gb3JpZ2luYWw7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHByb3BzLnBhcnRpYWxzW29wdGlvbnMuYXJnc1swXV0gPSBvcHRpb25zLmZuO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG59LHtcIi4uL3V0aWxzXCI6MzN9XSwyMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBlcnJvclByb3BzID0gWydkZXNjcmlwdGlvbicsICdmaWxlTmFtZScsICdsaW5lTnVtYmVyJywgJ21lc3NhZ2UnLCAnbmFtZScsICdudW1iZXInLCAnc3RhY2snXTtcblxuZnVuY3Rpb24gRXhjZXB0aW9uKG1lc3NhZ2UsIG5vZGUpIHtcbiAgdmFyIGxvYyA9IG5vZGUgJiYgbm9kZS5sb2MsXG4gICAgICBsaW5lID0gdW5kZWZpbmVkLFxuICAgICAgY29sdW1uID0gdW5kZWZpbmVkO1xuICBpZiAobG9jKSB7XG4gICAgbGluZSA9IGxvYy5zdGFydC5saW5lO1xuICAgIGNvbHVtbiA9IGxvYy5zdGFydC5jb2x1bW47XG5cbiAgICBtZXNzYWdlICs9ICcgLSAnICsgbGluZSArICc6JyArIGNvbHVtbjtcbiAgfVxuXG4gIHZhciB0bXAgPSBFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcblxuICAvLyBVbmZvcnR1bmF0ZWx5IGVycm9ycyBhcmUgbm90IGVudW1lcmFibGUgaW4gQ2hyb21lIChhdCBsZWFzdCksIHNvIGBmb3IgcHJvcCBpbiB0bXBgIGRvZXNuJ3Qgd29yay5cbiAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgZXJyb3JQcm9wcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgdGhpc1tlcnJvclByb3BzW2lkeF1dID0gdG1wW2Vycm9yUHJvcHNbaWR4XV07XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBFeGNlcHRpb24pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAobG9jKSB7XG4gICAgICB0aGlzLmxpbmVOdW1iZXIgPSBsaW5lO1xuXG4gICAgICAvLyBXb3JrIGFyb3VuZCBpc3N1ZSB1bmRlciBzYWZhcmkgd2hlcmUgd2UgY2FuJ3QgZGlyZWN0bHkgc2V0IHRoZSBjb2x1bW4gdmFsdWVcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29sdW1uJywgeyB2YWx1ZTogY29sdW1uIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChub3ApIHtcbiAgICAvKiBJZ25vcmUgaWYgdGhlIGJyb3dzZXIgaXMgdmVyeSBwYXJ0aWN1bGFyICovXG4gIH1cbn1cblxuRXhjZXB0aW9uLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBFeGNlcHRpb247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG59LHt9XSwyMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnJlZ2lzdGVyRGVmYXVsdEhlbHBlcnMgPSByZWdpc3RlckRlZmF1bHRIZWxwZXJzO1xuLy8gaXN0YW5idWwgaWdub3JlIG5leHRcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX2hlbHBlcnNCbG9ja0hlbHBlck1pc3NpbmcgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmxvY2staGVscGVyLW1pc3NpbmcnKTtcblxudmFyIF9oZWxwZXJzQmxvY2tIZWxwZXJNaXNzaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hlbHBlcnNCbG9ja0hlbHBlck1pc3NpbmcpO1xuXG52YXIgX2hlbHBlcnNFYWNoID0gcmVxdWlyZSgnLi9oZWxwZXJzL2VhY2gnKTtcblxudmFyIF9oZWxwZXJzRWFjaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oZWxwZXJzRWFjaCk7XG5cbnZhciBfaGVscGVyc0hlbHBlck1pc3NpbmcgPSByZXF1aXJlKCcuL2hlbHBlcnMvaGVscGVyLW1pc3NpbmcnKTtcblxudmFyIF9oZWxwZXJzSGVscGVyTWlzc2luZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oZWxwZXJzSGVscGVyTWlzc2luZyk7XG5cbnZhciBfaGVscGVyc0lmID0gcmVxdWlyZSgnLi9oZWxwZXJzL2lmJyk7XG5cbnZhciBfaGVscGVyc0lmMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hlbHBlcnNJZik7XG5cbnZhciBfaGVscGVyc0xvZyA9IHJlcXVpcmUoJy4vaGVscGVycy9sb2cnKTtcblxudmFyIF9oZWxwZXJzTG9nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hlbHBlcnNMb2cpO1xuXG52YXIgX2hlbHBlcnNMb29rdXAgPSByZXF1aXJlKCcuL2hlbHBlcnMvbG9va3VwJyk7XG5cbnZhciBfaGVscGVyc0xvb2t1cDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oZWxwZXJzTG9va3VwKTtcblxudmFyIF9oZWxwZXJzV2l0aCA9IHJlcXVpcmUoJy4vaGVscGVycy93aXRoJyk7XG5cbnZhciBfaGVscGVyc1dpdGgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGVscGVyc1dpdGgpO1xuXG5mdW5jdGlvbiByZWdpc3RlckRlZmF1bHRIZWxwZXJzKGluc3RhbmNlKSB7XG4gIF9oZWxwZXJzQmxvY2tIZWxwZXJNaXNzaW5nMlsnZGVmYXVsdCddKGluc3RhbmNlKTtcbiAgX2hlbHBlcnNFYWNoMlsnZGVmYXVsdCddKGluc3RhbmNlKTtcbiAgX2hlbHBlcnNIZWxwZXJNaXNzaW5nMlsnZGVmYXVsdCddKGluc3RhbmNlKTtcbiAgX2hlbHBlcnNJZjJbJ2RlZmF1bHQnXShpbnN0YW5jZSk7XG4gIF9oZWxwZXJzTG9nMlsnZGVmYXVsdCddKGluc3RhbmNlKTtcbiAgX2hlbHBlcnNMb29rdXAyWydkZWZhdWx0J10oaW5zdGFuY2UpO1xuICBfaGVscGVyc1dpdGgyWydkZWZhdWx0J10oaW5zdGFuY2UpO1xufVxuXG5cbn0se1wiLi9oZWxwZXJzL2Jsb2NrLWhlbHBlci1taXNzaW5nXCI6MjIsXCIuL2hlbHBlcnMvZWFjaFwiOjIzLFwiLi9oZWxwZXJzL2hlbHBlci1taXNzaW5nXCI6MjQsXCIuL2hlbHBlcnMvaWZcIjoyNSxcIi4vaGVscGVycy9sb2dcIjoyNixcIi4vaGVscGVycy9sb29rdXBcIjoyNyxcIi4vaGVscGVycy93aXRoXCI6Mjh9XSwyMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2Jsb2NrSGVscGVyTWlzc2luZycsIGZ1bmN0aW9uIChjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgdmFyIGludmVyc2UgPSBvcHRpb25zLmludmVyc2UsXG4gICAgICAgIGZuID0gb3B0aW9ucy5mbjtcblxuICAgIGlmIChjb250ZXh0ID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gZm4odGhpcyk7XG4gICAgfSBlbHNlIGlmIChjb250ZXh0ID09PSBmYWxzZSB8fCBjb250ZXh0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBpbnZlcnNlKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoX3V0aWxzLmlzQXJyYXkoY29udGV4dCkpIHtcbiAgICAgIGlmIChjb250ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaWRzKSB7XG4gICAgICAgICAgb3B0aW9ucy5pZHMgPSBbb3B0aW9ucy5uYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5oZWxwZXJzLmVhY2goY29udGV4dCwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaW52ZXJzZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmlkcykge1xuICAgICAgICB2YXIgZGF0YSA9IF91dGlscy5jcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgICAgICBkYXRhLmNvbnRleHRQYXRoID0gX3V0aWxzLmFwcGVuZENvbnRleHRQYXRoKG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCwgb3B0aW9ucy5uYW1lKTtcbiAgICAgICAgb3B0aW9ucyA9IHsgZGF0YTogZGF0YSB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm4oY29udGV4dCwgb3B0aW9ucyk7XG4gICAgfVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbn0se1wiLi4vdXRpbHNcIjozM31dLDIzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbi8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbnZhciBfZXhjZXB0aW9uID0gcmVxdWlyZSgnLi4vZXhjZXB0aW9uJyk7XG5cbnZhciBfZXhjZXB0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4Y2VwdGlvbik7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignZWFjaCcsIGZ1bmN0aW9uIChjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnTXVzdCBwYXNzIGl0ZXJhdG9yIHRvICNlYWNoJyk7XG4gICAgfVxuXG4gICAgdmFyIGZuID0gb3B0aW9ucy5mbixcbiAgICAgICAgaW52ZXJzZSA9IG9wdGlvbnMuaW52ZXJzZSxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIHJldCA9ICcnLFxuICAgICAgICBkYXRhID0gdW5kZWZpbmVkLFxuICAgICAgICBjb250ZXh0UGF0aCA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5pZHMpIHtcbiAgICAgIGNvbnRleHRQYXRoID0gX3V0aWxzLmFwcGVuZENvbnRleHRQYXRoKG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCwgb3B0aW9ucy5pZHNbMF0pICsgJy4nO1xuICAgIH1cblxuICAgIGlmIChfdXRpbHMuaXNGdW5jdGlvbihjb250ZXh0KSkge1xuICAgICAgY29udGV4dCA9IGNvbnRleHQuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICBkYXRhID0gX3V0aWxzLmNyZWF0ZUZyYW1lKG9wdGlvbnMuZGF0YSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhlY0l0ZXJhdGlvbihmaWVsZCwgaW5kZXgsIGxhc3QpIHtcbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGRhdGEua2V5ID0gZmllbGQ7XG4gICAgICAgIGRhdGEuaW5kZXggPSBpbmRleDtcbiAgICAgICAgZGF0YS5maXJzdCA9IGluZGV4ID09PSAwO1xuICAgICAgICBkYXRhLmxhc3QgPSAhIWxhc3Q7XG5cbiAgICAgICAgaWYgKGNvbnRleHRQYXRoKSB7XG4gICAgICAgICAgZGF0YS5jb250ZXh0UGF0aCA9IGNvbnRleHRQYXRoICsgZmllbGQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0ID0gcmV0ICsgZm4oY29udGV4dFtmaWVsZF0sIHtcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgYmxvY2tQYXJhbXM6IF91dGlscy5ibG9ja1BhcmFtcyhbY29udGV4dFtmaWVsZF0sIGZpZWxkXSwgW2NvbnRleHRQYXRoICsgZmllbGQsIG51bGxdKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoX3V0aWxzLmlzQXJyYXkoY29udGV4dCkpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IGNvbnRleHQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgaWYgKGkgaW4gY29udGV4dCkge1xuICAgICAgICAgICAgZXhlY0l0ZXJhdGlvbihpLCBpLCBpID09PSBjb250ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHByaW9yS2V5ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgLy8gV2UncmUgcnVubmluZyB0aGUgaXRlcmF0aW9ucyBvbmUgc3RlcCBvdXQgb2Ygc3luYyBzbyB3ZSBjYW4gZGV0ZWN0XG4gICAgICAgICAgICAvLyB0aGUgbGFzdCBpdGVyYXRpb24gd2l0aG91dCBoYXZlIHRvIHNjYW4gdGhlIG9iamVjdCB0d2ljZSBhbmQgY3JlYXRlXG4gICAgICAgICAgICAvLyBhbiBpdGVybWVkaWF0ZSBrZXlzIGFycmF5LlxuICAgICAgICAgICAgaWYgKHByaW9yS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZXhlY0l0ZXJhdGlvbihwcmlvcktleSwgaSAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJpb3JLZXkgPSBrZXk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcmlvcktleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZXhlY0l0ZXJhdGlvbihwcmlvcktleSwgaSAtIDEsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIHJldCA9IGludmVyc2UodGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG59LHtcIi4uL2V4Y2VwdGlvblwiOjIwLFwiLi4vdXRpbHNcIjozM31dLDI0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbi8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9leGNlcHRpb24gPSByZXF1aXJlKCcuLi9leGNlcHRpb24nKTtcblxudmFyIF9leGNlcHRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXhjZXB0aW9uKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdoZWxwZXJNaXNzaW5nJywgZnVuY3Rpb24gKCkgLyogW2FyZ3MsIF1vcHRpb25zICove1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBBIG1pc3NpbmcgZmllbGQgaW4gYSB7e2Zvb319IGNvbnN0cnVjdC5cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNvbWVvbmUgaXMgYWN0dWFsbHkgdHJ5aW5nIHRvIGNhbGwgc29tZXRoaW5nLCBibG93IHVwLlxuICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ01pc3NpbmcgaGVscGVyOiBcIicgKyBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdLm5hbWUgKyAnXCInKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxufSx7XCIuLi9leGNlcHRpb25cIjoyMH1dLDI1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignaWYnLCBmdW5jdGlvbiAoY29uZGl0aW9uYWwsIG9wdGlvbnMpIHtcbiAgICBpZiAoX3V0aWxzLmlzRnVuY3Rpb24oY29uZGl0aW9uYWwpKSB7XG4gICAgICBjb25kaXRpb25hbCA9IGNvbmRpdGlvbmFsLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCBiZWhhdmlvciBpcyB0byByZW5kZXIgdGhlIHBvc2l0aXZlIHBhdGggaWYgdGhlIHZhbHVlIGlzIHRydXRoeSBhbmQgbm90IGVtcHR5LlxuICAgIC8vIFRoZSBgaW5jbHVkZVplcm9gIG9wdGlvbiBtYXkgYmUgc2V0IHRvIHRyZWF0IHRoZSBjb25kdGlvbmFsIGFzIHB1cmVseSBub3QgZW1wdHkgYmFzZWQgb24gdGhlXG4gICAgLy8gYmVoYXZpb3Igb2YgaXNFbXB0eS4gRWZmZWN0aXZlbHkgdGhpcyBkZXRlcm1pbmVzIGlmIDAgaXMgaGFuZGxlZCBieSB0aGUgcG9zaXRpdmUgcGF0aCBvciBuZWdhdGl2ZS5cbiAgICBpZiAoIW9wdGlvbnMuaGFzaC5pbmNsdWRlWmVybyAmJiAhY29uZGl0aW9uYWwgfHwgX3V0aWxzLmlzRW1wdHkoY29uZGl0aW9uYWwpKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5mbih0aGlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCd1bmxlc3MnLCBmdW5jdGlvbiAoY29uZGl0aW9uYWwsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuaGVscGVyc1snaWYnXS5jYWxsKHRoaXMsIGNvbmRpdGlvbmFsLCB7IGZuOiBvcHRpb25zLmludmVyc2UsIGludmVyc2U6IG9wdGlvbnMuZm4sIGhhc2g6IG9wdGlvbnMuaGFzaCB9KTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG59LHtcIi4uL3V0aWxzXCI6MzN9XSwyNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignbG9nJywgZnVuY3Rpb24gKCkgLyogbWVzc2FnZSwgb3B0aW9ucyAqL3tcbiAgICB2YXIgYXJncyA9IFt1bmRlZmluZWRdLFxuICAgICAgICBvcHRpb25zID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIHZhciBsZXZlbCA9IDE7XG4gICAgaWYgKG9wdGlvbnMuaGFzaC5sZXZlbCAhPSBudWxsKSB7XG4gICAgICBsZXZlbCA9IG9wdGlvbnMuaGFzaC5sZXZlbDtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmRhdGEubGV2ZWwgIT0gbnVsbCkge1xuICAgICAgbGV2ZWwgPSBvcHRpb25zLmRhdGEubGV2ZWw7XG4gICAgfVxuICAgIGFyZ3NbMF0gPSBsZXZlbDtcblxuICAgIGluc3RhbmNlLmxvZy5hcHBseShpbnN0YW5jZSwgYXJncyk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxufSx7fV0sMjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2xvb2t1cCcsIGZ1bmN0aW9uIChvYmosIGZpZWxkKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmpbZmllbGRdO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbn0se31dLDI4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignd2l0aCcsIGZ1bmN0aW9uIChjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgaWYgKF91dGlscy5pc0Z1bmN0aW9uKGNvbnRleHQpKSB7XG4gICAgICBjb250ZXh0ID0gY29udGV4dC5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIHZhciBmbiA9IG9wdGlvbnMuZm47XG5cbiAgICBpZiAoIV91dGlscy5pc0VtcHR5KGNvbnRleHQpKSB7XG4gICAgICB2YXIgZGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgICAgIGlmIChvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5pZHMpIHtcbiAgICAgICAgZGF0YSA9IF91dGlscy5jcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgICAgICBkYXRhLmNvbnRleHRQYXRoID0gX3V0aWxzLmFwcGVuZENvbnRleHRQYXRoKG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCwgb3B0aW9ucy5pZHNbMF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm4oY29udGV4dCwge1xuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBibG9ja1BhcmFtczogX3V0aWxzLmJsb2NrUGFyYW1zKFtjb250ZXh0XSwgW2RhdGEgJiYgZGF0YS5jb250ZXh0UGF0aF0pXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxufSx7XCIuLi91dGlsc1wiOjMzfV0sMjk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgbG9nZ2VyID0ge1xuICBtZXRob2RNYXA6IFsnZGVidWcnLCAnaW5mbycsICd3YXJuJywgJ2Vycm9yJ10sXG4gIGxldmVsOiAnaW5mbycsXG5cbiAgLy8gTWFwcyBhIGdpdmVuIGxldmVsIHZhbHVlIHRvIHRoZSBgbWV0aG9kTWFwYCBpbmRleGVzIGFib3ZlLlxuICBsb29rdXBMZXZlbDogZnVuY3Rpb24gbG9va3VwTGV2ZWwobGV2ZWwpIHtcbiAgICBpZiAodHlwZW9mIGxldmVsID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIGxldmVsTWFwID0gX3V0aWxzLmluZGV4T2YobG9nZ2VyLm1ldGhvZE1hcCwgbGV2ZWwudG9Mb3dlckNhc2UoKSk7XG4gICAgICBpZiAobGV2ZWxNYXAgPj0gMCkge1xuICAgICAgICBsZXZlbCA9IGxldmVsTWFwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWwgPSBwYXJzZUludChsZXZlbCwgMTApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsZXZlbDtcbiAgfSxcblxuICAvLyBDYW4gYmUgb3ZlcnJpZGRlbiBpbiB0aGUgaG9zdCBlbnZpcm9ubWVudFxuICBsb2c6IGZ1bmN0aW9uIGxvZyhsZXZlbCkge1xuICAgIGxldmVsID0gbG9nZ2VyLmxvb2t1cExldmVsKGxldmVsKTtcblxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbG9nZ2VyLmxvb2t1cExldmVsKGxvZ2dlci5sZXZlbCkgPD0gbGV2ZWwpIHtcbiAgICAgIHZhciBtZXRob2QgPSBsb2dnZXIubWV0aG9kTWFwW2xldmVsXTtcbiAgICAgIGlmICghY29uc29sZVttZXRob2RdKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgICBtZXRob2QgPSAnbG9nJztcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1lc3NhZ2UgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIG1lc3NhZ2VbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlW21ldGhvZF0uYXBwbHkoY29uc29sZSwgbWVzc2FnZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gbG9nZ2VyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxufSx7XCIuL3V0aWxzXCI6MzN9XSwzMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4vKiBnbG9iYWwgd2luZG93ICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGZ1bmN0aW9uIChIYW5kbGViYXJzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHZhciByb290ID0gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB3aW5kb3csXG4gICAgICAkSGFuZGxlYmFycyA9IHJvb3QuSGFuZGxlYmFycztcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgSGFuZGxlYmFycy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChyb290LkhhbmRsZWJhcnMgPT09IEhhbmRsZWJhcnMpIHtcbiAgICAgIHJvb3QuSGFuZGxlYmFycyA9ICRIYW5kbGViYXJzO1xuICAgIH1cbiAgICByZXR1cm4gSGFuZGxlYmFycztcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7fV0sMzE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5jaGVja1JldmlzaW9uID0gY2hlY2tSZXZpc2lvbjtcbmV4cG9ydHMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbmV4cG9ydHMud3JhcFByb2dyYW0gPSB3cmFwUHJvZ3JhbTtcbmV4cG9ydHMucmVzb2x2ZVBhcnRpYWwgPSByZXNvbHZlUGFydGlhbDtcbmV4cG9ydHMuaW52b2tlUGFydGlhbCA9IGludm9rZVBhcnRpYWw7XG5leHBvcnRzLm5vb3AgPSBub29wO1xuLy8gaXN0YW5idWwgaWdub3JlIG5leHRcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqWydkZWZhdWx0J10gPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgVXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHMpO1xuXG52YXIgX2V4Y2VwdGlvbiA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XG5cbnZhciBfZXhjZXB0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4Y2VwdGlvbik7XG5cbnZhciBfYmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xuXG5mdW5jdGlvbiBjaGVja1JldmlzaW9uKGNvbXBpbGVySW5mbykge1xuICB2YXIgY29tcGlsZXJSZXZpc2lvbiA9IGNvbXBpbGVySW5mbyAmJiBjb21waWxlckluZm9bMF0gfHwgMSxcbiAgICAgIGN1cnJlbnRSZXZpc2lvbiA9IF9iYXNlLkNPTVBJTEVSX1JFVklTSU9OO1xuXG4gIGlmIChjb21waWxlclJldmlzaW9uICE9PSBjdXJyZW50UmV2aXNpb24pIHtcbiAgICBpZiAoY29tcGlsZXJSZXZpc2lvbiA8IGN1cnJlbnRSZXZpc2lvbikge1xuICAgICAgdmFyIHJ1bnRpbWVWZXJzaW9ucyA9IF9iYXNlLlJFVklTSU9OX0NIQU5HRVNbY3VycmVudFJldmlzaW9uXSxcbiAgICAgICAgICBjb21waWxlclZlcnNpb25zID0gX2Jhc2UuUkVWSVNJT05fQ0hBTkdFU1tjb21waWxlclJldmlzaW9uXTtcbiAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdUZW1wbGF0ZSB3YXMgcHJlY29tcGlsZWQgd2l0aCBhbiBvbGRlciB2ZXJzaW9uIG9mIEhhbmRsZWJhcnMgdGhhbiB0aGUgY3VycmVudCBydW50aW1lLiAnICsgJ1BsZWFzZSB1cGRhdGUgeW91ciBwcmVjb21waWxlciB0byBhIG5ld2VyIHZlcnNpb24gKCcgKyBydW50aW1lVmVyc2lvbnMgKyAnKSBvciBkb3duZ3JhZGUgeW91ciBydW50aW1lIHRvIGFuIG9sZGVyIHZlcnNpb24gKCcgKyBjb21waWxlclZlcnNpb25zICsgJykuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVzZSB0aGUgZW1iZWRkZWQgdmVyc2lvbiBpbmZvIHNpbmNlIHRoZSBydW50aW1lIGRvZXNuJ3Qga25vdyBhYm91dCB0aGlzIHJldmlzaW9uIHlldFxuICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ1RlbXBsYXRlIHdhcyBwcmVjb21waWxlZCB3aXRoIGEgbmV3ZXIgdmVyc2lvbiBvZiBIYW5kbGViYXJzIHRoYW4gdGhlIGN1cnJlbnQgcnVudGltZS4gJyArICdQbGVhc2UgdXBkYXRlIHlvdXIgcnVudGltZSB0byBhIG5ld2VyIHZlcnNpb24gKCcgKyBjb21waWxlckluZm9bMV0gKyAnKS4nKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVtcGxhdGUodGVtcGxhdGVTcGVjLCBlbnYpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKCFlbnYpIHtcbiAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnTm8gZW52aXJvbm1lbnQgcGFzc2VkIHRvIHRlbXBsYXRlJyk7XG4gIH1cbiAgaWYgKCF0ZW1wbGF0ZVNwZWMgfHwgIXRlbXBsYXRlU3BlYy5tYWluKSB7XG4gICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ1Vua25vd24gdGVtcGxhdGUgb2JqZWN0OiAnICsgdHlwZW9mIHRlbXBsYXRlU3BlYyk7XG4gIH1cblxuICB0ZW1wbGF0ZVNwZWMubWFpbi5kZWNvcmF0b3IgPSB0ZW1wbGF0ZVNwZWMubWFpbl9kO1xuXG4gIC8vIE5vdGU6IFVzaW5nIGVudi5WTSByZWZlcmVuY2VzIHJhdGhlciB0aGFuIGxvY2FsIHZhciByZWZlcmVuY2VzIHRocm91Z2hvdXQgdGhpcyBzZWN0aW9uIHRvIGFsbG93XG4gIC8vIGZvciBleHRlcm5hbCB1c2VycyB0byBvdmVycmlkZSB0aGVzZSBhcyBwc3VlZG8tc3VwcG9ydGVkIEFQSXMuXG4gIGVudi5WTS5jaGVja1JldmlzaW9uKHRlbXBsYXRlU3BlYy5jb21waWxlcik7XG5cbiAgZnVuY3Rpb24gaW52b2tlUGFydGlhbFdyYXBwZXIocGFydGlhbCwgY29udGV4dCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmhhc2gpIHtcbiAgICAgIGNvbnRleHQgPSBVdGlscy5leHRlbmQoe30sIGNvbnRleHQsIG9wdGlvbnMuaGFzaCk7XG4gICAgICBpZiAob3B0aW9ucy5pZHMpIHtcbiAgICAgICAgb3B0aW9ucy5pZHNbMF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhcnRpYWwgPSBlbnYuVk0ucmVzb2x2ZVBhcnRpYWwuY2FsbCh0aGlzLCBwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKTtcbiAgICB2YXIgcmVzdWx0ID0gZW52LlZNLmludm9rZVBhcnRpYWwuY2FsbCh0aGlzLCBwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKTtcblxuICAgIGlmIChyZXN1bHQgPT0gbnVsbCAmJiBlbnYuY29tcGlsZSkge1xuICAgICAgb3B0aW9ucy5wYXJ0aWFsc1tvcHRpb25zLm5hbWVdID0gZW52LmNvbXBpbGUocGFydGlhbCwgdGVtcGxhdGVTcGVjLmNvbXBpbGVyT3B0aW9ucywgZW52KTtcbiAgICAgIHJlc3VsdCA9IG9wdGlvbnMucGFydGlhbHNbb3B0aW9ucy5uYW1lXShjb250ZXh0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICBpZiAob3B0aW9ucy5pbmRlbnQpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gcmVzdWx0LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAoIWxpbmVzW2ldICYmIGkgKyAxID09PSBsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaW5lc1tpXSA9IG9wdGlvbnMuaW5kZW50ICsgbGluZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gbGluZXMuam9pbignXFxuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnVGhlIHBhcnRpYWwgJyArIG9wdGlvbnMubmFtZSArICcgY291bGQgbm90IGJlIGNvbXBpbGVkIHdoZW4gcnVubmluZyBpbiBydW50aW1lLW9ubHkgbW9kZScpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEp1c3QgYWRkIHdhdGVyXG4gIHZhciBjb250YWluZXIgPSB7XG4gICAgc3RyaWN0OiBmdW5jdGlvbiBzdHJpY3Qob2JqLCBuYW1lKSB7XG4gICAgICBpZiAoIShuYW1lIGluIG9iaikpIHtcbiAgICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ1wiJyArIG5hbWUgKyAnXCIgbm90IGRlZmluZWQgaW4gJyArIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqW25hbWVdO1xuICAgIH0sXG4gICAgbG9va3VwOiBmdW5jdGlvbiBsb29rdXAoZGVwdGhzLCBuYW1lKSB7XG4gICAgICB2YXIgbGVuID0gZGVwdGhzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGRlcHRoc1tpXSAmJiBkZXB0aHNbaV1bbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBkZXB0aHNbaV1bbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGxhbWJkYTogZnVuY3Rpb24gbGFtYmRhKGN1cnJlbnQsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgY3VycmVudCA9PT0gJ2Z1bmN0aW9uJyA/IGN1cnJlbnQuY2FsbChjb250ZXh0KSA6IGN1cnJlbnQ7XG4gICAgfSxcblxuICAgIGVzY2FwZUV4cHJlc3Npb246IFV0aWxzLmVzY2FwZUV4cHJlc3Npb24sXG4gICAgaW52b2tlUGFydGlhbDogaW52b2tlUGFydGlhbFdyYXBwZXIsXG5cbiAgICBmbjogZnVuY3Rpb24gZm4oaSkge1xuICAgICAgdmFyIHJldCA9IHRlbXBsYXRlU3BlY1tpXTtcbiAgICAgIHJldC5kZWNvcmF0b3IgPSB0ZW1wbGF0ZVNwZWNbaSArICdfZCddO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAgcHJvZ3JhbXM6IFtdLFxuICAgIHByb2dyYW06IGZ1bmN0aW9uIHByb2dyYW0oaSwgZGF0YSwgZGVjbGFyZWRCbG9ja1BhcmFtcywgYmxvY2tQYXJhbXMsIGRlcHRocykge1xuICAgICAgdmFyIHByb2dyYW1XcmFwcGVyID0gdGhpcy5wcm9ncmFtc1tpXSxcbiAgICAgICAgICBmbiA9IHRoaXMuZm4oaSk7XG4gICAgICBpZiAoZGF0YSB8fCBkZXB0aHMgfHwgYmxvY2tQYXJhbXMgfHwgZGVjbGFyZWRCbG9ja1BhcmFtcykge1xuICAgICAgICBwcm9ncmFtV3JhcHBlciA9IHdyYXBQcm9ncmFtKHRoaXMsIGksIGZuLCBkYXRhLCBkZWNsYXJlZEJsb2NrUGFyYW1zLCBibG9ja1BhcmFtcywgZGVwdGhzKTtcbiAgICAgIH0gZWxzZSBpZiAoIXByb2dyYW1XcmFwcGVyKSB7XG4gICAgICAgIHByb2dyYW1XcmFwcGVyID0gdGhpcy5wcm9ncmFtc1tpXSA9IHdyYXBQcm9ncmFtKHRoaXMsIGksIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9ncmFtV3JhcHBlcjtcbiAgICB9LFxuXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSh2YWx1ZSwgZGVwdGgpIHtcbiAgICAgIHdoaWxlICh2YWx1ZSAmJiBkZXB0aC0tKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuX3BhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIG1lcmdlOiBmdW5jdGlvbiBtZXJnZShwYXJhbSwgY29tbW9uKSB7XG4gICAgICB2YXIgb2JqID0gcGFyYW0gfHwgY29tbW9uO1xuXG4gICAgICBpZiAocGFyYW0gJiYgY29tbW9uICYmIHBhcmFtICE9PSBjb21tb24pIHtcbiAgICAgICAgb2JqID0gVXRpbHMuZXh0ZW5kKHt9LCBjb21tb24sIHBhcmFtKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuXG4gICAgbm9vcDogZW52LlZNLm5vb3AsXG4gICAgY29tcGlsZXJJbmZvOiB0ZW1wbGF0ZVNwZWMuY29tcGlsZXJcbiAgfTtcblxuICBmdW5jdGlvbiByZXQoY29udGV4dCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgICB2YXIgZGF0YSA9IG9wdGlvbnMuZGF0YTtcblxuICAgIHJldC5fc2V0dXAob3B0aW9ucyk7XG4gICAgaWYgKCFvcHRpb25zLnBhcnRpYWwgJiYgdGVtcGxhdGVTcGVjLnVzZURhdGEpIHtcbiAgICAgIGRhdGEgPSBpbml0RGF0YShjb250ZXh0LCBkYXRhKTtcbiAgICB9XG4gICAgdmFyIGRlcHRocyA9IHVuZGVmaW5lZCxcbiAgICAgICAgYmxvY2tQYXJhbXMgPSB0ZW1wbGF0ZVNwZWMudXNlQmxvY2tQYXJhbXMgPyBbXSA6IHVuZGVmaW5lZDtcbiAgICBpZiAodGVtcGxhdGVTcGVjLnVzZURlcHRocykge1xuICAgICAgaWYgKG9wdGlvbnMuZGVwdGhzKSB7XG4gICAgICAgIGRlcHRocyA9IGNvbnRleHQgIT0gb3B0aW9ucy5kZXB0aHNbMF0gPyBbY29udGV4dF0uY29uY2F0KG9wdGlvbnMuZGVwdGhzKSA6IG9wdGlvbnMuZGVwdGhzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVwdGhzID0gW2NvbnRleHRdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1haW4oY29udGV4dCAvKiwgb3B0aW9ucyovKSB7XG4gICAgICByZXR1cm4gJycgKyB0ZW1wbGF0ZVNwZWMubWFpbihjb250YWluZXIsIGNvbnRleHQsIGNvbnRhaW5lci5oZWxwZXJzLCBjb250YWluZXIucGFydGlhbHMsIGRhdGEsIGJsb2NrUGFyYW1zLCBkZXB0aHMpO1xuICAgIH1cbiAgICBtYWluID0gZXhlY3V0ZURlY29yYXRvcnModGVtcGxhdGVTcGVjLm1haW4sIG1haW4sIGNvbnRhaW5lciwgb3B0aW9ucy5kZXB0aHMgfHwgW10sIGRhdGEsIGJsb2NrUGFyYW1zKTtcbiAgICByZXR1cm4gbWFpbihjb250ZXh0LCBvcHRpb25zKTtcbiAgfVxuICByZXQuaXNUb3AgPSB0cnVlO1xuXG4gIHJldC5fc2V0dXAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5wYXJ0aWFsKSB7XG4gICAgICBjb250YWluZXIuaGVscGVycyA9IGNvbnRhaW5lci5tZXJnZShvcHRpb25zLmhlbHBlcnMsIGVudi5oZWxwZXJzKTtcblxuICAgICAgaWYgKHRlbXBsYXRlU3BlYy51c2VQYXJ0aWFsKSB7XG4gICAgICAgIGNvbnRhaW5lci5wYXJ0aWFscyA9IGNvbnRhaW5lci5tZXJnZShvcHRpb25zLnBhcnRpYWxzLCBlbnYucGFydGlhbHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRlbXBsYXRlU3BlYy51c2VQYXJ0aWFsIHx8IHRlbXBsYXRlU3BlYy51c2VEZWNvcmF0b3JzKSB7XG4gICAgICAgIGNvbnRhaW5lci5kZWNvcmF0b3JzID0gY29udGFpbmVyLm1lcmdlKG9wdGlvbnMuZGVjb3JhdG9ycywgZW52LmRlY29yYXRvcnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250YWluZXIuaGVscGVycyA9IG9wdGlvbnMuaGVscGVycztcbiAgICAgIGNvbnRhaW5lci5wYXJ0aWFscyA9IG9wdGlvbnMucGFydGlhbHM7XG4gICAgICBjb250YWluZXIuZGVjb3JhdG9ycyA9IG9wdGlvbnMuZGVjb3JhdG9ycztcbiAgICB9XG4gIH07XG5cbiAgcmV0Ll9jaGlsZCA9IGZ1bmN0aW9uIChpLCBkYXRhLCBibG9ja1BhcmFtcywgZGVwdGhzKSB7XG4gICAgaWYgKHRlbXBsYXRlU3BlYy51c2VCbG9ja1BhcmFtcyAmJiAhYmxvY2tQYXJhbXMpIHtcbiAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdtdXN0IHBhc3MgYmxvY2sgcGFyYW1zJyk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlRGVwdGhzICYmICFkZXB0aHMpIHtcbiAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdtdXN0IHBhc3MgcGFyZW50IGRlcHRocycpO1xuICAgIH1cblxuICAgIHJldHVybiB3cmFwUHJvZ3JhbShjb250YWluZXIsIGksIHRlbXBsYXRlU3BlY1tpXSwgZGF0YSwgMCwgYmxvY2tQYXJhbXMsIGRlcHRocyk7XG4gIH07XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHdyYXBQcm9ncmFtKGNvbnRhaW5lciwgaSwgZm4sIGRhdGEsIGRlY2xhcmVkQmxvY2tQYXJhbXMsIGJsb2NrUGFyYW1zLCBkZXB0aHMpIHtcbiAgZnVuY3Rpb24gcHJvZyhjb250ZXh0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcblxuICAgIHZhciBjdXJyZW50RGVwdGhzID0gZGVwdGhzO1xuICAgIGlmIChkZXB0aHMgJiYgY29udGV4dCAhPSBkZXB0aHNbMF0pIHtcbiAgICAgIGN1cnJlbnREZXB0aHMgPSBbY29udGV4dF0uY29uY2F0KGRlcHRocyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZuKGNvbnRhaW5lciwgY29udGV4dCwgY29udGFpbmVyLmhlbHBlcnMsIGNvbnRhaW5lci5wYXJ0aWFscywgb3B0aW9ucy5kYXRhIHx8IGRhdGEsIGJsb2NrUGFyYW1zICYmIFtvcHRpb25zLmJsb2NrUGFyYW1zXS5jb25jYXQoYmxvY2tQYXJhbXMpLCBjdXJyZW50RGVwdGhzKTtcbiAgfVxuXG4gIHByb2cgPSBleGVjdXRlRGVjb3JhdG9ycyhmbiwgcHJvZywgY29udGFpbmVyLCBkZXB0aHMsIGRhdGEsIGJsb2NrUGFyYW1zKTtcblxuICBwcm9nLnByb2dyYW0gPSBpO1xuICBwcm9nLmRlcHRoID0gZGVwdGhzID8gZGVwdGhzLmxlbmd0aCA6IDA7XG4gIHByb2cuYmxvY2tQYXJhbXMgPSBkZWNsYXJlZEJsb2NrUGFyYW1zIHx8IDA7XG4gIHJldHVybiBwcm9nO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlUGFydGlhbChwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKSB7XG4gIGlmICghcGFydGlhbCkge1xuICAgIGlmIChvcHRpb25zLm5hbWUgPT09ICdAcGFydGlhbC1ibG9jaycpIHtcbiAgICAgIHZhciBkYXRhID0gb3B0aW9ucy5kYXRhO1xuICAgICAgd2hpbGUgKGRhdGFbJ3BhcnRpYWwtYmxvY2snXSA9PT0gbm9vcCkge1xuICAgICAgICBkYXRhID0gZGF0YS5fcGFyZW50O1xuICAgICAgfVxuICAgICAgcGFydGlhbCA9IGRhdGFbJ3BhcnRpYWwtYmxvY2snXTtcbiAgICAgIGRhdGFbJ3BhcnRpYWwtYmxvY2snXSA9IG5vb3A7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnRpYWwgPSBvcHRpb25zLnBhcnRpYWxzW29wdGlvbnMubmFtZV07XG4gICAgfVxuICB9IGVsc2UgaWYgKCFwYXJ0aWFsLmNhbGwgJiYgIW9wdGlvbnMubmFtZSkge1xuICAgIC8vIFRoaXMgaXMgYSBkeW5hbWljIHBhcnRpYWwgdGhhdCByZXR1cm5lZCBhIHN0cmluZ1xuICAgIG9wdGlvbnMubmFtZSA9IHBhcnRpYWw7XG4gICAgcGFydGlhbCA9IG9wdGlvbnMucGFydGlhbHNbcGFydGlhbF07XG4gIH1cbiAgcmV0dXJuIHBhcnRpYWw7XG59XG5cbmZ1bmN0aW9uIGludm9rZVBhcnRpYWwocGFydGlhbCwgY29udGV4dCwgb3B0aW9ucykge1xuICBvcHRpb25zLnBhcnRpYWwgPSB0cnVlO1xuICBpZiAob3B0aW9ucy5pZHMpIHtcbiAgICBvcHRpb25zLmRhdGEuY29udGV4dFBhdGggPSBvcHRpb25zLmlkc1swXSB8fCBvcHRpb25zLmRhdGEuY29udGV4dFBhdGg7XG4gIH1cblxuICB2YXIgcGFydGlhbEJsb2NrID0gdW5kZWZpbmVkO1xuICBpZiAob3B0aW9ucy5mbiAmJiBvcHRpb25zLmZuICE9PSBub29wKSB7XG4gICAgb3B0aW9ucy5kYXRhID0gX2Jhc2UuY3JlYXRlRnJhbWUob3B0aW9ucy5kYXRhKTtcbiAgICBwYXJ0aWFsQmxvY2sgPSBvcHRpb25zLmRhdGFbJ3BhcnRpYWwtYmxvY2snXSA9IG9wdGlvbnMuZm47XG5cbiAgICBpZiAocGFydGlhbEJsb2NrLnBhcnRpYWxzKSB7XG4gICAgICBvcHRpb25zLnBhcnRpYWxzID0gVXRpbHMuZXh0ZW5kKHt9LCBvcHRpb25zLnBhcnRpYWxzLCBwYXJ0aWFsQmxvY2sucGFydGlhbHMpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwYXJ0aWFsID09PSB1bmRlZmluZWQgJiYgcGFydGlhbEJsb2NrKSB7XG4gICAgcGFydGlhbCA9IHBhcnRpYWxCbG9jaztcbiAgfVxuXG4gIGlmIChwYXJ0aWFsID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnVGhlIHBhcnRpYWwgJyArIG9wdGlvbnMubmFtZSArICcgY291bGQgbm90IGJlIGZvdW5kJyk7XG4gIH0gZWxzZSBpZiAocGFydGlhbCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIHBhcnRpYWwoY29udGV4dCwgb3B0aW9ucyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbm9vcCgpIHtcbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YShjb250ZXh0LCBkYXRhKSB7XG4gIGlmICghZGF0YSB8fCAhKCdyb290JyBpbiBkYXRhKSkge1xuICAgIGRhdGEgPSBkYXRhID8gX2Jhc2UuY3JlYXRlRnJhbWUoZGF0YSkgOiB7fTtcbiAgICBkYXRhLnJvb3QgPSBjb250ZXh0O1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBleGVjdXRlRGVjb3JhdG9ycyhmbiwgcHJvZywgY29udGFpbmVyLCBkZXB0aHMsIGRhdGEsIGJsb2NrUGFyYW1zKSB7XG4gIGlmIChmbi5kZWNvcmF0b3IpIHtcbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICBwcm9nID0gZm4uZGVjb3JhdG9yKHByb2csIHByb3BzLCBjb250YWluZXIsIGRlcHRocyAmJiBkZXB0aHNbMF0sIGRhdGEsIGJsb2NrUGFyYW1zLCBkZXB0aHMpO1xuICAgIFV0aWxzLmV4dGVuZChwcm9nLCBwcm9wcyk7XG4gIH1cbiAgcmV0dXJuIHByb2c7XG59XG5cblxufSx7XCIuL2Jhc2VcIjo3LFwiLi9leGNlcHRpb25cIjoyMCxcIi4vdXRpbHNcIjozM31dLDMyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIEJ1aWxkIG91dCBvdXIgYmFzaWMgU2FmZVN0cmluZyB0eXBlXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5mdW5jdGlvbiBTYWZlU3RyaW5nKHN0cmluZykge1xuICB0aGlzLnN0cmluZyA9IHN0cmluZztcbn1cblxuU2FmZVN0cmluZy5wcm90b3R5cGUudG9TdHJpbmcgPSBTYWZlU3RyaW5nLnByb3RvdHlwZS50b0hUTUwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAnJyArIHRoaXMuc3RyaW5nO1xufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gU2FmZVN0cmluZztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbn0se31dLDMzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZXh0ZW5kID0gZXh0ZW5kO1xuZXhwb3J0cy5pbmRleE9mID0gaW5kZXhPZjtcbmV4cG9ydHMuZXNjYXBlRXhwcmVzc2lvbiA9IGVzY2FwZUV4cHJlc3Npb247XG5leHBvcnRzLmlzRW1wdHkgPSBpc0VtcHR5O1xuZXhwb3J0cy5jcmVhdGVGcmFtZSA9IGNyZWF0ZUZyYW1lO1xuZXhwb3J0cy5ibG9ja1BhcmFtcyA9IGJsb2NrUGFyYW1zO1xuZXhwb3J0cy5hcHBlbmRDb250ZXh0UGF0aCA9IGFwcGVuZENvbnRleHRQYXRoO1xudmFyIGVzY2FwZSA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnLFxuICBcIidcIjogJyYjeDI3OycsXG4gICdgJzogJyYjeDYwOycsXG4gICc9JzogJyYjeDNEOydcbn07XG5cbnZhciBiYWRDaGFycyA9IC9bJjw+XCInYD1dL2csXG4gICAgcG9zc2libGUgPSAvWyY8PlwiJ2A9XS87XG5cbmZ1bmN0aW9uIGVzY2FwZUNoYXIoY2hyKSB7XG4gIHJldHVybiBlc2NhcGVbY2hyXTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKG9iaiAvKiAsIC4uLnNvdXJjZSAqLykge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGZvciAodmFyIGtleSBpbiBhcmd1bWVudHNbaV0pIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXJndW1lbnRzW2ldLCBrZXkpKSB7XG4gICAgICAgIG9ialtrZXldID0gYXJndW1lbnRzW2ldW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZXhwb3J0cy50b1N0cmluZyA9IHRvU3RyaW5nO1xuLy8gU291cmNlZCBmcm9tIGxvZGFzaFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL2xvZGFzaC9ibG9iL21hc3Rlci9MSUNFTlNFLnR4dFxuLyogZXNsaW50LWRpc2FibGUgZnVuYy1zdHlsZSAqL1xudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59O1xuLy8gZmFsbGJhY2sgZm9yIG9sZGVyIHZlcnNpb25zIG9mIENocm9tZSBhbmQgU2FmYXJpXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKGlzRnVuY3Rpb24oL3gvKSkge1xuICBleHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgfTtcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbi8qIGVzbGludC1lbmFibGUgZnVuYy1zdHlsZSAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nIDogZmFsc2U7XG59O1xuXG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuLy8gT2xkZXIgSUUgdmVyc2lvbnMgZG8gbm90IGRpcmVjdGx5IHN1cHBvcnQgaW5kZXhPZiBzbyB3ZSBtdXN0IGltcGxlbWVudCBvdXIgb3duLCBzYWRseS5cblxuZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlRXhwcmVzc2lvbihzdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZG9uJ3QgZXNjYXBlIFNhZmVTdHJpbmdzLCBzaW5jZSB0aGV5J3JlIGFscmVhZHkgc2FmZVxuICAgIGlmIChzdHJpbmcgJiYgc3RyaW5nLnRvSFRNTCkge1xuICAgICAgcmV0dXJuIHN0cmluZy50b0hUTUwoKTtcbiAgICB9IGVsc2UgaWYgKHN0cmluZyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSBlbHNlIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nICsgJyc7XG4gICAgfVxuXG4gICAgLy8gRm9yY2UgYSBzdHJpbmcgY29udmVyc2lvbiBhcyB0aGlzIHdpbGwgYmUgZG9uZSBieSB0aGUgYXBwZW5kIHJlZ2FyZGxlc3MgYW5kXG4gICAgLy8gdGhlIHJlZ2V4IHRlc3Qgd2lsbCBkbyB0aGlzIHRyYW5zcGFyZW50bHkgYmVoaW5kIHRoZSBzY2VuZXMsIGNhdXNpbmcgaXNzdWVzIGlmXG4gICAgLy8gYW4gb2JqZWN0J3MgdG8gc3RyaW5nIGhhcyBlc2NhcGVkIGNoYXJhY3RlcnMgaW4gaXQuXG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmc7XG4gIH1cblxuICBpZiAoIXBvc3NpYmxlLnRlc3Qoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKGJhZENoYXJzLCBlc2NhcGVDaGFyKTtcbn1cblxuZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlICYmIHZhbHVlICE9PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZyYW1lKG9iamVjdCkge1xuICB2YXIgZnJhbWUgPSBleHRlbmQoe30sIG9iamVjdCk7XG4gIGZyYW1lLl9wYXJlbnQgPSBvYmplY3Q7XG4gIHJldHVybiBmcmFtZTtcbn1cblxuZnVuY3Rpb24gYmxvY2tQYXJhbXMocGFyYW1zLCBpZHMpIHtcbiAgcGFyYW1zLnBhdGggPSBpZHM7XG4gIHJldHVybiBwYXJhbXM7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZENvbnRleHRQYXRoKGNvbnRleHRQYXRoLCBpZCkge1xuICByZXR1cm4gKGNvbnRleHRQYXRoID8gY29udGV4dFBhdGggKyAnLicgOiAnJykgKyBpZDtcbn1cblxuXG59LHt9XSwzNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBVU0FHRTpcbi8vIHZhciBoYW5kbGViYXJzID0gcmVxdWlyZSgnaGFuZGxlYmFycycpO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdmFyICovXG5cbi8vIHZhciBsb2NhbCA9IGhhbmRsZWJhcnMuY3JlYXRlKCk7XG5cbnZhciBoYW5kbGViYXJzID0gcmVxdWlyZSgnLi4vZGlzdC9janMvaGFuZGxlYmFycycpWydkZWZhdWx0J107XG5cbnZhciBwcmludGVyID0gcmVxdWlyZSgnLi4vZGlzdC9janMvaGFuZGxlYmFycy9jb21waWxlci9wcmludGVyJyk7XG5oYW5kbGViYXJzLlByaW50VmlzaXRvciA9IHByaW50ZXIuUHJpbnRWaXNpdG9yO1xuaGFuZGxlYmFycy5wcmludCA9IHByaW50ZXIucHJpbnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gaGFuZGxlYmFycztcblxuLy8gUHVibGlzaCBhIE5vZGUuanMgcmVxdWlyZSgpIGhhbmRsZXIgZm9yIC5oYW5kbGViYXJzIGFuZCAuaGJzIGZpbGVzXG5mdW5jdGlvbiBleHRlbnNpb24obW9kdWxlLCBmaWxlbmFtZSkge1xuICB2YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuICB2YXIgdGVtcGxhdGVTdHJpbmcgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZW5hbWUsICd1dGY4Jyk7XG4gIG1vZHVsZS5leHBvcnRzID0gaGFuZGxlYmFycy5jb21waWxlKHRlbXBsYXRlU3RyaW5nKTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5pZiAodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnICYmIHJlcXVpcmUuZXh0ZW5zaW9ucykge1xuICByZXF1aXJlLmV4dGVuc2lvbnNbJy5oYW5kbGViYXJzJ10gPSBleHRlbnNpb247XG4gIHJlcXVpcmUuZXh0ZW5zaW9uc1snLmhicyddID0gZXh0ZW5zaW9uO1xufVxuXG59LHtcIi4uL2Rpc3QvY2pzL2hhbmRsZWJhcnNcIjo1LFwiLi4vZGlzdC9janMvaGFuZGxlYmFycy9jb21waWxlci9wcmludGVyXCI6MTUsXCJmc1wiOjYzfV0sMzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ3JlYXRlIGEgc2ltcGxlIHBhdGggYWxpYXMgdG8gYWxsb3cgYnJvd3NlcmlmeSB0byByZXNvbHZlXG4vLyB0aGUgcnVudGltZSBvbiBhIHN1cHBvcnRlZCBwYXRoLlxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvY2pzL2hhbmRsZWJhcnMucnVudGltZScpWydkZWZhdWx0J107XG5cbn0se1wiLi9kaXN0L2Nqcy9oYW5kbGViYXJzLnJ1bnRpbWVcIjo2fV0sMzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnJlcXVpcmUoJ3doYXR3Zy1mZXRjaCcpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5yZXF1aXJlKCdlczYtcHJvbWlzZScpLnBvbHlmaWxsKCk7IC8vIG5lZWRlZCBmb3IgZmV0Y2hcblxudmFyIEhhbmRsZWJhcnMgPSByZXF1aXJlKCdoYW5kbGViYXJzJyk7XG4vKipcbiAqIE1ha2VzIHN1cmUgdGhhdCBhIHBhdGggaXMgY29udmVydGVkIHRvIGFuIGFycmF5LlxuICogQHBhcmFtIHBhdGhzXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xudmFyIGVuc3VyZVBhdGhBcnJheSA9IGZ1bmN0aW9uIGVuc3VyZVBhdGhBcnJheShwYXRocykge1xuICAgIGlmICghcGF0aHMpIHtcbiAgICAgICAgcGF0aHMgPSBbXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXRocyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGF0aHMgPSBbcGF0aHNdO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aHM7XG59O1xuXG4vKipcbiBUaGUgUmVzb3VyY2UgTWFuYWdlci5cbiBAY2xhc3MgUmVzb3VyY2VNYW5hZ2VyXG4gQGRlc2NyaXB0aW9uIFJlcHJlc2VudHMgYSBtYW5hZ2VyIHRoYXQgbG9hZHMgYW55IENTUyBhbmQgSmF2YXNjcmlwdCBSZXNvdXJjZXMgb24gdGhlIGZseS5cbiAqL1xuXG52YXIgUmVzb3VyY2VNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqXG4gICAgICogVXBvbiBpbml0aWFsaXphdGlvbi5cbiAgICAgKiBAbWVtYmVyT2YgUmVzb3VyY2VNYW5hZ2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVzb3VyY2VNYW5hZ2VyKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVzb3VyY2VNYW5hZ2VyKTtcblxuICAgICAgICB0aGlzLl9oZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICAgICAgdGhpcy5fY3NzUGF0aHMgPSB7fTtcbiAgICAgICAgdGhpcy5fc2NyaXB0TWFwcyA9IHt9O1xuICAgICAgICB0aGlzLl9kYXRhUHJvbWlzZXMgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIGphdmFzY3JpcHQgZmlsZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gcGF0aHMgLSBUaGUgcGF0aCB0byB0aGUgdmlldydzIGpzIGZpbGVcbiAgICAgKiBAbWVtYmVyT2YgUmVzb3VyY2VNYW5hZ2VyXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGFsbCBzY3JpcHRzIGhhdmUgYmVlbiBsb2FkZWRcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKFJlc291cmNlTWFuYWdlciwgW3tcbiAgICAgICAga2V5OiAnbG9hZFNjcmlwdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkU2NyaXB0KHBhdGhzKSB7XG4gICAgICAgICAgICB2YXIgc2NyaXB0LFxuICAgICAgICAgICAgICAgIG1hcCxcbiAgICAgICAgICAgICAgICBsb2FkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIHBhdGhzID0gZW5zdXJlUGF0aEFycmF5KHBhdGhzKTtcbiAgICAgICAgICAgIHBhdGhzLmZvckVhY2goZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgICAgICBtYXAgPSB0aGlzLl9zY3JpcHRNYXBzW3BhdGhdID0gdGhpcy5fc2NyaXB0TWFwc1twYXRoXSB8fCB7fTtcbiAgICAgICAgICAgICAgICBpZiAoIW1hcC5wcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcC5wYXRoID0gcGF0aDtcbiAgICAgICAgICAgICAgICAgICAgbWFwLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0ID0gdGhpcy5jcmVhdGVTY3JpcHRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvamF2YXNjcmlwdCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0LnNyYyA9IHBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2FkUHJvbWlzZXMucHVzaChtYXAucHJvbWlzZSk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGxvYWRQcm9taXNlcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhIHNjcmlwdCB0aGF0IGhhcyB0aGUgc3BlY2lmaWVkIHBhdGggZnJvbSB0aGUgaGVhZCBvZiB0aGUgZG9jdW1lbnQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBwYXRocyAtIFRoZSBwYXRocyBvZiB0aGUgc2NyaXB0cyB0byB1bmxvYWRcbiAgICAgICAgICogQG1lbWJlck9mIFJlc291cmNlTWFuYWdlclxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndW5sb2FkU2NyaXB0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVubG9hZFNjcmlwdChwYXRocykge1xuICAgICAgICAgICAgdmFyIGZpbGU7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICBwYXRocyA9IGVuc3VyZVBhdGhBcnJheShwYXRocyk7XG4gICAgICAgICAgICAgICAgcGF0aHMuZm9yRWFjaChmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBmaWxlID0gdGhpcy5faGVhZC5xdWVyeVNlbGVjdG9yQWxsKCdzY3JpcHRbc3JjPVwiJyArIHBhdGggKyAnXCJdJylbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oZWFkLnJlbW92ZUNoaWxkKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3NjcmlwdE1hcHNbcGF0aF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBzY3JpcHQgZWxlbWVudC5cbiAgICAgICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY3JlYXRlU2NyaXB0RWxlbWVudCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVTY3JpcHRFbGVtZW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ha2VzIGEgcmVxdWVzdCB0byBnZXQgZGF0YSBhbmQgY2FjaGVzIGl0LlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIHVybCB0byBmZXRjaCBkYXRhIGZyb21cbiAgICAgICAgICogQHBhcmFtIFtyZXFPcHRpb25zXSAtIG9wdGlvbnMgdG8gYmUgcGFzc2VkIHRvIGZldGNoIGNhbGxcbiAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmZXRjaERhdGEnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZmV0Y2hEYXRhKHVybCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIHJlcU9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgICAgICB2YXIgY2FjaGVJZCA9IHVybCArIEpTT04uc3RyaW5naWZ5KHJlcU9wdGlvbnMpO1xuXG4gICAgICAgICAgICByZXFPcHRpb25zLmNhY2hlID0gcmVxT3B0aW9ucy5jYWNoZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHJlcU9wdGlvbnMuY2FjaGU7XG5cbiAgICAgICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9kYXRhUHJvbWlzZXNbY2FjaGVJZF0gfHwgIXJlcU9wdGlvbnMuY2FjaGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kYXRhUHJvbWlzZXNbY2FjaGVJZF0gPSBmZXRjaCh1cmwsIHJlcU9wdGlvbnMpLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGZhaWx1cmUsIHJlbW92ZSBjYWNoZSBzbyB0aGF0IHN1YnNlcXVlbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVxdWVzdHMgd2lsbCB0cmlnZ2VyIG5ldyBhamF4IGNhbGxcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2RhdGFQcm9taXNlc1tjYWNoZUlkXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVByb21pc2VzW2NhY2hlSWRdO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvYWRzIGNzcyBmaWxlcy5cbiAgICAgICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IHBhdGhzIC0gQW4gYXJyYXkgb2YgY3NzIHBhdGhzIGZpbGVzIHRvIGxvYWRcbiAgICAgICAgICogQG1lbWJlck9mIFJlc291cmNlTWFuYWdlclxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbG9hZENzcycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkQ3NzKHBhdGhzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICBwYXRocyA9IGVuc3VyZVBhdGhBcnJheShwYXRocyk7XG4gICAgICAgICAgICAgICAgcGF0aHMuZm9yRWFjaChmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBmaWd1cmUgb3V0IGEgd2F5IHRvIGZpbmQgb3V0IHdoZW4gY3NzIGlzIGd1YXJhbnRlZWQgdG8gYmUgbG9hZGVkLFxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbWFrZSB0aGlzIHJldHVybiBhIHRydWVseSBhc3luY2hyb25vdXMgcHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2Nzc1BhdGhzW3BhdGhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3JlbCcsICdzdHlsZXNoZWV0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hlYWQuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3NzUGF0aHNbcGF0aF0gPSBlbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbmxvYWRzIGNzcyBwYXRocy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IHBhdGhzIC0gVGhlIGNzcyBwYXRocyB0byB1bmxvYWRcbiAgICAgICAgICogQG1lbWJlck9mIFJlc291cmNlTWFuYWdlclxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndW5sb2FkQ3NzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVubG9hZENzcyhwYXRocykge1xuICAgICAgICAgICAgdmFyIGVsO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgcGF0aHMgPSBlbnN1cmVQYXRoQXJyYXkocGF0aHMpO1xuICAgICAgICAgICAgICAgIHBhdGhzLmZvckVhY2goZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwgPSB0aGlzLl9jc3NQYXRoc1twYXRoXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oZWFkLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nzc1BhdGhzW3BhdGhdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXJzZXMgYSB0ZW1wbGF0ZSBpbnRvIGEgRE9NIGVsZW1lbnQsIHRoZW4gcmV0dXJucyBlbGVtZW50IGJhY2sgdG8geW91LlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIFRoZSBwYXRoIHRvIHRoZSB0ZW1wbGF0ZVxuICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbZWxdIC0gVGhlIGVsZW1lbnQgdG8gYXR0YWNoIHRlbXBsYXRlIHRvXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBbaGJzRGF0YV0gLSBUaGUgZGF0YSB0byB1c2UgZm9yIHRoZSBoYW5kbGViYXIgdGVtcGxhdGUgKGlmIGFwcGxpY2FibGUpXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggY29udGVudHMgb2YgdGVtcGxhdGUgZmlsZVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbG9hZFRlbXBsYXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWRUZW1wbGF0ZShwYXRoLCBlbCwgaGJzRGF0YSkge1xuXG4gICAgICAgICAgICB2YXIgaXNIYW5kbGViYXJGaWxlID0gZnVuY3Rpb24gaXNIYW5kbGViYXJGaWxlKGZpbGVQYXRoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGVQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFncyA9IGZpbGVQYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBleHQgPSBmcmFnc1tmcmFncy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4dCA9PT0gJ2hicyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmV0Y2gocGF0aCkudGhlbihmdW5jdGlvbiAocmVzcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwLnRleHQoKS50aGVuKGZ1bmN0aW9uIChjb250ZW50cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNIYW5kbGViYXJGaWxlKHBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50cyA9IEhhbmRsZWJhcnMuY29tcGlsZShjb250ZW50cykoaGJzRGF0YSB8fCB7fSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBjb250ZW50cztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gZWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhbGwgY2FjaGVkIHJlc291cmNlcy5cbiAgICAgICAgICogQG1lbWJlck9mIFJlc291cmNlTWFuYWdlclxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZmx1c2gnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgICAgICB0aGlzLnVubG9hZENzcyhPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLl9jc3NQYXRocykpO1xuICAgICAgICAgICAgdGhpcy5fY3NzUGF0aHMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIHMgaW4gdGhpcy5fc2NyaXB0TWFwcykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zY3JpcHRNYXBzLmhhc093blByb3BlcnR5KHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXAgPSB0aGlzLl9zY3JpcHRNYXBzW3NdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVubG9hZFNjcmlwdChtYXAucGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2NyaXB0TWFwcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5fZGF0YVByb21pc2VzID0ge307XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUmVzb3VyY2VNYW5hZ2VyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgUmVzb3VyY2VNYW5hZ2VyKCk7XG5cbn0se1wiZXM2LXByb21pc2VcIjo0LFwiaGFuZGxlYmFyc1wiOjM0LFwid2hhdHdnLWZldGNoXCI6NTd9XSwzNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3Jlc291cmNlTWFuYWdlckpzID0gcmVxdWlyZSgncmVzb3VyY2UtbWFuYWdlci1qcycpO1xuXG52YXIgX3Jlc291cmNlTWFuYWdlckpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Jlc291cmNlTWFuYWdlckpzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFByb21pc2UgPSByZXF1aXJlKCdlczYtcHJvbWlzZScpLlByb21pc2U7XG52YXIgcnVudGltZSA9IHJlcXVpcmUoJ2hhbmRsZWJhcnMvcnVudGltZScpO1xuXG4vKipcbiAqIFRha2VzIGEgdmFsdWUgYW5kIHNlcGFyYXRlcyB0aGUgbnVtYmVyIGFuZCB1bml0IGludG8gYSBrZXkvdmFsdWUgbWFwLlxuICogQHBhcmFtIHYgLSBUaGUgdmFsdWVcbiAqIEByZXR1cm5zIHt7bnVtOiBOdW1iZXIsIHVuaXQ6IHN0cmluZ319IFJldHVybnMgdGhlIG1hcFxuICogQHByaXZhdGVcbiAqL1xudmFyIGdldENzc1Byb3BVbml0TWFwID0gZnVuY3Rpb24gZ2V0Q3NzUHJvcFVuaXRNYXAodikge1xuICAgIHYudHJpbSgpO1xuICAgIHZhciBudW0gPSB2Lm1hdGNoKCdbMC05XFwuXSsnKSxcbiAgICAgICAgdW5pdCA9ICdtcyc7XG5cbiAgICBudW0gPSBudW0gPyBudW1bMF0gOiAnJztcbiAgICBpZiAobnVtKSB7XG4gICAgICAgIHVuaXQgPSB2LnNwbGl0KG51bSlbMV07XG4gICAgICAgIG51bSA9IE51bWJlcihudW0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBudW06IG51bSxcbiAgICAgICAgdW5pdDogdW5pdFxuICAgIH07XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgY3NzIHRpbWluZyB1bml0IHZhbHVlIGludG8gbWlsbGlzZWNvbmRzLlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbCAtIFRoZSB2YWx1ZSBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRpbWluZyB1bml0IHZhbHVlIGluIG1pbGxpc2Vjb25kc1xuICovXG52YXIgY29udmVydENzc1RpbWVWYWx1ZVRvTWlsbGlzZWNvbmRzID0gZnVuY3Rpb24gY29udmVydENzc1RpbWVWYWx1ZVRvTWlsbGlzZWNvbmRzKHZhbCkge1xuICAgIHZhciBudW1iZXIgPSBnZXRDc3NQcm9wVW5pdE1hcCh2YWwpLm51bSxcbiAgICAgICAgdW5pdCA9IHZhbC5yZXBsYWNlKG51bWJlciwgJycpO1xuICAgIGlmICh1bml0ID09PSAncycpIHtcbiAgICAgICAgdmFsID0gbnVtYmVyICogMTAwMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBudW1iZXI7XG4gICAgfVxuICAgIHJldHVybiB2YWwgKyAnbXMnO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhIGNzcyBwcm9wZXJ0eSBuYW1lIGFuZCByZXR1cm5zIHRoZSBqYXZhc2NyaXB0IHZlcnNpb24gb2YgaXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gY3NzUHJvcCAtIFRoZSBjc3MgcHJvcGVydHlcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGphdmFzY3JpcHQgdmVyc2lvblxuICogQHByaXZhdGVcbiAqL1xudmFyIGdldEpzUHJvcE5hbWUgPSBmdW5jdGlvbiBnZXRKc1Byb3BOYW1lKGNzc1Byb3ApIHtcbiAgICAvLyBjb252ZXJ0IHRvIGNhbWVsQ2FzZVxuICAgIHJldHVybiBjc3NQcm9wLnJlcGxhY2UoLy0oW2Etel0pL2csIGZ1bmN0aW9uIChsZXR0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGxldHRlclsxXS50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBCdWJibGVzIHVwIGVhY2ggcGFyZW50IG5vZGUgb2YgdGhlIGVsZW1lbnQsIHRyaWdnZXJpbmcgdGhlIGNhbGxiYWNrIG9uIGVhY2ggZWxlbWVudCB1bnRpbCB0cmF2ZXJzYWxcbiAqIGVpdGhlciBydW5zIG91dCBvZiBwYXJlbnQgbm9kZXMsIHJlYWNoZXMgdGhlIGRvY3VtZW50IGVsZW1lbnQsIG9yIGlmIGNhbGxiYWNrIHJldHVybnMgYSBmYWxzeSB2YWx1ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBBIGNhbGxiYWNrIHRoYXQgZmlyZXMgd2hpY2ggZ2V0cyBwYXNzZWQgdGhlIGN1cnJlbnQgZWxlbWVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW3N0YXJ0RWxdIC0gVGhlIGVsZW1lbnQgd2hlcmUgdHJhdmVyc2FsIHdpbGwgYmVnaW4gKGluY2x1ZGluZyB0aGUgcGFzc2VkIGVsZW1lbnQpLCBkZWZhdWx0cyB0byBjdXJyZW50IGVsXG4gKi9cbnZhciB0cmF2ZXJzZUVhY2hQYXJlbnQgPSBmdW5jdGlvbiB0cmF2ZXJzZUVhY2hQYXJlbnQoY2FsbGJhY2ssIHN0YXJ0RWwpIHtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IHN0YXJ0RWw7XG4gICAgdmFyIHByZWRpY2F0ZSA9IG51bGw7XG4gICAgLy8gY2hlY2sgaWYgdGhlIG5vZGUgaGFzIGNsYXNzbmFtZSBwcm9wZXJ0eSwgaWYgbm90LCB3ZSBrbm93IHdlJ3JlIGF0IHRoZSAjZG9jdW1lbnQgZWxlbWVudFxuICAgIHdoaWxlIChwYXJlbnROb2RlICYmIHR5cGVvZiBwYXJlbnROb2RlLmNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcHJlZGljYXRlID0gY2FsbGJhY2socGFyZW50Tm9kZSk7XG4gICAgICAgIGlmIChwcmVkaWNhdGUgIT09IHVuZGVmaW5lZCAmJiAhcHJlZGljYXRlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbn07XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IGZpcmVzIHdoZW4gdGhlIG1vZHVsZSdzIGxvYWQoKSBtZXRob2QgaXMgY2FsbGVkXG4gKiBAY2FsbGJhY2sgTW9kdWxlfm9uTG9hZFxuICogQHJldHVybiB7Kn0gTWF5IHJldHVybiBhIHByb21pc2Ugd2hlbiBkb25lXG4gKi9cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgZmlyZXMgd2hlbiB0aGUgbW9kdWxlJ3Mgc2hvdygpIG1ldGhvZCBpcyBjYWxsZWRcbiAqIHdoaWNoIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHN1YmNsYXNzIGN1c3RvbSBpbXBsZW1lbnRhdGlvbnMuXG4gKiBAY2FsbGJhY2sgTW9kdWxlfm9uU2hvd1xuICogQHJldHVybiB7Kn0gTWF5IHJldHVybiBhIHByb21pc2Ugd2hlbiBkb25lXG4gKi9cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgZmlyZXMgd2hlbiB0aGUgbW9kdWxlJ3MgaGlkZSgpIG1ldGhvZCBpcyBjYWxsZWRcbiAqIHdoaWNoIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHN1YmNsYXNzIGN1c3RvbSBpbXBsZW1lbnRhdGlvbnMuXG4gKiBAY2FsbGJhY2sgTW9kdWxlfm9uSGlkZVxuICovXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IGZpcmVzIHdoZW4gdGhlIG1vZHVsZSdzIGVuYWJsZSgpIG1ldGhvZCBpcyBjYWxsZWRcbiAqIEBjYWxsYmFjayBNb2R1bGV+b25FbmFibGVcbiAqL1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBmaXJlcyB3aGVuIHRoZSBtb2R1bGUncyBkaXNhYmxlKCkgbWV0aG9kIGlzIGNhbGxlZFxuICogQGNhbGxiYWNrIE1vZHVsZX5vbkRpc2FibGVcbiAqL1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBmaXJlcyB3aGVuIHRoZSBlcnJvcigpIG1ldGhvZCBpcyBjYWxsZWRcbiAqIEBjYWxsYmFjayBNb2R1bGV+b25FcnJvclxuICogQHBhcmFtIHtPYmplY3R9IFtlXSAtIFRoZSBlcnJvciBvYmplY3QgdGhhdCB3YXMgdHJpZ2dlcmVkXG4gKi9cblxuLyoqXG4gKiBAY2xhc3MgTW9kdWxlXG4gKiBAZGVzY3JpcHRpb24gQmFzZSBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYWxsIG1vZHVsZXMgb2YgYW4gQXBwLlxuICovXG5cbnZhciBNb2R1bGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXphdGlvbi5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCAtIFRoZSBtb2R1bGUgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBbiBvYmplY3Qgb2Ygb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sb2FkZWRDbGFzc10gLSBUaGUgY2xhc3MgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIG1vZHVsZSBlbGVtZW50IHdoZW4gaXQgaXMgbG9hZGVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmFjdGl2ZUNsYXNzXSAtIFRoZSBjbGFzcyB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byB0aGUgbW9kdWxlIGVsZW1lbnQgd2hlbiBpdCBpcyBzaG93blxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5kaXNhYmxlZENsYXNzXSAtIFRoZSBjbGFzcyB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byB0aGUgbW9kdWxlIGVsZW1lbnQgd2hlbiBkaXNhYmxlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lcnJvckNsYXNzXSAtIFRoZSBjbGFzcyB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byB0aGUgbW9kdWxlIGVsZW1lbnQgd2hlbiBpdCBoYXMgYSBsb2FkIGVycm9yXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IFtvcHRpb25zLnN0eWxlc10gLSBBcnJheSBvZiBzdHlsZXNoZWV0IHVybHMgb3Igc2luZ2xlIHVybFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEhUTUxUZW1wbGF0ZUVsZW1lbnR8SFRNTEVsZW1lbnR9IFtvcHRpb25zLnRlbXBsYXRlXSAtIFRoZSB0ZW1wbGF0ZSB0byBsb2FkIChjYW4gYmUgdXJsIHRvIGh0bWwgb3IgaGFuZGxlYmFycyBmaWxlIG9yIGh0bWwgdGVtcGxhdGUsIGp1c3QgYW4gZWxlbWVudCwgb3IgYW4gaHRtbCBzdHJpbmcpXG4gICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBbb3B0aW9ucy5kYXRhXSAtIFRoZSBkYXRhIG9yIHVybCB0byB0aGUgbW9kdWxlJ3MgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5yZXF1ZXN0T3B0aW9uc10gLSBUaGUgcmVxdWVzdCBvcHRpb25zIHRvIHVzZSB3aGVuIHJ1bm5pbmcgdGhlIGZldGNoIG1ldGhvZCB0byBnZXQgZGF0YVxuICAgICAqIEBwYXJhbSB7TW9kdWxlfm9uTG9hZH0gW29wdGlvbnMub25Mb2FkXSAtIEEgZnVuY3Rpb24gdGhhdCBmaXJlcyB3aGVuIG1vZHVsZSdzIGxvYWQoKSBtZXRob2QgaXMgY2FsbGVkXG4gICAgICogQHBhcmFtIHtNb2R1bGV+b25TaG93fSBbb3B0aW9ucy5vblNob3ddIC0gQSBmdW5jdGlvbiB0aGF0IGZpcmVzIHdoZW4gbW9kdWxlIGlzIHNob3duXG4gICAgICogQHBhcmFtIHtNb2R1bGV+b25IaWRlfSBbb3B0aW9ucy5vbkhpZGVdIC0gQSBmdW5jdGlvbiB0aGF0IGZpcmVzIHdoZW4gbW9kdWxlIGlzIGhpZGRlblxuICAgICAqIEBwYXJhbSB7TW9kdWxlfm9uRW5hYmxlfSBbb3B0aW9ucy5vbkVuYWJsZV0gLSBBIGZ1bmN0aW9uIHRoYXQgZmlyZXMgd2hlbiBtb2R1bGUgaXMgZW5hYmxlZFxuICAgICAqIEBwYXJhbSB7TW9kdWxlfm9uRGlzYWJsZX0gW29wdGlvbnMub25EaXNhYmxlXSAtIEEgZnVuY3Rpb24gdGhhdCBmaXJlcyB3aGVuIG1vZHVsZSBpcyBkaXNhYmxlZFxuICAgICAqIEBwYXJhbSB7TW9kdWxlfm9uRXJyb3J9IFtvcHRpb25zLm9uRXJyb3JdIC0gQSBmdW5jdGlvbiB0aGF0IGZpcmVzIHdoZW4gbW9kdWxlIGdvZXMgaW50byBlcnJvciBzdGF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5oZWxwZXJzXSAtIEFuIG9iamVjdCBjb250YWluaW5nIGEgbWFwcGluZyBvZiBoYW5kbGViYXIgaGVscGVyIGlkcyAoa2V5cykgdG8gdGhlaXIgZnVuY3Rpb25zICh2YWx1ZXMpIHRvIHVzZSB3aGVuIGhhbmRsZWJhciBjb21waWxpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNb2R1bGUoZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1vZHVsZSk7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgaWYgKCFlbCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk1vZHVsZSBlcnJvcjogTm8gZWxlbWVudCB3YXMgcGFzc2VkIHRvIGNvbnN0cnVjdG9yXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuXG4gICAgICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGxvYWRlZENsYXNzOiAnbW9kdWxlLWxvYWRlZCcsXG4gICAgICAgICAgICBhY3RpdmVDbGFzczogJ21vZHVsZS1hY3RpdmUnLFxuICAgICAgICAgICAgZGlzYWJsZWRDbGFzczogJ21vZHVsZS1kaXNhYmxlZCcsXG4gICAgICAgICAgICBlcnJvckNsYXNzOiAnbW9kdWxlLWVycm9yJyxcbiAgICAgICAgICAgIHN0eWxlczogW10sXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcIixcbiAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICByZXF1ZXN0T3B0aW9uczogbnVsbCxcbiAgICAgICAgICAgIG9uTG9hZDogZnVuY3Rpb24gb25Mb2FkKCkge30sXG4gICAgICAgICAgICBvblNob3c6IGZ1bmN0aW9uIG9uU2hvdygpIHt9LFxuICAgICAgICAgICAgb25IaWRlOiBmdW5jdGlvbiBvbkhpZGUoKSB7fSxcbiAgICAgICAgICAgIG9uRW5hYmxlOiBmdW5jdGlvbiBvbkVuYWJsZSgpIHt9LFxuICAgICAgICAgICAgb25EaXNhYmxlOiBmdW5jdGlvbiBvbkRpc2FibGUoKSB7fSxcbiAgICAgICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3IoKSB7fSxcbiAgICAgICAgICAgIGhlbHBlcnM6IHt9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gd2UgYXJlIGFkZGluZyBkZWZhdWx0IG9wdGlvbnMgdG8gcGFzc2VkIGN1c3RvbSBvcHRpb25zXG4gICAgICAgIC8vIHRvIGVuc3VyZSBhbGwgZXhwZWN0ZWQgb3B0aW9ucyBleGlzdCB3aGVuIGluc3RhbnRpYXRpbmcgc3ViIGNsYXNzZXNcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBkZWZhdWx0T3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRPcHRpb25zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbbmFtZV0gPSBkZWZhdWx0T3B0aW9uc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgICAgIC8vIHNldHVwIGhlbHBlcnNcbiAgICAgICAgZm9yICh2YXIgX25hbWUgaW4gb3B0aW9ucy5oZWxwZXJzKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oZWxwZXJzLmhhc093blByb3BlcnR5KF9uYW1lKSkge1xuICAgICAgICAgICAgICAgIHJ1bnRpbWUucmVnaXN0ZXJIZWxwZXIoX25hbWUsIG9wdGlvbnMuaGVscGVyc1tfbmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faGFuZGxlRWxlbWVudEluaXRpYWxTdGF0ZSgpO1xuXG4gICAgICAgIHRoaXMuc3ViTW9kdWxlcyA9IHt9O1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9lbENoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMubG9hZFN0YXR1cyA9ICdub3RMb2FkZWQnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIHRoZSBtb2R1bGUncyBzdHlsZXMsIHRlbXBsYXRlLCBhbmQgZGF0YSBhbmQgYXBwbGllcyBsb2FkZWQgY3NzIGNsYXNzZXMgYW5kIHN0YXRlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhNb2R1bGUsIFt7XG4gICAgICAgIGtleTogJ2xvYWQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZCgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRTdGF0dXMgPSAnbG9hZGluZyc7XG4gICAgICAgICAgICAgICAgLy8gbG9hZCBhbGwgc3ViTW9kdWxlc1xuICAgICAgICAgICAgICAgIHZhciBsb2FkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5zdWJNb2R1bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN1Yk1vZHVsZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnN1Yk1vZHVsZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRQcm9taXNlcy5wdXNoKHZpZXcubG9hZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwobG9hZFByb21pc2VzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldFN0eWxlcyhfdGhpcy5vcHRpb25zLnN0eWxlcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZmV0Y2hEYXRhKF90aGlzLm9wdGlvbnMuZGF0YSwgX3RoaXMub3B0aW9ucy5yZXF1ZXN0T3B0aW9ucykudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRUZW1wbGF0ZShkYXRhKS50aGVuKGZ1bmN0aW9uIChub2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlcyA9IG5vZGVzIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaG9sZCByZWZlcmVuY2UgdG8gY2hpbGRyZW4gdG8gcmVtb3ZlIHRoZW0gbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3JkZXIgbWF0dGVycyBoZXJlIHNvIHdlIGFsd2F5cyBzdGFydCBmcm9tIHRoZSBmaXJzdCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2VsQ2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFwcGVuZGluZyBjaGlsZCBjaGFuZ2VzIGxlbmd0aCBvZiBub2RlcyBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZy5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbC5hcHBlbmRDaGlsZChmcmFnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9hZFN0YXR1cyA9ICdsb2FkZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVsLmNsYXNzTGlzdC5hZGQoX3RoaXMub3B0aW9ucy5sb2FkZWRDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub3B0aW9ucy5vbkxvYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3cgZXJyb3IgdG8gcmVqZWN0IHByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ha2VzIGEgcmVxdWVzdCB0byBnZXQgdGhlIGRhdGEgZm9yIHRoZSBtb2R1bGUuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gdXJsIC0gVGhlIHVybCB0byBmZXRjaCBkYXRhIGZyb20gb3IgZGF0YSBvYmplY3RcbiAgICAgICAgICogQHBhcmFtIFtvcHRpb25zXSAtIGZldGNoIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmZXRjaERhdGEnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZmV0Y2hEYXRhKHVybCwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9yZXNvdXJjZU1hbmFnZXJKczIuZGVmYXVsdC5mZXRjaERhdGEodXJsLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBjc3MgZmlsZXMgZm9yIHRoZSBtb2R1bGUuXG4gICAgICAgICAqIEBwYXJhbSBjc3NVcmxcbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldFN0eWxlcycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdHlsZXMoY3NzVXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gX3Jlc291cmNlTWFuYWdlckpzMi5kZWZhdWx0LmxvYWRDc3MoY3NzVXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBodG1sIHRlbXBsYXRlIGZvciB0aGUgbW9kdWxlLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdIC0gVGhlIGRhdGEgdG8gaW5qZWN0IChpZiB0ZW1wbGF0ZSBpcyBhIGhhbmRsZWJhciBmaWxlKVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gUmV0dXJucyBhIGRvY3VtZW50IGZyYWdtZW50IGNvbnRhaW5pbmcgdGhlIGNvbnRlbnRzIG9mIHRoZSB0ZW1wbGF0ZSB3aXRoIHRoZSBkYXRhIGluamVjdGVkXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRUZW1wbGF0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUZW1wbGF0ZShkYXRhKSB7XG4gICAgICAgICAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGUgfHwgJyc7XG5cbiAgICAgICAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpc0hhbmRsZWJhckZpbGUgPSBmdW5jdGlvbiBpc0hhbmRsZWJhckZpbGUoZmlsZVBhdGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYWdzID0gZmlsZVBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4dCA9IGZyYWdzW2ZyYWdzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXh0ID09PSAnaGJzJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5faXNIVE1MVGVtcGxhdGUodGVtcGxhdGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gdGVtcGxhdGUgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHVwZGF0ZSB0byBhY2NvbW1vZGF0ZSBzaXR1YXRpb25zIHdoZXJlIHRoZSB1c2VyIHdhbnRzIHRvIGFkb3B0Tm9kZSBpbnN0ZWFkIG9mIGNsb25pbmcgaXRcbiAgICAgICAgICAgICAgICB2YXIgdHBsID0gZG9jdW1lbnQuaW1wb3J0Tm9kZSh0ZW1wbGF0ZS5jb250ZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRwbC5jaGlsZE5vZGVzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGVtcGxhdGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgYW4gaHRtbCBlbGVtZW50XG4gICAgICAgICAgICAgICAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICAgICAgZnJhZy5hcHBlbmRDaGlsZCh0ZW1wbGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmcmFnLmNoaWxkTm9kZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgX3JldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaHRtbCBvciBoYW5kbGViYXIgZmlsZVxuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdjogX3Jlc291cmNlTWFuYWdlckpzMi5kZWZhdWx0LmxvYWRUZW1wbGF0ZSh0ZW1wbGF0ZSwgdGVtcERpdiwgZGF0YSkudGhlbihmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZW1wRGl2LmNoaWxkTm9kZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIF9yZXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKF9yZXQpKSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQudjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIHRlbXBsYXRlIGFyZ3VtZW50IGlzIGluZGVlZCBhbiBodG1sIHRlbXBsYXRlIGVsZW1lbnQuXG4gICAgICAgICAqIFRoaXMgaXMgbWFpbmx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzIHdoZXJlIHBoYW50b20gaXMgbm90IGF3YXJlIG9mIEhUTUxUZW1wbGF0ZUVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIHRlbXBsYXRlXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2lzSFRNTFRlbXBsYXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pc0hUTUxUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlIGluc3RhbmNlb2YgSFRNTFRlbXBsYXRlRWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmlnZ2VycyBhIGxvYWQgZXJyb3Igb24gdGhlIG1vZHVsZS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtlcnJdIC0gVGhlIGVycm9yIG9iamVjdCB0byB0cmlnZ2VyXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJldHVybnMgYSBwcm9taXNlIHdoZW4gZXJyb3Jpbmcgb3BlcmF0aW9uIGlzIGNvbXBsZXRlXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdlcnJvcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlcnJvcihlcnIpIHtcbiAgICAgICAgICAgIHZhciBlID0gZXJyIHx8IG5ldyBFcnJvcigpO1xuXG4gICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQodGhpcy5vcHRpb25zLmVycm9yQ2xhc3MpO1xuXG4gICAgICAgICAgICB0aGlzLmVycm9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubG9hZFN0YXR1cyA9ICdub3RMb2FkZWQnO1xuXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMub25FcnJvcihlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhaXRGb3JUcmFuc2l0aW9uKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmFibGVzIHRoZSBtb2R1bGUuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdlbmFibGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5vcHRpb25zLmRpc2FibGVkQ2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uRW5hYmxlKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53YWl0Rm9yVHJhbnNpdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVzIHRoZSBtb2R1bGUuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkaXNhYmxlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCh0aGlzLm9wdGlvbnMuZGlzYWJsZWRDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uRGlzYWJsZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FpdEZvclRyYW5zaXRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93cyB0aGUgbW9kdWxlLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2hvdycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQodGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vblNob3coKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhaXRGb3JUcmFuc2l0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSGlkZXMgdGhlIG1vZHVsZS5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2hpZGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uSGlkZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FpdEZvclRyYW5zaXRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHVwIGVsZW1lbnQgaW50ZXJuYWxseSBieSBldmFsdWF0aW5nIGl0cyBpbml0aWFsIHN0YXRlLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2hhbmRsZUVsZW1lbnRJbml0aWFsU3RhdGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUVsZW1lbnRJbml0aWFsU3RhdGUoKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgICAgICAgICAgaWYgKCFlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnModGhpcy5vcHRpb25zLmRpc2FibGVkQ2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3JpZ0Rpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucyh0aGlzLm9wdGlvbnMuZXJyb3JDbGFzcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcmlnRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IobmV3IEVycm9yKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc3RvcmVzIHRoZSBlbGVtZW50cyBjbGFzc2VzIGJhY2sgdG8gdGhlIHdheSB0aGV5IHdlcmUgYmVmb3JlIGluc3RhbnRpYXRpb24uXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfcmVzZXRFbGVtZW50SW5pdGlhbFN0YXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNldEVsZW1lbnRJbml0aWFsU3RhdGUoKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZENsYXNzID0gb3B0aW9ucy5kaXNhYmxlZENsYXNzLFxuICAgICAgICAgICAgICAgIGVycm9yQ2xhc3MgPSBvcHRpb25zLmVycm9yQ2xhc3M7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5lbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9vcmlnRGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoZGlzYWJsZWRDbGFzcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZShkaXNhYmxlZENsYXNzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9vcmlnRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoZXJyb3JDbGFzcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZChlcnJvckNsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCdWlsZHMgYSB0cmFuc2l0aW9uIHByb21pc2UgdGhhdCB3YWl0cyB0byByZXNvbHZlIHVudGlsIHRoZSBtb2R1bGUgZWwncyBDU1MgdHJhbnNpdGlvbiBpcyBjb21wbGV0ZWQgKGlmIGFwcGxpY2FibGUpLlxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBlbGVtZW50IGhhcyBmaW5pc2hlZCBhbmltYXRpbmdcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3dhaXRGb3JUcmFuc2l0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHdhaXRGb3JUcmFuc2l0aW9uKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb24gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZS5iaW5kKF90aGlzMiwgX3RoaXMyLmVsKSwgZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoX3RoaXMyLmVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSB0aW1lIGlzIHRha2VzIGZvciB0aGUgZWxlbWVudCB0byB0cmFuc2l0aW9uIHRvIGl0cyBzaG93IHN0YXRlLlxuICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIHRoZSB0b3RhbCBDU1MgdHJhbnNpdGlvbiB0aW1lIGluIG1pbGxpc2Vjb25kc1xuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0VHJhbnNpdGlvbkR1cmF0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRyYW5zaXRpb25EdXJhdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkZWxheVByb3AgPSB0aGlzLmdldENzc0NvbXB1dGVkUHJvcGVydHkoJ3RyYW5zaXRpb24tZGVsYXknKSB8fCAnMG1zJyxcbiAgICAgICAgICAgICAgICBkdXJhdGlvblByb3AgPSB0aGlzLmdldENzc0NvbXB1dGVkUHJvcGVydHkoJ3RyYW5zaXRpb24tZHVyYXRpb24nKSB8fCAnMG1zJyxcbiAgICAgICAgICAgICAgICB0aW1lcyA9IEFycmF5LmlzQXJyYXkoZHVyYXRpb25Qcm9wKSA/IGR1cmF0aW9uUHJvcCA6IFtkdXJhdGlvblByb3BdLFxuICAgICAgICAgICAgICAgIGRlbGF5ID0gQXJyYXkuaXNBcnJheShkZWxheVByb3ApID8gZGVsYXlQcm9wIDogW2RlbGF5UHJvcF0sXG4gICAgICAgICAgICAgICAgaGlnaGVzdCA9IDAsXG4gICAgICAgICAgICAgICAgbWFwO1xuXG4gICAgICAgICAgICB0aW1lcy5wdXNoLmFwcGx5KHRpbWVzLCBkZWxheSk7IC8vIGFjY291bnQgZm9yIGRlbGF5XG5cbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBoaWdoZXN0IG51bWJlciBvZiB0aW1lXG4gICAgICAgICAgICB0aW1lcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlLnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICB2ID0gY29udmVydENzc1RpbWVWYWx1ZVRvTWlsbGlzZWNvbmRzKHYpO1xuICAgICAgICAgICAgICAgICAgICBtYXAgPSBnZXRDc3NQcm9wVW5pdE1hcCh2KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcC5udW0gPiBoaWdoZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaWdoZXN0ID0gbWFwLm51bTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBoaWdoZXN0O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGNvbXB1dGVkIHByb3BlcnR5IG9mIHRoZSBlbGVtZW50LlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCAtIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXRcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRDc3NDb21wdXRlZFByb3BlcnR5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENzc0NvbXB1dGVkUHJvcGVydHkocHJvcCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5lbCk7XG4gICAgICAgICAgICByZXR1cm4gc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcm9wKSB8fCB0aGlzLmVsLnN0eWxlW2dldEpzUHJvcE5hbWUocHJvcCldO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgZWxlbWVudCB0aGF0IGhhcyBhIGNzcyBjbGFzcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAtIFRoZSBjbGFzcyBuYW1lIHRoYXQgdGhlIGFuY2VzdG9yIG11c3QgaGF2ZSB0byBtYXRjaFxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHN0YXJ0VGFyZ2V0IC0gVGhlIGVsZW1lbnQgdGhlIG1ldGhvZCBzaG91bGQgc3RhcnQgZnJvbVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0Q2xvc2VzdEFuY2VzdG9yRWxlbWVudEJ5Q2xhc3NOYW1lJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENsb3Nlc3RBbmNlc3RvckVsZW1lbnRCeUNsYXNzTmFtZShjbGFzc05hbWUsIHN0YXJ0VGFyZ2V0KSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIHRyYXZlcnNlRWFjaFBhcmVudChmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBzdGFydFRhcmdldCB8fCB0aGlzLmVsLnBhcmVudE5vZGUgfHwgdGhpcy5lbCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlc3Ryb3lzIGFsbCBuZXN0ZWQgdmlld3MgYW5kIGNsZWFucyB1cC5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgc3ViTW9kdWxlcyA9IHRoaXMuc3ViTW9kdWxlcztcblxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHN1Yk1vZHVsZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3ViTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHN1Yk1vZHVsZXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBzdWJNb2R1bGVzW2tleV0uZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3ViTW9kdWxlcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmVycm9yZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubG9hZFN0YXR1cyA9ICdub3RMb2FkZWQnO1xuXG4gICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5vcHRpb25zLmxvYWRlZENsYXNzKTtcbiAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpO1xuXG4gICAgICAgICAgICB0aGlzLl9yZXNldEVsZW1lbnRJbml0aWFsU3RhdGUoKTtcblxuICAgICAgICAgICAgdGhpcy5fZWxDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpczMuZWwuY29udGFpbnMoZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzMy5lbC5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9lbENoaWxkcmVuID0gW107XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTW9kdWxlO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBNb2R1bGU7XG5cbn0se1wiZXM2LXByb21pc2VcIjo0LFwiaGFuZGxlYmFycy9ydW50aW1lXCI6MzUsXCJyZXNvdXJjZS1tYW5hZ2VyLWpzXCI6MzZ9XSwzODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWInKVxuXG59LHtcIi4vbGliXCI6NDN9XSwzOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc2FwID0gcmVxdWlyZSgnYXNhcC9yYXcnKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbi8vIFN0YXRlczpcbi8vXG4vLyAwIC0gcGVuZGluZ1xuLy8gMSAtIGZ1bGZpbGxlZCB3aXRoIF92YWx1ZVxuLy8gMiAtIHJlamVjdGVkIHdpdGggX3ZhbHVlXG4vLyAzIC0gYWRvcHRlZCB0aGUgc3RhdGUgb2YgYW5vdGhlciBwcm9taXNlLCBfdmFsdWVcbi8vXG4vLyBvbmNlIHRoZSBzdGF0ZSBpcyBubyBsb25nZXIgcGVuZGluZyAoMCkgaXQgaXMgaW1tdXRhYmxlXG5cbi8vIEFsbCBgX2AgcHJlZml4ZWQgcHJvcGVydGllcyB3aWxsIGJlIHJlZHVjZWQgdG8gYF97cmFuZG9tIG51bWJlcn1gXG4vLyBhdCBidWlsZCB0aW1lIHRvIG9iZnVzY2F0ZSB0aGVtIGFuZCBkaXNjb3VyYWdlIHRoZWlyIHVzZS5cbi8vIFdlIGRvbid0IHVzZSBzeW1ib2xzIG9yIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0byBmdWxseSBoaWRlIHRoZW1cbi8vIGJlY2F1c2UgdGhlIHBlcmZvcm1hbmNlIGlzbid0IGdvb2QgZW5vdWdoLlxuXG5cbi8vIHRvIGF2b2lkIHVzaW5nIHRyeS9jYXRjaCBpbnNpZGUgY3JpdGljYWwgZnVuY3Rpb25zLCB3ZVxuLy8gZXh0cmFjdCB0aGVtIHRvIGhlcmUuXG52YXIgTEFTVF9FUlJPUiA9IG51bGw7XG52YXIgSVNfRVJST1IgPSB7fTtcbmZ1bmN0aW9uIGdldFRoZW4ob2JqKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG9iai50aGVuO1xuICB9IGNhdGNoIChleCkge1xuICAgIExBU1RfRVJST1IgPSBleDtcbiAgICByZXR1cm4gSVNfRVJST1I7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5Q2FsbE9uZShmbiwgYSkge1xuICB0cnkge1xuICAgIHJldHVybiBmbihhKTtcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBMQVNUX0VSUk9SID0gZXg7XG4gICAgcmV0dXJuIElTX0VSUk9SO1xuICB9XG59XG5mdW5jdGlvbiB0cnlDYWxsVHdvKGZuLCBhLCBiKSB7XG4gIHRyeSB7XG4gICAgZm4oYSwgYik7XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgTEFTVF9FUlJPUiA9IGV4O1xuICAgIHJldHVybiBJU19FUlJPUjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5cbmZ1bmN0aW9uIFByb21pc2UoZm4pIHtcbiAgaWYgKHR5cGVvZiB0aGlzICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ldycpO1xuICB9XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSBmdW5jdGlvbicpO1xuICB9XG4gIHRoaXMuXzQ1ID0gMDtcbiAgdGhpcy5fODEgPSAwO1xuICB0aGlzLl82NSA9IG51bGw7XG4gIHRoaXMuXzU0ID0gbnVsbDtcbiAgaWYgKGZuID09PSBub29wKSByZXR1cm47XG4gIGRvUmVzb2x2ZShmbiwgdGhpcyk7XG59XG5Qcm9taXNlLl8xMCA9IG51bGw7XG5Qcm9taXNlLl85NyA9IG51bGw7XG5Qcm9taXNlLl82MSA9IG5vb3A7XG5cblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICBpZiAodGhpcy5jb25zdHJ1Y3RvciAhPT0gUHJvbWlzZSkge1xuICAgIHJldHVybiBzYWZlVGhlbih0aGlzLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gIH1cbiAgdmFyIHJlcyA9IG5ldyBQcm9taXNlKG5vb3ApO1xuICBoYW5kbGUodGhpcywgbmV3IEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHJlcykpO1xuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gc2FmZVRoZW4oc2VsZiwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgcmV0dXJuIG5ldyBzZWxmLmNvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVzID0gbmV3IFByb21pc2Uobm9vcCk7XG4gICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICBoYW5kbGUoc2VsZiwgbmV3IEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHJlcykpO1xuICB9KTtcbn07XG5mdW5jdGlvbiBoYW5kbGUoc2VsZiwgZGVmZXJyZWQpIHtcbiAgd2hpbGUgKHNlbGYuXzgxID09PSAzKSB7XG4gICAgc2VsZiA9IHNlbGYuXzY1O1xuICB9XG4gIGlmIChQcm9taXNlLl8xMCkge1xuICAgIFByb21pc2UuXzEwKHNlbGYpO1xuICB9XG4gIGlmIChzZWxmLl84MSA9PT0gMCkge1xuICAgIGlmIChzZWxmLl80NSA9PT0gMCkge1xuICAgICAgc2VsZi5fNDUgPSAxO1xuICAgICAgc2VsZi5fNTQgPSBkZWZlcnJlZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNlbGYuXzQ1ID09PSAxKSB7XG4gICAgICBzZWxmLl80NSA9IDI7XG4gICAgICBzZWxmLl81NCA9IFtzZWxmLl81NCwgZGVmZXJyZWRdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLl81NC5wdXNoKGRlZmVycmVkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaGFuZGxlUmVzb2x2ZWQoc2VsZiwgZGVmZXJyZWQpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVSZXNvbHZlZChzZWxmLCBkZWZlcnJlZCkge1xuICBhc2FwKGZ1bmN0aW9uKCkge1xuICAgIHZhciBjYiA9IHNlbGYuXzgxID09PSAxID8gZGVmZXJyZWQub25GdWxmaWxsZWQgOiBkZWZlcnJlZC5vblJlamVjdGVkO1xuICAgIGlmIChjYiA9PT0gbnVsbCkge1xuICAgICAgaWYgKHNlbGYuXzgxID09PSAxKSB7XG4gICAgICAgIHJlc29sdmUoZGVmZXJyZWQucHJvbWlzZSwgc2VsZi5fNjUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqZWN0KGRlZmVycmVkLnByb21pc2UsIHNlbGYuXzY1KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJldCA9IHRyeUNhbGxPbmUoY2IsIHNlbGYuXzY1KTtcbiAgICBpZiAocmV0ID09PSBJU19FUlJPUikge1xuICAgICAgcmVqZWN0KGRlZmVycmVkLnByb21pc2UsIExBU1RfRVJST1IpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlKGRlZmVycmVkLnByb21pc2UsIHJldCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlc29sdmUoc2VsZiwgbmV3VmFsdWUpIHtcbiAgLy8gUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZTogaHR0cHM6Ly9naXRodWIuY29tL3Byb21pc2VzLWFwbHVzL3Byb21pc2VzLXNwZWMjdGhlLXByb21pc2UtcmVzb2x1dGlvbi1wcm9jZWR1cmVcbiAgaWYgKG5ld1ZhbHVlID09PSBzZWxmKSB7XG4gICAgcmV0dXJuIHJlamVjdChcbiAgICAgIHNlbGYsXG4gICAgICBuZXcgVHlwZUVycm9yKCdBIHByb21pc2UgY2Fubm90IGJlIHJlc29sdmVkIHdpdGggaXRzZWxmLicpXG4gICAgKTtcbiAgfVxuICBpZiAoXG4gICAgbmV3VmFsdWUgJiZcbiAgICAodHlwZW9mIG5ld1ZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgbmV3VmFsdWUgPT09ICdmdW5jdGlvbicpXG4gICkge1xuICAgIHZhciB0aGVuID0gZ2V0VGhlbihuZXdWYWx1ZSk7XG4gICAgaWYgKHRoZW4gPT09IElTX0VSUk9SKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KHNlbGYsIExBU1RfRVJST1IpO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICB0aGVuID09PSBzZWxmLnRoZW4gJiZcbiAgICAgIG5ld1ZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZVxuICAgICkge1xuICAgICAgc2VsZi5fODEgPSAzO1xuICAgICAgc2VsZi5fNjUgPSBuZXdWYWx1ZTtcbiAgICAgIGZpbmFsZShzZWxmKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBkb1Jlc29sdmUodGhlbi5iaW5kKG5ld1ZhbHVlKSwgc2VsZik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHNlbGYuXzgxID0gMTtcbiAgc2VsZi5fNjUgPSBuZXdWYWx1ZTtcbiAgZmluYWxlKHNlbGYpO1xufVxuXG5mdW5jdGlvbiByZWplY3Qoc2VsZiwgbmV3VmFsdWUpIHtcbiAgc2VsZi5fODEgPSAyO1xuICBzZWxmLl82NSA9IG5ld1ZhbHVlO1xuICBpZiAoUHJvbWlzZS5fOTcpIHtcbiAgICBQcm9taXNlLl85NyhzZWxmLCBuZXdWYWx1ZSk7XG4gIH1cbiAgZmluYWxlKHNlbGYpO1xufVxuZnVuY3Rpb24gZmluYWxlKHNlbGYpIHtcbiAgaWYgKHNlbGYuXzQ1ID09PSAxKSB7XG4gICAgaGFuZGxlKHNlbGYsIHNlbGYuXzU0KTtcbiAgICBzZWxmLl81NCA9IG51bGw7XG4gIH1cbiAgaWYgKHNlbGYuXzQ1ID09PSAyKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLl81NC5sZW5ndGg7IGkrKykge1xuICAgICAgaGFuZGxlKHNlbGYsIHNlbGYuXzU0W2ldKTtcbiAgICB9XG4gICAgc2VsZi5fNTQgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHByb21pc2Upe1xuICB0aGlzLm9uRnVsZmlsbGVkID0gdHlwZW9mIG9uRnVsZmlsbGVkID09PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiBudWxsO1xuICB0aGlzLm9uUmVqZWN0ZWQgPSB0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uUmVqZWN0ZWQgOiBudWxsO1xuICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xufVxuXG4vKipcbiAqIFRha2UgYSBwb3RlbnRpYWxseSBtaXNiZWhhdmluZyByZXNvbHZlciBmdW5jdGlvbiBhbmQgbWFrZSBzdXJlXG4gKiBvbkZ1bGZpbGxlZCBhbmQgb25SZWplY3RlZCBhcmUgb25seSBjYWxsZWQgb25jZS5cbiAqXG4gKiBNYWtlcyBubyBndWFyYW50ZWVzIGFib3V0IGFzeW5jaHJvbnkuXG4gKi9cbmZ1bmN0aW9uIGRvUmVzb2x2ZShmbiwgcHJvbWlzZSkge1xuICB2YXIgZG9uZSA9IGZhbHNlO1xuICB2YXIgcmVzID0gdHJ5Q2FsbFR3byhmbiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICBkb25lID0gdHJ1ZTtcbiAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgZG9uZSA9IHRydWU7XG4gICAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gIH0pXG4gIGlmICghZG9uZSAmJiByZXMgPT09IElTX0VSUk9SKSB7XG4gICAgZG9uZSA9IHRydWU7XG4gICAgcmVqZWN0KHByb21pc2UsIExBU1RfRVJST1IpO1xuICB9XG59XG5cbn0se1wiYXNhcC9yYXdcIjozfV0sNDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4vY29yZS5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5Qcm9taXNlLnByb3RvdHlwZS5kb25lID0gZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIHZhciBzZWxmID0gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudGhlbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogdGhpcztcbiAgc2VsZi50aGVuKG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9LCAwKTtcbiAgfSk7XG59O1xuXG59LHtcIi4vY29yZS5qc1wiOjM5fV0sNDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vL1RoaXMgZmlsZSBjb250YWlucyB0aGUgRVM2IGV4dGVuc2lvbnMgdG8gdGhlIGNvcmUgUHJvbWlzZXMvQSsgQVBJXG5cbnZhciBQcm9taXNlID0gcmVxdWlyZSgnLi9jb3JlLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcblxuLyogU3RhdGljIEZ1bmN0aW9ucyAqL1xuXG52YXIgVFJVRSA9IHZhbHVlUHJvbWlzZSh0cnVlKTtcbnZhciBGQUxTRSA9IHZhbHVlUHJvbWlzZShmYWxzZSk7XG52YXIgTlVMTCA9IHZhbHVlUHJvbWlzZShudWxsKTtcbnZhciBVTkRFRklORUQgPSB2YWx1ZVByb21pc2UodW5kZWZpbmVkKTtcbnZhciBaRVJPID0gdmFsdWVQcm9taXNlKDApO1xudmFyIEVNUFRZU1RSSU5HID0gdmFsdWVQcm9taXNlKCcnKTtcblxuZnVuY3Rpb24gdmFsdWVQcm9taXNlKHZhbHVlKSB7XG4gIHZhciBwID0gbmV3IFByb21pc2UoUHJvbWlzZS5fNjEpO1xuICBwLl84MSA9IDE7XG4gIHAuXzY1ID0gdmFsdWU7XG4gIHJldHVybiBwO1xufVxuUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHJldHVybiB2YWx1ZTtcblxuICBpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiBOVUxMO1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFVOREVGSU5FRDtcbiAgaWYgKHZhbHVlID09PSB0cnVlKSByZXR1cm4gVFJVRTtcbiAgaWYgKHZhbHVlID09PSBmYWxzZSkgcmV0dXJuIEZBTFNFO1xuICBpZiAodmFsdWUgPT09IDApIHJldHVybiBaRVJPO1xuICBpZiAodmFsdWUgPT09ICcnKSByZXR1cm4gRU1QVFlTVFJJTkc7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciB0aGVuID0gdmFsdWUudGhlbjtcbiAgICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UodGhlbi5iaW5kKHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHJlamVjdChleCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlUHJvbWlzZSh2YWx1ZSk7XG59O1xuXG5Qcm9taXNlLmFsbCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnIpO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gcmVzb2x2ZShbXSk7XG4gICAgdmFyIHJlbWFpbmluZyA9IGFyZ3MubGVuZ3RoO1xuICAgIGZ1bmN0aW9uIHJlcyhpLCB2YWwpIHtcbiAgICAgIGlmICh2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBQcm9taXNlICYmIHZhbC50aGVuID09PSBQcm9taXNlLnByb3RvdHlwZS50aGVuKSB7XG4gICAgICAgICAgd2hpbGUgKHZhbC5fODEgPT09IDMpIHtcbiAgICAgICAgICAgIHZhbCA9IHZhbC5fNjU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWwuXzgxID09PSAxKSByZXR1cm4gcmVzKGksIHZhbC5fNjUpO1xuICAgICAgICAgIGlmICh2YWwuXzgxID09PSAyKSByZWplY3QodmFsLl82NSk7XG4gICAgICAgICAgdmFsLnRoZW4oZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmVzKGksIHZhbCk7XG4gICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHRoZW4gPSB2YWwudGhlbjtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBwID0gbmV3IFByb21pc2UodGhlbi5iaW5kKHZhbCkpO1xuICAgICAgICAgICAgcC50aGVuKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgcmVzKGksIHZhbCk7XG4gICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXJnc1tpXSA9IHZhbDtcbiAgICAgIGlmICgtLXJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICByZXNvbHZlKGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlcyhpLCBhcmdzW2ldKTtcbiAgICB9XG4gIH0pO1xufTtcblxuUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZWplY3QodmFsdWUpO1xuICB9KTtcbn07XG5cblByb21pc2UucmFjZSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKiBQcm90b3R5cGUgTWV0aG9kcyAqL1xuXG5Qcm9taXNlLnByb3RvdHlwZVsnY2F0Y2gnXSA9IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG59O1xuXG59LHtcIi4vY29yZS5qc1wiOjM5fV0sNDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4vY29yZS5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5Qcm9taXNlLnByb3RvdHlwZVsnZmluYWxseSddID0gZnVuY3Rpb24gKGYpIHtcbiAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGYoKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG4gIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGYoKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSk7XG4gIH0pO1xufTtcblxufSx7XCIuL2NvcmUuanNcIjozOX1dLDQzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvcmUuanMnKTtcbnJlcXVpcmUoJy4vZG9uZS5qcycpO1xucmVxdWlyZSgnLi9maW5hbGx5LmpzJyk7XG5yZXF1aXJlKCcuL2VzNi1leHRlbnNpb25zLmpzJyk7XG5yZXF1aXJlKCcuL25vZGUtZXh0ZW5zaW9ucy5qcycpO1xucmVxdWlyZSgnLi9zeW5jaHJvbm91cy5qcycpO1xuXG59LHtcIi4vY29yZS5qc1wiOjM5LFwiLi9kb25lLmpzXCI6NDAsXCIuL2VzNi1leHRlbnNpb25zLmpzXCI6NDEsXCIuL2ZpbmFsbHkuanNcIjo0MixcIi4vbm9kZS1leHRlbnNpb25zLmpzXCI6NDQsXCIuL3N5bmNocm9ub3VzLmpzXCI6NDV9XSw0NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoaXMgZmlsZSBjb250YWlucyB0aGVuL3Byb21pc2Ugc3BlY2lmaWMgZXh0ZW5zaW9ucyB0aGF0IGFyZSBvbmx5IHVzZWZ1bFxuLy8gZm9yIG5vZGUuanMgaW50ZXJvcFxuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4vY29yZS5qcycpO1xudmFyIGFzYXAgPSByZXF1aXJlKCdhc2FwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcblxuLyogU3RhdGljIEZ1bmN0aW9ucyAqL1xuXG5Qcm9taXNlLmRlbm9kZWlmeSA9IGZ1bmN0aW9uIChmbiwgYXJndW1lbnRDb3VudCkge1xuICBpZiAoXG4gICAgdHlwZW9mIGFyZ3VtZW50Q291bnQgPT09ICdudW1iZXInICYmIGFyZ3VtZW50Q291bnQgIT09IEluZmluaXR5XG4gICkge1xuICAgIHJldHVybiBkZW5vZGVpZnlXaXRoQ291bnQoZm4sIGFyZ3VtZW50Q291bnQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkZW5vZGVpZnlXaXRob3V0Q291bnQoZm4pO1xuICB9XG59XG5cbnZhciBjYWxsYmFja0ZuID0gKFxuICAnZnVuY3Rpb24gKGVyciwgcmVzKSB7JyArXG4gICdpZiAoZXJyKSB7IHJqKGVycik7IH0gZWxzZSB7IHJzKHJlcyk7IH0nICtcbiAgJ30nXG4pO1xuZnVuY3Rpb24gZGVub2RlaWZ5V2l0aENvdW50KGZuLCBhcmd1bWVudENvdW50KSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRDb3VudDsgaSsrKSB7XG4gICAgYXJncy5wdXNoKCdhJyArIGkpO1xuICB9XG4gIHZhciBib2R5ID0gW1xuICAgICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBhcmdzLmpvaW4oJywnKSArICcpIHsnLFxuICAgICd2YXIgc2VsZiA9IHRoaXM7JyxcbiAgICAncmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChycywgcmopIHsnLFxuICAgICd2YXIgcmVzID0gZm4uY2FsbCgnLFxuICAgIFsnc2VsZiddLmNvbmNhdChhcmdzKS5jb25jYXQoW2NhbGxiYWNrRm5dKS5qb2luKCcsJyksXG4gICAgJyk7JyxcbiAgICAnaWYgKHJlcyAmJicsXG4gICAgJyh0eXBlb2YgcmVzID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiByZXMgPT09IFwiZnVuY3Rpb25cIikgJiYnLFxuICAgICd0eXBlb2YgcmVzLnRoZW4gPT09IFwiZnVuY3Rpb25cIicsXG4gICAgJykge3JzKHJlcyk7fScsXG4gICAgJ30pOycsXG4gICAgJ307J1xuICBdLmpvaW4oJycpO1xuICByZXR1cm4gRnVuY3Rpb24oWydQcm9taXNlJywgJ2ZuJ10sIGJvZHkpKFByb21pc2UsIGZuKTtcbn1cbmZ1bmN0aW9uIGRlbm9kZWlmeVdpdGhvdXRDb3VudChmbikge1xuICB2YXIgZm5MZW5ndGggPSBNYXRoLm1heChmbi5sZW5ndGggLSAxLCAzKTtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbkxlbmd0aDsgaSsrKSB7XG4gICAgYXJncy5wdXNoKCdhJyArIGkpO1xuICB9XG4gIHZhciBib2R5ID0gW1xuICAgICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBhcmdzLmpvaW4oJywnKSArICcpIHsnLFxuICAgICd2YXIgc2VsZiA9IHRoaXM7JyxcbiAgICAndmFyIGFyZ3M7JyxcbiAgICAndmFyIGFyZ0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7JyxcbiAgICAnaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAnICsgZm5MZW5ndGggKyAnKSB7JyxcbiAgICAnYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoICsgMSk7JyxcbiAgICAnZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsnLFxuICAgICdhcmdzW2ldID0gYXJndW1lbnRzW2ldOycsXG4gICAgJ30nLFxuICAgICd9JyxcbiAgICAncmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChycywgcmopIHsnLFxuICAgICd2YXIgY2IgPSAnICsgY2FsbGJhY2tGbiArICc7JyxcbiAgICAndmFyIHJlczsnLFxuICAgICdzd2l0Y2ggKGFyZ0xlbmd0aCkgeycsXG4gICAgYXJncy5jb25jYXQoWydleHRyYSddKS5tYXAoZnVuY3Rpb24gKF8sIGluZGV4KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAnY2FzZSAnICsgKGluZGV4KSArICc6JyArXG4gICAgICAgICdyZXMgPSBmbi5jYWxsKCcgKyBbJ3NlbGYnXS5jb25jYXQoYXJncy5zbGljZSgwLCBpbmRleCkpLmNvbmNhdCgnY2InKS5qb2luKCcsJykgKyAnKTsnICtcbiAgICAgICAgJ2JyZWFrOydcbiAgICAgICk7XG4gICAgfSkuam9pbignJyksXG4gICAgJ2RlZmF1bHQ6JyxcbiAgICAnYXJnc1thcmdMZW5ndGhdID0gY2I7JyxcbiAgICAncmVzID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7JyxcbiAgICAnfScsXG4gICAgXG4gICAgJ2lmIChyZXMgJiYnLFxuICAgICcodHlwZW9mIHJlcyA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgcmVzID09PSBcImZ1bmN0aW9uXCIpICYmJyxcbiAgICAndHlwZW9mIHJlcy50aGVuID09PSBcImZ1bmN0aW9uXCInLFxuICAgICcpIHtycyhyZXMpO30nLFxuICAgICd9KTsnLFxuICAgICd9OydcbiAgXS5qb2luKCcnKTtcblxuICByZXR1cm4gRnVuY3Rpb24oXG4gICAgWydQcm9taXNlJywgJ2ZuJ10sXG4gICAgYm9keVxuICApKFByb21pc2UsIGZuKTtcbn1cblxuUHJvbWlzZS5ub2RlaWZ5ID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHZhciBjYWxsYmFjayA9XG4gICAgICB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nID8gYXJncy5wb3AoKSA6IG51bGw7XG4gICAgdmFyIGN0eCA9IHRoaXM7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpLm5vZGVpZnkoY2FsbGJhY2ssIGN0eCk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlmIChjYWxsYmFjayA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsbGJhY2sgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICByZWplY3QoZXgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbGxiYWNrLmNhbGwoY3R4LCBleCk7XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblByb21pc2UucHJvdG90eXBlLm5vZGVpZnkgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGN0eCkge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicpIHJldHVybiB0aGlzO1xuXG4gIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwoY3R4LCBudWxsLCB2YWx1ZSk7XG4gICAgfSk7XG4gIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwoY3R4LCBlcnIpO1xuICAgIH0pO1xuICB9KTtcbn1cblxufSx7XCIuL2NvcmUuanNcIjozOSxcImFzYXBcIjoyfV0sNDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4vY29yZS5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5Qcm9taXNlLmVuYWJsZVN5bmNocm9ub3VzID0gZnVuY3Rpb24gKCkge1xuICBQcm9taXNlLnByb3RvdHlwZS5pc1BlbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZSgpID09IDA7XG4gIH07XG5cbiAgUHJvbWlzZS5wcm90b3R5cGUuaXNGdWxmaWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZSgpID09IDE7XG4gIH07XG5cbiAgUHJvbWlzZS5wcm90b3R5cGUuaXNSZWplY3RlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldFN0YXRlKCkgPT0gMjtcbiAgfTtcblxuICBQcm9taXNlLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fODEgPT09IDMpIHtcbiAgICAgIHJldHVybiB0aGlzLl82NS5nZXRWYWx1ZSgpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBnZXQgYSB2YWx1ZSBvZiBhbiB1bmZ1bGZpbGxlZCBwcm9taXNlLicpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl82NTtcbiAgfTtcblxuICBQcm9taXNlLnByb3RvdHlwZS5nZXRSZWFzb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuXzgxID09PSAzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fNjUuZ2V0UmVhc29uKCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZ2V0IGEgcmVqZWN0aW9uIHJlYXNvbiBvZiBhIG5vbi1yZWplY3RlZCBwcm9taXNlLicpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl82NTtcbiAgfTtcblxuICBQcm9taXNlLnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fODEgPT09IDMpIHtcbiAgICAgIHJldHVybiB0aGlzLl82NS5nZXRTdGF0ZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fODEgPT09IC0xIHx8IHRoaXMuXzgxID09PSAtMikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuXzgxO1xuICB9O1xufTtcblxuUHJvbWlzZS5kaXNhYmxlU3luY2hyb25vdXMgPSBmdW5jdGlvbigpIHtcbiAgUHJvbWlzZS5wcm90b3R5cGUuaXNQZW5kaW5nID0gdW5kZWZpbmVkO1xuICBQcm9taXNlLnByb3RvdHlwZS5pc0Z1bGZpbGxlZCA9IHVuZGVmaW5lZDtcbiAgUHJvbWlzZS5wcm90b3R5cGUuaXNSZWplY3RlZCA9IHVuZGVmaW5lZDtcbiAgUHJvbWlzZS5wcm90b3R5cGUuZ2V0VmFsdWUgPSB1bmRlZmluZWQ7XG4gIFByb21pc2UucHJvdG90eXBlLmdldFJlYXNvbiA9IHVuZGVmaW5lZDtcbiAgUHJvbWlzZS5wcm90b3R5cGUuZ2V0U3RhdGUgPSB1bmRlZmluZWQ7XG59O1xuXG59LHtcIi4vY29yZS5qc1wiOjM5fV0sNDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLypcbiAqIENvcHlyaWdodCAyMDA5LTIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLnR4dCBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAvc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG5leHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwL3NvdXJjZS1tYXAtY29uc3VtZXInKS5Tb3VyY2VNYXBDb25zdW1lcjtcbmV4cG9ydHMuU291cmNlTm9kZSA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC9zb3VyY2Utbm9kZScpLlNvdXJjZU5vZGU7XG5cbn0se1wiLi9zb3VyY2UtbWFwL3NvdXJjZS1tYXAtY29uc3VtZXJcIjo1MyxcIi4vc291cmNlLW1hcC9zb3VyY2UtbWFwLWdlbmVyYXRvclwiOjU0LFwiLi9zb3VyY2UtbWFwL3NvdXJjZS1ub2RlXCI6NTV9XSw0NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgLyoqXG4gICAqIEEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggaXMgYSBjb21iaW5hdGlvbiBvZiBhbiBhcnJheSBhbmQgYSBzZXQuIEFkZGluZyBhIG5ld1xuICAgKiBtZW1iZXIgaXMgTygxKSwgdGVzdGluZyBmb3IgbWVtYmVyc2hpcCBpcyBPKDEpLCBhbmQgZmluZGluZyB0aGUgaW5kZXggb2YgYW5cbiAgICogZWxlbWVudCBpcyBPKDEpLiBSZW1vdmluZyBlbGVtZW50cyBmcm9tIHRoZSBzZXQgaXMgbm90IHN1cHBvcnRlZC4gT25seVxuICAgKiBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQgZm9yIG1lbWJlcnNoaXAuXG4gICAqL1xuICBmdW5jdGlvbiBBcnJheVNldCgpIHtcbiAgICB0aGlzLl9hcnJheSA9IFtdO1xuICAgIHRoaXMuX3NldCA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBtZXRob2QgZm9yIGNyZWF0aW5nIEFycmF5U2V0IGluc3RhbmNlcyBmcm9tIGFuIGV4aXN0aW5nIGFycmF5LlxuICAgKi9cbiAgQXJyYXlTZXQuZnJvbUFycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfZnJvbUFycmF5KGFBcnJheSwgYUFsbG93RHVwbGljYXRlcykge1xuICAgIHZhciBzZXQgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYUFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzZXQuYWRkKGFBcnJheVtpXSwgYUFsbG93RHVwbGljYXRlcyk7XG4gICAgfVxuICAgIHJldHVybiBzZXQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiBob3cgbWFueSB1bmlxdWUgaXRlbXMgYXJlIGluIHRoaXMgQXJyYXlTZXQuIElmIGR1cGxpY2F0ZXMgaGF2ZSBiZWVuXG4gICAqIGFkZGVkLCB0aGFuIHRob3NlIGRvIG5vdCBjb3VudCB0b3dhcmRzIHRoZSBzaXplLlxuICAgKlxuICAgKiBAcmV0dXJucyBOdW1iZXJcbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gQXJyYXlTZXRfc2l6ZSgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5fc2V0KS5sZW5ndGg7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgZ2l2ZW4gc3RyaW5nIHRvIHRoaXMgc2V0LlxuICAgKlxuICAgKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBBcnJheVNldF9hZGQoYVN0ciwgYUFsbG93RHVwbGljYXRlcykge1xuICAgIHZhciBpc0R1cGxpY2F0ZSA9IHRoaXMuaGFzKGFTdHIpO1xuICAgIHZhciBpZHggPSB0aGlzLl9hcnJheS5sZW5ndGg7XG4gICAgaWYgKCFpc0R1cGxpY2F0ZSB8fCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgICB0aGlzLl9hcnJheS5wdXNoKGFTdHIpO1xuICAgIH1cbiAgICBpZiAoIWlzRHVwbGljYXRlKSB7XG4gICAgICB0aGlzLl9zZXRbdXRpbC50b1NldFN0cmluZyhhU3RyKV0gPSBpZHg7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJcyB0aGUgZ2l2ZW4gc3RyaW5nIGEgbWVtYmVyIG9mIHRoaXMgc2V0P1xuICAgKlxuICAgKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBBcnJheVNldF9oYXMoYVN0cikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC50b1NldFN0cmluZyhhU3RyKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoYXQgaXMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBzdHJpbmcgaW4gdGhlIGFycmF5P1xuICAgKlxuICAgKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gQXJyYXlTZXRfaW5kZXhPZihhU3RyKSB7XG4gICAgaWYgKHRoaXMuaGFzKGFTdHIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0W3V0aWwudG9TZXRTdHJpbmcoYVN0cildO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTdHIgKyAnXCIgaXMgbm90IGluIHRoZSBzZXQuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoYXQgaXMgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4P1xuICAgKlxuICAgKiBAcGFyYW0gTnVtYmVyIGFJZHhcbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIEFycmF5U2V0X2F0KGFJZHgpIHtcbiAgICBpZiAoYUlkeCA+PSAwICYmIGFJZHggPCB0aGlzLl9hcnJheS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcnJheVthSWR4XTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBlbGVtZW50IGluZGV4ZWQgYnkgJyArIGFJZHgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcnJheSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNldCAod2hpY2ggaGFzIHRoZSBwcm9wZXIgaW5kaWNlc1xuICAgKiBpbmRpY2F0ZWQgYnkgaW5kZXhPZikuIE5vdGUgdGhhdCB0aGlzIGlzIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgYXJyYXkgdXNlZFxuICAgKiBmb3Igc3RvcmluZyB0aGUgbWVtYmVycyBzbyB0aGF0IG5vIG9uZSBjYW4gbWVzcyB3aXRoIGludGVybmFsIHN0YXRlLlxuICAgKi9cbiAgQXJyYXlTZXQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF90b0FycmF5KCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheS5zbGljZSgpO1xuICB9O1xuXG4gIGV4cG9ydHMuQXJyYXlTZXQgPSBBcnJheVNldDtcblxufSk7XG5cbn0se1wiLi91dGlsXCI6NTYsXCJhbWRlZmluZVwiOjF9XSw0ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICpcbiAqIEJhc2VkIG9uIHRoZSBCYXNlIDY0IFZMUSBpbXBsZW1lbnRhdGlvbiBpbiBDbG9zdXJlIENvbXBpbGVyOlxuICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jbG9zdXJlLWNvbXBpbGVyL3NvdXJjZS9icm93c2UvdHJ1bmsvc3JjL2NvbS9nb29nbGUvZGVidWdnaW5nL3NvdXJjZW1hcC9CYXNlNjRWTFEuamF2YVxuICpcbiAqIENvcHlyaWdodCAyMDExIFRoZSBDbG9zdXJlIENvbXBpbGVyIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICogICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAqICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZFxuICogICAgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkXG4gKiAgICBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICogVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciBiYXNlNjQgPSByZXF1aXJlKCcuL2Jhc2U2NCcpO1xuXG4gIC8vIEEgc2luZ2xlIGJhc2UgNjQgZGlnaXQgY2FuIGNvbnRhaW4gNiBiaXRzIG9mIGRhdGEuIEZvciB0aGUgYmFzZSA2NCB2YXJpYWJsZVxuICAvLyBsZW5ndGggcXVhbnRpdGllcyB3ZSB1c2UgaW4gdGhlIHNvdXJjZSBtYXAgc3BlYywgdGhlIGZpcnN0IGJpdCBpcyB0aGUgc2lnbixcbiAgLy8gdGhlIG5leHQgZm91ciBiaXRzIGFyZSB0aGUgYWN0dWFsIHZhbHVlLCBhbmQgdGhlIDZ0aCBiaXQgaXMgdGhlXG4gIC8vIGNvbnRpbnVhdGlvbiBiaXQuIFRoZSBjb250aW51YXRpb24gYml0IHRlbGxzIHVzIHdoZXRoZXIgdGhlcmUgYXJlIG1vcmVcbiAgLy8gZGlnaXRzIGluIHRoaXMgdmFsdWUgZm9sbG93aW5nIHRoaXMgZGlnaXQuXG4gIC8vXG4gIC8vICAgQ29udGludWF0aW9uXG4gIC8vICAgfCAgICBTaWduXG4gIC8vICAgfCAgICB8XG4gIC8vICAgViAgICBWXG4gIC8vICAgMTAxMDExXG5cbiAgdmFyIFZMUV9CQVNFX1NISUZUID0gNTtcblxuICAvLyBiaW5hcnk6IDEwMDAwMFxuICB2YXIgVkxRX0JBU0UgPSAxIDw8IFZMUV9CQVNFX1NISUZUO1xuXG4gIC8vIGJpbmFyeTogMDExMTExXG4gIHZhciBWTFFfQkFTRV9NQVNLID0gVkxRX0JBU0UgLSAxO1xuXG4gIC8vIGJpbmFyeTogMTAwMDAwXG4gIHZhciBWTFFfQ09OVElOVUFUSU9OX0JJVCA9IFZMUV9CQVNFO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBmcm9tIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgdG8gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAgICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gICAqICAgMSBiZWNvbWVzIDIgKDEwIGJpbmFyeSksIC0xIGJlY29tZXMgMyAoMTEgYmluYXJ5KVxuICAgKiAgIDIgYmVjb21lcyA0ICgxMDAgYmluYXJ5KSwgLTIgYmVjb21lcyA1ICgxMDEgYmluYXJ5KVxuICAgKi9cbiAgZnVuY3Rpb24gdG9WTFFTaWduZWQoYVZhbHVlKSB7XG4gICAgcmV0dXJuIGFWYWx1ZSA8IDBcbiAgICAgID8gKCgtYVZhbHVlKSA8PCAxKSArIDFcbiAgICAgIDogKGFWYWx1ZSA8PCAxKSArIDA7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdG8gYSB0d28tY29tcGxlbWVudCB2YWx1ZSBmcm9tIGEgdmFsdWUgd2hlcmUgdGhlIHNpZ24gYml0IGlzXG4gICAqIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICAgKiAgIDIgKDEwIGJpbmFyeSkgYmVjb21lcyAxLCAzICgxMSBiaW5hcnkpIGJlY29tZXMgLTFcbiAgICogICA0ICgxMDAgYmluYXJ5KSBiZWNvbWVzIDIsIDUgKDEwMSBiaW5hcnkpIGJlY29tZXMgLTJcbiAgICovXG4gIGZ1bmN0aW9uIGZyb21WTFFTaWduZWQoYVZhbHVlKSB7XG4gICAgdmFyIGlzTmVnYXRpdmUgPSAoYVZhbHVlICYgMSkgPT09IDE7XG4gICAgdmFyIHNoaWZ0ZWQgPSBhVmFsdWUgPj4gMTtcbiAgICByZXR1cm4gaXNOZWdhdGl2ZVxuICAgICAgPyAtc2hpZnRlZFxuICAgICAgOiBzaGlmdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJhc2UgNjQgVkxRIGVuY29kZWQgdmFsdWUuXG4gICAqL1xuICBleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIGJhc2U2NFZMUV9lbmNvZGUoYVZhbHVlKSB7XG4gICAgdmFyIGVuY29kZWQgPSBcIlwiO1xuICAgIHZhciBkaWdpdDtcblxuICAgIHZhciB2bHEgPSB0b1ZMUVNpZ25lZChhVmFsdWUpO1xuXG4gICAgZG8ge1xuICAgICAgZGlnaXQgPSB2bHEgJiBWTFFfQkFTRV9NQVNLO1xuICAgICAgdmxxID4+Pj0gVkxRX0JBU0VfU0hJRlQ7XG4gICAgICBpZiAodmxxID4gMCkge1xuICAgICAgICAvLyBUaGVyZSBhcmUgc3RpbGwgbW9yZSBkaWdpdHMgaW4gdGhpcyB2YWx1ZSwgc28gd2UgbXVzdCBtYWtlIHN1cmUgdGhlXG4gICAgICAgIC8vIGNvbnRpbnVhdGlvbiBiaXQgaXMgbWFya2VkLlxuICAgICAgICBkaWdpdCB8PSBWTFFfQ09OVElOVUFUSU9OX0JJVDtcbiAgICAgIH1cbiAgICAgIGVuY29kZWQgKz0gYmFzZTY0LmVuY29kZShkaWdpdCk7XG4gICAgfSB3aGlsZSAodmxxID4gMCk7XG5cbiAgICByZXR1cm4gZW5jb2RlZDtcbiAgfTtcblxuICAvKipcbiAgICogRGVjb2RlcyB0aGUgbmV4dCBiYXNlIDY0IFZMUSB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBzdHJpbmcgYW5kIHJldHVybnMgdGhlXG4gICAqIHZhbHVlIGFuZCB0aGUgcmVzdCBvZiB0aGUgc3RyaW5nIHZpYSB0aGUgb3V0IHBhcmFtZXRlci5cbiAgICovXG4gIGV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2RlY29kZShhU3RyLCBhSW5kZXgsIGFPdXRQYXJhbSkge1xuICAgIHZhciBzdHJMZW4gPSBhU3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICB2YXIgc2hpZnQgPSAwO1xuICAgIHZhciBjb250aW51YXRpb24sIGRpZ2l0O1xuXG4gICAgZG8ge1xuICAgICAgaWYgKGFJbmRleCA+PSBzdHJMZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbW9yZSBkaWdpdHMgaW4gYmFzZSA2NCBWTFEgdmFsdWUuXCIpO1xuICAgICAgfVxuXG4gICAgICBkaWdpdCA9IGJhc2U2NC5kZWNvZGUoYVN0ci5jaGFyQ29kZUF0KGFJbmRleCsrKSk7XG4gICAgICBpZiAoZGlnaXQgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYmFzZTY0IGRpZ2l0OiBcIiArIGFTdHIuY2hhckF0KGFJbmRleCAtIDEpKTtcbiAgICAgIH1cblxuICAgICAgY29udGludWF0aW9uID0gISEoZGlnaXQgJiBWTFFfQ09OVElOVUFUSU9OX0JJVCk7XG4gICAgICBkaWdpdCAmPSBWTFFfQkFTRV9NQVNLO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgKGRpZ2l0IDw8IHNoaWZ0KTtcbiAgICAgIHNoaWZ0ICs9IFZMUV9CQVNFX1NISUZUO1xuICAgIH0gd2hpbGUgKGNvbnRpbnVhdGlvbik7XG5cbiAgICBhT3V0UGFyYW0udmFsdWUgPSBmcm9tVkxRU2lnbmVkKHJlc3VsdCk7XG4gICAgYU91dFBhcmFtLnJlc3QgPSBhSW5kZXg7XG4gIH07XG5cbn0pO1xuXG59LHtcIi4vYmFzZTY0XCI6NDksXCJhbWRlZmluZVwiOjF9XSw0OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciBpbnRUb0NoYXJNYXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycuc3BsaXQoJycpO1xuXG4gIC8qKlxuICAgKiBFbmNvZGUgYW4gaW50ZWdlciBpbiB0aGUgcmFuZ2Ugb2YgMCB0byA2MyB0byBhIHNpbmdsZSBiYXNlIDY0IGRpZ2l0LlxuICAgKi9cbiAgZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgaWYgKDAgPD0gbnVtYmVyICYmIG51bWJlciA8IGludFRvQ2hhck1hcC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBpbnRUb0NoYXJNYXBbbnVtYmVyXTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk11c3QgYmUgYmV0d2VlbiAwIGFuZCA2MzogXCIgKyBhTnVtYmVyKTtcbiAgfTtcblxuICAvKipcbiAgICogRGVjb2RlIGEgc2luZ2xlIGJhc2UgNjQgY2hhcmFjdGVyIGNvZGUgZGlnaXQgdG8gYW4gaW50ZWdlci4gUmV0dXJucyAtMSBvblxuICAgKiBmYWlsdXJlLlxuICAgKi9cbiAgZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcbiAgICB2YXIgYmlnQSA9IDY1OyAgICAgLy8gJ0EnXG4gICAgdmFyIGJpZ1ogPSA5MDsgICAgIC8vICdaJ1xuXG4gICAgdmFyIGxpdHRsZUEgPSA5NzsgIC8vICdhJ1xuICAgIHZhciBsaXR0bGVaID0gMTIyOyAvLyAneidcblxuICAgIHZhciB6ZXJvID0gNDg7ICAgICAvLyAnMCdcbiAgICB2YXIgbmluZSA9IDU3OyAgICAgLy8gJzknXG5cbiAgICB2YXIgcGx1cyA9IDQzOyAgICAgLy8gJysnXG4gICAgdmFyIHNsYXNoID0gNDc7ICAgIC8vICcvJ1xuXG4gICAgdmFyIGxpdHRsZU9mZnNldCA9IDI2O1xuICAgIHZhciBudW1iZXJPZmZzZXQgPSA1MjtcblxuICAgIC8vIDAgLSAyNTogQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcbiAgICBpZiAoYmlnQSA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBiaWdaKSB7XG4gICAgICByZXR1cm4gKGNoYXJDb2RlIC0gYmlnQSk7XG4gICAgfVxuXG4gICAgLy8gMjYgLSA1MTogYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcbiAgICBpZiAobGl0dGxlQSA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBsaXR0bGVaKSB7XG4gICAgICByZXR1cm4gKGNoYXJDb2RlIC0gbGl0dGxlQSArIGxpdHRsZU9mZnNldCk7XG4gICAgfVxuXG4gICAgLy8gNTIgLSA2MTogMDEyMzQ1Njc4OVxuICAgIGlmICh6ZXJvIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IG5pbmUpIHtcbiAgICAgIHJldHVybiAoY2hhckNvZGUgLSB6ZXJvICsgbnVtYmVyT2Zmc2V0KTtcbiAgICB9XG5cbiAgICAvLyA2MjogK1xuICAgIGlmIChjaGFyQ29kZSA9PSBwbHVzKSB7XG4gICAgICByZXR1cm4gNjI7XG4gICAgfVxuXG4gICAgLy8gNjM6IC9cbiAgICBpZiAoY2hhckNvZGUgPT0gc2xhc2gpIHtcbiAgICAgIHJldHVybiA2MztcbiAgICB9XG5cbiAgICAvLyBJbnZhbGlkIGJhc2U2NCBkaWdpdC5cbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbn0pO1xuXG59LHtcImFtZGVmaW5lXCI6MX1dLDUwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgZXhwb3J0cy5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG4gIGV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQgPSAyO1xuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmUgaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaC5cbiAgICpcbiAgICogQHBhcmFtIGFMb3cgSW5kaWNlcyBoZXJlIGFuZCBsb3dlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICAgKiBAcGFyYW0gYUhpZ2ggSW5kaWNlcyBoZXJlIGFuZCBoaWdoZXIgZG8gbm90IGNvbnRhaW4gdGhlIG5lZWRsZS5cbiAgICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgYmVpbmcgc2VhcmNoZWQgZm9yLlxuICAgKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBub24tZW1wdHkgYXJyYXkgYmVpbmcgc2VhcmNoZWQuXG4gICAqIEBwYXJhbSBhQ29tcGFyZSBGdW5jdGlvbiB3aGljaCB0YWtlcyB0d28gZWxlbWVudHMgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEuXG4gICAqIEBwYXJhbSBhQmlhcyBFaXRoZXIgJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAgICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gICAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gICAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAgICovXG4gIGZ1bmN0aW9uIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHRlcm1pbmF0ZXMgd2hlbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBpcyB0cnVlOlxuICAgIC8vXG4gICAgLy8gICAxLiBXZSBmaW5kIHRoZSBleGFjdCBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgICAvL1xuICAgIC8vICAgMi4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBidXQgd2UgY2FuIHJldHVybiB0aGUgaW5kZXggb2ZcbiAgICAvLyAgICAgIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudC5cbiAgICAvL1xuICAgIC8vICAgMy4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBhbmQgdGhlcmUgaXMgbm8gbmV4dC1jbG9zZXN0XG4gICAgLy8gICAgICBlbGVtZW50IHRoYW4gdGhlIG9uZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgc28gd2UgcmV0dXJuIC0xLlxuICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKChhSGlnaCAtIGFMb3cpIC8gMikgKyBhTG93O1xuICAgIHZhciBjbXAgPSBhQ29tcGFyZShhTmVlZGxlLCBhSGF5c3RhY2tbbWlkXSwgdHJ1ZSk7XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgLy8gRm91bmQgdGhlIGVsZW1lbnQgd2UgYXJlIGxvb2tpbmcgZm9yLlxuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9XG4gICAgZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgLy8gT3VyIG5lZWRsZSBpcyBncmVhdGVyIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgICBpZiAoYUhpZ2ggLSBtaWQgPiAxKSB7XG4gICAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSB1cHBlciBoYWxmLlxuICAgICAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKG1pZCwgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGV4YWN0IG5lZWRsZSBlbGVtZW50IHdhcyBub3QgZm91bmQgaW4gdGhpcyBoYXlzdGFjay4gRGV0ZXJtaW5lIGlmXG4gICAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgICAgaWYgKGFCaWFzID09IGV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQpIHtcbiAgICAgICAgcmV0dXJuIGFIaWdoIDwgYUhheXN0YWNrLmxlbmd0aCA/IGFIaWdoIDogLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWlkO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIE91ciBuZWVkbGUgaXMgbGVzcyB0aGFuIGFIYXlzdGFja1ttaWRdLlxuICAgICAgaWYgKG1pZCAtIGFMb3cgPiAxKSB7XG4gICAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSBsb3dlciBoYWxmLlxuICAgICAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKGFMb3csIG1pZCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgICAgaWYgKGFCaWFzID09IGV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQpIHtcbiAgICAgICAgcmV0dXJuIG1pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhTG93IDwgMCA/IC0xIDogYUxvdztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoIHdoaWNoIHdpbGwgYWx3YXlzIHRyeSBhbmQgcmV0dXJuXG4gICAqIHRoZSBpbmRleCBvZiB0aGUgY2xvc2VzdCBlbGVtZW50IGlmIHRoZXJlIGlzIG5vIGV4YWN0IGhpdC4gVGhpcyBpcyBiZWNhdXNlXG4gICAqIG1hcHBpbmdzIGJldHdlZW4gb3JpZ2luYWwgYW5kIGdlbmVyYXRlZCBsaW5lL2NvbCBwYWlycyBhcmUgc2luZ2xlIHBvaW50cyxcbiAgICogYW5kIHRoZXJlIGlzIGFuIGltcGxpY2l0IHJlZ2lvbiBiZXR3ZWVuIGVhY2ggb2YgdGhlbSwgc28gYSBtaXNzIGp1c3QgbWVhbnNcbiAgICogdGhhdCB5b3UgYXJlbid0IG9uIHRoZSB2ZXJ5IHN0YXJ0IG9mIGEgcmVnaW9uLlxuICAgKlxuICAgKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCB5b3UgYXJlIGxvb2tpbmcgZm9yLlxuICAgKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBhcnJheSB0aGF0IGlzIGJlaW5nIHNlYXJjaGVkLlxuICAgKiBAcGFyYW0gYUNvbXBhcmUgQSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0aGUgbmVlZGxlIGFuZCBhbiBlbGVtZW50IGluIHRoZVxuICAgKiAgICAgYXJyYXkgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIG5lZWRsZSBpcyBsZXNzXG4gICAqICAgICB0aGFuLCBlcXVhbCB0bywgb3IgZ3JlYXRlciB0aGFuIHRoZSBlbGVtZW50LCByZXNwZWN0aXZlbHkuXG4gICAqIEBwYXJhbSBhQmlhcyBFaXRoZXIgJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAgICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gICAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gICAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAgICogICAgIERlZmF1bHRzIHRvICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICAgKi9cbiAgZXhwb3J0cy5zZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2goYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgICBpZiAoYUhheXN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IHJlY3Vyc2l2ZVNlYXJjaCgtMSwgYUhheXN0YWNrLmxlbmd0aCwgYU5lZWRsZSwgYUhheXN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ29tcGFyZSwgYUJpYXMgfHwgZXhwb3J0cy5HUkVBVEVTVF9MT1dFUl9CT1VORCk7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8vIFdlIGhhdmUgZm91bmQgZWl0aGVyIHRoZSBleGFjdCBlbGVtZW50LCBvciB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQgdGhhblxuICAgIC8vIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IuIEhvd2V2ZXIsIHRoZXJlIG1heSBiZSBtb3JlIHRoYW4gb25lIHN1Y2hcbiAgICAvLyBlbGVtZW50LiBNYWtlIHN1cmUgd2UgYWx3YXlzIHJldHVybiB0aGUgc21hbGxlc3Qgb2YgdGhlc2UuXG4gICAgd2hpbGUgKGluZGV4IC0gMSA+PSAwKSB7XG4gICAgICBpZiAoYUNvbXBhcmUoYUhheXN0YWNrW2luZGV4XSwgYUhheXN0YWNrW2luZGV4IC0gMV0sIHRydWUpICE9PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLS1pbmRleDtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH07XG5cbn0pO1xuXG59LHtcImFtZGVmaW5lXCI6MX1dLDUxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxNCBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgbWFwcGluZ0IgaXMgYWZ0ZXIgbWFwcGluZ0Egd2l0aCByZXNwZWN0IHRvIGdlbmVyYXRlZFxuICAgKiBwb3NpdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIobWFwcGluZ0EsIG1hcHBpbmdCKSB7XG4gICAgLy8gT3B0aW1pemVkIGZvciBtb3N0IGNvbW1vbiBjYXNlXG4gICAgdmFyIGxpbmVBID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZTtcbiAgICB2YXIgbGluZUIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICAgIHZhciBjb2x1bW5BID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uO1xuICAgIHZhciBjb2x1bW5CID0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICAgIHJldHVybiBsaW5lQiA+IGxpbmVBIHx8IGxpbmVCID09IGxpbmVBICYmIGNvbHVtbkIgPj0gY29sdW1uQSB8fFxuICAgICAgICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikgPD0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGRhdGEgc3RydWN0dXJlIHRvIHByb3ZpZGUgYSBzb3J0ZWQgdmlldyBvZiBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiBhXG4gICAqIHBlcmZvcm1hbmNlIGNvbnNjaW91cyBtYW5uZXIuIEl0IHRyYWRlcyBhIG5lZ2xpYmFibGUgb3ZlcmhlYWQgaW4gZ2VuZXJhbFxuICAgKiBjYXNlIGZvciBhIGxhcmdlIHNwZWVkdXAgaW4gY2FzZSBvZiBtYXBwaW5ncyBiZWluZyBhZGRlZCBpbiBvcmRlci5cbiAgICovXG4gIGZ1bmN0aW9uIE1hcHBpbmdMaXN0KCkge1xuICAgIHRoaXMuX2FycmF5ID0gW107XG4gICAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgICAvLyBTZXJ2ZXMgYXMgaW5maW11bVxuICAgIHRoaXMuX2xhc3QgPSB7Z2VuZXJhdGVkTGluZTogLTEsIGdlbmVyYXRlZENvbHVtbjogMH07XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGludGVybmFsIGl0ZW1zLiBUaGlzIG1ldGhvZCB0YWtlcyB0aGUgc2FtZSBhcmd1bWVudHMgdGhhdFxuICAgKiBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIHRha2VzLlxuICAgKlxuICAgKiBOT1RFOiBUaGUgb3JkZXIgb2YgdGhlIG1hcHBpbmdzIGlzIE5PVCBndWFyYW50ZWVkLlxuICAgKi9cbiAgTWFwcGluZ0xpc3QucHJvdG90eXBlLnVuc29ydGVkRm9yRWFjaCA9XG4gICAgZnVuY3Rpb24gTWFwcGluZ0xpc3RfZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKSB7XG4gICAgICB0aGlzLl9hcnJheS5mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgZ2l2ZW4gc291cmNlIG1hcHBpbmcuXG4gICAqXG4gICAqIEBwYXJhbSBPYmplY3QgYU1hcHBpbmdcbiAgICovXG4gIE1hcHBpbmdMaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBNYXBwaW5nTGlzdF9hZGQoYU1hcHBpbmcpIHtcbiAgICB2YXIgbWFwcGluZztcbiAgICBpZiAoZ2VuZXJhdGVkUG9zaXRpb25BZnRlcih0aGlzLl9sYXN0LCBhTWFwcGluZykpIHtcbiAgICAgIHRoaXMuX2xhc3QgPSBhTWFwcGluZztcbiAgICAgIHRoaXMuX2FycmF5LnB1c2goYU1hcHBpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2FycmF5LnB1c2goYU1hcHBpbmcpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmxhdCwgc29ydGVkIGFycmF5IG9mIG1hcHBpbmdzLiBUaGUgbWFwcGluZ3MgYXJlIHNvcnRlZCBieVxuICAgKiBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gICAqXG4gICAqIFdBUk5JTkc6IFRoaXMgbWV0aG9kIHJldHVybnMgaW50ZXJuYWwgZGF0YSB3aXRob3V0IGNvcHlpbmcsIGZvclxuICAgKiBwZXJmb3JtYW5jZS4gVGhlIHJldHVybiB2YWx1ZSBtdXN0IE5PVCBiZSBtdXRhdGVkLCBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXNcbiAgICogYW4gaW1tdXRhYmxlIGJvcnJvdy4gSWYgeW91IHdhbnQgdG8gdGFrZSBvd25lcnNoaXAsIHlvdSBtdXN0IG1ha2UgeW91ciBvd25cbiAgICogY29weS5cbiAgICovXG4gIE1hcHBpbmdMaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gTWFwcGluZ0xpc3RfdG9BcnJheSgpIHtcbiAgICBpZiAoIXRoaXMuX3NvcnRlZCkge1xuICAgICAgdGhpcy5fYXJyYXkuc29ydCh1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKTtcbiAgICAgIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hcnJheTtcbiAgfTtcblxuICBleHBvcnRzLk1hcHBpbmdMaXN0ID0gTWFwcGluZ0xpc3Q7XG5cbn0pO1xuXG59LHtcIi4vdXRpbFwiOjU2LFwiYW1kZWZpbmVcIjoxfV0sNTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICAvLyBJdCB0dXJucyBvdXQgdGhhdCBzb21lIChtb3N0PykgSmF2YVNjcmlwdCBlbmdpbmVzIGRvbid0IHNlbGYtaG9zdFxuICAvLyBgQXJyYXkucHJvdG90eXBlLnNvcnRgLiBUaGlzIG1ha2VzIHNlbnNlIGJlY2F1c2UgQysrIHdpbGwgbGlrZWx5IHJlbWFpblxuICAvLyBmYXN0ZXIgdGhhbiBKUyB3aGVuIGRvaW5nIHJhdyBDUFUtaW50ZW5zaXZlIHNvcnRpbmcuIEhvd2V2ZXIsIHdoZW4gdXNpbmcgYVxuICAvLyBjdXN0b20gY29tcGFyYXRvciBmdW5jdGlvbiwgY2FsbGluZyBiYWNrIGFuZCBmb3J0aCBiZXR3ZWVuIHRoZSBWTSdzIEMrKyBhbmRcbiAgLy8gSklUJ2QgSlMgaXMgcmF0aGVyIHNsb3cgKmFuZCogbG9zZXMgSklUIHR5cGUgaW5mb3JtYXRpb24sIHJlc3VsdGluZyBpblxuICAvLyB3b3JzZSBnZW5lcmF0ZWQgY29kZSBmb3IgdGhlIGNvbXBhcmF0b3IgZnVuY3Rpb24gdGhhbiB3b3VsZCBiZSBvcHRpbWFsLiBJblxuICAvLyBmYWN0LCB3aGVuIHNvcnRpbmcgd2l0aCBhIGNvbXBhcmF0b3IsIHRoZXNlIGNvc3RzIG91dHdlaWdoIHRoZSBiZW5lZml0cyBvZlxuICAvLyBzb3J0aW5nIGluIEMrKy4gQnkgdXNpbmcgb3VyIG93biBKUy1pbXBsZW1lbnRlZCBRdWljayBTb3J0IChiZWxvdyksIHdlIGdldFxuICAvLyBhIH4zNTAwbXMgbWVhbiBzcGVlZC11cCBpbiBgYmVuY2gvYmVuY2guaHRtbGAuXG5cbiAgLyoqXG4gICAqIFN3YXAgdGhlIGVsZW1lbnRzIGluZGV4ZWQgYnkgYHhgIGFuZCBgeWAgaW4gdGhlIGFycmF5IGBhcnlgLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAgICogICAgICAgIFRoZSBhcnJheS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogICAgICAgIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgaXRlbS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogICAgICAgIFRoZSBpbmRleCBvZiB0aGUgc2Vjb25kIGl0ZW0uXG4gICAqL1xuICBmdW5jdGlvbiBzd2FwKGFyeSwgeCwgeSkge1xuICAgIHZhciB0ZW1wID0gYXJ5W3hdO1xuICAgIGFyeVt4XSA9IGFyeVt5XTtcbiAgICBhcnlbeV0gPSB0ZW1wO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciB3aXRoaW4gdGhlIHJhbmdlIGBsb3cgLi4gaGlnaGAgaW5jbHVzaXZlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gbG93XG4gICAqICAgICAgICBUaGUgbG93ZXIgYm91bmQgb24gdGhlIHJhbmdlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGlnaFxuICAgKiAgICAgICAgVGhlIHVwcGVyIGJvdW5kIG9uIHRoZSByYW5nZS5cbiAgICovXG4gIGZ1bmN0aW9uIHJhbmRvbUludEluUmFuZ2UobG93LCBoaWdoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobG93ICsgKE1hdGgucmFuZG9tKCkgKiAoaGlnaCAtIGxvdykpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgUXVpY2sgU29ydCBhbGdvcml0aG0uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICAgKiAgICAgICAgQW4gYXJyYXkgdG8gc29ydC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvclxuICAgKiAgICAgICAgRnVuY3Rpb24gdG8gdXNlIHRvIGNvbXBhcmUgdHdvIGl0ZW1zLlxuICAgKiBAcGFyYW0ge051bWJlcn0gcFxuICAgKiAgICAgICAgU3RhcnQgaW5kZXggb2YgdGhlIGFycmF5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSByXG4gICAqICAgICAgICBFbmQgaW5kZXggb2YgdGhlIGFycmF5XG4gICAqL1xuICBmdW5jdGlvbiBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHAsIHIpIHtcbiAgICAvLyBJZiBvdXIgbG93ZXIgYm91bmQgaXMgbGVzcyB0aGFuIG91ciB1cHBlciBib3VuZCwgd2UgKDEpIHBhcnRpdGlvbiB0aGVcbiAgICAvLyBhcnJheSBpbnRvIHR3byBwaWVjZXMgYW5kICgyKSByZWN1cnNlIG9uIGVhY2ggaGFsZi4gSWYgaXQgaXMgbm90LCB0aGlzIGlzXG4gICAgLy8gdGhlIGVtcHR5IGFycmF5IGFuZCBvdXIgYmFzZSBjYXNlLlxuXG4gICAgaWYgKHAgPCByKSB7XG4gICAgICAvLyAoMSkgUGFydGl0aW9uaW5nLlxuICAgICAgLy9cbiAgICAgIC8vIFRoZSBwYXJ0aXRpb25pbmcgY2hvb3NlcyBhIHBpdm90IGJldHdlZW4gYHBgIGFuZCBgcmAgYW5kIG1vdmVzIGFsbFxuICAgICAgLy8gZWxlbWVudHMgdGhhdCBhcmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwaXZvdCB0byB0aGUgYmVmb3JlIGl0LCBhbmRcbiAgICAgIC8vIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBhcmUgZ3JlYXRlciB0aGFuIGl0IGFmdGVyIGl0LiBUaGUgZWZmZWN0IGlzIHRoYXRcbiAgICAgIC8vIG9uY2UgcGFydGl0aW9uIGlzIGRvbmUsIHRoZSBwaXZvdCBpcyBpbiB0aGUgZXhhY3QgcGxhY2UgaXQgd2lsbCBiZSB3aGVuXG4gICAgICAvLyB0aGUgYXJyYXkgaXMgcHV0IGluIHNvcnRlZCBvcmRlciwgYW5kIGl0IHdpbGwgbm90IG5lZWQgdG8gYmUgbW92ZWRcbiAgICAgIC8vIGFnYWluLiBUaGlzIHJ1bnMgaW4gTyhuKSB0aW1lLlxuXG4gICAgICAvLyBBbHdheXMgY2hvb3NlIGEgcmFuZG9tIHBpdm90IHNvIHRoYXQgYW4gaW5wdXQgYXJyYXkgd2hpY2ggaXMgcmV2ZXJzZVxuICAgICAgLy8gc29ydGVkIGRvZXMgbm90IGNhdXNlIE8obl4yKSBydW5uaW5nIHRpbWUuXG4gICAgICB2YXIgcGl2b3RJbmRleCA9IHJhbmRvbUludEluUmFuZ2UocCwgcik7XG4gICAgICB2YXIgaSA9IHAgLSAxO1xuXG4gICAgICBzd2FwKGFyeSwgcGl2b3RJbmRleCwgcik7XG4gICAgICB2YXIgcGl2b3QgPSBhcnlbcl07XG5cbiAgICAgIC8vIEltbWVkaWF0ZWx5IGFmdGVyIGBqYCBpcyBpbmNyZW1lbnRlZCBpbiB0aGlzIGxvb3AsIHRoZSBmb2xsb3dpbmcgaG9sZFxuICAgICAgLy8gdHJ1ZTpcbiAgICAgIC8vXG4gICAgICAvLyAgICogRXZlcnkgZWxlbWVudCBpbiBgYXJ5W3AgLi4gaV1gIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcGl2b3QuXG4gICAgICAvL1xuICAgICAgLy8gICAqIEV2ZXJ5IGVsZW1lbnQgaW4gYGFyeVtpKzEgLi4gai0xXWAgaXMgZ3JlYXRlciB0aGFuIHRoZSBwaXZvdC5cbiAgICAgIGZvciAodmFyIGogPSBwOyBqIDwgcjsgaisrKSB7XG4gICAgICAgIGlmIChjb21wYXJhdG9yKGFyeVtqXSwgcGl2b3QpIDw9IDApIHtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgc3dhcChhcnksIGksIGopO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN3YXAoYXJ5LCBpICsgMSwgaik7XG4gICAgICB2YXIgcSA9IGkgKyAxO1xuXG4gICAgICAvLyAoMikgUmVjdXJzZSBvbiBlYWNoIGhhbGYuXG5cbiAgICAgIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcCwgcSAtIDEpO1xuICAgICAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBxICsgMSwgcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNvcnQgdGhlIGdpdmVuIGFycmF5IGluLXBsYWNlIHdpdGggdGhlIGdpdmVuIGNvbXBhcmF0b3IgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICAgKiAgICAgICAgQW4gYXJyYXkgdG8gc29ydC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvclxuICAgKiAgICAgICAgRnVuY3Rpb24gdG8gdXNlIHRvIGNvbXBhcmUgdHdvIGl0ZW1zLlxuICAgKi9cbiAgZXhwb3J0cy5xdWlja1NvcnQgPSBmdW5jdGlvbiAoYXJ5LCBjb21wYXJhdG9yKSB7XG4gICAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCAwLCBhcnkubGVuZ3RoIC0gMSk7XG4gIH07XG5cbn0pO1xuXG59LHtcImFtZGVmaW5lXCI6MX1dLDUzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbiAgdmFyIGJpbmFyeVNlYXJjaCA9IHJlcXVpcmUoJy4vYmluYXJ5LXNlYXJjaCcpO1xuICB2YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xuICB2YXIgYmFzZTY0VkxRID0gcmVxdWlyZSgnLi9iYXNlNjQtdmxxJyk7XG4gIHZhciBxdWlja1NvcnQgPSByZXF1aXJlKCcuL3F1aWNrLXNvcnQnKS5xdWlja1NvcnQ7XG5cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCkge1xuICAgIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICAgIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNvdXJjZU1hcCA9IEpTT04ucGFyc2UoYVNvdXJjZU1hcC5yZXBsYWNlKC9eXFwpXFxdXFx9Jy8sICcnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNvdXJjZU1hcC5zZWN0aW9ucyAhPSBudWxsXG4gICAgICA/IG5ldyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwKVxuICAgICAgOiBuZXcgQmFzaWNTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXApO1xuICB9XG5cbiAgU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9IGZ1bmN0aW9uKGFTb3VyY2VNYXApIHtcbiAgICByZXR1cm4gQmFzaWNTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwKGFTb3VyY2VNYXApO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbiAgLy8gYF9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZCBgX19vcmlnaW5hbE1hcHBpbmdzYCBhcmUgYXJyYXlzIHRoYXQgaG9sZCB0aGVcbiAgLy8gcGFyc2VkIG1hcHBpbmcgY29vcmRpbmF0ZXMgZnJvbSB0aGUgc291cmNlIG1hcCdzIFwibWFwcGluZ3NcIiBhdHRyaWJ1dGUuIFRoZXlcbiAgLy8gYXJlIGxhemlseSBpbnN0YW50aWF0ZWQsIGFjY2Vzc2VkIHZpYSB0aGUgYF9nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gIC8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgZ2V0dGVycyByZXNwZWN0aXZlbHksIGFuZCB3ZSBvbmx5IHBhcnNlIHRoZSBtYXBwaW5nc1xuICAvLyBhbmQgY3JlYXRlIHRoZXNlIGFycmF5cyBvbmNlIHF1ZXJpZWQgZm9yIGEgc291cmNlIGxvY2F0aW9uLiBXZSBqdW1wIHRocm91Z2hcbiAgLy8gdGhlc2UgaG9vcHMgYmVjYXVzZSB0aGVyZSBjYW4gYmUgbWFueSB0aG91c2FuZHMgb2YgbWFwcGluZ3MsIGFuZCBwYXJzaW5nXG4gIC8vIHRoZW0gaXMgZXhwZW5zaXZlLCBzbyB3ZSBvbmx5IHdhbnQgdG8gZG8gaXQgaWYgd2UgbXVzdC5cbiAgLy9cbiAgLy8gRWFjaCBvYmplY3QgaW4gdGhlIGFycmF5cyBpcyBvZiB0aGUgZm9ybTpcbiAgLy9cbiAgLy8gICAgIHtcbiAgLy8gICAgICAgZ2VuZXJhdGVkTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbiAgLy8gICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4gIC8vICAgICAgIHNvdXJjZTogVGhlIHBhdGggdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIHRoYXQgZ2VuZXJhdGVkIHRoaXNcbiAgLy8gICAgICAgICAgICAgICBjaHVuayBvZiBjb2RlLFxuICAvLyAgICAgICBvcmlnaW5hbExpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbiAgLy8gICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuICAvLyAgICAgICBvcmlnaW5hbENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4gIC8vICAgICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuICAvLyAgICAgICBuYW1lOiBUaGUgbmFtZSBvZiB0aGUgb3JpZ2luYWwgc3ltYm9sIHdoaWNoIGdlbmVyYXRlZCB0aGlzIGNodW5rIG9mXG4gIC8vICAgICAgICAgICAgIGNvZGUuXG4gIC8vICAgICB9XG4gIC8vXG4gIC8vIEFsbCBwcm9wZXJ0aWVzIGV4Y2VwdCBmb3IgYGdlbmVyYXRlZExpbmVgIGFuZCBgZ2VuZXJhdGVkQ29sdW1uYCBjYW4gYmVcbiAgLy8gYG51bGxgLlxuICAvL1xuICAvLyBgX2dlbmVyYXRlZE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zLlxuICAvL1xuICAvLyBgX29yaWdpbmFsTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIG9yaWdpbmFsIHBvc2l0aW9ucy5cblxuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IG51bGw7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfZ2VuZXJhdGVkTWFwcGluZ3MnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncykge1xuICAgICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgIH1cbiAgfSk7XG5cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG51bGw7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfb3JpZ2luYWxNYXBwaW5ncycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MpIHtcbiAgICAgICAgdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncywgdGhpcy5zb3VyY2VSb290KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzO1xuICAgIH1cbiAgfSk7XG5cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yKGFTdHIsIGluZGV4KSB7XG4gICAgICB2YXIgYyA9IGFTdHIuY2hhckF0KGluZGV4KTtcbiAgICAgIHJldHVybiBjID09PSBcIjtcIiB8fCBjID09PSBcIixcIjtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gICAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICAgKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICAgKi9cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50IF9wYXJzZU1hcHBpbmdzXCIpO1xuICAgIH07XG5cbiAgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSID0gMTtcbiAgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVIgPSAyO1xuXG4gIFNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EID0gMTtcbiAgU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQgPSAyO1xuXG4gIC8qKlxuICAgKiBJdGVyYXRlIG92ZXIgZWFjaCBtYXBwaW5nIGJldHdlZW4gYW4gb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uIGFuZCBhXG4gICAqIGdlbmVyYXRlZCBsaW5lL2NvbHVtbiBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gICAqXG4gICAqIEBwYXJhbSBGdW5jdGlvbiBhQ2FsbGJhY2tcbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGVhY2ggbWFwcGluZy5cbiAgICogQHBhcmFtIE9iamVjdCBhQ29udGV4dFxuICAgKiAgICAgICAgT3B0aW9uYWwuIElmIHNwZWNpZmllZCwgdGhpcyBvYmplY3Qgd2lsbCBiZSB0aGUgdmFsdWUgb2YgYHRoaXNgIGV2ZXJ5XG4gICAqICAgICAgICB0aW1lIHRoYXQgYGFDYWxsYmFja2AgaXMgY2FsbGVkLlxuICAgKiBAcGFyYW0gYU9yZGVyXG4gICAqICAgICAgICBFaXRoZXIgYFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUmAgb3JcbiAgICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUmAuIFNwZWNpZmllcyB3aGV0aGVyIHlvdSB3YW50IHRvXG4gICAqICAgICAgICBpdGVyYXRlIG92ZXIgdGhlIG1hcHBpbmdzIHNvcnRlZCBieSB0aGUgZ2VuZXJhdGVkIGZpbGUncyBsaW5lL2NvbHVtblxuICAgKiAgICAgICAgb3JkZXIgb3IgdGhlIG9yaWdpbmFsJ3Mgc291cmNlL2xpbmUvY29sdW1uIG9yZGVyLCByZXNwZWN0aXZlbHkuIERlZmF1bHRzIHRvXG4gICAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSYC5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5lYWNoTWFwcGluZyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZWFjaE1hcHBpbmcoYUNhbGxiYWNrLCBhQ29udGV4dCwgYU9yZGVyKSB7XG4gICAgICB2YXIgY29udGV4dCA9IGFDb250ZXh0IHx8IG51bGw7XG4gICAgICB2YXIgb3JkZXIgPSBhT3JkZXIgfHwgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSO1xuXG4gICAgICB2YXIgbWFwcGluZ3M7XG4gICAgICBzd2l0Y2ggKG9yZGVyKSB7XG4gICAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjpcbiAgICAgICAgbWFwcGluZ3MgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSOlxuICAgICAgICBtYXBwaW5ncyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcmRlciBvZiBpdGVyYXRpb24uXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuc291cmNlUm9vdDtcbiAgICAgIG1hcHBpbmdzLm1hcChmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2UgPT09IG51bGwgPyBudWxsIDogdGhpcy5fc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCAmJiBzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2UgPSB1dGlsLmpvaW4oc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIGdlbmVyYXRlZExpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uLFxuICAgICAgICAgIG9yaWdpbmFsTGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgb3JpZ2luYWxDb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgbmFtZTogbWFwcGluZy5uYW1lID09PSBudWxsID8gbnVsbCA6IHRoaXMuX25hbWVzLmF0KG1hcHBpbmcubmFtZSlcbiAgICAgICAgfTtcbiAgICAgIH0sIHRoaXMpLmZvckVhY2goYUNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICAgKiBsaW5lLCBhbmQgY29sdW1uIHByb3ZpZGVkLiBJZiBubyBjb2x1bW4gaXMgcHJvdmlkZWQsIHJldHVybnMgYWxsIG1hcHBpbmdzXG4gICAqIGNvcnJlc3BvbmRpbmcgdG8gYSBlaXRoZXIgdGhlIGxpbmUgd2UgYXJlIHNlYXJjaGluZyBmb3Igb3IgdGhlIG5leHRcbiAgICogY2xvc2VzdCBsaW5lIHRoYXQgaGFzIGFueSBtYXBwaW5ncy4gT3RoZXJ3aXNlLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICAgKiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBsaW5lIGFuZCBlaXRoZXIgdGhlIGNvbHVtbiB3ZSBhcmUgc2VhcmNoaW5nIGZvclxuICAgKiBvciB0aGUgbmV4dCBjbG9zZXN0IGNvbHVtbiB0aGF0IGhhcyBhbnkgb2Zmc2V0cy5cbiAgICpcbiAgICogVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIC0gY29sdW1uOiBPcHRpb25hbC4gdGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICpcbiAgICogYW5kIGFuIGFycmF5IG9mIG9iamVjdHMgaXMgcmV0dXJuZWQsIGVhY2ggd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICAgKi9cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmFsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvciA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yKGFBcmdzKSB7XG4gICAgICB2YXIgbGluZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpO1xuXG4gICAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIGV4YWN0IG1hdGNoLCBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmdcbiAgICAgIC8vIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IG1hcHBpbmcgbGVzcyB0aGFuIHRoZSBuZWVkbGUuIEJ5XG4gICAgICAvLyBzZXR0aW5nIG5lZWRsZS5vcmlnaW5hbENvbHVtbiB0byAwLCB3ZSB0aHVzIGZpbmQgdGhlIGxhc3QgbWFwcGluZyBmb3JcbiAgICAgIC8vIHRoZSBnaXZlbiBsaW5lLCBwcm92aWRlZCBzdWNoIGEgbWFwcGluZyBleGlzdHMuXG4gICAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgICBzb3VyY2U6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyksXG4gICAgICAgIG9yaWdpbmFsTGluZTogbGluZSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJywgMClcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBuZWVkbGUuc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIG5lZWRsZS5zb3VyY2UpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzLmhhcyhuZWVkbGUuc291cmNlKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuZWVkbGUuc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKG5lZWRsZS5zb3VyY2UpO1xuXG4gICAgICB2YXIgbWFwcGluZ3MgPSBbXTtcblxuICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcobmVlZGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxNYXBwaW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxMaW5lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsQ29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EKTtcbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgICAgaWYgKGFBcmdzLmNvbHVtbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIG9yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lO1xuXG4gICAgICAgICAgLy8gSXRlcmF0ZSB1bnRpbCBlaXRoZXIgd2UgcnVuIG91dCBvZiBtYXBwaW5ncywgb3Igd2UgcnVuIGludG9cbiAgICAgICAgICAvLyBhIG1hcHBpbmcgZm9yIGEgZGlmZmVyZW50IGxpbmUgdGhhbiB0aGUgb25lIHdlIGZvdW5kLiBTaW5jZVxuICAgICAgICAgIC8vIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byBmaW5kIGFsbCBtYXBwaW5ncyBmb3JcbiAgICAgICAgICAvLyB0aGUgbGluZSB3ZSBmb3VuZC5cbiAgICAgICAgICB3aGlsZSAobWFwcGluZyAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gb3JpZ2luYWxMaW5lKSB7XG4gICAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1srK2luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG9yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAgIC8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4gICAgICAgICAgLy8gYSBtYXBwaW5nIGZvciBhIGRpZmZlcmVudCBsaW5lIHRoYW4gdGhlIG9uZSB3ZSB3ZXJlIHNlYXJjaGluZyBmb3IuXG4gICAgICAgICAgLy8gU2luY2UgbWFwcGluZ3MgYXJlIHNvcnRlZCwgdGhpcyBpcyBndWFyYW50ZWVkIHRvIGZpbmQgYWxsIG1hcHBpbmdzIGZvclxuICAgICAgICAgIC8vIHRoZSBsaW5lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLlxuICAgICAgICAgIHdoaWxlIChtYXBwaW5nICYmXG4gICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSBsaW5lICYmXG4gICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPT0gb3JpZ2luYWxDb2x1bW4pIHtcbiAgICAgICAgICAgIG1hcHBpbmdzLnB1c2goe1xuICAgICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFwcGluZ3M7XG4gICAgfTtcblxuICBleHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbiAgLyoqXG4gICAqIEEgQmFzaWNTb3VyY2VNYXBDb25zdW1lciBpbnN0YW5jZSByZXByZXNlbnRzIGEgcGFyc2VkIHNvdXJjZSBtYXAgd2hpY2ggd2UgY2FuXG4gICAqIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgZmlsZSBwb3NpdGlvbnMgYnkgZ2l2aW5nIGl0IGEgZmlsZVxuICAgKiBwb3NpdGlvbiBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAgICpcbiAgICogVGhlIG9ubHkgcGFyYW1ldGVyIGlzIHRoZSByYXcgc291cmNlIG1hcCAoZWl0aGVyIGFzIGEgSlNPTiBzdHJpbmcsIG9yXG4gICAqIGFscmVhZHkgcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYywgc291cmNlIG1hcHMgaGF2ZSB0aGVcbiAgICogZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gICAqXG4gICAqICAgLSB2ZXJzaW9uOiBXaGljaCB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwIHNwZWMgdGhpcyBtYXAgaXMgZm9sbG93aW5nLlxuICAgKiAgIC0gc291cmNlczogQW4gYXJyYXkgb2YgVVJMcyB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICAgKiAgIC0gbmFtZXM6IEFuIGFycmF5IG9mIGlkZW50aWZpZXJzIHdoaWNoIGNhbiBiZSByZWZlcnJlbmNlZCBieSBpbmRpdmlkdWFsIG1hcHBpbmdzLlxuICAgKiAgIC0gc291cmNlUm9vdDogT3B0aW9uYWwuIFRoZSBVUkwgcm9vdCBmcm9tIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSByZWxhdGl2ZS5cbiAgICogICAtIHNvdXJjZXNDb250ZW50OiBPcHRpb25hbC4gQW4gYXJyYXkgb2YgY29udGVudHMgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAgICogICAtIG1hcHBpbmdzOiBBIHN0cmluZyBvZiBiYXNlNjQgVkxRcyB3aGljaCBjb250YWluIHRoZSBhY3R1YWwgbWFwcGluZ3MuXG4gICAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gICAqXG4gICAqIEhlcmUgaXMgYW4gZXhhbXBsZSBzb3VyY2UgbWFwLCB0YWtlbiBmcm9tIHRoZSBzb3VyY2UgbWFwIHNwZWNbMF06XG4gICAqXG4gICAqICAgICB7XG4gICAqICAgICAgIHZlcnNpb24gOiAzLFxuICAgKiAgICAgICBmaWxlOiBcIm91dC5qc1wiLFxuICAgKiAgICAgICBzb3VyY2VSb290IDogXCJcIixcbiAgICogICAgICAgc291cmNlczogW1wiZm9vLmpzXCIsIFwiYmFyLmpzXCJdLFxuICAgKiAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAgICogICAgICAgbWFwcGluZ3M6IFwiQUEsQUI7O0FCQ0RFO1wiXG4gICAqICAgICB9XG4gICAqXG4gICAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0P3BsaT0xI1xuICAgKi9cbiAgZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gICAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gICAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgICB9XG5cbiAgICB2YXIgdmVyc2lvbiA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3ZlcnNpb24nKTtcbiAgICB2YXIgc291cmNlcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXMnKTtcbiAgICAvLyBTYXNzIDMuMyBsZWF2ZXMgb3V0IHRoZSAnbmFtZXMnIGFycmF5LCBzbyB3ZSBkZXZpYXRlIGZyb20gdGhlIHNwZWMgKHdoaWNoXG4gICAgLy8gcmVxdWlyZXMgdGhlIGFycmF5KSB0byBwbGF5IG5pY2UgaGVyZS5cbiAgICB2YXIgbmFtZXMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICduYW1lcycsIFtdKTtcbiAgICB2YXIgc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgICB2YXIgc291cmNlc0NvbnRlbnQgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VzQ29udGVudCcsIG51bGwpO1xuICAgIHZhciBtYXBwaW5ncyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ21hcHBpbmdzJyk7XG4gICAgdmFyIGZpbGUgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdmaWxlJywgbnVsbCk7XG5cbiAgICAvLyBPbmNlIGFnYWluLCBTYXNzIGRldmlhdGVzIGZyb20gdGhlIHNwZWMgYW5kIHN1cHBsaWVzIHRoZSB2ZXJzaW9uIGFzIGFcbiAgICAvLyBzdHJpbmcgcmF0aGVyIHRoYW4gYSBudW1iZXIsIHNvIHdlIHVzZSBsb29zZSBlcXVhbGl0eSBjaGVja2luZyBoZXJlLlxuICAgIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdmVyc2lvbjogJyArIHZlcnNpb24pO1xuICAgIH1cblxuICAgIC8vIFNvbWUgc291cmNlIG1hcHMgcHJvZHVjZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbGlrZSBcIi4vZm9vLmpzXCIgaW5zdGVhZCBvZlxuICAgIC8vIFwiZm9vLmpzXCIuICBOb3JtYWxpemUgdGhlc2UgZmlyc3Qgc28gdGhhdCBmdXR1cmUgY29tcGFyaXNvbnMgd2lsbCBzdWNjZWVkLlxuICAgIC8vIFNlZSBidWd6aWwubGEvMTA5MDc2OC5cbiAgICBzb3VyY2VzID0gc291cmNlcy5tYXAodXRpbC5ub3JtYWxpemUpO1xuXG4gICAgLy8gUGFzcyBgdHJ1ZWAgYmVsb3cgdG8gYWxsb3cgZHVwbGljYXRlIG5hbWVzIGFuZCBzb3VyY2VzLiBXaGlsZSBzb3VyY2UgbWFwc1xuICAgIC8vIGFyZSBpbnRlbmRlZCB0byBiZSBjb21wcmVzc2VkIGFuZCBkZWR1cGxpY2F0ZWQsIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyXG4gICAgLy8gc29tZXRpbWVzIGdlbmVyYXRlcyBzb3VyY2UgbWFwcyB3aXRoIGR1cGxpY2F0ZXMgaW4gdGhlbS4gU2VlIEdpdGh1YiBpc3N1ZVxuICAgIC8vICM3MiBhbmQgYnVnemlsLmxhLzg4OTQ5Mi5cbiAgICB0aGlzLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShuYW1lcywgdHJ1ZSk7XG4gICAgdGhpcy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShzb3VyY2VzLCB0cnVlKTtcblxuICAgIHRoaXMuc291cmNlUm9vdCA9IHNvdXJjZVJvb3Q7XG4gICAgdGhpcy5zb3VyY2VzQ29udGVudCA9IHNvdXJjZXNDb250ZW50O1xuICAgIHRoaXMuX21hcHBpbmdzID0gbWFwcGluZ3M7XG4gICAgdGhpcy5maWxlID0gZmlsZTtcbiAgfVxuXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb25zdW1lciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGZyb20gYSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gICAqXG4gICAqIEBwYXJhbSBTb3VyY2VNYXBHZW5lcmF0b3IgYVNvdXJjZU1hcFxuICAgKiAgICAgICAgVGhlIHNvdXJjZSBtYXAgdGhhdCB3aWxsIGJlIGNvbnN1bWVkLlxuICAgKiBAcmV0dXJucyBCYXNpY1NvdXJjZU1hcENvbnN1bWVyXG4gICAqL1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCkge1xuICAgICAgdmFyIHNtYyA9IE9iamVjdC5jcmVhdGUoQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuXG4gICAgICB2YXIgbmFtZXMgPSBzbWMuX25hbWVzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX25hbWVzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgICB2YXIgc291cmNlcyA9IHNtYy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9zb3VyY2VzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgICBzbWMuc291cmNlUm9vdCA9IGFTb3VyY2VNYXAuX3NvdXJjZVJvb3Q7XG4gICAgICBzbWMuc291cmNlc0NvbnRlbnQgPSBhU291cmNlTWFwLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KHNtYy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtYy5zb3VyY2VSb290KTtcbiAgICAgIHNtYy5maWxlID0gYVNvdXJjZU1hcC5fZmlsZTtcblxuICAgICAgLy8gQmVjYXVzZSB3ZSBhcmUgbW9kaWZ5aW5nIHRoZSBlbnRyaWVzIChieSBjb252ZXJ0aW5nIHN0cmluZyBzb3VyY2VzIGFuZFxuICAgICAgLy8gbmFtZXMgdG8gaW5kaWNlcyBpbnRvIHRoZSBzb3VyY2VzIGFuZCBuYW1lcyBBcnJheVNldHMpLCB3ZSBoYXZlIHRvIG1ha2VcbiAgICAgIC8vIGEgY29weSBvZiB0aGUgZW50cnkgb3IgZWxzZSBiYWQgdGhpbmdzIGhhcHBlbi4gU2hhcmVkIG11dGFibGUgc3RhdGVcbiAgICAgIC8vIHN0cmlrZXMgYWdhaW4hIFNlZSBnaXRodWIgaXNzdWUgIzE5MS5cblxuICAgICAgdmFyIGdlbmVyYXRlZE1hcHBpbmdzID0gYVNvdXJjZU1hcC5fbWFwcGluZ3MudG9BcnJheSgpLnNsaWNlKCk7XG4gICAgICB2YXIgZGVzdEdlbmVyYXRlZE1hcHBpbmdzID0gc21jLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICAgIHZhciBkZXN0T3JpZ2luYWxNYXBwaW5ncyA9IHNtYy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzcmNNYXBwaW5nID0gZ2VuZXJhdGVkTWFwcGluZ3NbaV07XG4gICAgICAgIHZhciBkZXN0TWFwcGluZyA9IG5ldyBNYXBwaW5nO1xuICAgICAgICBkZXN0TWFwcGluZy5nZW5lcmF0ZWRMaW5lID0gc3JjTWFwcGluZy5nZW5lcmF0ZWRMaW5lO1xuICAgICAgICBkZXN0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gPSBzcmNNYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgICBpZiAoc3JjTWFwcGluZy5zb3VyY2UpIHtcbiAgICAgICAgICBkZXN0TWFwcGluZy5zb3VyY2UgPSBzb3VyY2VzLmluZGV4T2Yoc3JjTWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgIGRlc3RNYXBwaW5nLm9yaWdpbmFsTGluZSA9IHNyY01hcHBpbmcub3JpZ2luYWxMaW5lO1xuICAgICAgICAgIGRlc3RNYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gc3JjTWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAgIGlmIChzcmNNYXBwaW5nLm5hbWUpIHtcbiAgICAgICAgICAgIGRlc3RNYXBwaW5nLm5hbWUgPSBuYW1lcy5pbmRleE9mKHNyY01hcHBpbmcubmFtZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVzdE9yaWdpbmFsTWFwcGluZ3MucHVzaChkZXN0TWFwcGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBkZXN0R2VuZXJhdGVkTWFwcGluZ3MucHVzaChkZXN0TWFwcGluZyk7XG4gICAgICB9XG5cbiAgICAgIHF1aWNrU29ydChzbWMuX19vcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcblxuICAgICAgcmV0dXJuIHNtYztcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gICAqL1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIG9yaWdpbmFsIHNvdXJjZXMuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZXMudG9BcnJheSgpLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VSb290ICE9IG51bGwgPyB1dGlsLmpvaW4odGhpcy5zb3VyY2VSb290LCBzKSA6IHM7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBQcm92aWRlIHRoZSBKSVQgd2l0aCBhIG5pY2Ugc2hhcGUgLyBoaWRkZW4gY2xhc3MuXG4gICAqL1xuICBmdW5jdGlvbiBNYXBwaW5nKCkge1xuICAgIHRoaXMuZ2VuZXJhdGVkTGluZSA9IDA7XG4gICAgdGhpcy5nZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgIHRoaXMuc291cmNlID0gbnVsbDtcbiAgICB0aGlzLm9yaWdpbmFsTGluZSA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gICAgdGhpcy5uYW1lID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gICAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICAgKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICAgKi9cbiAgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICAgIHZhciBnZW5lcmF0ZWRMaW5lID0gMTtcbiAgICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSAwO1xuICAgICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgICAgdmFyIGxlbmd0aCA9IGFTdHIubGVuZ3RoO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciBjYWNoZWRTZWdtZW50cyA9IHt9O1xuICAgICAgdmFyIHRlbXAgPSB7fTtcbiAgICAgIHZhciBvcmlnaW5hbE1hcHBpbmdzID0gW107XG4gICAgICB2YXIgZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICAgIHZhciBtYXBwaW5nLCBzdHIsIHNlZ21lbnQsIGVuZCwgdmFsdWU7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoYVN0ci5jaGFyQXQoaW5kZXgpID09PSAnOycpIHtcbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYVN0ci5jaGFyQXQoaW5kZXgpID09PSAnLCcpIHtcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG1hcHBpbmcgPSBuZXcgTWFwcGluZygpO1xuICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IGdlbmVyYXRlZExpbmU7XG5cbiAgICAgICAgICAvLyBCZWNhdXNlIGVhY2ggb2Zmc2V0IGlzIGVuY29kZWQgcmVsYXRpdmUgdG8gdGhlIHByZXZpb3VzIG9uZSxcbiAgICAgICAgICAvLyBtYW55IHNlZ21lbnRzIG9mdGVuIGhhdmUgdGhlIHNhbWUgZW5jb2RpbmcuIFdlIGNhbiBleHBsb2l0IHRoaXNcbiAgICAgICAgICAvLyBmYWN0IGJ5IGNhY2hpbmcgdGhlIHBhcnNlZCB2YXJpYWJsZSBsZW5ndGggZmllbGRzIG9mIGVhY2ggc2VnbWVudCxcbiAgICAgICAgICAvLyBhbGxvd2luZyB1cyB0byBhdm9pZCBhIHNlY29uZCBwYXJzZSBpZiB3ZSBlbmNvdW50ZXIgdGhlIHNhbWVcbiAgICAgICAgICAvLyBzZWdtZW50IGFnYWluLlxuICAgICAgICAgIGZvciAoZW5kID0gaW5kZXg7IGVuZCA8IGxlbmd0aDsgZW5kKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yKGFTdHIsIGVuZCkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0ciA9IGFTdHIuc2xpY2UoaW5kZXgsIGVuZCk7XG5cbiAgICAgICAgICBzZWdtZW50ID0gY2FjaGVkU2VnbWVudHNbc3RyXTtcbiAgICAgICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICAgICAgaW5kZXggKz0gc3RyLmxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VnbWVudCA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kKSB7XG4gICAgICAgICAgICAgIGJhc2U2NFZMUS5kZWNvZGUoYVN0ciwgaW5kZXgsIHRlbXApO1xuICAgICAgICAgICAgICB2YWx1ZSA9IHRlbXAudmFsdWU7XG4gICAgICAgICAgICAgIGluZGV4ID0gdGVtcC5yZXN0O1xuICAgICAgICAgICAgICBzZWdtZW50LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCBhIHNvdXJjZSwgYnV0IG5vIGxpbmUgYW5kIGNvbHVtbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCBhIHNvdXJjZSBhbmQgbGluZSwgYnV0IG5vIGNvbHVtbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYWNoZWRTZWdtZW50c1tzdHJdID0gc2VnbWVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBHZW5lcmF0ZWQgY29sdW1uLlxuICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uID0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gKyBzZWdtZW50WzBdO1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBzb3VyY2UuXG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHByZXZpb3VzU291cmNlICsgc2VnbWVudFsxXTtcbiAgICAgICAgICAgIHByZXZpb3VzU291cmNlICs9IHNlZ21lbnRbMV07XG5cbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIGxpbmUuXG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9IHByZXZpb3VzT3JpZ2luYWxMaW5lICsgc2VnbWVudFsyXTtcbiAgICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgICAgICAvLyBMaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWRcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lICs9IDE7XG5cbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIGNvbHVtbi5cbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBwcmV2aW91c09yaWdpbmFsQ29sdW1uICsgc2VnbWVudFszXTtcbiAgICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAgIC8vIE9yaWdpbmFsIG5hbWUuXG4gICAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IHByZXZpb3VzTmFtZSArIHNlZ21lbnRbNF07XG4gICAgICAgICAgICAgIHByZXZpb3VzTmFtZSArPSBzZWdtZW50WzRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGdlbmVyYXRlZE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcXVpY2tTb3J0KGdlbmVyYXRlZE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKTtcbiAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IGdlbmVyYXRlZE1hcHBpbmdzO1xuXG4gICAgICBxdWlja1NvcnQob3JpZ2luYWxNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG4gICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG9yaWdpbmFsTWFwcGluZ3M7XG4gICAgfTtcblxuICAvKipcbiAgICogRmluZCB0aGUgbWFwcGluZyB0aGF0IGJlc3QgbWF0Y2hlcyB0aGUgaHlwb3RoZXRpY2FsIFwibmVlZGxlXCIgbWFwcGluZyB0aGF0XG4gICAqIHdlIGFyZSBzZWFyY2hpbmcgZm9yIGluIHRoZSBnaXZlbiBcImhheXN0YWNrXCIgb2YgbWFwcGluZ3MuXG4gICAqL1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2ZpbmRNYXBwaW5nKGFOZWVkbGUsIGFNYXBwaW5ncywgYUxpbmVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb2x1bW5OYW1lLCBhQ29tcGFyYXRvciwgYUJpYXMpIHtcbiAgICAgIC8vIFRvIHJldHVybiB0aGUgcG9zaXRpb24gd2UgYXJlIHNlYXJjaGluZyBmb3IsIHdlIG11c3QgZmlyc3QgZmluZCB0aGVcbiAgICAgIC8vIG1hcHBpbmcgZm9yIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgdGhlbiByZXR1cm4gdGhlIG9wcG9zaXRlIHBvc2l0aW9uIGl0XG4gICAgICAvLyBwb2ludHMgdG8uIEJlY2F1c2UgdGhlIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHdlIGNhbiB1c2UgYmluYXJ5IHNlYXJjaCB0b1xuICAgICAgLy8gZmluZCB0aGUgYmVzdCBtYXBwaW5nLlxuXG4gICAgICBpZiAoYU5lZWRsZVthTGluZU5hbWVdIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTGluZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxLCBnb3QgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgYU5lZWRsZVthTGluZU5hbWVdKTtcbiAgICAgIH1cbiAgICAgIGlmIChhTmVlZGxlW2FDb2x1bW5OYW1lXSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29sdW1uIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FDb2x1bW5OYW1lXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiaW5hcnlTZWFyY2guc2VhcmNoKGFOZWVkbGUsIGFNYXBwaW5ncywgYUNvbXBhcmF0b3IsIGFCaWFzKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBsYXN0IGNvbHVtbiBmb3IgZWFjaCBnZW5lcmF0ZWQgbWFwcGluZy4gVGhlIGxhc3QgY29sdW1uIGlzXG4gICAqIGluY2x1c2l2ZS5cbiAgICovXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbXB1dGVDb2x1bW5TcGFucyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY29tcHV0ZUNvbHVtblNwYW5zKCkge1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgICAvLyBNYXBwaW5ncyBkbyBub3QgY29udGFpbiBhIGZpZWxkIGZvciB0aGUgbGFzdCBnZW5lcmF0ZWQgY29sdW1udC4gV2VcbiAgICAgICAgLy8gY2FuIGNvbWUgdXAgd2l0aCBhbiBvcHRpbWlzdGljIGVzdGltYXRlLCBob3dldmVyLCBieSBhc3N1bWluZyB0aGF0XG4gICAgICAgIC8vIG1hcHBpbmdzIGFyZSBjb250aWd1b3VzIChpLmUuIGdpdmVuIHR3byBjb25zZWN1dGl2ZSBtYXBwaW5ncywgdGhlXG4gICAgICAgIC8vIGZpcnN0IG1hcHBpbmcgZW5kcyB3aGVyZSB0aGUgc2Vjb25kIG9uZSBzdGFydHMpLlxuICAgICAgICBpZiAoaW5kZXggKyAxIDwgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIG5leHRNYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXggKyAxXTtcblxuICAgICAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgPT09IG5leHRNYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICAgIG1hcHBpbmcubGFzdEdlbmVyYXRlZENvbHVtbiA9IG5leHRNYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtIDE7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgbGFzdCBtYXBwaW5nIGZvciBlYWNoIGxpbmUgc3BhbnMgdGhlIGVudGlyZSBsaW5lLlxuICAgICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBJbmZpbml0eTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UsIGxpbmUsIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBnZW5lcmF0ZWRcbiAgICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gICAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAgICogICAtIGJpYXM6IEVpdGhlciAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gICAqICAgICAnU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gICAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gICAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAgICogICAgIERlZmF1bHRzIHRvICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gICAqXG4gICAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gICAqL1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5vcmlnaW5hbFBvc2l0aW9uRm9yID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgICBnZW5lcmF0ZWRMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgICB9O1xuXG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhcbiAgICAgICAgbmVlZGxlLFxuICAgICAgICB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncyxcbiAgICAgICAgXCJnZW5lcmF0ZWRMaW5lXCIsXG4gICAgICAgIFwiZ2VuZXJhdGVkQ29sdW1uXCIsXG4gICAgICAgIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQsXG4gICAgICAgIHV0aWwuZ2V0QXJnKGFBcmdzLCAnYmlhcycsIFNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EKVxuICAgICAgKTtcblxuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcobWFwcGluZywgJ3NvdXJjZScsIG51bGwpO1xuICAgICAgICAgIGlmIChzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuYXQoc291cmNlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBzb3VyY2UgPSB1dGlsLmpvaW4odGhpcy5zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbmFtZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICduYW1lJywgbnVsbCk7XG4gICAgICAgICAgaWYgKG5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG5hbWUgPSB0aGlzLl9uYW1lcy5hdChuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsTGluZScsIG51bGwpLFxuICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICBuYW1lOiBudWxsXG4gICAgICB9O1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIHdlIGhhdmUgdGhlIHNvdXJjZSBjb250ZW50IGZvciBldmVyeSBzb3VyY2UgaW4gdGhlIHNvdXJjZVxuICAgKiBtYXAsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgICBmdW5jdGlvbiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCkge1xuICAgICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50Lmxlbmd0aCA+PSB0aGlzLl9zb3VyY2VzLnNpemUoKSAmJlxuICAgICAgICAhdGhpcy5zb3VyY2VzQ29udGVudC5zb21lKGZ1bmN0aW9uIChzYykgeyByZXR1cm4gc2MgPT0gbnVsbDsgfSk7XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlIGNvbnRlbnQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIHRoZSB1cmwgb2YgdGhlXG4gICAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAgICogYXZhaWxpYmxlLlxuICAgKi9cbiAgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvciA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlLCBudWxsT25NaXNzaW5nKSB7XG4gICAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBhU291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIGFTb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fc291cmNlcy5oYXMoYVNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGFTb3VyY2UpXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHVybDtcbiAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbFxuICAgICAgICAgICYmICh1cmwgPSB1dGlsLnVybFBhcnNlKHRoaXMuc291cmNlUm9vdCkpKSB7XG4gICAgICAgIC8vIFhYWDogZmlsZTovLyBVUklzIGFuZCBhYnNvbHV0ZSBwYXRocyBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IgZm9yXG4gICAgICAgIC8vIG1hbnkgdXNlcnMuIFdlIGNhbiBoZWxwIHRoZW0gb3V0IHdoZW4gdGhleSBleHBlY3QgZmlsZTovLyBVUklzIHRvXG4gICAgICAgIC8vIGJlaGF2ZSBsaWtlIGl0IHdvdWxkIGlmIHRoZXkgd2VyZSBydW5uaW5nIGEgbG9jYWwgSFRUUCBzZXJ2ZXIuIFNlZVxuICAgICAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04ODU1OTcuXG4gICAgICAgIHZhciBmaWxlVXJpQWJzUGF0aCA9IGFTb3VyY2UucmVwbGFjZSgvXmZpbGU6XFwvXFwvLywgXCJcIik7XG4gICAgICAgIGlmICh1cmwuc2NoZW1lID09IFwiZmlsZVwiXG4gICAgICAgICAgICAmJiB0aGlzLl9zb3VyY2VzLmhhcyhmaWxlVXJpQWJzUGF0aCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoZmlsZVVyaUFic1BhdGgpXVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCghdXJsLnBhdGggfHwgdXJsLnBhdGggPT0gXCIvXCIpXG4gICAgICAgICAgICAmJiB0aGlzLl9zb3VyY2VzLmhhcyhcIi9cIiArIGFTb3VyY2UpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKFwiL1wiICsgYVNvdXJjZSldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCByZWN1cnNpdmVseSBmcm9tXG4gICAgICAvLyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IuIEluIHRoYXQgY2FzZSwgd2VcbiAgICAgIC8vIGRvbid0IHdhbnQgdG8gdGhyb3cgaWYgd2UgY2FuJ3QgZmluZCB0aGUgc291cmNlIC0gd2UganVzdCB3YW50IHRvXG4gICAgICAvLyByZXR1cm4gbnVsbCwgc28gd2UgcHJvdmlkZSBhIGZsYWcgdG8gZXhpdCBncmFjZWZ1bGx5LlxuICAgICAgaWYgKG51bGxPbk1pc3NpbmcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU291cmNlICsgJ1wiIGlzIG5vdCBpbiB0aGUgU291cmNlTWFwLicpO1xuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gICAqIGxpbmUsIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aFxuICAgKiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgLSBiaWFzOiBFaXRoZXIgJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICAgKiAgICAgJ1NvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICAgKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICAgKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gICAqICAgICBEZWZhdWx0cyB0byAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICAgKlxuICAgKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAgICovXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncykge1xuICAgICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyk7XG4gICAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgICBsYXN0Q29sdW1uOiBudWxsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcblxuICAgICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIG9yaWdpbmFsTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICAgIG9yaWdpbmFsQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgICB9O1xuXG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhcbiAgICAgICAgbmVlZGxlLFxuICAgICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgICBcIm9yaWdpbmFsQ29sdW1uXCIsXG4gICAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMsXG4gICAgICAgIHV0aWwuZ2V0QXJnKGFBcmdzLCAnYmlhcycsIFNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EKVxuICAgICAgKTtcblxuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgICBpZiAobWFwcGluZy5zb3VyY2UgPT09IG5lZWRsZS5zb3VyY2UpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICBsYXN0Q29sdW1uOiBudWxsXG4gICAgICB9O1xuICAgIH07XG5cbiAgZXhwb3J0cy5CYXNpY1NvdXJjZU1hcENvbnN1bWVyID0gQmFzaWNTb3VyY2VNYXBDb25zdW1lcjtcblxuICAvKipcbiAgICogQW4gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaFxuICAgKiB3ZSBjYW4gcXVlcnkgZm9yIGluZm9ybWF0aW9uLiBJdCBkaWZmZXJzIGZyb20gQmFzaWNTb3VyY2VNYXBDb25zdW1lciBpblxuICAgKiB0aGF0IGl0IHRha2VzIFwiaW5kZXhlZFwiIHNvdXJjZSBtYXBzIChpLmUuIG9uZXMgd2l0aCBhIFwic2VjdGlvbnNcIiBmaWVsZCkgYXNcbiAgICogaW5wdXQuXG4gICAqXG4gICAqIFRoZSBvbmx5IHBhcmFtZXRlciBpcyBhIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3IgYWxyZWFkeVxuICAgKiBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjIGZvciBpbmRleGVkIHNvdXJjZSBtYXBzLCB0aGV5XG4gICAqIGhhdmUgdGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICAgKlxuICAgKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy5cbiAgICogICAtIGZpbGU6IE9wdGlvbmFsLiBUaGUgZ2VuZXJhdGVkIGZpbGUgdGhpcyBzb3VyY2UgbWFwIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICogICAtIHNlY3Rpb25zOiBBIGxpc3Qgb2Ygc2VjdGlvbiBkZWZpbml0aW9ucy5cbiAgICpcbiAgICogRWFjaCB2YWx1ZSB1bmRlciB0aGUgXCJzZWN0aW9uc1wiIGZpZWxkIGhhcyB0d28gZmllbGRzOlxuICAgKiAgIC0gb2Zmc2V0OiBUaGUgb2Zmc2V0IGludG8gdGhlIG9yaWdpbmFsIHNwZWNpZmllZCBhdCB3aGljaCB0aGlzIHNlY3Rpb25cbiAgICogICAgICAgYmVnaW5zIHRvIGFwcGx5LCBkZWZpbmVkIGFzIGFuIG9iamVjdCB3aXRoIGEgXCJsaW5lXCIgYW5kIFwiY29sdW1uXCJcbiAgICogICAgICAgZmllbGQuXG4gICAqICAgLSBtYXA6IEEgc291cmNlIG1hcCBkZWZpbml0aW9uLiBUaGlzIHNvdXJjZSBtYXAgY291bGQgYWxzbyBiZSBpbmRleGVkLFxuICAgKiAgICAgICBidXQgZG9lc24ndCBoYXZlIHRvIGJlLlxuICAgKlxuICAgKiBJbnN0ZWFkIG9mIHRoZSBcIm1hcFwiIGZpZWxkLCBpdCdzIGFsc28gcG9zc2libGUgdG8gaGF2ZSBhIFwidXJsXCIgZmllbGRcbiAgICogc3BlY2lmeWluZyBhIFVSTCB0byByZXRyaWV2ZSBhIHNvdXJjZSBtYXAgZnJvbSwgYnV0IHRoYXQncyBjdXJyZW50bHlcbiAgICogdW5zdXBwb3J0ZWQuXG4gICAqXG4gICAqIEhlcmUncyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXSwgYnV0XG4gICAqIG1vZGlmaWVkIHRvIG9taXQgYSBzZWN0aW9uIHdoaWNoIHVzZXMgdGhlIFwidXJsXCIgZmllbGQuXG4gICAqXG4gICAqICB7XG4gICAqICAgIHZlcnNpb24gOiAzLFxuICAgKiAgICBmaWxlOiBcImFwcC5qc1wiLFxuICAgKiAgICBzZWN0aW9uczogW3tcbiAgICogICAgICBvZmZzZXQ6IHtsaW5lOjEwMCwgY29sdW1uOjEwfSxcbiAgICogICAgICBtYXA6IHtcbiAgICogICAgICAgIHZlcnNpb24gOiAzLFxuICAgKiAgICAgICAgZmlsZTogXCJzZWN0aW9uLmpzXCIsXG4gICAqICAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gICAqICAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAgICogICAgICAgIG1hcHBpbmdzOiBcIkFBQUEsRTs7QUJDREU7XCJcbiAgICogICAgICB9XG4gICAqICAgIH1dLFxuICAgKiAgfVxuICAgKlxuICAgKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdCNoZWFkaW5nPWguNTM1ZXMzeGVwcmd0XG4gICAqL1xuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCkge1xuICAgIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICAgIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNvdXJjZU1hcCA9IEpTT04ucGFyc2UoYVNvdXJjZU1hcC5yZXBsYWNlKC9eXFwpXFxdXFx9Jy8sICcnKSk7XG4gICAgfVxuXG4gICAgdmFyIHZlcnNpb24gPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICd2ZXJzaW9uJyk7XG4gICAgdmFyIHNlY3Rpb25zID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc2VjdGlvbnMnKTtcblxuICAgIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdmVyc2lvbjogJyArIHZlcnNpb24pO1xuICAgIH1cblxuICAgIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICB0aGlzLl9uYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuXG4gICAgdmFyIGxhc3RPZmZzZXQgPSB7XG4gICAgICBsaW5lOiAtMSxcbiAgICAgIGNvbHVtbjogMFxuICAgIH07XG4gICAgdGhpcy5fc2VjdGlvbnMgPSBzZWN0aW9ucy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgIGlmIChzLnVybCkge1xuICAgICAgICAvLyBUaGUgdXJsIGZpZWxkIHdpbGwgcmVxdWlyZSBzdXBwb3J0IGZvciBhc3luY2hyb25pY2l0eS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzE2XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcG9ydCBmb3IgdXJsIGZpZWxkIGluIHNlY3Rpb25zIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBvZmZzZXQgPSB1dGlsLmdldEFyZyhzLCAnb2Zmc2V0Jyk7XG4gICAgICB2YXIgb2Zmc2V0TGluZSA9IHV0aWwuZ2V0QXJnKG9mZnNldCwgJ2xpbmUnKTtcbiAgICAgIHZhciBvZmZzZXRDb2x1bW4gPSB1dGlsLmdldEFyZyhvZmZzZXQsICdjb2x1bW4nKTtcblxuICAgICAgaWYgKG9mZnNldExpbmUgPCBsYXN0T2Zmc2V0LmxpbmUgfHxcbiAgICAgICAgICAob2Zmc2V0TGluZSA9PT0gbGFzdE9mZnNldC5saW5lICYmIG9mZnNldENvbHVtbiA8IGxhc3RPZmZzZXQuY29sdW1uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3Rpb24gb2Zmc2V0cyBtdXN0IGJlIG9yZGVyZWQgYW5kIG5vbi1vdmVybGFwcGluZy4nKTtcbiAgICAgIH1cbiAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGdlbmVyYXRlZE9mZnNldDoge1xuICAgICAgICAgIC8vIFRoZSBvZmZzZXQgZmllbGRzIGFyZSAwLWJhc2VkLCBidXQgd2UgdXNlIDEtYmFzZWQgaW5kaWNlcyB3aGVuXG4gICAgICAgICAgLy8gZW5jb2RpbmcvZGVjb2RpbmcgZnJvbSBWTFEuXG4gICAgICAgICAgZ2VuZXJhdGVkTGluZTogb2Zmc2V0TGluZSArIDEsXG4gICAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBvZmZzZXRDb2x1bW4gKyAxXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnN1bWVyOiBuZXcgU291cmNlTWFwQ29uc3VtZXIodXRpbC5nZXRBcmcocywgJ21hcCcpKVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcbiAgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gICAqL1xuICBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2Ygb3JpZ2luYWwgc291cmNlcy5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnc291cmNlcycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5fc2VjdGlvbnNbaV0uY29uc3VtZXIuc291cmNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHNvdXJjZXMucHVzaCh0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzW2pdKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBzb3VyY2VzO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICAgKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICAgKlxuICAgKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAgICogICAtIG5hbWU6IFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLCBvciBudWxsLlxuICAgKi9cbiAgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5vcmlnaW5hbFBvc2l0aW9uRm9yID1cbiAgICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgICAgfTtcblxuICAgICAgLy8gRmluZCB0aGUgc2VjdGlvbiBjb250YWluaW5nIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24gd2UncmUgdHJ5aW5nIHRvIG1hcFxuICAgICAgLy8gdG8gYW4gb3JpZ2luYWwgcG9zaXRpb24uXG4gICAgICB2YXIgc2VjdGlvbkluZGV4ID0gYmluYXJ5U2VhcmNoLnNlYXJjaChuZWVkbGUsIHRoaXMuX3NlY3Rpb25zLFxuICAgICAgICBmdW5jdGlvbihuZWVkbGUsIHNlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgY21wID0gbmVlZGxlLmdlbmVyYXRlZExpbmUgLSBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lO1xuICAgICAgICAgIGlmIChjbXApIHtcbiAgICAgICAgICAgIHJldHVybiBjbXA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIChuZWVkbGUuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgIHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgIH0pO1xuICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tzZWN0aW9uSW5kZXhdO1xuXG4gICAgICBpZiAoIXNlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgICAgbmFtZTogbnVsbFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VjdGlvbi5jb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgICAgbGluZTogbmVlZGxlLmdlbmVyYXRlZExpbmUgLVxuICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgIGNvbHVtbjogbmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IG5lZWRsZS5nZW5lcmF0ZWRMaW5lXG4gICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICA6IDApLFxuICAgICAgICBiaWFzOiBhQXJncy5iaWFzXG4gICAgICB9KTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAgICogbWFwLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VjdGlvbnMuZXZlcnkoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHMuY29uc3VtZXIuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZVxuICAgKiBvcmlnaW5hbCBzb3VyY2UgZmlsZS4gUmV0dXJucyBudWxsIGlmIG5vIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50IGlzXG4gICAqIGF2YWlsYWJsZS5cbiAgICovXG4gIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvciA9XG4gICAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgbnVsbE9uTWlzc2luZykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuXG4gICAgICAgIHZhciBjb250ZW50ID0gc2VjdGlvbi5jb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIHRydWUpO1xuICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobnVsbE9uTWlzc2luZykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAgICogbGluZSwgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoXG4gICAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICpcbiAgICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gICAqL1xuICBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcblxuICAgICAgICAvLyBPbmx5IGNvbnNpZGVyIHRoaXMgc2VjdGlvbiBpZiB0aGUgcmVxdWVzdGVkIHNvdXJjZSBpcyBpbiB0aGUgbGlzdCBvZlxuICAgICAgICAvLyBzb3VyY2VzIG9mIHRoZSBjb25zdW1lci5cbiAgICAgICAgaWYgKHNlY3Rpb24uY29uc3VtZXIuc291cmNlcy5pbmRleE9mKHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJykpID09PSAtMSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBnZW5lcmF0ZWRQb3NpdGlvbiA9IHNlY3Rpb24uY29uc3VtZXIuZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpO1xuICAgICAgICBpZiAoZ2VuZXJhdGVkUG9zaXRpb24pIHtcbiAgICAgICAgICB2YXIgcmV0ID0ge1xuICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkUG9zaXRpb24ubGluZSArXG4gICAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZFBvc2l0aW9uLmNvbHVtbiArXG4gICAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBnZW5lcmF0ZWRQb3NpdGlvbi5saW5lXG4gICAgICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgICAgIDogMClcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsXG4gICAgICB9O1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAgICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gICAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gICAqL1xuICBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuICAgICAgICB2YXIgc2VjdGlvbk1hcHBpbmdzID0gc2VjdGlvbi5jb25zdW1lci5fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VjdGlvbk1hcHBpbmdzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIG1hcHBpbmcgPSBzZWN0aW9uTWFwcGluZ3NbaV07XG5cbiAgICAgICAgICB2YXIgc291cmNlID0gc2VjdGlvbi5jb25zdW1lci5fc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgICAgaWYgKHNlY3Rpb24uY29uc3VtZXIuc291cmNlUm9vdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc291cmNlID0gdXRpbC5qb2luKHNlY3Rpb24uY29uc3VtZXIuc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgICAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcblxuICAgICAgICAgIHZhciBuYW1lID0gc2VjdGlvbi5jb25zdW1lci5fbmFtZXMuYXQobWFwcGluZy5uYW1lKTtcbiAgICAgICAgICB0aGlzLl9uYW1lcy5hZGQobmFtZSk7XG4gICAgICAgICAgbmFtZSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG5cbiAgICAgICAgICAvLyBUaGUgbWFwcGluZ3MgY29taW5nIGZyb20gdGhlIGNvbnN1bWVyIGZvciB0aGUgc2VjdGlvbiBoYXZlXG4gICAgICAgICAgLy8gZ2VuZXJhdGVkIHBvc2l0aW9ucyByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIHNlY3Rpb24sIHNvIHdlXG4gICAgICAgICAgLy8gbmVlZCB0byBvZmZzZXQgdGhlbSB0byBiZSByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbmNhdGVuYXRlZFxuICAgICAgICAgIC8vIGdlbmVyYXRlZCBmaWxlLlxuICAgICAgICAgIHZhciBhZGp1c3RlZE1hcHBpbmcgPSB7XG4gICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgIGdlbmVyYXRlZExpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSArXG4gICAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuY29sdW1uICtcbiAgICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSlcbiAgICAgICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICAgICAgIDogMCxcbiAgICAgICAgICAgIG9yaWdpbmFsTGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgICBvcmlnaW5hbENvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLnB1c2goYWRqdXN0ZWRNYXBwaW5nKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGFkanVzdGVkTWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncy5wdXNoKGFkanVzdGVkTWFwcGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgcXVpY2tTb3J0KHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCk7XG4gICAgICBxdWlja1NvcnQodGhpcy5fX29yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICAgIH07XG5cbiAgZXhwb3J0cy5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIgPSBJbmRleGVkU291cmNlTWFwQ29uc3VtZXI7XG5cbn0pO1xuXG59LHtcIi4vYXJyYXktc2V0XCI6NDcsXCIuL2Jhc2U2NC12bHFcIjo0OCxcIi4vYmluYXJ5LXNlYXJjaFwiOjUwLFwiLi9xdWljay1zb3J0XCI6NTIsXCIuL3V0aWxcIjo1NixcImFtZGVmaW5lXCI6MX1dLDU0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgdmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuICB2YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xuICB2YXIgTWFwcGluZ0xpc3QgPSByZXF1aXJlKCcuL21hcHBpbmctbGlzdCcpLk1hcHBpbmdMaXN0O1xuXG4gIC8qKlxuICAgKiBBbiBpbnN0YW5jZSBvZiB0aGUgU291cmNlTWFwR2VuZXJhdG9yIHJlcHJlc2VudHMgYSBzb3VyY2UgbWFwIHdoaWNoIGlzXG4gICAqIGJlaW5nIGJ1aWx0IGluY3JlbWVudGFsbHkuIFlvdSBtYXkgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAqIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBmaWxlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqICAgLSBzb3VyY2VSb290OiBBIHJvb3QgZm9yIGFsbCByZWxhdGl2ZSBVUkxzIGluIHRoaXMgc291cmNlIG1hcC5cbiAgICovXG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncykge1xuICAgIGlmICghYUFyZ3MpIHtcbiAgICAgIGFBcmdzID0ge307XG4gICAgfVxuICAgIHRoaXMuX2ZpbGUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2ZpbGUnLCBudWxsKTtcbiAgICB0aGlzLl9zb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2VSb290JywgbnVsbCk7XG4gICAgdGhpcy5fc2tpcFZhbGlkYXRpb24gPSB1dGlsLmdldEFyZyhhQXJncywgJ3NraXBWYWxpZGF0aW9uJywgZmFsc2UpO1xuICAgIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICB0aGlzLl9uYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuICAgIHRoaXMuX21hcHBpbmdzID0gbmV3IE1hcHBpbmdMaXN0KCk7XG4gICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbiAgfVxuXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFNvdXJjZU1hcEdlbmVyYXRvciBiYXNlZCBvbiBhIFNvdXJjZU1hcENvbnN1bWVyXG4gICAqXG4gICAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcC5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5mcm9tU291cmNlTWFwID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZnJvbVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIpIHtcbiAgICAgIHZhciBzb3VyY2VSb290ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZVJvb3Q7XG4gICAgICB2YXIgZ2VuZXJhdG9yID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcih7XG4gICAgICAgIGZpbGU6IGFTb3VyY2VNYXBDb25zdW1lci5maWxlLFxuICAgICAgICBzb3VyY2VSb290OiBzb3VyY2VSb290XG4gICAgICB9KTtcbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgICB2YXIgbmV3TWFwcGluZyA9IHtcbiAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgIGxpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG5ld01hcHBpbmcuc291cmNlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBuZXdNYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV3TWFwcGluZy5vcmlnaW5hbCA9IHtcbiAgICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChtYXBwaW5nLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbmV3TWFwcGluZy5uYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdlbmVyYXRvci5hZGRNYXBwaW5nKG5ld01hcHBpbmcpO1xuICAgICAgfSk7XG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgICBnZW5lcmF0b3Iuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIHNpbmdsZSBtYXBwaW5nIGZyb20gb3JpZ2luYWwgc291cmNlIGxpbmUgYW5kIGNvbHVtbiB0byB0aGUgZ2VuZXJhdGVkXG4gICAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBmb3IgdGhpcyBzb3VyY2UgbWFwIGJlaW5nIGNyZWF0ZWQuIFRoZSBtYXBwaW5nXG4gICAqIG9iamVjdCBzaG91bGQgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBnZW5lcmF0ZWQ6IEFuIG9iamVjdCB3aXRoIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAgICogICAtIG9yaWdpbmFsOiBBbiBvYmplY3Qgd2l0aCB0aGUgb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAgICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIChyZWxhdGl2ZSB0byB0aGUgc291cmNlUm9vdCkuXG4gICAqICAgLSBuYW1lOiBBbiBvcHRpb25hbCBvcmlnaW5hbCB0b2tlbiBuYW1lIGZvciB0aGlzIG1hcHBpbmcuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFkZE1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hZGRNYXBwaW5nKGFBcmdzKSB7XG4gICAgICB2YXIgZ2VuZXJhdGVkID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdnZW5lcmF0ZWQnKTtcbiAgICAgIHZhciBvcmlnaW5hbCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnb3JpZ2luYWwnLCBudWxsKTtcbiAgICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScsIG51bGwpO1xuICAgICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhhQXJncywgJ25hbWUnLCBudWxsKTtcblxuICAgICAgaWYgKCF0aGlzLl9za2lwVmFsaWRhdGlvbikge1xuICAgICAgICB0aGlzLl92YWxpZGF0ZU1hcHBpbmcoZ2VuZXJhdGVkLCBvcmlnaW5hbCwgc291cmNlLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNvdXJjZSAhPSBudWxsICYmICF0aGlzLl9zb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuYW1lICE9IG51bGwgJiYgIXRoaXMuX25hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICB0aGlzLl9uYW1lcy5hZGQobmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX21hcHBpbmdzLmFkZCh7XG4gICAgICAgIGdlbmVyYXRlZExpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IGdlbmVyYXRlZC5jb2x1bW4sXG4gICAgICAgIG9yaWdpbmFsTGluZTogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5saW5lLFxuICAgICAgICBvcmlnaW5hbENvbHVtbjogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5jb2x1bW4sXG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICBuYW1lOiBuYW1lXG4gICAgICB9KTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNvdXJjZSBjb250ZW50IGZvciBhIHNvdXJjZSBmaWxlLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3Jfc2V0U291cmNlQ29udGVudChhU291cmNlRmlsZSwgYVNvdXJjZUNvbnRlbnQpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhU291cmNlRmlsZTtcbiAgICAgIGlmICh0aGlzLl9zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLl9zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYVNvdXJjZUNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAvLyBBZGQgdGhlIHNvdXJjZSBjb250ZW50IHRvIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IF9zb3VyY2VzQ29udGVudHMgbWFwIGlmIHRoZSBwcm9wZXJ0eSBpcyBudWxsLlxuICAgICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICAvLyBSZW1vdmUgdGhlIHNvdXJjZSBmaWxlIGZyb20gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgICAvLyBJZiB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAgaXMgZW1wdHksIHNldCB0aGUgcHJvcGVydHkgdG8gbnVsbC5cbiAgICAgICAgZGVsZXRlIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fc291cmNlc0NvbnRlbnRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgbWFwcGluZ3Mgb2YgYSBzdWItc291cmNlLW1hcCBmb3IgYSBzcGVjaWZpYyBzb3VyY2UgZmlsZSB0byB0aGVcbiAgICogc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQuIEVhY2ggbWFwcGluZyB0byB0aGUgc3VwcGxpZWQgc291cmNlIGZpbGUgaXNcbiAgICogcmV3cml0dGVuIHVzaW5nIHRoZSBzdXBwbGllZCBzb3VyY2UgbWFwLiBOb3RlOiBUaGUgcmVzb2x1dGlvbiBmb3IgdGhlXG4gICAqIHJlc3VsdGluZyBtYXBwaW5ncyBpcyB0aGUgbWluaW1pdW0gb2YgdGhpcyBtYXAgYW5kIHRoZSBzdXBwbGllZCBtYXAuXG4gICAqXG4gICAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZC5cbiAgICogQHBhcmFtIGFTb3VyY2VGaWxlIE9wdGlvbmFsLiBUaGUgZmlsZW5hbWUgb2YgdGhlIHNvdXJjZSBmaWxlLlxuICAgKiAgICAgICAgSWYgb21pdHRlZCwgU291cmNlTWFwQ29uc3VtZXIncyBmaWxlIHByb3BlcnR5IHdpbGwgYmUgdXNlZC5cbiAgICogQHBhcmFtIGFTb3VyY2VNYXBQYXRoIE9wdGlvbmFsLiBUaGUgZGlybmFtZSBvZiB0aGUgcGF0aCB0byB0aGUgc291cmNlIG1hcFxuICAgKiAgICAgICAgdG8gYmUgYXBwbGllZC4gSWYgcmVsYXRpdmUsIGl0IGlzIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBDb25zdW1lci5cbiAgICogICAgICAgIFRoaXMgcGFyYW1ldGVyIGlzIG5lZWRlZCB3aGVuIHRoZSB0d28gc291cmNlIG1hcHMgYXJlbid0IGluIHRoZSBzYW1lXG4gICAqICAgICAgICBkaXJlY3RvcnksIGFuZCB0aGUgc291cmNlIG1hcCB0byBiZSBhcHBsaWVkIGNvbnRhaW5zIHJlbGF0aXZlIHNvdXJjZVxuICAgKiAgICAgICAgcGF0aHMuIElmIHNvLCB0aG9zZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbmVlZCB0byBiZSByZXdyaXR0ZW5cbiAgICogICAgICAgIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYXBwbHlTb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyLCBhU291cmNlRmlsZSwgYVNvdXJjZU1hcFBhdGgpIHtcbiAgICAgIHZhciBzb3VyY2VGaWxlID0gYVNvdXJjZUZpbGU7XG4gICAgICAvLyBJZiBhU291cmNlRmlsZSBpcyBvbWl0dGVkLCB3ZSB3aWxsIHVzZSB0aGUgZmlsZSBwcm9wZXJ0eSBvZiB0aGUgU291cmNlTWFwXG4gICAgICBpZiAoYVNvdXJjZUZpbGUgPT0gbnVsbCkge1xuICAgICAgICBpZiAoYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwIHJlcXVpcmVzIGVpdGhlciBhbiBleHBsaWNpdCBzb3VyY2UgZmlsZSwgJyArXG4gICAgICAgICAgICAnb3IgdGhlIHNvdXJjZSBtYXBcXCdzIFwiZmlsZVwiIHByb3BlcnR5LiBCb3RoIHdlcmUgb21pdHRlZC4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2VGaWxlID0gYVNvdXJjZU1hcENvbnN1bWVyLmZpbGU7XG4gICAgICB9XG4gICAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgICAvLyBNYWtlIFwic291cmNlRmlsZVwiIHJlbGF0aXZlIGlmIGFuIGFic29sdXRlIFVybCBpcyBwYXNzZWQuXG4gICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgICAgfVxuICAgICAgLy8gQXBwbHlpbmcgdGhlIFNvdXJjZU1hcCBjYW4gYWRkIGFuZCByZW1vdmUgaXRlbXMgZnJvbSB0aGUgc291cmNlcyBhbmRcbiAgICAgIC8vIHRoZSBuYW1lcyBhcnJheS5cbiAgICAgIHZhciBuZXdTb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gICAgICB2YXIgbmV3TmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcblxuICAgICAgLy8gRmluZCBtYXBwaW5ncyBmb3IgdGhlIFwic291cmNlRmlsZVwiXG4gICAgICB0aGlzLl9tYXBwaW5ncy51bnNvcnRlZEZvckVhY2goZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBzb3VyY2VGaWxlICYmIG1hcHBpbmcub3JpZ2luYWxMaW5lICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBDaGVjayBpZiBpdCBjYW4gYmUgbWFwcGVkIGJ5IHRoZSBzb3VyY2UgbWFwLCB0aGVuIHVwZGF0ZSB0aGUgbWFwcGluZy5cbiAgICAgICAgICB2YXIgb3JpZ2luYWwgPSBhU291cmNlTWFwQ29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ29weSBtYXBwaW5nXG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IG9yaWdpbmFsLnNvdXJjZTtcbiAgICAgICAgICAgIGlmIChhU291cmNlTWFwUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5qb2luKGFTb3VyY2VNYXBQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICAgICAgICBpZiAob3JpZ2luYWwubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IG9yaWdpbmFsLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgIW5ld1NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgICBuZXdTb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICAgIGlmIChuYW1lICE9IG51bGwgJiYgIW5ld05hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICAgIG5ld05hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHRoaXMuX3NvdXJjZXMgPSBuZXdTb3VyY2VzO1xuICAgICAgdGhpcy5fbmFtZXMgPSBuZXdOYW1lcztcblxuICAgICAgLy8gQ29weSBzb3VyY2VzQ29udGVudHMgb2YgYXBwbGllZCBtYXAuXG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhU291cmNlTWFwUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEEgbWFwcGluZyBjYW4gaGF2ZSBvbmUgb2YgdGhlIHRocmVlIGxldmVscyBvZiBkYXRhOlxuICAgKlxuICAgKiAgIDEuIEp1c3QgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbi5cbiAgICogICAyLiBUaGUgR2VuZXJhdGVkIHBvc2l0aW9uLCBvcmlnaW5hbCBwb3NpdGlvbiwgYW5kIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAzLiBHZW5lcmF0ZWQgYW5kIG9yaWdpbmFsIHBvc2l0aW9uLCBvcmlnaW5hbCBzb3VyY2UsIGFzIHdlbGwgYXMgYSBuYW1lXG4gICAqICAgICAgdG9rZW4uXG4gICAqXG4gICAqIFRvIG1haW50YWluIGNvbnNpc3RlbmN5LCB3ZSB2YWxpZGF0ZSB0aGF0IGFueSBuZXcgbWFwcGluZyBiZWluZyBhZGRlZCBmYWxsc1xuICAgKiBpbiB0byBvbmUgb2YgdGhlc2UgY2F0ZWdvcmllcy5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZhbGlkYXRlTWFwcGluZyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3ZhbGlkYXRlTWFwcGluZyhhR2VuZXJhdGVkLCBhT3JpZ2luYWwsIGFTb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhTmFtZSkge1xuICAgICAgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAgICYmICFhT3JpZ2luYWwgJiYgIWFTb3VyY2UgJiYgIWFOYW1lKSB7XG4gICAgICAgIC8vIENhc2UgMS5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYUdlbmVyYXRlZCAmJiAnbGluZScgaW4gYUdlbmVyYXRlZCAmJiAnY29sdW1uJyBpbiBhR2VuZXJhdGVkXG4gICAgICAgICAgICAgICAmJiBhT3JpZ2luYWwgJiYgJ2xpbmUnIGluIGFPcmlnaW5hbCAmJiAnY29sdW1uJyBpbiBhT3JpZ2luYWxcbiAgICAgICAgICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICAgJiYgYU9yaWdpbmFsLmxpbmUgPiAwICYmIGFPcmlnaW5hbC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICAgJiYgYVNvdXJjZSkge1xuICAgICAgICAvLyBDYXNlcyAyIGFuZCAzLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1hcHBpbmc6ICcgKyBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZ2VuZXJhdGVkOiBhR2VuZXJhdGVkLFxuICAgICAgICAgIHNvdXJjZTogYVNvdXJjZSxcbiAgICAgICAgICBvcmlnaW5hbDogYU9yaWdpbmFsLFxuICAgICAgICAgIG5hbWU6IGFOYW1lXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIC8qKlxuICAgKiBTZXJpYWxpemUgdGhlIGFjY3VtdWxhdGVkIG1hcHBpbmdzIGluIHRvIHRoZSBzdHJlYW0gb2YgYmFzZSA2NCBWTFFzXG4gICAqIHNwZWNpZmllZCBieSB0aGUgc291cmNlIG1hcCBmb3JtYXQuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9zZXJpYWxpemVNYXBwaW5ncyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NlcmlhbGl6ZU1hcHBpbmdzKCkge1xuICAgICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZExpbmUgPSAxO1xuICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSAwO1xuICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgIHZhciBtYXBwaW5nO1xuXG4gICAgICB2YXIgbWFwcGluZ3MgPSB0aGlzLl9tYXBwaW5ncy50b0FycmF5KCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWFwcGluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbWFwcGluZyA9IG1hcHBpbmdzW2ldO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgICB3aGlsZSAobWFwcGluZy5nZW5lcmF0ZWRMaW5lICE9PSBwcmV2aW91c0dlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyc7XG4gICAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZExpbmUrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBpZiAoIXV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZywgbWFwcGluZ3NbaSAtIDFdKSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSAnLCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbik7XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZSh0aGlzLl9zb3VyY2VzLmluZGV4T2YobWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c1NvdXJjZSk7XG4gICAgICAgICAgcHJldmlvdXNTb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2YobWFwcGluZy5zb3VyY2UpO1xuXG4gICAgICAgICAgLy8gbGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkIGluIFNvdXJjZU1hcCBzcGVjIHZlcnNpb24gM1xuICAgICAgICAgIHJlc3VsdCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbExpbmUpO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmUgLSAxO1xuXG4gICAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbENvbHVtbik7XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBiYXNlNjRWTFEuZW5jb2RlKHRoaXMuX25hbWVzLmluZGV4T2YobWFwcGluZy5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c05hbWUpO1xuICAgICAgICAgICAgcHJldmlvdXNOYW1lID0gdGhpcy5fbmFtZXMuaW5kZXhPZihtYXBwaW5nLm5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudCA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoYVNvdXJjZXMsIGFTb3VyY2VSb290KSB7XG4gICAgICByZXR1cm4gYVNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYVNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUoYVNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleSA9IHV0aWwudG9TZXRTdHJpbmcoc291cmNlKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9zb3VyY2VzQ29udGVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5KVxuICAgICAgICAgID8gdGhpcy5fc291cmNlc0NvbnRlbnRzW2tleV1cbiAgICAgICAgICA6IG51bGw7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBFeHRlcm5hbGl6ZSB0aGUgc291cmNlIG1hcC5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9KU09OID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9KU09OKCkge1xuICAgICAgdmFyIG1hcCA9IHtcbiAgICAgICAgdmVyc2lvbjogdGhpcy5fdmVyc2lvbixcbiAgICAgICAgc291cmNlczogdGhpcy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICAgIG5hbWVzOiB0aGlzLl9uYW1lcy50b0FycmF5KCksXG4gICAgICAgIG1hcHBpbmdzOiB0aGlzLl9zZXJpYWxpemVNYXBwaW5ncygpXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuX2ZpbGUgIT0gbnVsbCkge1xuICAgICAgICBtYXAuZmlsZSA9IHRoaXMuX2ZpbGU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIG1hcC5zb3VyY2VSb290ID0gdGhpcy5fc291cmNlUm9vdDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgbWFwLnNvdXJjZXNDb250ZW50ID0gdGhpcy5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudChtYXAuc291cmNlcywgbWFwLnNvdXJjZVJvb3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQgdG8gYSBzdHJpbmcuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSk7XG4gICAgfTtcblxuICBleHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IFNvdXJjZU1hcEdlbmVyYXRvcjtcblxufSk7XG5cbn0se1wiLi9hcnJheS1zZXRcIjo0NyxcIi4vYmFzZTY0LXZscVwiOjQ4LFwiLi9tYXBwaW5nLWxpc3RcIjo1MSxcIi4vdXRpbFwiOjU2LFwiYW1kZWZpbmVcIjoxfV0sNTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICB2YXIgU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICAvLyBNYXRjaGVzIGEgV2luZG93cy1zdHlsZSBgXFxyXFxuYCBuZXdsaW5lIG9yIGEgYFxcbmAgbmV3bGluZSB1c2VkIGJ5IGFsbCBvdGhlclxuICAvLyBvcGVyYXRpbmcgc3lzdGVtcyB0aGVzZSBkYXlzIChjYXB0dXJpbmcgdGhlIHJlc3VsdCkuXG4gIHZhciBSRUdFWF9ORVdMSU5FID0gLyhcXHI/XFxuKS87XG5cbiAgLy8gTmV3bGluZSBjaGFyYWN0ZXIgY29kZSBmb3IgY2hhckNvZGVBdCgpIGNvbXBhcmlzb25zXG4gIHZhciBORVdMSU5FX0NPREUgPSAxMDtcblxuICAvLyBQcml2YXRlIHN5bWJvbCBmb3IgaWRlbnRpZnlpbmcgYFNvdXJjZU5vZGVgcyB3aGVuIG11bHRpcGxlIHZlcnNpb25zIG9mXG4gIC8vIHRoZSBzb3VyY2UtbWFwIGxpYnJhcnkgYXJlIGxvYWRlZC4gVGhpcyBNVVNUIE5PVCBDSEFOR0UgYWNyb3NzXG4gIC8vIHZlcnNpb25zIVxuICB2YXIgaXNTb3VyY2VOb2RlID0gXCIkJCRpc1NvdXJjZU5vZGUkJCRcIjtcblxuICAvKipcbiAgICogU291cmNlTm9kZXMgcHJvdmlkZSBhIHdheSB0byBhYnN0cmFjdCBvdmVyIGludGVycG9sYXRpbmcvY29uY2F0ZW5hdGluZ1xuICAgKiBzbmlwcGV0cyBvZiBnZW5lcmF0ZWQgSmF2YVNjcmlwdCBzb3VyY2UgY29kZSB3aGlsZSBtYWludGFpbmluZyB0aGUgbGluZSBhbmRcbiAgICogY29sdW1uIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgb3JpZ2luYWwgc291cmNlIGNvZGUuXG4gICAqXG4gICAqIEBwYXJhbSBhTGluZSBUaGUgb3JpZ2luYWwgbGluZSBudW1iZXIuXG4gICAqIEBwYXJhbSBhQ29sdW1uIFRoZSBvcmlnaW5hbCBjb2x1bW4gbnVtYmVyLlxuICAgKiBAcGFyYW0gYVNvdXJjZSBUaGUgb3JpZ2luYWwgc291cmNlJ3MgZmlsZW5hbWUuXG4gICAqIEBwYXJhbSBhQ2h1bmtzIE9wdGlvbmFsLiBBbiBhcnJheSBvZiBzdHJpbmdzIHdoaWNoIGFyZSBzbmlwcGV0cyBvZlxuICAgKiAgICAgICAgZ2VuZXJhdGVkIEpTLCBvciBvdGhlciBTb3VyY2VOb2Rlcy5cbiAgICogQHBhcmFtIGFOYW1lIFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLlxuICAgKi9cbiAgZnVuY3Rpb24gU291cmNlTm9kZShhTGluZSwgYUNvbHVtbiwgYVNvdXJjZSwgYUNodW5rcywgYU5hbWUpIHtcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdGhpcy5zb3VyY2VDb250ZW50cyA9IHt9O1xuICAgIHRoaXMubGluZSA9IGFMaW5lID09IG51bGwgPyBudWxsIDogYUxpbmU7XG4gICAgdGhpcy5jb2x1bW4gPSBhQ29sdW1uID09IG51bGwgPyBudWxsIDogYUNvbHVtbjtcbiAgICB0aGlzLnNvdXJjZSA9IGFTb3VyY2UgPT0gbnVsbCA/IG51bGwgOiBhU291cmNlO1xuICAgIHRoaXMubmFtZSA9IGFOYW1lID09IG51bGwgPyBudWxsIDogYU5hbWU7XG4gICAgdGhpc1tpc1NvdXJjZU5vZGVdID0gdHJ1ZTtcbiAgICBpZiAoYUNodW5rcyAhPSBudWxsKSB0aGlzLmFkZChhQ2h1bmtzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgU291cmNlTm9kZSBmcm9tIGdlbmVyYXRlZCBjb2RlIGFuZCBhIFNvdXJjZU1hcENvbnN1bWVyLlxuICAgKlxuICAgKiBAcGFyYW0gYUdlbmVyYXRlZENvZGUgVGhlIGdlbmVyYXRlZCBjb2RlXG4gICAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcCBmb3IgdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAqIEBwYXJhbSBhUmVsYXRpdmVQYXRoIE9wdGlvbmFsLiBUaGUgcGF0aCB0aGF0IHJlbGF0aXZlIHNvdXJjZXMgaW4gdGhlXG4gICAqICAgICAgICBTb3VyY2VNYXBDb25zdW1lciBzaG91bGQgYmUgcmVsYXRpdmUgdG8uXG4gICAqL1xuICBTb3VyY2VOb2RlLmZyb21TdHJpbmdXaXRoU291cmNlTWFwID1cbiAgICBmdW5jdGlvbiBTb3VyY2VOb2RlX2Zyb21TdHJpbmdXaXRoU291cmNlTWFwKGFHZW5lcmF0ZWRDb2RlLCBhU291cmNlTWFwQ29uc3VtZXIsIGFSZWxhdGl2ZVBhdGgpIHtcbiAgICAgIC8vIFRoZSBTb3VyY2VOb2RlIHdlIHdhbnQgdG8gZmlsbCB3aXRoIHRoZSBnZW5lcmF0ZWQgY29kZVxuICAgICAgLy8gYW5kIHRoZSBTb3VyY2VNYXBcbiAgICAgIHZhciBub2RlID0gbmV3IFNvdXJjZU5vZGUoKTtcblxuICAgICAgLy8gQWxsIGV2ZW4gaW5kaWNlcyBvZiB0aGlzIGFycmF5IGFyZSBvbmUgbGluZSBvZiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4gICAgICAvLyB3aGlsZSBhbGwgb2RkIGluZGljZXMgYXJlIHRoZSBuZXdsaW5lcyBiZXR3ZWVuIHR3byBhZGphY2VudCBsaW5lc1xuICAgICAgLy8gKHNpbmNlIGBSRUdFWF9ORVdMSU5FYCBjYXB0dXJlcyBpdHMgbWF0Y2gpLlxuICAgICAgLy8gUHJvY2Vzc2VkIGZyYWdtZW50cyBhcmUgcmVtb3ZlZCBmcm9tIHRoaXMgYXJyYXksIGJ5IGNhbGxpbmcgYHNoaWZ0TmV4dExpbmVgLlxuICAgICAgdmFyIHJlbWFpbmluZ0xpbmVzID0gYUdlbmVyYXRlZENvZGUuc3BsaXQoUkVHRVhfTkVXTElORSk7XG4gICAgICB2YXIgc2hpZnROZXh0TGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGluZUNvbnRlbnRzID0gcmVtYWluaW5nTGluZXMuc2hpZnQoKTtcbiAgICAgICAgLy8gVGhlIGxhc3QgbGluZSBvZiBhIGZpbGUgbWlnaHQgbm90IGhhdmUgYSBuZXdsaW5lLlxuICAgICAgICB2YXIgbmV3TGluZSA9IHJlbWFpbmluZ0xpbmVzLnNoaWZ0KCkgfHwgXCJcIjtcbiAgICAgICAgcmV0dXJuIGxpbmVDb250ZW50cyArIG5ld0xpbmU7XG4gICAgICB9O1xuXG4gICAgICAvLyBXZSBuZWVkIHRvIHJlbWVtYmVyIHRoZSBwb3NpdGlvbiBvZiBcInJlbWFpbmluZ0xpbmVzXCJcbiAgICAgIHZhciBsYXN0R2VuZXJhdGVkTGluZSA9IDEsIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuXG4gICAgICAvLyBUaGUgZ2VuZXJhdGUgU291cmNlTm9kZXMgd2UgbmVlZCBhIGNvZGUgcmFuZ2UuXG4gICAgICAvLyBUbyBleHRyYWN0IGl0IGN1cnJlbnQgYW5kIGxhc3QgbWFwcGluZyBpcyB1c2VkLlxuICAgICAgLy8gSGVyZSB3ZSBzdG9yZSB0aGUgbGFzdCBtYXBwaW5nLlxuICAgICAgdmFyIGxhc3RNYXBwaW5nID0gbnVsbDtcblxuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgIGlmIChsYXN0TWFwcGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIGFkZCB0aGUgY29kZSBmcm9tIFwibGFzdE1hcHBpbmdcIiB0byBcIm1hcHBpbmdcIjpcbiAgICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGVyZSBpcyBhIG5ldyBsaW5lIGluIGJldHdlZW4uXG4gICAgICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IFwiXCI7XG4gICAgICAgICAgICAvLyBBc3NvY2lhdGUgZmlyc3QgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICAgICAgbGFzdEdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICAgICAgLy8gVGhlIHJlbWFpbmluZyBjb2RlIGlzIGFkZGVkIHdpdGhvdXQgbWFwcGluZ1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICAgICAgLy8gQXNzb2NpYXRlIHRoZSBjb2RlIGJldHdlZW4gXCJsYXN0R2VuZXJhdGVkQ29sdW1uXCIgYW5kXG4gICAgICAgICAgICAvLyBcIm1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXCIgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzWzBdO1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBuZXh0TGluZS5zdWJzdHIoMCwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgICByZW1haW5pbmdMaW5lc1swXSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgY29kZSk7XG4gICAgICAgICAgICAvLyBObyBtb3JlIHJlbWFpbmluZyBjb2RlLCBjb250aW51ZVxuICAgICAgICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBhZGQgdGhlIGdlbmVyYXRlZCBjb2RlIHVudGlsIHRoZSBmaXJzdCBtYXBwaW5nXG4gICAgICAgIC8vIHRvIHRoZSBTb3VyY2VOb2RlIHdpdGhvdXQgYW55IG1hcHBpbmcuXG4gICAgICAgIC8vIEVhY2ggbGluZSBpcyBhZGRlZCBhcyBzZXBhcmF0ZSBzdHJpbmcuXG4gICAgICAgIHdoaWxlIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIG5vZGUuYWRkKHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdEdlbmVyYXRlZENvbHVtbiA8IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSB7XG4gICAgICAgICAgdmFyIG5leHRMaW5lID0gcmVtYWluaW5nTGluZXNbMF07XG4gICAgICAgICAgbm9kZS5hZGQobmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSk7XG4gICAgICAgICAgcmVtYWluaW5nTGluZXNbMF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICBsYXN0TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIC8vIFdlIGhhdmUgcHJvY2Vzc2VkIGFsbCBtYXBwaW5ncy5cbiAgICAgIGlmIChyZW1haW5pbmdMaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChsYXN0TWFwcGluZykge1xuICAgICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgcmVtYWluaW5nIGNvZGUgaW4gdGhlIGN1cnJlbnQgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbmQgYWRkIHRoZSByZW1haW5pbmcgbGluZXMgd2l0aG91dCBhbnkgbWFwcGluZ1xuICAgICAgICBub2RlLmFkZChyZW1haW5pbmdMaW5lcy5qb2luKFwiXCIpKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ29weSBzb3VyY2VzQ29udGVudCBpbnRvIFNvdXJjZU5vZGVcbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChhUmVsYXRpdmVQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBub2RlO1xuXG4gICAgICBmdW5jdGlvbiBhZGRNYXBwaW5nV2l0aENvZGUobWFwcGluZywgY29kZSkge1xuICAgICAgICBpZiAobWFwcGluZyA9PT0gbnVsbCB8fCBtYXBwaW5nLnNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9kZS5hZGQoY29kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IGFSZWxhdGl2ZVBhdGhcbiAgICAgICAgICAgID8gdXRpbC5qb2luKGFSZWxhdGl2ZVBhdGgsIG1hcHBpbmcuc291cmNlKVxuICAgICAgICAgICAgOiBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgICBub2RlLmFkZChuZXcgU291cmNlTm9kZShtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcubmFtZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoaXMgc291cmNlIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSBhQ2h1bmsgQSBzdHJpbmcgc25pcHBldCBvZiBnZW5lcmF0ZWQgSlMgY29kZSwgYW5vdGhlciBpbnN0YW5jZSBvZlxuICAgKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfYWRkKGFDaHVuaykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFDaHVuaykpIHtcbiAgICAgIGFDaHVuay5mb3JFYWNoKGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICB0aGlzLmFkZChjaHVuayk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKGFDaHVuaykge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goYUNodW5rKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBzb3VyY2Ugbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gICAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcHJlcGVuZChhQ2h1bmspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgICBmb3IgKHZhciBpID0gYUNodW5rLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aGlzLnByZXBlbmQoYUNodW5rW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhpcy5jaGlsZHJlbi51bnNoaWZ0KGFDaHVuayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBKUyBzbmlwcGV0cyBpbiB0aGlzIG5vZGUgYW5kIGl0cyBjaGlsZHJlbi4gVGhlXG4gICAqIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIG9uY2UgZm9yIGVhY2ggc25pcHBldCBvZiBKUyBhbmQgaXMgcGFzc2VkIHRoYXRcbiAgICogc25pcHBldCBhbmQgdGhlIGl0cyBvcmlnaW5hbCBhc3NvY2lhdGVkIHNvdXJjZSdzIGxpbmUvY29sdW1uIGxvY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gU291cmNlTm9kZV93YWxrKGFGbikge1xuICAgIHZhciBjaHVuaztcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2h1bmsgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGNodW5rW2lzU291cmNlTm9kZV0pIHtcbiAgICAgICAgY2h1bmsud2FsayhhRm4pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChjaHVuayAhPT0gJycpIHtcbiAgICAgICAgICBhRm4oY2h1bmssIHsgc291cmNlOiB0aGlzLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIExpa2UgYFN0cmluZy5wcm90b3R5cGUuam9pbmAgZXhjZXB0IGZvciBTb3VyY2VOb2Rlcy4gSW5zZXJ0cyBgYVN0cmAgYmV0d2VlblxuICAgKiBlYWNoIG9mIGB0aGlzLmNoaWxkcmVuYC5cbiAgICpcbiAgICogQHBhcmFtIGFTZXAgVGhlIHNlcGFyYXRvci5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBTb3VyY2VOb2RlX2pvaW4oYVNlcCkge1xuICAgIHZhciBuZXdDaGlsZHJlbjtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgIG5ld0NoaWxkcmVuID0gW107XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuLTE7IGkrKykge1xuICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKGFTZXApO1xuICAgICAgfVxuICAgICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXdDaGlsZHJlbjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGwgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlIG9uIHRoZSB2ZXJ5IHJpZ2h0LW1vc3Qgc291cmNlIHNuaXBwZXQuIFVzZWZ1bFxuICAgKiBmb3IgdHJpbW1pbmcgd2hpdGVzcGFjZSBmcm9tIHRoZSBlbmQgb2YgYSBzb3VyY2Ugbm9kZSwgZXRjLlxuICAgKlxuICAgKiBAcGFyYW0gYVBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gcmVwbGFjZS5cbiAgICogQHBhcmFtIGFSZXBsYWNlbWVudCBUaGUgdGhpbmcgdG8gcmVwbGFjZSB0aGUgcGF0dGVybiB3aXRoLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUucmVwbGFjZVJpZ2h0ID0gZnVuY3Rpb24gU291cmNlTm9kZV9yZXBsYWNlUmlnaHQoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCkge1xuICAgIHZhciBsYXN0Q2hpbGQgPSB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3RDaGlsZFtpc1NvdXJjZU5vZGVdKSB7XG4gICAgICBsYXN0Q2hpbGQucmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbGFzdENoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdID0gbGFzdENoaWxkLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKCcnLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS4gVGhpcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3JcbiAgICogaW4gdGhlIHNvdXJjZXNDb250ZW50IGZpZWxkLlxuICAgKlxuICAgKiBAcGFyYW0gYVNvdXJjZUZpbGUgVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZVxuICAgKiBAcGFyYW0gYVNvdXJjZUNvbnRlbnQgVGhlIGNvbnRlbnQgb2YgdGhlIHNvdXJjZSBmaWxlXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgICBmdW5jdGlvbiBTb3VyY2VOb2RlX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgICB0aGlzLnNvdXJjZUNvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoYVNvdXJjZUZpbGUpXSA9IGFTb3VyY2VDb250ZW50O1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBTb3VyY2VOb2Rlcy4gVGhlIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIGZvciBlYWNoXG4gICAqIHNvdXJjZSBmaWxlIGNvbnRlbnQgYW5kIGlzIHBhc3NlZCB0aGUgZmlsZW5hbWUgYW5kIHNvdXJjZSBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrU291cmNlQ29udGVudHMgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2Fsa1NvdXJjZUNvbnRlbnRzKGFGbikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV1baXNTb3VyY2VOb2RlXSkge1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0ud2Fsa1NvdXJjZUNvbnRlbnRzKGFGbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZXMgPSBPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUNvbnRlbnRzKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGFGbih1dGlsLmZyb21TZXRTdHJpbmcoc291cmNlc1tpXSksIHRoaXMuc291cmNlQ29udGVudHNbc291cmNlc1tpXV0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUuIFdhbGtzIG92ZXIgdGhlIHRyZWVcbiAgICogYW5kIGNvbmNhdGVuYXRlcyBhbGwgdGhlIHZhcmlvdXMgc25pcHBldHMgdG9nZXRoZXIgdG8gb25lIHN0cmluZy5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZygpIHtcbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICB0aGlzLndhbGsoZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICBzdHIgKz0gY2h1bms7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUgYWxvbmcgd2l0aCBhIHNvdXJjZVxuICAgKiBtYXAuXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS50b1N0cmluZ1dpdGhTb3VyY2VNYXAgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nV2l0aFNvdXJjZU1hcChhQXJncykge1xuICAgIHZhciBnZW5lcmF0ZWQgPSB7XG4gICAgICBjb2RlOiBcIlwiLFxuICAgICAgbGluZTogMSxcbiAgICAgIGNvbHVtbjogMFxuICAgIH07XG4gICAgdmFyIG1hcCA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgdmFyIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgdmFyIGxhc3RPcmlnaW5hbExpbmUgPSBudWxsO1xuICAgIHZhciBsYXN0T3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICAgIHZhciBsYXN0T3JpZ2luYWxOYW1lID0gbnVsbDtcbiAgICB0aGlzLndhbGsoZnVuY3Rpb24gKGNodW5rLCBvcmlnaW5hbCkge1xuICAgICAgZ2VuZXJhdGVkLmNvZGUgKz0gY2h1bms7XG4gICAgICBpZiAob3JpZ2luYWwuc291cmNlICE9PSBudWxsXG4gICAgICAgICAgJiYgb3JpZ2luYWwubGluZSAhPT0gbnVsbFxuICAgICAgICAgICYmIG9yaWdpbmFsLmNvbHVtbiAhPT0gbnVsbCkge1xuICAgICAgICBpZihsYXN0T3JpZ2luYWxTb3VyY2UgIT09IG9yaWdpbmFsLnNvdXJjZVxuICAgICAgICAgICB8fCBsYXN0T3JpZ2luYWxMaW5lICE9PSBvcmlnaW5hbC5saW5lXG4gICAgICAgICAgIHx8IGxhc3RPcmlnaW5hbENvbHVtbiAhPT0gb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgIHx8IGxhc3RPcmlnaW5hbE5hbWUgIT09IG9yaWdpbmFsLm5hbWUpIHtcbiAgICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsLnNvdXJjZSxcbiAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgIGxpbmU6IG9yaWdpbmFsLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5uYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgICBsYXN0T3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgICAgbGFzdE9yaWdpbmFsQ29sdW1uID0gb3JpZ2luYWwuY29sdW1uO1xuICAgICAgICBsYXN0T3JpZ2luYWxOYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpZHggPSAwLCBsZW5ndGggPSBjaHVuay5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgaWYgKGNodW5rLmNoYXJDb2RlQXQoaWR4KSA9PT0gTkVXTElORV9DT0RFKSB7XG4gICAgICAgICAgZ2VuZXJhdGVkLmxpbmUrKztcbiAgICAgICAgICBnZW5lcmF0ZWQuY29sdW1uID0gMDtcbiAgICAgICAgICAvLyBNYXBwaW5ncyBlbmQgYXQgZW9sXG4gICAgICAgICAgaWYgKGlkeCArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICAgICAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICAgICAgc291cmNlOiBvcmlnaW5hbC5zb3VyY2UsXG4gICAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbmFtZTogb3JpZ2luYWwubmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdlbmVyYXRlZC5jb2x1bW4rKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMud2Fsa1NvdXJjZUNvbnRlbnRzKGZ1bmN0aW9uIChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KSB7XG4gICAgICBtYXAuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7IGNvZGU6IGdlbmVyYXRlZC5jb2RlLCBtYXA6IG1hcCB9O1xuICB9O1xuXG4gIGV4cG9ydHMuU291cmNlTm9kZSA9IFNvdXJjZU5vZGU7XG5cbn0pO1xuXG59LHtcIi4vc291cmNlLW1hcC1nZW5lcmF0b3JcIjo1NCxcIi4vdXRpbFwiOjU2LFwiYW1kZWZpbmVcIjoxfV0sNTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICAvKipcbiAgICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2V0dGluZyB2YWx1ZXMgZnJvbSBwYXJhbWV0ZXIvb3B0aW9uc1xuICAgKiBvYmplY3RzLlxuICAgKlxuICAgKiBAcGFyYW0gYXJncyBUaGUgb2JqZWN0IHdlIGFyZSBleHRyYWN0aW5nIHZhbHVlcyBmcm9tXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB3ZSBhcmUgZ2V0dGluZy5cbiAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBBbiBvcHRpb25hbCB2YWx1ZSB0byByZXR1cm4gaWYgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmdcbiAgICogZnJvbSB0aGUgb2JqZWN0LiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQgYW5kIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nLCBhblxuICAgKiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICovXG4gIGZ1bmN0aW9uIGdldEFyZyhhQXJncywgYU5hbWUsIGFEZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAoYU5hbWUgaW4gYUFyZ3MpIHtcbiAgICAgIHJldHVybiBhQXJnc1thTmFtZV07XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICByZXR1cm4gYURlZmF1bHRWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhTmFtZSArICdcIiBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LicpO1xuICAgIH1cbiAgfVxuICBleHBvcnRzLmdldEFyZyA9IGdldEFyZztcblxuICB2YXIgdXJsUmVnZXhwID0gL14oPzooW1xcdytcXC0uXSspOik/XFwvXFwvKD86KFxcdys6XFx3KylAKT8oW1xcdy5dKikoPzo6KFxcZCspKT8oXFxTKikkLztcbiAgdmFyIGRhdGFVcmxSZWdleHAgPSAvXmRhdGE6LitcXCwuKyQvO1xuXG4gIGZ1bmN0aW9uIHVybFBhcnNlKGFVcmwpIHtcbiAgICB2YXIgbWF0Y2ggPSBhVXJsLm1hdGNoKHVybFJlZ2V4cCk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzY2hlbWU6IG1hdGNoWzFdLFxuICAgICAgYXV0aDogbWF0Y2hbMl0sXG4gICAgICBob3N0OiBtYXRjaFszXSxcbiAgICAgIHBvcnQ6IG1hdGNoWzRdLFxuICAgICAgcGF0aDogbWF0Y2hbNV1cbiAgICB9O1xuICB9XG4gIGV4cG9ydHMudXJsUGFyc2UgPSB1cmxQYXJzZTtcblxuICBmdW5jdGlvbiB1cmxHZW5lcmF0ZShhUGFyc2VkVXJsKSB7XG4gICAgdmFyIHVybCA9ICcnO1xuICAgIGlmIChhUGFyc2VkVXJsLnNjaGVtZSkge1xuICAgICAgdXJsICs9IGFQYXJzZWRVcmwuc2NoZW1lICsgJzonO1xuICAgIH1cbiAgICB1cmwgKz0gJy8vJztcbiAgICBpZiAoYVBhcnNlZFVybC5hdXRoKSB7XG4gICAgICB1cmwgKz0gYVBhcnNlZFVybC5hdXRoICsgJ0AnO1xuICAgIH1cbiAgICBpZiAoYVBhcnNlZFVybC5ob3N0KSB7XG4gICAgICB1cmwgKz0gYVBhcnNlZFVybC5ob3N0O1xuICAgIH1cbiAgICBpZiAoYVBhcnNlZFVybC5wb3J0KSB7XG4gICAgICB1cmwgKz0gXCI6XCIgKyBhUGFyc2VkVXJsLnBvcnRcbiAgICB9XG4gICAgaWYgKGFQYXJzZWRVcmwucGF0aCkge1xuICAgICAgdXJsICs9IGFQYXJzZWRVcmwucGF0aDtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBleHBvcnRzLnVybEdlbmVyYXRlID0gdXJsR2VuZXJhdGU7XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZXMgYSBwYXRoLCBvciB0aGUgcGF0aCBwb3J0aW9uIG9mIGEgVVJMOlxuICAgKlxuICAgKiAtIFJlcGxhY2VzIGNvbnNlcXV0aXZlIHNsYXNoZXMgd2l0aCBvbmUgc2xhc2guXG4gICAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnLicgcGFydHMuXG4gICAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnPGRpcj4vLi4nIHBhcnRzLlxuICAgKlxuICAgKiBCYXNlZCBvbiBjb2RlIGluIHRoZSBOb2RlLmpzICdwYXRoJyBjb3JlIG1vZHVsZS5cbiAgICpcbiAgICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIHVybCB0byBub3JtYWxpemUuXG4gICAqL1xuICBmdW5jdGlvbiBub3JtYWxpemUoYVBhdGgpIHtcbiAgICB2YXIgcGF0aCA9IGFQYXRoO1xuICAgIHZhciB1cmwgPSB1cmxQYXJzZShhUGF0aCk7XG4gICAgaWYgKHVybCkge1xuICAgICAgaWYgKCF1cmwucGF0aCkge1xuICAgICAgICByZXR1cm4gYVBhdGg7XG4gICAgICB9XG4gICAgICBwYXRoID0gdXJsLnBhdGg7XG4gICAgfVxuICAgIHZhciBpc0Fic29sdXRlID0gKHBhdGguY2hhckF0KDApID09PSAnLycpO1xuXG4gICAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdCgvXFwvKy8pO1xuICAgIGZvciAodmFyIHBhcnQsIHVwID0gMCwgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgICBpZiAocGFydCA9PT0gJy4nKSB7XG4gICAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgICB1cCsrO1xuICAgICAgfSBlbHNlIGlmICh1cCA+IDApIHtcbiAgICAgICAgaWYgKHBhcnQgPT09ICcnKSB7XG4gICAgICAgICAgLy8gVGhlIGZpcnN0IHBhcnQgaXMgYmxhbmsgaWYgdGhlIHBhdGggaXMgYWJzb2x1dGUuIFRyeWluZyB0byBnb1xuICAgICAgICAgIC8vIGFib3ZlIHRoZSByb290IGlzIGEgbm8tb3AuIFRoZXJlZm9yZSB3ZSBjYW4gcmVtb3ZlIGFsbCAnLi4nIHBhcnRzXG4gICAgICAgICAgLy8gZGlyZWN0bHkgYWZ0ZXIgdGhlIHJvb3QuXG4gICAgICAgICAgcGFydHMuc3BsaWNlKGkgKyAxLCB1cCk7XG4gICAgICAgICAgdXAgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnRzLnNwbGljZShpLCAyKTtcbiAgICAgICAgICB1cC0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHBhdGggPSBwYXJ0cy5qb2luKCcvJyk7XG5cbiAgICBpZiAocGF0aCA9PT0gJycpIHtcbiAgICAgIHBhdGggPSBpc0Fic29sdXRlID8gJy8nIDogJy4nO1xuICAgIH1cblxuICAgIGlmICh1cmwpIHtcbiAgICAgIHVybC5wYXRoID0gcGF0aDtcbiAgICAgIHJldHVybiB1cmxHZW5lcmF0ZSh1cmwpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuICBleHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcblxuICAvKipcbiAgICogSm9pbnMgdHdvIHBhdGhzL1VSTHMuXG4gICAqXG4gICAqIEBwYXJhbSBhUm9vdCBUaGUgcm9vdCBwYXRoIG9yIFVSTC5cbiAgICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBqb2luZWQgd2l0aCB0aGUgcm9vdC5cbiAgICpcbiAgICogLSBJZiBhUGF0aCBpcyBhIFVSTCBvciBhIGRhdGEgVVJJLCBhUGF0aCBpcyByZXR1cm5lZCwgdW5sZXNzIGFQYXRoIGlzIGFcbiAgICogICBzY2hlbWUtcmVsYXRpdmUgVVJMOiBUaGVuIHRoZSBzY2hlbWUgb2YgYVJvb3QsIGlmIGFueSwgaXMgcHJlcGVuZGVkXG4gICAqICAgZmlyc3QuXG4gICAqIC0gT3RoZXJ3aXNlIGFQYXRoIGlzIGEgcGF0aC4gSWYgYVJvb3QgaXMgYSBVUkwsIHRoZW4gaXRzIHBhdGggcG9ydGlvblxuICAgKiAgIGlzIHVwZGF0ZWQgd2l0aCB0aGUgcmVzdWx0IGFuZCBhUm9vdCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlIHRoZSByZXN1bHRcbiAgICogICBpcyByZXR1cm5lZC5cbiAgICogICAtIElmIGFQYXRoIGlzIGFic29sdXRlLCB0aGUgcmVzdWx0IGlzIGFQYXRoLlxuICAgKiAgIC0gT3RoZXJ3aXNlIHRoZSB0d28gcGF0aHMgYXJlIGpvaW5lZCB3aXRoIGEgc2xhc2guXG4gICAqIC0gSm9pbmluZyBmb3IgZXhhbXBsZSAnaHR0cDovLycgYW5kICd3d3cuZXhhbXBsZS5jb20nIGlzIGFsc28gc3VwcG9ydGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gam9pbihhUm9vdCwgYVBhdGgpIHtcbiAgICBpZiAoYVJvb3QgPT09IFwiXCIpIHtcbiAgICAgIGFSb290ID0gXCIuXCI7XG4gICAgfVxuICAgIGlmIChhUGF0aCA9PT0gXCJcIikge1xuICAgICAgYVBhdGggPSBcIi5cIjtcbiAgICB9XG4gICAgdmFyIGFQYXRoVXJsID0gdXJsUGFyc2UoYVBhdGgpO1xuICAgIHZhciBhUm9vdFVybCA9IHVybFBhcnNlKGFSb290KTtcbiAgICBpZiAoYVJvb3RVcmwpIHtcbiAgICAgIGFSb290ID0gYVJvb3RVcmwucGF0aCB8fCAnLyc7XG4gICAgfVxuXG4gICAgLy8gYGpvaW4oZm9vLCAnLy93d3cuZXhhbXBsZS5vcmcnKWBcbiAgICBpZiAoYVBhdGhVcmwgJiYgIWFQYXRoVXJsLnNjaGVtZSkge1xuICAgICAgaWYgKGFSb290VXJsKSB7XG4gICAgICAgIGFQYXRoVXJsLnNjaGVtZSA9IGFSb290VXJsLnNjaGVtZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUGF0aFVybCk7XG4gICAgfVxuXG4gICAgaWYgKGFQYXRoVXJsIHx8IGFQYXRoLm1hdGNoKGRhdGFVcmxSZWdleHApKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuXG4gICAgLy8gYGpvaW4oJ2h0dHA6Ly8nLCAnd3d3LmV4YW1wbGUuY29tJylgXG4gICAgaWYgKGFSb290VXJsICYmICFhUm9vdFVybC5ob3N0ICYmICFhUm9vdFVybC5wYXRoKSB7XG4gICAgICBhUm9vdFVybC5ob3N0ID0gYVBhdGg7XG4gICAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICAgIH1cblxuICAgIHZhciBqb2luZWQgPSBhUGF0aC5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgPyBhUGF0aFxuICAgICAgOiBub3JtYWxpemUoYVJvb3QucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyBhUGF0aCk7XG5cbiAgICBpZiAoYVJvb3RVcmwpIHtcbiAgICAgIGFSb290VXJsLnBhdGggPSBqb2luZWQ7XG4gICAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICAgIH1cbiAgICByZXR1cm4gam9pbmVkO1xuICB9XG4gIGV4cG9ydHMuam9pbiA9IGpvaW47XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBwYXRoIHJlbGF0aXZlIHRvIGEgVVJMIG9yIGFub3RoZXIgcGF0aC5cbiAgICpcbiAgICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICAgKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgVVJMIHRvIGJlIG1hZGUgcmVsYXRpdmUgdG8gYVJvb3QuXG4gICAqL1xuICBmdW5jdGlvbiByZWxhdGl2ZShhUm9vdCwgYVBhdGgpIHtcbiAgICBpZiAoYVJvb3QgPT09IFwiXCIpIHtcbiAgICAgIGFSb290ID0gXCIuXCI7XG4gICAgfVxuXG4gICAgYVJvb3QgPSBhUm9vdC5yZXBsYWNlKC9cXC8kLywgJycpO1xuXG4gICAgLy8gSXQgaXMgcG9zc2libGUgZm9yIHRoZSBwYXRoIHRvIGJlIGFib3ZlIHRoZSByb290LiBJbiB0aGlzIGNhc2UsIHNpbXBseVxuICAgIC8vIGNoZWNraW5nIHdoZXRoZXIgdGhlIHJvb3QgaXMgYSBwcmVmaXggb2YgdGhlIHBhdGggd29uJ3Qgd29yay4gSW5zdGVhZCwgd2VcbiAgICAvLyBuZWVkIHRvIHJlbW92ZSBjb21wb25lbnRzIGZyb20gdGhlIHJvb3Qgb25lIGJ5IG9uZSwgdW50aWwgZWl0aGVyIHdlIGZpbmRcbiAgICAvLyBhIHByZWZpeCB0aGF0IGZpdHMsIG9yIHdlIHJ1biBvdXQgb2YgY29tcG9uZW50cyB0byByZW1vdmUuXG4gICAgdmFyIGxldmVsID0gMDtcbiAgICB3aGlsZSAoYVBhdGguaW5kZXhPZihhUm9vdCArICcvJykgIT09IDApIHtcbiAgICAgIHZhciBpbmRleCA9IGFSb290Lmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgcmV0dXJuIGFQYXRoO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgb25seSBwYXJ0IG9mIHRoZSByb290IHRoYXQgaXMgbGVmdCBpcyB0aGUgc2NoZW1lIChpLmUuIGh0dHA6Ly8sXG4gICAgICAvLyBmaWxlOi8vLywgZXRjLiksIG9uZSBvciBtb3JlIHNsYXNoZXMgKC8pLCBvciBzaW1wbHkgbm90aGluZyBhdCBhbGwsIHdlXG4gICAgICAvLyBoYXZlIGV4aGF1c3RlZCBhbGwgY29tcG9uZW50cywgc28gdGhlIHBhdGggaXMgbm90IHJlbGF0aXZlIHRvIHRoZSByb290LlxuICAgICAgYVJvb3QgPSBhUm9vdC5zbGljZSgwLCBpbmRleCk7XG4gICAgICBpZiAoYVJvb3QubWF0Y2goL14oW15cXC9dKzpcXC8pP1xcLyokLykpIHtcbiAgICAgICAgcmV0dXJuIGFQYXRoO1xuICAgICAgfVxuXG4gICAgICArK2xldmVsO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBhZGQgYSBcIi4uL1wiIGZvciBlYWNoIGNvbXBvbmVudCB3ZSByZW1vdmVkIGZyb20gdGhlIHJvb3QuXG4gICAgcmV0dXJuIEFycmF5KGxldmVsICsgMSkuam9pbihcIi4uL1wiKSArIGFQYXRoLnN1YnN0cihhUm9vdC5sZW5ndGggKyAxKTtcbiAgfVxuICBleHBvcnRzLnJlbGF0aXZlID0gcmVsYXRpdmU7XG5cbiAgLyoqXG4gICAqIEJlY2F1c2UgYmVoYXZpb3IgZ29lcyB3YWNreSB3aGVuIHlvdSBzZXQgYF9fcHJvdG9fX2Agb24gb2JqZWN0cywgd2VcbiAgICogaGF2ZSB0byBwcmVmaXggYWxsIHRoZSBzdHJpbmdzIGluIG91ciBzZXQgd2l0aCBhbiBhcmJpdHJhcnkgY2hhcmFjdGVyLlxuICAgKlxuICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9wdWxsLzMxIGFuZFxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8zMFxuICAgKlxuICAgKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAgICovXG4gIGZ1bmN0aW9uIHRvU2V0U3RyaW5nKGFTdHIpIHtcbiAgICByZXR1cm4gJyQnICsgYVN0cjtcbiAgfVxuICBleHBvcnRzLnRvU2V0U3RyaW5nID0gdG9TZXRTdHJpbmc7XG5cbiAgZnVuY3Rpb24gZnJvbVNldFN0cmluZyhhU3RyKSB7XG4gICAgcmV0dXJuIGFTdHIuc3Vic3RyKDEpO1xuICB9XG4gIGV4cG9ydHMuZnJvbVNldFN0cmluZyA9IGZyb21TZXRTdHJpbmc7XG5cbiAgLyoqXG4gICAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2hlcmUgdGhlIG9yaWdpbmFsIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gICAqXG4gICAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAgICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBvcmlnaW5hbCBzb3VyY2UvbGluZS9jb2x1bW4sIGJ1dCBkaWZmZXJlbnQgZ2VuZXJhdGVkXG4gICAqIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhIG1hcHBpbmcgd2l0aCBhXG4gICAqIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyhtYXBwaW5nQSwgbWFwcGluZ0IsIG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgICB2YXIgY21wID0gbWFwcGluZ0Euc291cmNlIC0gbWFwcGluZ0Iuc291cmNlO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgICBpZiAoY21wICE9PSAwIHx8IG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwcGluZ0EubmFtZSAtIG1hcHBpbmdCLm5hbWU7XG4gIH07XG4gIGV4cG9ydHMuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMgPSBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucztcblxuICAvKipcbiAgICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGRlZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBpbmRpY2VzIHdoZXJlXG4gICAqIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAgICpcbiAgICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICAgKiBtYXBwaW5ncyB3aXRoIHRoZSBzYW1lIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4sIGJ1dCBkaWZmZXJlbnRcbiAgICogc291cmNlL25hbWUvb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHRoZSBzYW1lLiBVc2VmdWwgd2hlbiBzZWFyY2hpbmcgZm9yIGFcbiAgICogbWFwcGluZyB3aXRoIGEgc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgICB2YXIgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gICAgaWYgKGNtcCAhPT0gMCB8fCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5zb3VyY2UgLSBtYXBwaW5nQi5zb3VyY2U7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcHBpbmdBLm5hbWUgLSBtYXBwaW5nQi5uYW1lO1xuICB9O1xuICBleHBvcnRzLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkID0gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQ7XG5cbiAgZnVuY3Rpb24gc3RyY21wKGFTdHIxLCBhU3RyMikge1xuICAgIGlmIChhU3RyMSA9PT0gYVN0cjIpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChhU3RyMSA+IGFTdHIyKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGluZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBzdHJpbmdzIHdoZXJlXG4gICAqIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikge1xuICAgIHZhciBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbiAgfTtcbiAgZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCA9IGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkO1xuXG59KTtcblxufSx7XCJhbWRlZmluZVwiOjF9XSw1NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24oc2VsZikge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHNlbGYuZmV0Y2gpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdXBwb3J0ID0ge1xuICAgIHNlYXJjaFBhcmFtczogJ1VSTFNlYXJjaFBhcmFtcycgaW4gc2VsZixcbiAgICBpdGVyYWJsZTogJ1N5bWJvbCcgaW4gc2VsZiAmJiAnaXRlcmF0b3InIGluIFN5bWJvbCxcbiAgICBibG9iOiAnRmlsZVJlYWRlcicgaW4gc2VsZiAmJiAnQmxvYicgaW4gc2VsZiAmJiAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgQmxvYigpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbiAgfVxuXG4gIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyKSB7XG4gICAgdmFyIHZpZXdDbGFzc2VzID0gW1xuICAgICAgJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nXG4gICAgXVxuXG4gICAgdmFyIGlzRGF0YVZpZXcgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKVxuICAgIH1cblxuICAgIHZhciBpc0FycmF5QnVmZmVyVmlldyA9IEFycmF5QnVmZmVyLmlzVmlldyB8fCBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSlcbiAgICB9XG4gICAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXFxeX2B8fl0vaS50ZXN0KG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZScpXG4gICAgfVxuICAgIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8vIEJ1aWxkIGEgZGVzdHJ1Y3RpdmUgaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZSBsaXN0XG4gIGZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KClcbiAgICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICAgIGl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZXJhdG9yXG4gIH1cblxuICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9XG5cbiAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgICAgIH0sIHRoaXMpXG5cbiAgICB9IGVsc2UgaWYgKGhlYWRlcnMpIHtcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCBoZWFkZXJzW25hbWVdKVxuICAgICAgfSwgdGhpcylcbiAgICB9XG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gICAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSlcbiAgICB2YXIgbGlzdCA9IHRoaXMubWFwW25hbWVdXG4gICAgaWYgKCFsaXN0KSB7XG4gICAgICBsaXN0ID0gW11cbiAgICAgIHRoaXMubWFwW25hbWVdID0gbGlzdFxuICAgIH1cbiAgICBsaXN0LnB1c2godmFsdWUpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldXG4gICAgcmV0dXJuIHZhbHVlcyA/IHZhbHVlc1swXSA6IG51bGxcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV0gfHwgW11cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuaGFzT3duUHJvcGVydHkobm9ybWFsaXplTmFtZShuYW1lKSlcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV0gPSBbbm9ybWFsaXplVmFsdWUodmFsdWUpXVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5tYXApLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgdGhpcy5tYXBbbmFtZV0uZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbHVlLCBuYW1lLCB0aGlzKVxuICAgICAgfSwgdGhpcylcbiAgICB9LCB0aGlzKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdXG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7IGl0ZW1zLnB1c2gobmFtZSkgfSlcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXVxuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkgeyBpdGVtcy5wdXNoKHZhbHVlKSB9KVxuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXVxuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkgeyBpdGVtcy5wdXNoKFtuYW1lLCB2YWx1ZV0pIH0pXG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICBIZWFkZXJzLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gSGVhZGVycy5wcm90b3R5cGUuZW50cmllc1xuICB9XG5cbiAgZnVuY3Rpb24gY29uc3VtZWQoYm9keSkge1xuICAgIGlmIChib2R5LmJvZHlVc2VkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJykpXG4gICAgfVxuICAgIGJvZHkuYm9keVVzZWQgPSB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpXG4gICAgICB9XG4gICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QocmVhZGVyLmVycm9yKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzQXJyYXlCdWZmZXIoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKVxuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzVGV4dChibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYilcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEFycmF5QnVmZmVyQXNUZXh0KGJ1Zikge1xuICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIHZhciBjaGFycyA9IG5ldyBBcnJheSh2aWV3Lmxlbmd0aClcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pXG4gICAgfVxuICAgIHJldHVybiBjaGFycy5qb2luKCcnKVxuICB9XG5cbiAgZnVuY3Rpb24gYnVmZmVyQ2xvbmUoYnVmKSB7XG4gICAgaWYgKGJ1Zi5zbGljZSkge1xuICAgICAgcmV0dXJuIGJ1Zi5zbGljZSgwKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zi5ieXRlTGVuZ3RoKVxuICAgICAgdmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmKSlcbiAgICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlXG5cbiAgICB0aGlzLl9pbml0Qm9keSA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgIHRoaXMuX2JvZHlJbml0ID0gYm9keVxuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gJydcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IgJiYgQmxvYi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QmxvYiA9IGJvZHlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5mb3JtRGF0YSAmJiBGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5Rm9ybURhdGEgPSBib2R5XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIHN1cHBvcnQuYmxvYiAmJiBpc0RhdGFWaWV3KGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkuYnVmZmVyKVxuICAgICAgICAvLyBJRSAxMC0xMSBjYW4ndCBoYW5kbGUgYSBEYXRhVmlldyBib2R5LlxuICAgICAgICB0aGlzLl9ib2R5SW5pdCA9IG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgQm9keUluaXQgdHlwZScpXG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCB0aGlzLl9ib2R5QmxvYi50eXBlKVxuICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICB0aGlzLmJsb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlCbG9iKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5VGV4dF0pKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBjb25zdW1lZCh0aGlzKSB8fCBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUFycmF5QnVmZmVyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgIHJldHVybiByZWFkQmxvYkFzVGV4dCh0aGlzLl9ib2R5QmxvYilcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVhZEFycmF5QnVmZmVyQXNUZXh0KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmpzb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKEpTT04ucGFyc2UpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIEhUVFAgbWV0aG9kcyB3aG9zZSBjYXBpdGFsaXphdGlvbiBzaG91bGQgYmUgbm9ybWFsaXplZFxuICB2YXIgbWV0aG9kcyA9IFsnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUE9TVCcsICdQVVQnXVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgcmV0dXJuIChtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSkgPyB1cGNhc2VkIDogbWV0aG9kXG4gIH1cblxuICBmdW5jdGlvbiBSZXF1ZXN0KGlucHV0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keVxuXG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMudXJsID0gaW5wdXRcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlucHV0LmJvZHlVc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpXG4gICAgICB9XG4gICAgICB0aGlzLnVybCA9IGlucHV0LnVybFxuICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGlucHV0LmNyZWRlbnRpYWxzXG4gICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKVxuICAgICAgfVxuICAgICAgdGhpcy5tZXRob2QgPSBpbnB1dC5tZXRob2RcbiAgICAgIHRoaXMubW9kZSA9IGlucHV0Lm1vZGVcbiAgICAgIGlmICghYm9keSAmJiBpbnB1dC5fYm9keUluaXQgIT0gbnVsbCkge1xuICAgICAgICBib2R5ID0gaW5wdXQuX2JvZHlJbml0XG4gICAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ29taXQnXG4gICAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKVxuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbFxuICAgIHRoaXMucmVmZXJyZXIgPSBudWxsXG5cbiAgICBpZiAoKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSAmJiBib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gICAgfVxuICAgIHRoaXMuX2luaXRCb2R5KGJvZHkpXG4gIH1cblxuICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7IGJvZHk6IHRoaXMuX2JvZHlJbml0IH0pXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGUoYm9keSkge1xuICAgIHZhciBmb3JtID0gbmV3IEZvcm1EYXRhKClcbiAgICBib2R5LnRyaW0oKS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGlmIChieXRlcykge1xuICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpXG4gICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGZvcm1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpXG4gICAgcmF3SGVhZGVycy5zcGxpdCgnXFxyXFxuJykuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgcGFydHMgPSBsaW5lLnNwbGl0KCc6JylcbiAgICAgIHZhciBrZXkgPSBwYXJ0cy5zaGlmdCgpLnRyaW0oKVxuICAgICAgaWYgKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJ0cy5qb2luKCc6JykudHJpbSgpXG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gaGVhZGVyc1xuICB9XG5cbiAgQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKVxuXG4gIGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSAnZGVmYXVsdCdcbiAgICB0aGlzLnN0YXR1cyA9ICdzdGF0dXMnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1cyA6IDIwMFxuICAgIHRoaXMub2sgPSB0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCAzMDBcbiAgICB0aGlzLnN0YXR1c1RleHQgPSAnc3RhdHVzVGV4dCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdHVzVGV4dCA6ICdPSydcbiAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJ1xuICAgIHRoaXMuX2luaXRCb2R5KGJvZHlJbml0KVxuICB9XG5cbiAgQm9keS5jYWxsKFJlc3BvbnNlLnByb3RvdHlwZSlcblxuICBSZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICAgIHVybDogdGhpcy51cmxcbiAgICB9KVxuICB9XG5cbiAgUmVzcG9uc2UuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogMCwgc3RhdHVzVGV4dDogJyd9KVxuICAgIHJlc3BvbnNlLnR5cGUgPSAnZXJyb3InXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICB2YXIgcmVkaXJlY3RTdGF0dXNlcyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF1cblxuICBSZXNwb25zZS5yZWRpcmVjdCA9IGZ1bmN0aW9uKHVybCwgc3RhdHVzKSB7XG4gICAgaWYgKHJlZGlyZWN0U3RhdHVzZXMuaW5kZXhPZihzdGF0dXMpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3RhdHVzIGNvZGUnKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogc3RhdHVzLCBoZWFkZXJzOiB7bG9jYXRpb246IHVybH19KVxuICB9XG5cbiAgc2VsZi5IZWFkZXJzID0gSGVhZGVyc1xuICBzZWxmLlJlcXVlc3QgPSBSZXF1ZXN0XG4gIHNlbGYuUmVzcG9uc2UgPSBSZXNwb25zZVxuXG4gIHNlbGYuZmV0Y2ggPSBmdW5jdGlvbihpbnB1dCwgaW5pdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpXG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcblxuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAnJylcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLnVybCA9ICdyZXNwb25zZVVSTCcgaW4geGhyID8geGhyLnJlc3BvbnNlVVJMIDogb3B0aW9ucy5oZWFkZXJzLmdldCgnWC1SZXF1ZXN0LVVSTCcpXG4gICAgICAgIHZhciBib2R5ID0gJ3Jlc3BvbnNlJyBpbiB4aHIgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0XG4gICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKVxuICAgICAgfVxuXG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgICAgfVxuXG4gICAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICB9XG5cbiAgICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSlcblxuICAgICAgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdpbmNsdWRlJykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZiAoJ3Jlc3BvbnNlVHlwZScgaW4geGhyICYmIHN1cHBvcnQuYmxvYikge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InXG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKVxuICAgICAgfSlcblxuICAgICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdClcbiAgICB9KVxuICB9XG4gIHNlbGYuZmV0Y2gucG9seWZpbGwgPSB0cnVlXG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcyk7XG5cbn0se31dLDU4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgZmlyZXMgYWZ0ZXIgdGhlIGxlZnQgYXJyb3cgaXMgY2xpY2tlZFxuICogQGNhbGxiYWNrIENhcm91c2VsQXJyb3dzfm9uTGVmdEFycm93Q2xpY2tcbiAqL1xuXG4vKipcbiAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBmaXJlcyBhZnRlciB0aGUgcmlnaHQgYXJyb3cgaXMgY2xpY2tlZFxuICogQGNhbGxiYWNrIENhcm91c2VsQXJyb3dzfm9uUmlnaHRBcnJvd0NsaWNrXG4gKi9cblxuLyoqXG4gKiBBZGRzIGZ1bmN0aW9uYWxpdHkgZm9yIGNhcm91c2VsJ3MgbGVmdCBhbmQgcmlnaHQgYXJyb3dzLlxuICogQGNvbnN0cnVjdG9yIENhcm91c2VsQXJyb3dzXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQ2Fyb3VzZWxBcnJvd3MgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBjYXJvdXNlbCBpcyBpbnN0YW50aWF0ZWQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIHBhc3NlZCBpbnRvIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gb3B0aW9ucy5sZWZ0QXJyb3cgLSBUaGUgaHRtbCBlbGVtZW50IHRvIHVzZSBhcyB0aGUgbGVmdCBhcnJvd1xuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG9wdGlvbnMucmlnaHRBcnJvdyAtIFRoZSBodG1sIGVsZW1lbnQgdG8gdXNlIGFzIHRoZSByaWdodCBhcnJvd1xuICAgICAqIEBwYXJhbSB7SFRNTENvbGxlY3Rpb259IG9wdGlvbnMucGFuZWxzIC0gVGhlIGNhcm91c2VsIHBhbmVsIGVsZW1lbnRzIHRoYXQgdG8gYmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBhcnJvd3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYXJyb3dEaXNhYmxlZENsYXNzXSAtIFRoZSBDU1MgY2xhc3MgdGhhdCBnZXRzIGFkZGVkIHRvIGFuIGFycm93IHdoZW4gaXQgYmVjb21lcyBkaXNhYmxlZFxuICAgICAqIEBwYXJhbSB7Q2Fyb3VzZWxBcnJvd3N+b25MZWZ0QXJyb3dDbGlja30gW29wdGlvbnMub25MZWZ0QXJyb3dDbGlja10gLSBXaGVuIHRoZSBsZWZ0IGFycm93IGlzIGNsaWNrZWRcbiAgICAgKiBAcGFyYW0ge0Nhcm91c2VsQXJyb3dzfm9uUmlnaHRBcnJvd0NsaWNrfSBbb3B0aW9ucy5vblJpZ2h0QXJyb3dDbGlja10gLSBXaGVuIHRoZSByaWdodCBhcnJvdyBpcyBjbGlja2VkXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2Fyb3VzZWxBcnJvd3Mob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYXJvdXNlbEFycm93cyk7XG5cbiAgICAgICAgb3B0aW9ucyA9IF9leHRlbmRzKHtcbiAgICAgICAgICAgIGxlZnRBcnJvdzogbnVsbCxcbiAgICAgICAgICAgIHJpZ2h0QXJyb3c6IG51bGwsXG4gICAgICAgICAgICBwYW5lbHM6IFtdLFxuICAgICAgICAgICAgYXJyb3dEaXNhYmxlZENsYXNzOiAnY2Fyb3VzZWwtYXJyb3ctZGlzYWJsZWQnLFxuICAgICAgICAgICAgb25MZWZ0QXJyb3dDbGljazogbnVsbCxcbiAgICAgICAgICAgIG9uUmlnaHRBcnJvd0NsaWNrOiBudWxsLFxuICAgICAgICAgICAgaW5pdGlhbEluZGV4OiAwXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmICghb3B0aW9ucy5sZWZ0QXJyb3cgJiYgIW9wdGlvbnMucmlnaHRBcnJvdykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ2Fyb3VzZWwgQXJyb3dzIEVycm9yOiBubyBsZWZ0IGFuZCByaWdodCBhcnJvd3Mgd2VyZSBwYXNzZWQgaW50byBjb25zdHJ1Y3RvcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgICAgICB0aGlzLmFycm93cyA9IFtdO1xuXG4gICAgICAgIC8vIHNldHVwIGxpc3RlbmVyc1xuICAgICAgICBpZiAob3B0aW9ucy5sZWZ0QXJyb3cpIHtcbiAgICAgICAgICAgIHRoaXMuYXJyb3dzLnB1c2gob3B0aW9ucy5sZWZ0QXJyb3cpO1xuICAgICAgICAgICAgdGhpcy5fbGVmdEFycm93RXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm9uTGVmdEFycm93Q2xpY2soZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgb3B0aW9ucy5sZWZ0QXJyb3cuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9sZWZ0QXJyb3dFdmVudExpc3RlbmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnJpZ2h0QXJyb3cpIHtcbiAgICAgICAgICAgIHRoaXMuYXJyb3dzLnB1c2gob3B0aW9ucy5yaWdodEFycm93KTtcbiAgICAgICAgICAgIHRoaXMuX3JpZ2h0QXJyb3dFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMub25SaWdodEFycm93Q2xpY2soZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgb3B0aW9ucy5yaWdodEFycm93LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fcmlnaHRBcnJvd0V2ZW50TGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgYXJyb3cgYmFzZWQgb24gdGhlIHN1cHBsaWVkIHBhbmVsIGluZGV4LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwYW5lbEluZGV4IC0gVGhlIG5ldyBwYW5lbCBpbmRleFxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoQ2Fyb3VzZWxBcnJvd3MsIFt7XG4gICAgICAgIGtleTogJ3VwZGF0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUocGFuZWxJbmRleCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRJdGVtTnVtID0gcGFuZWxJbmRleCArIDEsXG4gICAgICAgICAgICAgICAgbWF4SXRlbXMgPSB0aGlzLm9wdGlvbnMucGFuZWxzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBtaW5JdGVtcyA9IDE7XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50SXRlbU51bSA8IG1heEl0ZW1zICYmIGN1cnJlbnRJdGVtTnVtID4gbWluSXRlbXMpIHtcbiAgICAgICAgICAgICAgICAvLyBub3Qgb24gZmlyc3Qgb3IgbGFzdCBpdGVtXG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudEl0ZW1OdW0gPT09IG1heEl0ZW1zICYmIGN1cnJlbnRJdGVtTnVtID09PSBtaW5JdGVtcykge1xuICAgICAgICAgICAgICAgIC8vIG9uIHRoZSBvbmx5IHBhbmVsIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50SXRlbU51bSA9PT0gbWF4SXRlbXMpIHtcbiAgICAgICAgICAgICAgICAvLyBvbiBsYXN0IGl0ZW1cbiAgICAgICAgICAgICAgICB0aGlzLmRpc2FibGVSaWdodEFycm93KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGVMZWZ0QXJyb3coKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudEl0ZW1OdW0gPT09IG1pbkl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgLy8gb24gZmlyc3QgaXRlbVxuICAgICAgICAgICAgICAgIHRoaXMuZGlzYWJsZUxlZnRBcnJvdygpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlUmlnaHRBcnJvdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVzIGFsbCBhcnJvd3NcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Rpc2FibGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZUxlZnRBcnJvdygpO1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlUmlnaHRBcnJvdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVzIGxlZnQgYXJyb3cuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkaXNhYmxlTGVmdEFycm93JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVMZWZ0QXJyb3coKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxlZnRBcnJvdykge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5sZWZ0QXJyb3cuY2xhc3NMaXN0LmFkZCh0aGlzLm9wdGlvbnMuYXJyb3dEaXNhYmxlZENsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlcyByaWdodCBhcnJvdy5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Rpc2FibGVSaWdodEFycm93JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVSaWdodEFycm93KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yaWdodEFycm93KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnJpZ2h0QXJyb3cuY2xhc3NMaXN0LmFkZCh0aGlzLm9wdGlvbnMuYXJyb3dEaXNhYmxlZENsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZS1lbmFibGVzIGFsbCBhcnJvd3MuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdlbmFibGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGVMZWZ0QXJyb3coKTtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlUmlnaHRBcnJvdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlLWVuYWJsZXMgbGVmdCBhcnJvdy5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2VuYWJsZUxlZnRBcnJvdycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVMZWZ0QXJyb3coKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxlZnRBcnJvdykge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5sZWZ0QXJyb3cuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLm9wdGlvbnMuYXJyb3dEaXNhYmxlZENsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZS1lbmFibGVzIHJpZ2h0IGFycm93LlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZW5hYmxlUmlnaHRBcnJvdycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVSaWdodEFycm93KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yaWdodEFycm93KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnJpZ2h0QXJyb3cuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLm9wdGlvbnMuYXJyb3dEaXNhYmxlZENsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIHRoZSBsZWZ0IGFycm93IGlzIGNsaWNrZWQuXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ29uTGVmdEFycm93Q2xpY2snLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25MZWZ0QXJyb3dDbGljayhlKSB7XG4gICAgICAgICAgICB2YXIgaXNEaXNhYmxlZCA9IHRoaXMub3B0aW9ucy5sZWZ0QXJyb3cuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMub3B0aW9ucy5hcnJvd0Rpc2FibGVkQ2xhc3MpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbkxlZnRBcnJvd0NsaWNrICYmICFpc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uTGVmdEFycm93Q2xpY2soZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiB0aGUgcmlnaHQgYXJyb3cgaXMgY2xpY2tlZC5cbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnb25SaWdodEFycm93Q2xpY2snLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25SaWdodEFycm93Q2xpY2soZSkge1xuICAgICAgICAgICAgdmFyIGlzRGlzYWJsZWQgPSB0aGlzLm9wdGlvbnMucmlnaHRBcnJvdy5jbGFzc0xpc3QuY29udGFpbnModGhpcy5vcHRpb25zLmFycm93RGlzYWJsZWRDbGFzcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9uUmlnaHRBcnJvd0NsaWNrICYmICFpc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uUmlnaHRBcnJvd0NsaWNrKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmFsIGNsZWFudXAgb2YgaW5zdGFuY2UuXG4gICAgICAgICAqIEBtZW1iZXJPZiBDYXJvdXNlbEFycm93c1xuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGVzdHJveScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sZWZ0QXJyb3cpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMubGVmdEFycm93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fbGVmdEFycm93RXZlbnRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmlnaHRBcnJvdykge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5yaWdodEFycm93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fcmlnaHRBcnJvd0V2ZW50TGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENhcm91c2VsQXJyb3dzO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDYXJvdXNlbEFycm93cztcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se31dLDU5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfcHJvbWlzZSA9IHJlcXVpcmUoJ3Byb21pc2UnKTtcblxudmFyIF9wcm9taXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb21pc2UpO1xuXG52YXIgX21vZHVsZUpzID0gcmVxdWlyZSgnbW9kdWxlLWpzJyk7XG5cbnZhciBfbW9kdWxlSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbW9kdWxlSnMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBDYXJvdXNlbFBhbmVsID0gZnVuY3Rpb24gKF9Nb2R1bGUpIHtcbiAgICBfaW5oZXJpdHMoQ2Fyb3VzZWxQYW5lbCwgX01vZHVsZSk7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHNvbWUgc3R1ZmYgdXAuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgLSBUaGUgZWxlbWVudCB0aGF0IHJlcHJlc2VudHMgYSBwYW5lbC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFjdGl2ZUNsYXNzXSAtIFRoZSBjc3MgY2xhc3MgdGhhdCBnZXRzIGFwcGxpZWQgd2hlbiB0aGUgbW9kdWxlIGlzIHNob3dpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYXNzZXRMb2FkZWRDbGFzc10gLSBUaGUgY3NzIGNsYXNzIHRoYXQgZ2V0cyBhZGRlZCB3aGVuIHRoZSBhc3NldCBoYXMgYmVlbiBsb2FkZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubGF6eUxvYWRBdHRyXSAtIFRoZSBsYXp5IGxvYWRpbmcgYXR0cmlidXRlIG9mIHRoZSBwYW5lbCBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIHNyYyB0byBsb2FkXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2Fyb3VzZWxQYW5lbChlbCwgb3B0aW9ucykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2Fyb3VzZWxQYW5lbCk7XG5cbiAgICAgICAgb3B0aW9ucyA9IF9leHRlbmRzKHtcbiAgICAgICAgICAgIGFjdGl2ZUNsYXNzOiAnY2Fyb3VzZWwtcGFuZWwtYWN0aXZlJyxcbiAgICAgICAgICAgIGxhenlMb2FkQXR0cjogbnVsbCxcbiAgICAgICAgICAgIGxvYWRlZENsYXNzOiAnY2Fyb3VzZWwtcGFuZWwtbG9hZGVkJyxcbiAgICAgICAgICAgIGFzc2V0TG9hZGVkQ2xhc3M6ICdjYXJvdXNlbC1wYW5lbC1hc3NldC1sb2FkZWQnXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDYXJvdXNlbFBhbmVsLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ2Fyb3VzZWxQYW5lbCkpLmNhbGwodGhpcywgZWwsIG9wdGlvbnMpKTtcblxuICAgICAgICBfdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgX3RoaXMuZWwgPSBlbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGFsbCBsYXp5LWxvYWRhYmxlIGltYWdlcyB3aXRoaW4gdGhlIHBhbmVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoQ2Fyb3VzZWxQYW5lbCwgW3tcbiAgICAgICAga2V5OiAnbG9hZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBsb2FkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvYWRhYmxlSW1hZ2VzKCkuZm9yRWFjaChmdW5jdGlvbiAoaW1nRWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbG9hZGVkQ2xhc3MgPSBfdGhpczIub3B0aW9ucy5hc3NldExvYWRlZENsYXNzO1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gX3RoaXMyLl9sb2FkSW1hZ2UoaW1nRWwpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpczIuZWwuY2xhc3NMaXN0LmFkZChsb2FkZWRDbGFzcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbG9hZFByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIF9nZXQoQ2Fyb3VzZWxQYW5lbC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDYXJvdXNlbFBhbmVsLnByb3RvdHlwZSksICdsb2FkJywgdGhpcykuY2FsbCh0aGlzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3Byb21pc2UyLmRlZmF1bHQuYWxsKGxvYWRQcm9taXNlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBsaXZlIHNldCBvZiBsb2FkYWJsZSBpbWFnZSBlbGVtZW50cyB3aXRoaW4gdGhlIHBhbmVsIChvciB0aGUgcGFuZWwgaXRzZWxmIGlmIGl0IGlzIGFuIDxpbWc+KS5cbiAgICAgICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2xvYWRhYmxlSW1hZ2VzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9sb2FkYWJsZUltYWdlcygpIHtcbiAgICAgICAgICAgIC8vIGlmIHBhbmVsIGhhcyBsYXp5IGxvYWQgYXR0cmlidXRlLCAgYWRkIHRvIGxvYWRhYmxlIGFzc2V0c1xuICAgICAgICAgICAgaWYgKHRoaXMuZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW1nJyAmJiB0aGlzLmVsLmdldEF0dHJpYnV0ZSh0aGlzLm9wdGlvbnMubGF6eUxvYWRBdHRyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbdGhpcy5lbF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2ltZ1snICsgdGhpcy5vcHRpb25zLmxhenlMb2FkQXR0ciArICddJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hbnVhbGx5IGxhenkgbG9hZHMgYSByZXNvdXJjZSB1c2luZyBhbiBlbGVtZW50J3MgZGF0YSBhdHRyaWJ1dGUuXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gaW1nIC0gVGhlIGltYWdlIGVsZW1lbnQgdG8gbG9hZFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2xvYWRJbWFnZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9hZEltYWdlKGltZykge1xuICAgICAgICAgICAgdmFyIHNyYyA9IGltZy5nZXRBdHRyaWJ1dGUodGhpcy5vcHRpb25zLmxhenlMb2FkQXR0cik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IF9wcm9taXNlMi5kZWZhdWx0KGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShpbWcpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElFIDktMTEgaGF2ZSBhbiBpc3N1ZSB3aGVyZSBpdCBhdXRvbWF0aWNhbGx5IHRyaWdnZXJzIGFuIGVycm9yIG9uIHNvbWUgaW1hZ2VzLFxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdGhlbiB3aWxsIGltbWVkaWF0ZWx5IHRyaWdnZXIgb25sb2FkKCkgY2F1c2luZyBpbnRlcm1pdHRlbnQgZXJyb3JzIHRvIGFwcGVhclxuICAgICAgICAgICAgICAgICAgICAvLyB1bnRpbCB0aGlzIGlzIGZpeGVkIG9yIHdlIGhhdmUgYSB3b3JrYXJvdW5kLCB3ZSB3aWxsIGJlIHJlc29sdmluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBldmVuIGlmIHRoZXJlIGlzIGFuIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaW1nKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGltZy5zcmMgPSBzcmM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDYXJvdXNlbFBhbmVsO1xufShfbW9kdWxlSnMyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDYXJvdXNlbFBhbmVsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxufSx7XCJtb2R1bGUtanNcIjozNyxcInByb21pc2VcIjozOH1dLDYwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3Byb21pc2UgPSByZXF1aXJlKCdwcm9taXNlJyk7XG5cbnZhciBfcHJvbWlzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9taXNlKTtcblxudmFyIF9jYXJvdXNlbFBhbmVsID0gcmVxdWlyZSgnLi9jYXJvdXNlbC1wYW5lbCcpO1xuXG52YXIgX2Nhcm91c2VsUGFuZWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2Fyb3VzZWxQYW5lbCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGZpcmVzIGFmdGVyIGEgbmV3IGFjdGl2ZSBwYW5lbCBpcyBzZXRcbiAqIEBjYWxsYmFjayBDYXJvdXNlbFBhbmVsc35vbkNoYW5nZVxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBuZXcgcGFuZWxcbiAqL1xuXG4vKipcbiAqIEFkZHMgZnVuY3Rpb25hbGl0eSBmb3IgY2Fyb3VzZWwgcGFuZWxzLiBOb3QgcmVhbGx5IG1lYW50IHRvIGJlIHVzZWQgb3duIGl0cyBvd24sIHVubGVzcyB5b3Ugd2FudFxuICogdG8gY3VzdG9taXplIHRoZSB0aGUgamF2YXNjcmlwdCBsb2dpYyBmb3IgdGhlIFwicGFuZWxzXCIgb2YgdGhlIENhcm91c2VsIChhc3N1bWluZyB0aGF0IHlvdSBhY3R1YWxseVxuICoga25vdyB3aGF0IHlvdSdyZSBkb2luZyB3aGVuIHlvdSBkbyBzbykuXG4gKiBAY29uc3RydWN0b3IgQ2Fyb3VzZWxQYW5lbHNcbiAqL1xudmFyIENhcm91c2VsUGFuZWxzID0gZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgY2Fyb3VzZWwgaXMgaW5zdGFudGlhdGVkLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyBwYXNzZWQgaW50byBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7SFRNTENvbGxlY3Rpb258Tm9kZUxpc3R9IG9wdGlvbnMucGFuZWxzIC0gVGhlIHBhbmVscyBpbiB3aGljaCB0byB1c2UgZm9yIHRoZSBjYXJvdXNlbCAoYW4gYXJyYXkgb2YgcGhvdG9zKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hc3NldExvYWRlZENsYXNzXSAtIFRoZSBDU1MgY2xhc3MgdGhhdCBnZXRzIGFkZGVkIHRvIGEgcGFuZWwgZWwgd2hlbiBpdCBpcyBsb2FkZWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGFuZWxBY3RpdmVDbGFzc10gLSBUaGUgQ1NTIGNsYXNzIHRoYXQgZ2V0cyBhZGRlZCB0byBhbiBwYW5lbCB3aGVuIGl0IGJlY29tZXMgYWN0aXZlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBhbmVsQmFja0NsYXNzXSAtIFRoZSBDU1MgY2xhc3MgdGhhdCBnZXRzIGFkZGVkIHRvIGFsbCBwYW5lbCBlbGVtZW50cyB0aGF0IGFwcGVhciBiZWZvcmUgdGhlIGN1cnJlbnQgcGFuZWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGFuZWxGb3J3YXJkQ2xhc3NdIC0gVGhlIENTUyBjbGFzcyB0aGF0IGdldHMgYWRkZWQgdG8gYWxsIHBhbmVsIGVsZW1lbnRzIHRoYXQgYXBwZWFyIGFoZWFkIG9mIHRoZSBjdXJyZW50IHBhbmVsXG4gICAgICogQHBhcmFtIHtDYXJvdXNlbFBhbmVsc35vbkNoYW5nZX0gW29wdGlvbnMub25DaGFuZ2VdIC0gV2hlbiB0aGUgY3VycmVudCBwYW5lbCBpcyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhenlMb2FkQXR0cl0gLSBUaGUgbGF6eSBsb2FkaW5nIGF0dHJpYnV0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENhcm91c2VsUGFuZWxzKG9wdGlvbnMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhcm91c2VsUGFuZWxzKTtcblxuICAgICAgICBvcHRpb25zID0gX2V4dGVuZHMoe1xuICAgICAgICAgICAgcGFuZWxzOiBbXSxcbiAgICAgICAgICAgIGFzc2V0TG9hZGVkQ2xhc3M6ICdjYXJvdXNlbC1hc3NldC1sb2FkZWQnLFxuICAgICAgICAgICAgcGFuZWxBY3RpdmVDbGFzczogJ2Nhcm91c2VsLXBhbmVsLWFjdGl2ZScsXG4gICAgICAgICAgICBwYW5lbExvYWRlZENsYXNzOiAnY2Fyb3VzZWwtcGFuZWwtbG9hZGVkJyxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiBudWxsLFxuICAgICAgICAgICAgbGF6eUxvYWRBdHRyOiAnZGF0YS1zcmMnLFxuICAgICAgICAgICAgcGFuZWxCYWNrQ2xhc3M6ICdjYXJvdXNlbC1wYW5lbC1iZWhpbmQnLFxuICAgICAgICAgICAgcGFuZWxGb3J3YXJkQ2xhc3M6ICdjYXJvdXNlbC1wYW5lbC1haGVhZCdcbiAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLnBhbmVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2Nhcm91c2VsIGVycm9yOiBubyBwYW5lbHMgd2VyZSBwYXNzZWQgaW4gY29uc3RydWN0b3InKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BhbmVsTW9kdWxlcyA9IHRoaXMuX3NldHVwUGFuZWxNb2R1bGVzKG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGZvcndhcmQgY2xhc3NlcyBpbml0aWFsbHlcbiAgICAgICAgdGhpcy5fcGFuZWxNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICAgICAgICBwYW5lbC5lbC5jbGFzc0xpc3QuYWRkKG9wdGlvbnMucGFuZWxGb3J3YXJkQ2xhc3MpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgdGhlIHBhbmVsIG1vZHVsZSBpbnN0YW5jZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgaW5pdGlhbGl6YXRpb24gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcGFuZWwgaW5zdGFuY2VzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKENhcm91c2VsUGFuZWxzLCBbe1xuICAgICAgICBrZXk6ICdfc2V0dXBQYW5lbE1vZHVsZXMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwUGFuZWxNb2R1bGVzKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBtb2R1bGVzID0gW107XG4gICAgICAgICAgICAvLyBwYW5lbHMgY2FuIGJlIGVpdGhlciBhbiBhcnJheSBvciBhbiBIVE1MQ29sbGVjdGlvbiBzbyB3ZVxuICAgICAgICAgICAgLy8gYXJlIGRvaW5nIGFuIG9sZC1zY2hvb2wgZm9yIGxvb3AgdG8gc2F0aXNpZnkgYm90aCBzY2VuYXJpb3NcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5wYW5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVzW2ldID0gbmV3IF9jYXJvdXNlbFBhbmVsMi5kZWZhdWx0KG9wdGlvbnMucGFuZWxzW2ldLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUNsYXNzOiBvcHRpb25zLnBhbmVsQWN0aXZlQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgIGxhenlMb2FkQXR0cjogb3B0aW9ucy5sYXp5TG9hZEF0dHIsXG4gICAgICAgICAgICAgICAgICAgIGFzc2V0TG9hZGVkQ2xhc3M6IG9wdGlvbnMuYXNzZXRMb2FkZWRDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVkQ2xhc3M6IG9wdGlvbnMucGFuZWxMb2FkZWRDbGFzc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVHJhbnNpdGlvbnMgdG8gYSBwYW5lbCBvZiBhbiBpbmRleC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IG51bWJlciB0byBnbyB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dvVG8nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ29UbyhpbmRleCkge1xuICAgICAgICAgICAgdmFyIG1heEluZGV4ID0gdGhpcy5vcHRpb25zLnBhbmVscy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgIG1pbkluZGV4ID0gMCxcbiAgICAgICAgICAgICAgICBwcmV2SW5kZXggPSB0aGlzLmdldEN1cnJlbnRJbmRleCgpLFxuICAgICAgICAgICAgICAgIGVycm9yTXNnLFxuICAgICAgICAgICAgICAgIHByb21pc2U7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInIHx8IGluZGV4ID4gbWF4SW5kZXggfHwgaW5kZXggPCBtaW5JbmRleCkge1xuICAgICAgICAgICAgICAgIGVycm9yTXNnID0gJ2Nhcm91c2VsIHBhbmVsIGVycm9yOiB1bmFibGUgdG8gdHJhbnNpdGlvbiB0byBhbiBpbmRleCBvZiAnICsgaW5kZXggKyAnd2hpY2ggZG9lcyBub3QgZXhpc3QhJztcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yTXNnKTtcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gX3Byb21pc2UyLmRlZmF1bHQucmVqZWN0KG5ldyBFcnJvcihlcnJvck1zZykpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2SW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBhdCBpbmRleFxuICAgICAgICAgICAgICAgIHByb21pc2UgPSBfcHJvbWlzZTIuZGVmYXVsdC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb21pc2UgPSB0aGlzLmxvYWQoaW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVBhbmVscyhpbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub25DaGFuZ2UoaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ha2VzIGFsbCBwYW5lbHMgaW5hY3RpdmUgZXhjZXB0IGZvciB0aGUgb25lIGF0IHRoZSBpbmRleCBwcm92aWRlZC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvSW5kZXggLSBUaGUgbmV3IGluZGV4XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfdXBkYXRlUGFuZWxzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVQYW5lbHModG9JbmRleCkge1xuICAgICAgICAgICAgdmFyIGZyb21JbmRleCA9IHRoaXMuZ2V0Q3VycmVudEluZGV4KCk7XG4gICAgICAgICAgICB2YXIgZnJvbVBhbmVsID0gdGhpcy5fcGFuZWxNb2R1bGVzW2Zyb21JbmRleF07XG4gICAgICAgICAgICB2YXIgdG9QYW5lbCA9IHRoaXMuX3BhbmVsTW9kdWxlc1t0b0luZGV4XTtcbiAgICAgICAgICAgIHZhciByYW5nZVBhbmVscyA9IFtdO1xuICAgICAgICAgICAgdmFyIHRvQWRkID0gJyc7XG4gICAgICAgICAgICB2YXIgdG9SZW1vdmUgPSAnJztcblxuICAgICAgICAgICAgaWYgKGZyb21JbmRleCA+IHRvSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBpbmNsdWRlIGZyb21JbmRleCBidXQgbm90IHRvSW5kZXhcbiAgICAgICAgICAgICAgICByYW5nZVBhbmVscyA9IHRoaXMuX3BhbmVsTW9kdWxlcy5zbGljZSh0b0luZGV4ICsgMSwgZnJvbUluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgdG9BZGQgPSB0aGlzLm9wdGlvbnMucGFuZWxGb3J3YXJkQ2xhc3M7XG4gICAgICAgICAgICAgICAgdG9SZW1vdmUgPSB0aGlzLm9wdGlvbnMucGFuZWxCYWNrQ2xhc3M7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZyb21JbmRleCA8IHRvSW5kZXgpIHtcbiAgICAgICAgICAgICAgICByYW5nZVBhbmVscyA9IHRoaXMuX3BhbmVsTW9kdWxlcy5zbGljZShmcm9tSW5kZXgsIHRvSW5kZXgpO1xuICAgICAgICAgICAgICAgIHRvQWRkID0gdGhpcy5vcHRpb25zLnBhbmVsQmFja0NsYXNzO1xuICAgICAgICAgICAgICAgIHRvUmVtb3ZlID0gdGhpcy5vcHRpb25zLnBhbmVsRm9yd2FyZENsYXNzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByYW5nZVBhbmVscy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgcC5lbC5jbGFzc0xpc3QuYWRkKHRvQWRkKTtcbiAgICAgICAgICAgICAgICBwLmVsLmNsYXNzTGlzdC5yZW1vdmUodG9SZW1vdmUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChmcm9tUGFuZWwpIHtcbiAgICAgICAgICAgICAgICBmcm9tUGFuZWwuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9QYW5lbC5lbC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5wYW5lbEZvcndhcmRDbGFzcywgdGhpcy5vcHRpb25zLnBhbmVsQmFja0NsYXNzKTtcbiAgICAgICAgICAgIHRvUGFuZWwuc2hvdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGN1cnJlbnQgaW5kZXggdGhhdCBpcyBzaG93aW5nLlxuICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0Q3VycmVudEluZGV4JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEN1cnJlbnRJbmRleCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50SW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogTG9hZHMgYXNzZXRzIGZvciBhIGdpdmVuIHBhbmVsLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaWR4IC0gVGhlIGluZGV4IG9mIHRoZSBwYW5lbCBjb250YWluaW5nIHRoZSBhc3NldHMgdG8gbG9hZFxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2xvYWQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZChpZHgpIHtcbiAgICAgICAgICAgIHZhciBwYW5lbE1vZHVsZSA9IHRoaXMuX3BhbmVsTW9kdWxlc1tpZHhdO1xuICAgICAgICAgICAgaWYgKHBhbmVsTW9kdWxlLmxvYWRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcHJvbWlzZTIuZGVmYXVsdC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFuZWxNb2R1bGUubG9hZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvYWRzIGFzc2V0cyBmb3IgYSBnaXZlbiBwYW5lbC5cbiAgICAgICAgICogQGRlcHJlY2F0ZWQgc2luY2UgMi4xLjZcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBwYW5lbCBjb250YWluaW5nIHRoZSBhc3NldHMgdG8gbG9hZFxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2xvYWRQYW5lbEFzc2V0cycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkUGFuZWxBc3NldHMoaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvYWQoaW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmFsIGNsZWFudXAgb2YgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkZXN0cm95JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBjdXJyZW50SW5kZXggPSB0aGlzLmdldEN1cnJlbnRJbmRleCgpO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudEluZGV4KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wYW5lbHNbY3VycmVudEluZGV4XS5jbGFzc0xpc3QucmVtb3ZlKG9wdGlvbnMucGFuZWxBY3RpdmVDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SW5kZXggPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIHRoaXMuX3BhbmVsTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuZWwuY2xhc3NMaXN0LnJlbW92ZShvcHRpb25zLnBhbmVsRm9yd2FyZENsYXNzLCBvcHRpb25zLnBhbmVsQmFja0NsYXNzKTtcbiAgICAgICAgICAgICAgICBtb2R1bGUuZGVzdHJveSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ2Fyb3VzZWxQYW5lbHM7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENhcm91c2VsUGFuZWxzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxufSx7XCIuL2Nhcm91c2VsLXBhbmVsXCI6NTksXCJwcm9taXNlXCI6Mzh9XSw2MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGZpcmVzIGFmdGVyIGEgbmV3IGFjdGl2ZSBwYW5lbCBpcyBzZXRcbiAqIEBjYWxsYmFjayBDYXJvdXNlbFRodW1ic35vbkNoYW5nZVxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBuZXcgcGFuZWxcbiAqL1xuXG4vKipcbiAqIEFkZHMgdGh1bWJuYWlscyBmb3IgY2Fyb3VzZWwuIE5vdCByZWFsbHkgbWVhbnQgdG8gYmUgdXNlZCBvd24gaXRzIG93biwgdW5sZXNzIHlvdVxuICogd2FudCB0byBjdXN0b21pemUgdGhlIGphdmFzY3JpcHQgbG9naWMgZm9yIHRoZSBcInRodW1ibmFpbHNcIiBvZiB5b3VyIENhcm91c2VsIGluc3RhbmNlIChhc3N1bWluZyB0aGF0IHlvdSBhY3R1YWxseVxuICoga25vdyB3aGF0IHlvdSdyZSBkb2luZyB3aGVuIHlvdSBkbyBzbykuXG4gKiBAY2xhc3MgQ2Fyb3VzZWxUaHVtYnNcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBDYXJvdXNlbFRodW1icyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gY2Fyb3VzZWwgaXMgaW5zdGFudGlhdGVkLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyBwYXNzZWQgaW50byBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7SFRNTENvbGxlY3Rpb259IFtvcHRpb25zLnRodW1ibmFpbHNdIC0gQSBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzIHRoYXQgYXJlIHRoZSB0aHVtYm5haWxzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRodW1ibmFpbEFjdGl2ZUNsYXNzXSAtIFRoZSBDU1MgY2xhc3MgdGhhdCBnZXRzIGFkZGVkIHRvIGEgdGh1bWJuYWlsIGVsZW1lbnQgd2hlbiBpdCBiZWNvbWVzIGFjdGl2ZVxuICAgICAqIEBwYXJhbSB7Q2Fyb3VzZWxUaHVtYnN+b25DaGFuZ2V9IFtvcHRpb25zLm9uQ2hhbmdlXSAtIFdoZW4gYSBuZXcgdGh1bWJuYWlsIGJlY29tZXMgYWN0aXZlXG4gICAgICogQG1lbWJlck9mIENhcm91c2VsVGh1bWJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2Fyb3VzZWxUaHVtYnMob3B0aW9ucykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2Fyb3VzZWxUaHVtYnMpO1xuXG4gICAgICAgIG9wdGlvbnMgPSBfZXh0ZW5kcyh7XG4gICAgICAgICAgICB0aHVtYm5haWxzOiBbXSxcbiAgICAgICAgICAgIHRodW1ibmFpbEFjdGl2ZVRyaWdnZXJFdmVudDogJ2NsaWNrJyxcbiAgICAgICAgICAgIHRodW1ibmFpbEFjdGl2ZUNsYXNzOiAnY2Fyb3VzZWwtdGh1bWJuYWlsLWFjdGl2ZScsXG4gICAgICAgICAgICBvbkNoYW5nZTogbnVsbFxuICAgICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl90aHVtYm5haWxFdmVudExpc3RlbmVyID0gdGhpcy5vblRodW1ibmFpbEV2ZW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXAoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSBjYXJvdXNlbCBpbnN0YW5jZSBieSBhZGRpbmcgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSB0aHVtYm5haWxzLlxuICAgICAqIEBtZW1iZXJPZiBDYXJvdXNlbFRodW1ic1xuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoQ2Fyb3VzZWxUaHVtYnMsIFt7XG4gICAgICAgIGtleTogJ3NldHVwJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwKCkge1xuICAgICAgICAgICAgdmFyIHRodW1icyA9IHRoaXMub3B0aW9ucy50aHVtYm5haWxzO1xuICAgICAgICAgICAgaWYgKHRodW1icy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJUaHVtYnNFdmVudExpc3RlbmVyKCdhZGRFdmVudExpc3RlbmVyJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2Nhcm91c2VsIHRodW1iIGVycm9yOiBubyB0aHVtYm5haWxzIHdlcmUgcGFzc2VkIHRvIGNvbnN0cnVjdG9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBhIHRodW1ibmFpbCBpcyBjbGlja2VkLlxuICAgICAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGUgLSBUaGUgY2xpY2sgZXZlbnRcbiAgICAgICAgICogQG1lbWJlck9mIENhcm91c2VsVGh1bWJzXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdvblRodW1ibmFpbEV2ZW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uVGh1bWJuYWlsRXZlbnQoZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90aHVtYm5haWxBcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHRodW1ibmFpbCBIVE1MQ29sbGVjdGlvbiB0byByZWFsIGFycmF5IHNvIHdlIGNhbiBwZXJmb3JtIG5lY2Vzc2FyeSBhcnJheSBtZXRob2RzXG4gICAgICAgICAgICAgICAgdGhpcy5fdGh1bWJuYWlsQXJyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5vcHRpb25zLnRodW1ibmFpbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fdGh1bWJuYWlsQXJyLmluZGV4T2YoZS5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgICAgIC8vIHdlIGFyZSBjaGVja2luZyB0aGF0IHRoZSBzZWxlY3RlZCB0aHVtYm5haWwgaXMgc3RpbGwgaW4gdGhlIEhUTUxDb2xsZWN0aW9uXG4gICAgICAgICAgICAvLyBiZWNhdXNlIGl0IGlzIGxpdmUgaW50cm9kdWNpbmcgdGhlIHBvc3NpYmlsaXR5IHRoYXQgdGhlIGVsZW1lbnQgaXMgbm8gbG9uZ2VyIGluIHRoZSBET01cbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEgJiYgaW5kZXggIT09IHRoaXMuZ2V0Q3VycmVudEluZGV4KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdvVG8oaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMub25DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uQ2hhbmdlKGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGZvciBlcnJvcnMgdXBvbiBpbml0aWFsaXplLlxuICAgICAgICAgKiBAbWVtYmVyT2YgQ2Fyb3VzZWxUaHVtYnNcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19jaGVja0ZvckluaXRFcnJvcnMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2NoZWNrRm9ySW5pdEVycm9ycygpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgICAgIHRodW1ibmFpbENvdW50ID0gb3B0aW9ucy50aHVtYm5haWxzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICghdGh1bWJuYWlsQ291bnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdjYXJvdXNlbCBlcnJvcjogbm8gdGh1bWJuYWlscyB3ZXJlIHBhc3NlZCBpbiBjb25zdHJ1Y3RvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ha2VzIGFsbCB0aHVtYm5haWxzIGluYWN0aXZlIGV4Y2VwdCBmb3IgdGhlIG9uZSBhdCB0aGUgaW5kZXggcHJvdmlkZWQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSBuZXcgaW5kZXhcbiAgICAgICAgICogQG1lbWJlck9mIENhcm91c2VsVGh1bWJzXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnb1RvJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdvVG8oaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciB0aHVtYnMgPSB0aGlzLm9wdGlvbnMudGh1bWJuYWlscyxcbiAgICAgICAgICAgICAgICBwcmV2SW5kZXggPSB0aGlzLmdldEN1cnJlbnRJbmRleCgpIHx8IDAsXG4gICAgICAgICAgICAgICAgYWN0aXZlQ2xhc3MgPSB0aGlzLm9wdGlvbnMudGh1bWJuYWlsQWN0aXZlQ2xhc3MsXG4gICAgICAgICAgICAgICAgbWF4SW5kZXggPSB0aHVtYnMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICBtaW5JbmRleCA9IDA7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA+IG1heEluZGV4IHx8IGluZGV4IDwgbWluSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdjYXJvdXNlbCB0aHVtYm5haWwgZXJyb3I6IHVuYWJsZSB0byB0cmFuc2l0aW9uIHRvIGEgdGh1bWJuYWlsIHdpdGggYW4gaW5kZXggb2YgJyArIGluZGV4ICsgJywgaXQgZG9lcyBub3QgZXhpc3QhJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRodW1ic1tpbmRleF0uY2xhc3NMaXN0LmFkZChhY3RpdmVDbGFzcyk7XG5cbiAgICAgICAgICAgIGlmIChwcmV2SW5kZXggIT09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdGh1bWJzW3ByZXZJbmRleF0uY2xhc3NMaXN0LnJlbW92ZShhY3RpdmVDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SW5kZXggPSBpbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHRodW1ibmFpbCBpbmRleCB0aGF0IGlzIHNob3dpbmcuXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgdGhlIGluZGV4XG4gICAgICAgICAqIEBtZW1iZXJPZiBDYXJvdXNlbFRodW1ic1xuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0Q3VycmVudEluZGV4JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEN1cnJlbnRJbmRleCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50SW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVHJpZ2dlcnMgYW4gZXZlbnQgbGlzdGVuZXIgbWV0aG9kIG9uIGFsbCB0aHVtYm5haWwgZWxlbWVudHMuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2QgLSBUaGUgZXZlbnQgbGlzdGVuZXIgbWV0aG9kIHRvIGNhbGwgb24gZWFjaCBvZiB0aGUgZWxlbWVudHNcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RyaWdnZXJUaHVtYnNFdmVudExpc3RlbmVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRyaWdnZXJUaHVtYnNFdmVudExpc3RlbmVyKG1ldGhvZCkge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5vcHRpb25zLnRodW1ibmFpbHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgZWw7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGVsID0gdGhpcy5vcHRpb25zLnRodW1ibmFpbHNbaV07XG4gICAgICAgICAgICAgICAgZWxbbWV0aG9kXSh0aGlzLm9wdGlvbnMudGh1bWJuYWlsQWN0aXZlVHJpZ2dlckV2ZW50LCB0aGlzLl90aHVtYm5haWxFdmVudExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXN0cm95cyB0aGUgaW5zdGFuY2UuXG4gICAgICAgICAqIEBtZW1iZXJPZiBDYXJvdXNlbFRodW1ic1xuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGVzdHJveScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgICAgdmFyIHRodW1icyA9IHRoaXMub3B0aW9ucy50aHVtYm5haWxzO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEluZGV4ID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aHVtYnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyVGh1bWJzRXZlbnRMaXN0ZW5lcigncmVtb3ZlRXZlbnRMaXN0ZW5lcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENhcm91c2VsVGh1bWJzO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDYXJvdXNlbFRodW1icztcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se31dLDYyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2Nhcm91c2VsVGh1bWJzID0gcmVxdWlyZSgnLi9jYXJvdXNlbC10aHVtYnMnKTtcblxudmFyIF9jYXJvdXNlbFRodW1iczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jYXJvdXNlbFRodW1icyk7XG5cbnZhciBfY2Fyb3VzZWxQYW5lbHMgPSByZXF1aXJlKCcuL2Nhcm91c2VsLXBhbmVscycpO1xuXG52YXIgX2Nhcm91c2VsUGFuZWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nhcm91c2VsUGFuZWxzKTtcblxudmFyIF9jYXJvdXNlbEFycm93cyA9IHJlcXVpcmUoJy4vY2Fyb3VzZWwtYXJyb3dzJyk7XG5cbnZhciBfY2Fyb3VzZWxBcnJvd3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2Fyb3VzZWxBcnJvd3MpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBmaXJlcyBhZnRlciBhIG5ldyBhY3RpdmUgcGFuZWwgaXMgc2V0XG4gKiBAY2FsbGJhY2sgQ2Fyb3VzZWx+b25QYW5lbENoYW5nZVxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBuZXcgcGFuZWxcbiAqL1xuXG4vKipcbiAqIEFkZHMgY2Fyb3VzZWwgZnVuY3Rpb25hbGl0eSB0byBhIHNldCB1cCBwcmUtZGV0ZXJtaW5lZCBIVE1MIG1hcmt1cC5cbiAqIEBjbGFzcyBDYXJvdXNlbFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIHBhc3NlZCBpbnRvIGluc3RhbmNlXG4gKiBAcGFyYW0ge0hUTUxDb2xsZWN0aW9ufSBvcHRpb25zLnBhbmVscyAtIFRoZSBwYW5lbHMgaW4gd2hpY2ggdG8gdXNlIGZvciB0aGUgY2Fyb3VzZWwgKGFuIGFycmF5IG9mIHBob3RvcylcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hc3NldExvYWRpbmdDbGFzc10gLSBUaGUgQ1NTIGNsYXNzIHRoYXQgZ2V0cyBhZGRlZCB0byBhbiBhc3NldCB3aGVuIGl0IGlzIGxvYWRpbmdcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYXV0b0xvYWRBc3NldHNdIC0gV2hldGhlciBvciBub3QgdG8gYXV0b21hdGljYWxseSBsb2FkIGFzc2V0cyB3aGVuIGFjdGl2ZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBhbmVsQWN0aXZlQ2xhc3NdIC0gVGhlIENTUyBjbGFzcyB0aGF0IGdldHMgYWRkZWQgdG8gYW4gcGFuZWwgd2hlbiBpdCBiZWNvbWVzIGFjdGl2ZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBhbmVsTG9hZGVkQ2xhc3NdIC0gVGhlIENTUyBjbGFzcyB0aGF0IGdldHMgYWRkZWQgdG8gYW4gcGFuZWwgd2hlbiBpdCBpcyBmdWxseSBsb2FkZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wYW5lbEJhY2tDbGFzc10gLSBUaGUgQ1NTIGNsYXNzIHRoYXQgZ2V0cyBhZGRlZCB0byBhbGwgcGFuZWwgZWxlbWVudHMgdGhhdCBhcHBlYXIgYmVmb3JlIHRoZSBjdXJyZW50IHBhbmVsXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGFuZWxGb3J3YXJkQ2xhc3NdIC0gVGhlIENTUyBjbGFzcyB0aGF0IGdldHMgYWRkZWQgdG8gYWxsIHBhbmVsIGVsZW1lbnRzIHRoYXQgYXBwZWFyIGFoZWFkIG9mIHRoZSBjdXJyZW50IHBhbmVsXG4gKiBAcGFyYW0ge0Nhcm91c2Vsfm9uUGFuZWxDaGFuZ2V9IFtvcHRpb25zLm9uUGFuZWxDaGFuZ2VdIC0gV2hlbiB0aGUgY3VycmVudCBwYW5lbCBpcyBjaGFuZ2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGF6eUxvYWRBdHRyXSAtIFRoZSBhdHRyaWJ1dGUgY29udGFpbmluZyB0aGUgdXJsIHBhdGggdG8gY29udGVudCB0aGF0IGlzIHRvIGJlIGxhenkgbG9hZGVkXG4gKiBAcGFyYW0ge0hUTUxDb2xsZWN0aW9ufSBbb3B0aW9ucy50aHVtYm5haWxzXSAtIEEgY29sbGVjdGlvbiBvZiBlbGVtZW50cyB0aGF0IGFyZSB0aGUgdGh1bWJuYWlsc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRodW1ibmFpbEFjdGl2ZUNsYXNzXSAtIFRoZSBDU1MgY2xhc3MgdGhhdCBnZXRzIGFkZGVkIHRvIGEgdGh1bWJuYWlsIGVsZW1lbnQgd2hlbiBpdCBiZWNvbWVzIGFjdGl2ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmluaXRpYWxJbmRleF0gLSBUaGUgaW5kZXggb2YgdGhlIHBhbmVsIHRvIGdvIHRvIHVwb24gaW5zdGFudGlhdGlvbiAoaWYgbm90IGRlY2xhcmVkLCBnb1RvKCkgbXVzdCBiZSBjYWxsZWQgbWFudWFsbHkpLlxuICovXG5cbnZhciBDYXJvdXNlbCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgc3R1ZmYuXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDYXJvdXNlbChvcHRpb25zKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYXJvdXNlbCk7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgLy8gaWYgdW5kZWZpbmVkIG9yIG51bGwgaXMgcGFzc2VkIGluIG9wdGlvbnMgZm9yIHBhbmVscyBvciB0aHVtYm5haWxzLFxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHNhbml0aXplIGl0IHRvIGFuIGVtcHR5IGFycmF5IHRvIHByZXZlbnQgYSBjcmFzaFxuICAgICAgICBpZiAoIW9wdGlvbnMucGFuZWxzKSB7XG4gICAgICAgICAgICBvcHRpb25zLnBhbmVscyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucy50aHVtYm5haWxzKSB7XG4gICAgICAgICAgICBvcHRpb25zLnRodW1ibmFpbHMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMgPSBfZXh0ZW5kcyh7XG4gICAgICAgICAgICBwYW5lbHM6IFtdLFxuICAgICAgICAgICAgYXNzZXRMb2FkaW5nQ2xhc3M6ICdjYXJvdXNlbC1hc3NldC1sb2FkaW5nJyxcbiAgICAgICAgICAgIGF1dG9Mb2FkQXNzZXRzOiB0cnVlLFxuICAgICAgICAgICAgcGFuZWxBY3RpdmVDbGFzczogJ2Nhcm91c2VsLXBhbmVsLWFjdGl2ZScsXG4gICAgICAgICAgICBwYW5lbExvYWRlZENsYXNzOiAnY2Fyb3VzZWwtcGFuZWwtbG9hZGVkJyxcbiAgICAgICAgICAgIHBhbmVsQmFja0NsYXNzOiAnY2Fyb3VzZWwtcGFuZWwtYmVoaW5kJyxcbiAgICAgICAgICAgIHBhbmVsRm9yd2FyZENsYXNzOiAnY2Fyb3VzZWwtcGFuZWwtYWhlYWQnLFxuICAgICAgICAgICAgb25QYW5lbENoYW5nZTogbnVsbCxcbiAgICAgICAgICAgIGxhenlMb2FkQXR0cjogJ2RhdGEtc3JjJyxcbiAgICAgICAgICAgIHRodW1ibmFpbHM6IFtdLFxuICAgICAgICAgICAgdGh1bWJuYWlsQWN0aXZlVHJpZ2dlckV2ZW50OiAnY2xpY2snLFxuICAgICAgICAgICAgdGh1bWJuYWlsQWN0aXZlQ2xhc3M6ICdjYXJvdXNlbC10aHVtYm5haWwtYWN0aXZlJyxcbiAgICAgICAgICAgIGluaXRpYWxJbmRleDogMCxcbiAgICAgICAgICAgIGxlZnRBcnJvdzogbnVsbCxcbiAgICAgICAgICAgIHJpZ2h0QXJyb3c6IG51bGwsXG4gICAgICAgICAgICBhcnJvd0FjdGl2ZUNsYXNzOiAnY2Fyb3VzZWwtYXJyb3ctYWN0aXZlJyxcbiAgICAgICAgICAgIGFycm93RGlzYWJsZWRDbGFzczogJ2Nhcm91c2VsLWFycm93LWRpc2FibGVkJyxcbiAgICAgICAgICAgIG9uTGVmdEFycm93Q2xpY2s6IG51bGwsXG4gICAgICAgICAgICBvblJpZ2h0QXJyb3dDbGljazogbnVsbFxuICAgICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnN1Yk1vZHVsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fY2hlY2tGb3JJbml0RXJyb3JzKCk7XG4gICAgICAgIHRoaXMuc2V0dXAoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSBjYXJvdXNlbCBpbnN0YW5jZSBhbmQgYWxsIGNvbnRyb2xzLlxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoQ2Fyb3VzZWwsIFt7XG4gICAgICAgIGtleTogJ3NldHVwJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwKCkge1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuc3ViTW9kdWxlcy5wYW5lbHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1Yk1vZHVsZXMucGFuZWxzID0gdGhpcy5fc2V0dXBQYW5lbHModGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50aHVtYm5haWxzLmxlbmd0aCAmJiAhdGhpcy5zdWJNb2R1bGVzLnRodW1ibmFpbHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1Yk1vZHVsZXMudGh1bWJuYWlscyA9IHRoaXMuX3NldHVwVGh1bWJzKHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgodGhpcy5vcHRpb25zLmxlZnRBcnJvdyB8fCB0aGlzLm9wdGlvbnMucmlnaHRBcnJvdykgJiYgIXRoaXMuc3ViTW9kdWxlcy5hcnJvd3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1Yk1vZHVsZXMuYXJyb3dzID0gdGhpcy5fc2V0dXBBcnJvd3ModGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuaW5pdGlhbEluZGV4ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZ29Ubyh0aGlzLm9wdGlvbnMuaW5pdGlhbEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHVwIHRoZSBjYXJvdXNlbCB0aHVtYnMuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIGluaXRpYWxpemUgb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJuIHtDYXJvdXNlbFRodW1ic30gUmV0dXJucyB0aHVtYm5haWwgaW5zdGFuY2VcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19zZXR1cFRodW1icycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBUaHVtYnMob3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBfY2Fyb3VzZWxUaHVtYnMyLmRlZmF1bHQoX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogdGhpcy5vblRodW1ibmFpbENoYW5nZS5iaW5kKHRoaXMpXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB1cCB0aGUgY2Fyb3VzZWwgcGFuZWxzLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBpbml0aWFsaXplIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybiB7Q2Fyb3VzZWxQYW5lbHN9IFJldHVybnMgcGFuZWxzIGluc3RhbmNlXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfc2V0dXBQYW5lbHMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwUGFuZWxzKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBhbmVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IF9jYXJvdXNlbFBhbmVsczIuZGVmYXVsdChfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTogdGhpcy5vblBhbmVsQ2hhbmdlLmJpbmQodGhpcylcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB1cCB0aGUgY2Fyb3VzZWwgYXJyb3dzLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBpbml0aWFsaXplIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybiB7Q2Fyb3VzZWxBcnJvd3N9IFJldHVybnMgYXJyb3dzIGluc3RhbmNlXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfc2V0dXBBcnJvd3MnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwQXJyb3dzKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBpbnRlcm5hbE9wdGlvbnM7XG4gICAgICAgICAgICAvLyBtYWtlIGNsb25lIG9mIG9yaWdpbmFsIG9wdGlvbnNcbiAgICAgICAgICAgIGludGVybmFsT3B0aW9ucyA9IF9leHRlbmRzKHt9LCBvcHRpb25zKTtcblxuICAgICAgICAgICAgaW50ZXJuYWxPcHRpb25zLm9uTGVmdEFycm93Q2xpY2sgPSB0aGlzLm9uTGVmdEFycm93Q2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgICAgIGludGVybmFsT3B0aW9ucy5vblJpZ2h0QXJyb3dDbGljayA9IHRoaXMub25SaWdodEFycm93Q2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgX2Nhcm91c2VsQXJyb3dzMi5kZWZhdWx0KGludGVybmFsT3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGZvciBlcnJvcnMgdXBvbiBpbml0aWFsaXplLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2NoZWNrRm9ySW5pdEVycm9ycycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tGb3JJbml0RXJyb3JzKCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgcGFuZWxDb3VudCA9IG9wdGlvbnMucGFuZWxzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICB0aHVtYm5haWxDb3VudCA9IG9wdGlvbnMudGh1bWJuYWlscy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodGh1bWJuYWlsQ291bnQgJiYgdGh1bWJuYWlsQ291bnQgIT09IHBhbmVsQ291bnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2Nhcm91c2VsIHdhcm5pbmc6IG51bWJlciBvZiB0aHVtYm5haWxzIHBhc3NlZCBpbiBjb25zdHJ1Y3RvciBkbyBub3QgZXF1YWwgdGhlIG51bWJlciBvZiBwYW5lbHMnICsgJ1xcbicgKyAncGFuZWxzOiAnICsgcGFuZWxDb3VudCArICdcXG4nICsgJ3RodW1ibmFpbHM6ICcgKyB0aHVtYm5haWxDb3VudCArICdcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIGEgcGFuZWwgaW5kZXggY2hhbmdlcy5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIG5ldyBpbmRleFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnb25QYW5lbENoYW5nZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblBhbmVsQ2hhbmdlKGluZGV4KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdWJNb2R1bGVzLnRodW1ibmFpbHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1Yk1vZHVsZXMudGh1bWJuYWlscy5nb1RvKGluZGV4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuc3ViTW9kdWxlcy5hcnJvd3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1Yk1vZHVsZXMuYXJyb3dzLnVwZGF0ZShpbmRleCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMub25QYW5lbENoYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vblBhbmVsQ2hhbmdlKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIHRoZSB0aHVtYm5haWwgaW5kZXggY2hhbmdlcy5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIG5ldyBpbmRleFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnb25UaHVtYm5haWxDaGFuZ2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25UaHVtYm5haWxDaGFuZ2UoaW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuZ29UbyhpbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiB0aGUgcmlnaHQgYXJyb3cgb2YgdGhlIGNhcm91c2VsIGlzIGNsaWNrZWQuXG4gICAgICAgICAqIEBwYXJhbSBlXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdvblJpZ2h0QXJyb3dDbGljaycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblJpZ2h0QXJyb3dDbGljayhlKSB7XG4gICAgICAgICAgICB0aGlzLmdvVG8odGhpcy5zdWJNb2R1bGVzLnBhbmVscy5nZXRDdXJyZW50SW5kZXgoKSArIDEpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vblJpZ2h0QXJyb3dDbGljaykge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vblJpZ2h0QXJyb3dDbGljayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIHRoZSBsZWZ0IGFycm93IG9mIHRoZSBjYXJvdXNlbCBpcyBjbGlja2VkLlxuICAgICAgICAgKiBAcGFyYW0gZVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnb25MZWZ0QXJyb3dDbGljaycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkxlZnRBcnJvd0NsaWNrKGUpIHtcbiAgICAgICAgICAgIHRoaXMuZ29Ubyh0aGlzLnN1Yk1vZHVsZXMucGFuZWxzLmdldEN1cnJlbnRJbmRleCgpIC0gMSk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9uTGVmdEFycm93Q2xpY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub25MZWZ0QXJyb3dDbGljayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFuc2l0aW9uIHRvIGEgbmV3IHBhbmVsIGFuZCB0aHVtYm5haWwuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBudW1iZXIgdG8gZ28gdG9cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dvVG8nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ29UbyhpbmRleCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgbWF4SW5kZXggPSBvcHRpb25zLnBhbmVscy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgIG1pbkluZGV4ID0gMDtcblxuICAgICAgICAgICAgaWYgKGluZGV4ID4gbWF4SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBzZXQgdG8gZmlyc3QgaW5kZXggaWYgdG9vIGhpZ2hcbiAgICAgICAgICAgICAgICBpbmRleCA9IG1pbkluZGV4O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA8IG1pbkluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gc2V0IHRvIGxhc3QgaW5kZXggaWYgdG9vIGxvd1xuICAgICAgICAgICAgICAgIGluZGV4ID0gbWF4SW5kZXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnN1Yk1vZHVsZXMudGh1bWJuYWlscykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3ViTW9kdWxlcy50aHVtYm5haWxzLmdvVG8oaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3ViTW9kdWxlcy5hcnJvd3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1Yk1vZHVsZXMuYXJyb3dzLnVwZGF0ZShpbmRleCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnN1Yk1vZHVsZXMucGFuZWxzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ViTW9kdWxlcy5wYW5lbHMuZ29UbyhpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgY3VycmVudCBpbmRleCB0aGF0IGlzIHNob3dpbmcuXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgdGhlIGluZGV4XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRDdXJyZW50SW5kZXgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q3VycmVudEluZGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ViTW9kdWxlcy5wYW5lbHMuZ2V0Q3VycmVudEluZGV4KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogTW92ZXMgY2Fyb3VzZWwgdG8gbmV4dCBwYW5lbC5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ25leHQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgIHRoaXMuZ29Ubyh0aGlzLmdldEN1cnJlbnRJbmRleCgpICsgMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogTW92ZXMgdG8gcHJldmlvdXMgY2Fyb3VzZWwgcGFuZWwuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdwcmV2JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByZXYoKSB7XG4gICAgICAgICAgICB0aGlzLmdvVG8odGhpcy5nZXRDdXJyZW50SW5kZXgoKSAtIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlc3Ryb3lzIGFsbCBzdWIgbW9kdWxlcy5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnN1Yk1vZHVsZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdWJNb2R1bGVzLmhhc093blByb3BlcnR5KGtleSkgJiYgdGhpcy5zdWJNb2R1bGVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJNb2R1bGVzW2tleV0uZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDYXJvdXNlbDtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQ2Fyb3VzZWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG59LHtcIi4vY2Fyb3VzZWwtYXJyb3dzXCI6NTgsXCIuL2Nhcm91c2VsLXBhbmVsc1wiOjYwLFwiLi9jYXJvdXNlbC10aHVtYnNcIjo2MX1dLDYzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblxufSx7fV0sNjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIFNwbGl0IGEgZmlsZW5hbWUgaW50byBbcm9vdCwgZGlyLCBiYXNlbmFtZSwgZXh0XSwgdW5peCB2ZXJzaW9uXG4vLyAncm9vdCcgaXMganVzdCBhIHNsYXNoLCBvciBub3RoaW5nLlxudmFyIHNwbGl0UGF0aFJlID1cbiAgICAvXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztcbnZhciBzcGxpdFBhdGggPSBmdW5jdGlvbihmaWxlbmFtZSkge1xuICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSk7XG59O1xuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciByZXN1bHQgPSBzcGxpdFBhdGgocGF0aCksXG4gICAgICByb290ID0gcmVzdWx0WzBdLFxuICAgICAgZGlyID0gcmVzdWx0WzFdO1xuXG4gIGlmICghcm9vdCAmJiAhZGlyKSB7XG4gICAgLy8gTm8gZGlybmFtZSB3aGF0c29ldmVyXG4gICAgcmV0dXJuICcuJztcbiAgfVxuXG4gIGlmIChkaXIpIHtcbiAgICAvLyBJdCBoYXMgYSBkaXJuYW1lLCBzdHJpcCB0cmFpbGluZyBzbGFzaFxuICAgIGRpciA9IGRpci5zdWJzdHIoMCwgZGlyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIHJvb3QgKyBkaXI7XG59O1xuXG5cbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbihwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBzcGxpdFBhdGgocGF0aClbMl07XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBjb21wYXJpc29uIGNhc2UtaW5zZW5zaXRpdmUgb24gd2luZG93cz9cbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gc3BsaXRQYXRoKHBhdGgpWzNdO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcbn0se1wiX3Byb2Nlc3NcIjo2NX1dLDY1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cbn0se31dfSx7fSxbNjJdKSg2Milcbn0pOyJdfQ==\n\n/* global\n    hide\n    toggle\n */\n'use strict';\n\n(function () {\n  /**\n               * Render the FAQ questions from a file located at /faq.js.\n               */\n  window.renderFAQ = function () {\n    /**\n                                   * Destination of all FAQ items\n                                   * @type {Element}\n                                   */\n    var _destination = document.getElementsByClassName('faq-placeholder')[0];\n\n    /**\n                                                                               * Template for each wrapper section, including an image.\n                                                                               * @type {Element}\n                                                                               */\n    var _section = document.getElementsByClassName('template faq-section')[0];\n    bootstrapTemplate(_section);\n\n    /**\n                                  * Template for each wrapper subsection, including an image.\n                                  * @type {Element}\n                                  */\n    var _subsection =\n    document.getElementsByClassName('template faq-subsection')[0];\n    bootstrapTemplate(_subsection);\n\n    /**\n                                     * Template for each question.\n                                     * @type {[type]}\n                                     */\n    var _question = document.\n    getElementsByClassName('template faq-question')[0];\n    bootstrapTemplate(_question);\n\n    for (var sectionTitle in window.faq) {\n      // Since we're working with a global obj, let's make sure we're not\n      // screwed by accidental prototyping.\n      if (!window.faq.hasOwnProperty(sectionTitle)) {\n        continue;\n      }\n\n      /** @type {object} Shortcut  */\n      var section = window.faq[sectionTitle];\n\n      /** @type {Element} The new section where we're putting the FAQ elements */\n      var _thisSection = _section.cloneNode(true);\n\n      // Fill in template data\n      _thisSection.querySelectorAll('h1')[0].innerHTML = sectionTitle;\n      _thisSection.querySelectorAll('img')[0].src = section.image;\n\n      var _thisDestination = _thisSection.querySelectorAll('.faq-content')[0];\n\n      for (var subsectionTitle in section.questions) {\n        if (!section.questions.hasOwnProperty(subsectionTitle)) {\n          continue;\n        }\n\n        /** @type {object,string} The set of either subsections or questions */\n        var subsection = section.questions[subsectionTitle];\n\n        if (typeof subsection === 'string') {\n          // we have a question\n          addQuestion(subsectionTitle, subsection, _thisDestination);\n        } else {\n          // we have a subsection\n          var _thisSubsection = _subsection.cloneNode(true);\n\n          _thisSubsection.querySelectorAll('h2')[0].innerHTML = subsectionTitle;\n\n          for (var question in subsection) {\n            if (!subsection.hasOwnProperty(question)) {\n              continue;\n            }\n\n            addQuestion(question, subsection[question], _thisSubsection);\n          }\n\n          _thisDestination.appendChild(_thisSubsection);\n        }\n      }\n      // Finally, append to the DOM.\n      _destination.appendChild(_thisSection);\n    }\n\n    /**\n       * Bootstrap a template by removing it from the dom and removing the template class.\n       *\n       * @param {Element} domNode The domNode to bootstrap into a template\n       */\n    function bootstrapTemplate(domNode) {\n      // Remove from DOM\n      domNode.parentNode.removeChild(domNode);\n\n      // Remove the template class\n      domNode.className = domNode.className.replace('template', '');\n    }\n\n    /**\n       * Add a question using the global question template to an Element, appendTo.\n       * @param {string} question question\n       * @param {string} answer answer\n       * @param {Element} appendTo Element to append the question to\n       */\n    function addQuestion(question, answer, appendTo) {\n      var _thisQuestion = _question.cloneNode(true);\n\n      _thisQuestion.querySelectorAll('h3')[0].innerHTML = question;\n      _thisQuestion.querySelectorAll('p')[0].innerHTML = answer;\n\n      appendTo.appendChild(_thisQuestion);\n    }\n  };\n\n  /**\n      * Bind click events and hide elements from the FAQ\n      */\n  window.bindFAQ = function () {\n    var select = '.faq-content';\n\n    var allElements = document.querySelectorAll(select);\n    hide(allElements);\n\n    allElements.forEach(function (e) {\n      e.style.cursor = 'auto';\n\n      // Prevent the click listener on the parent from affecting this (i.e. re-hiding this element)\n      e.addEventListener('click', function (event) {\n        event.stopPropagation();\n      });\n    });\n\n    var sections = document.querySelectorAll('.faq-section');\n    sections.forEach(function (e) {\n      e.style.cursor = 'pointer';\n\n      e.addEventListener('click', function () {\n        this.querySelectorAll(select).forEach(toggle);\n      });\n    });\n  };\n})();\n//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZhcS5qcyJdLCJuYW1lcyI6WyJ3aW5kb3ciLCJyZW5kZXJGQVEiLCJfZGVzdGluYXRpb24iLCJkb2N1bWVudCIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJfc2VjdGlvbiIsImJvb3RzdHJhcFRlbXBsYXRlIiwiX3N1YnNlY3Rpb24iLCJfcXVlc3Rpb24iLCJzZWN0aW9uVGl0bGUiLCJmYXEiLCJoYXNPd25Qcm9wZXJ0eSIsInNlY3Rpb24iLCJfdGhpc1NlY3Rpb24iLCJjbG9uZU5vZGUiLCJxdWVyeVNlbGVjdG9yQWxsIiwiaW5uZXJIVE1MIiwic3JjIiwiaW1hZ2UiLCJfdGhpc0Rlc3RpbmF0aW9uIiwic3Vic2VjdGlvblRpdGxlIiwicXVlc3Rpb25zIiwic3Vic2VjdGlvbiIsImFkZFF1ZXN0aW9uIiwiX3RoaXNTdWJzZWN0aW9uIiwicXVlc3Rpb24iLCJhcHBlbmRDaGlsZCIsImRvbU5vZGUiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJjbGFzc05hbWUiLCJyZXBsYWNlIiwiYW5zd2VyIiwiYXBwZW5kVG8iLCJfdGhpc1F1ZXN0aW9uIiwiYmluZEZBUSIsInNlbGVjdCIsImFsbEVsZW1lbnRzIiwiaGlkZSIsImZvckVhY2giLCJlIiwic3R5bGUiLCJjdXJzb3IiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJzdG9wUHJvcGFnYXRpb24iLCJzZWN0aW9ucyIsInRvZ2dsZSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7QUFJQTs7QUFFQSxDQUFDLFlBQVc7QUFDVjs7O0FBR0FBLFNBQU9DLFNBQVAsR0FBbUIsWUFBTTtBQUN2Qjs7OztBQUlBLFFBQU1DLGVBQWVDLFNBQVNDLHNCQUFULENBQWdDLGlCQUFoQyxFQUFtRCxDQUFuRCxDQUFyQjs7QUFFQTs7OztBQUlBLFFBQU1DLFdBQVdGLFNBQVNDLHNCQUFULENBQWdDLHNCQUFoQyxFQUF3RCxDQUF4RCxDQUFqQjtBQUNBRSxzQkFBa0JELFFBQWxCOztBQUVBOzs7O0FBSUEsUUFBTUU7QUFD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LFFBQU1DLFNBQVMsY0FBZjs7QUFFQSxRQUFNQyxjQUFjbEMsU0FBU1ksZ0JBQVQsQ0FBMEJxQixNQUExQixDQUFwQjtBQUNBRSxTQUFLRCxXQUFMOztBQUVBQSxnQkFBWUUsT0FBWixDQUFvQixVQUFDQyxDQUFELEVBQU87QUFDekJBLFFBQUVDLEtBQUYsQ0FBUUMsTUFBUixHQUFpQixNQUFqQjs7QUFFQTtBQUNBRixRQUFFRyxnQkFBRixDQUFtQixPQUFuQixFQUE0QixVQUFTQyxLQUFULEVBQWdCO0FBQzFDQSxjQUFNQyxlQUFOO0FBQ0QsT0FGRDtBQUdELEtBUEQ7O0FBU0EsUUFBTUMsV0FBVzNDLFNBQVNZLGdCQUFULENBQTBCLGNBQTFCLENBQWpCO0FBQ0ErQixhQUFTUCxPQUFULENBQWlCLFVBQUNDLENBQUQsRUFBTztBQUN0QkEsUUFBRUMsS0FBRixDQUFRQyxNQUFSLEdBQWlCLFNBQWpCOztBQUVBRixRQUFFRyxnQkFBRixDQUFtQixPQUFuQixFQUE0QixZQUFXO0FBQ3JDLGFBQUs1QixnQkFBTCxDQUFzQnFCLE1BQXRCLEVBQThCRyxPQUE5QixDQUFzQ1EsTUFBdEM7QUFDRCxPQUZEO0FBR0QsS0FORDtBQU9ELEdBdkJEO0FBd0JELENBN0lEIiwiZmlsZSI6ImZhcS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbFxuICAgIGhpZGVcbiAgICB0b2dnbGVcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4oZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIEZBUSBxdWVzdGlvbnMgZnJvbSBhIGZpbGUgbG9jYXRlZCBhdCAvZmFxLmpzLlxuICAgKi9cbiAgd2luZG93LnJlbmRlckZBUSA9ICgpID0+IHtcbiAgICAvKipcbiAgICAgKiBEZXN0aW5hdGlvbiBvZiBhbGwgRkFRIGl0ZW1zXG4gICAgICogQHR5cGUge0VsZW1lbnR9XG4gICAgICovXG4gICAgY29uc3QgX2Rlc3RpbmF0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZmFxLXBsYWNlaG9sZGVyJylbMF07XG5cbiAgICAvKipcbiAgICAgKiBUZW1wbGF0ZSBmb3IgZWFjaCB3cmFwcGVyIHNlY3Rpb24sIGluY2x1ZGluZyBhbiBpbWFnZS5cbiAgICAgKiBAdHlwZSB7RWxlbWVudH1cbiAgICAgKi9cbiAgICBjb25zdCBfc2VjdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3RlbXBsYXRlIGZhcS1zZWN0aW9uJylbMF07XG4gICAgYm9vdHN0cmFwVGVtcGxhdGUoX3NlY3Rpb24pO1xuXG4gICAgLyoqXG4gICAgICogVGVtcGxhdGUgZm9yIGVhY2ggd3JhcHBlciBzdWJzZWN0aW9uLCBpbmNsdWRpbmcgYW4gaW1hZ2UuXG4gICAgICogQHR5cGUge0VsZW1lbnR9XG4gICAgICovXG4gICAgY29uc3QgX3N1YnNlY3Rpb24gPVxuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgndGVtcGxhdGUgZmFxLXN1YnNlY3Rpb24nKVswXTtcbiAgICBib290c3RyYXBUZW1wbGF0ZShfc3Vic2VjdGlvbik7XG5cbiAgICAvKipcbiAgICAgKiBUZW1wbGF0ZSBmb3IgZWFjaCBxdWVzdGlvbi5cbiAgICAgKiBAdHlwZSB7W3R5cGVdfVxuICAgICAqL1xuICAgIGNvbnN0IF9xdWVzdGlvbiA9IGRvY3VtZW50XG4gICAgICAuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgndGVtcGxhdGUgZmFxLXF1ZXN0aW9uJylbMF07XG4gICAgYm9vdHN0cmFwVGVtcGxhdGUoX3F1ZXN0aW9uKTtcblxuICAgIGZvciAobGV0IHNlY3Rpb25UaXRsZSBpbiB3aW5kb3cuZmFxKSB7XG4gICAgICAvLyBTaW5jZSB3ZSdyZSB3b3JraW5nIHdpdGggYSBnbG9iYWwgb2JqLCBsZXQncyBtYWtlIHN1cmUgd2UncmUgbm90XG4gICAgICAvLyBzY3Jld2VkIGJ5IGFjY2lkZW50YWwgcHJvdG90eXBpbmcuXG4gICAgICBpZiAoIXdpbmRvdy5mYXEuaGFzT3duUHJvcGVydHkoc2VjdGlvblRpdGxlKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLyoqIEB0eXBlIHtvYmplY3R9IFNob3J0Y3V0ICAqL1xuICAgICAgY29uc3Qgc2VjdGlvbiA9IHdpbmRvdy5mYXFbc2VjdGlvblRpdGxlXTtcblxuICAgICAgLyoqIEB0eXBlIHtFbGVtZW50fSBUaGUgbmV3IHNlY3Rpb24gd2hlcmUgd2UncmUgcHV0dGluZyB0aGUgRkFRIGVsZW1lbnRzICovXG4gICAgICBjb25zdCBfdGhpc1NlY3Rpb24gPSBfc2VjdGlvbi5jbG9uZU5vZGUodHJ1ZSk7XG5cbiAgICAgIC8vIEZpbGwgaW4gdGVtcGxhdGUgZGF0YVxuICAgICAgX3RoaXNTZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ2gxJylbMF0uaW5uZXJIVE1MID0gc2VjdGlvblRpdGxlO1xuICAgICAgX3RoaXNTZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ2ltZycpWzBdLnNyYyA9IHNlY3Rpb24uaW1hZ2U7XG5cbiAgICAgIGNvbnN0IF90aGlzRGVzdGluYXRpb24gPSBfdGhpc1NlY3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnLmZhcS1jb250ZW50JylbMF07XG5cbiAgICAgIGZvciAobGV0IHN1YnNlY3Rpb25UaXRsZSBpbiBzZWN0aW9uLnF1ZXN0aW9ucykge1xuICAgICAgICBpZiAoIXNlY3Rpb24ucXVlc3Rpb25zLmhhc093blByb3BlcnR5KHN1YnNlY3Rpb25UaXRsZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAdHlwZSB7b2JqZWN0LHN0cmluZ30gVGhlIHNldCBvZiBlaXRoZXIgc3Vic2VjdGlvbnMgb3IgcXVlc3Rpb25zICovXG4gICAgICAgIGNvbnN0IHN1YnNlY3Rpb24gPSBzZWN0aW9uLnF1ZXN0aW9uc1tzdWJzZWN0aW9uVGl0bGVdO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygc3Vic2VjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyB3ZSBoYXZlIGEgcXVlc3Rpb25cbiAgICAgICAgICBhZGRRdWVzdGlvbihzdWJzZWN0aW9uVGl0bGUsIHN1YnNlY3Rpb24sIF90aGlzRGVzdGluYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHdlIGhhdmUgYSBzdWJzZWN0aW9uXG4gICAgICAgICAgY29uc3QgX3RoaXNTdWJzZWN0aW9uID0gX3N1YnNlY3Rpb24uY2xvbmVOb2RlKHRydWUpO1xuXG4gICAgICAgICAgX3RoaXNTdWJzZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ2gyJylbMF0uaW5uZXJIVE1MID0gc3Vic2VjdGlvblRpdGxlO1xuXG4gICAgICAgICAgZm9yIChsZXQgcXVlc3Rpb24gaW4gc3Vic2VjdGlvbikge1xuICAgICAgICAgICAgaWYgKCFzdWJzZWN0aW9uLmhhc093blByb3BlcnR5KHF1ZXN0aW9uKSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYWRkUXVlc3Rpb24ocXVlc3Rpb24sIHN1YnNlY3Rpb25bcXVlc3Rpb25dLCBfdGhpc1N1YnNlY3Rpb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzRGVzdGluYXRpb24uYXBwZW5kQ2hpbGQoX3RoaXNTdWJzZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRmluYWxseSwgYXBwZW5kIHRvIHRoZSBET00uXG4gICAgICBfZGVzdGluYXRpb24uYXBwZW5kQ2hpbGQoX3RoaXNTZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCb290c3RyYXAgYSB0ZW1wbGF0ZSBieSByZW1vdmluZyBpdCBmcm9tIHRoZSBkb20gYW5kIHJlbW92aW5nIHRoZSB0ZW1wbGF0ZSBjbGFzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZG9tTm9kZSBUaGUgZG9tTm9kZSB0byBib290c3RyYXAgaW50byBhIHRlbXBsYXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYm9vdHN0cmFwVGVtcGxhdGUoZG9tTm9kZSkge1xuICAgICAgLy8gUmVtb3ZlIGZyb20gRE9NXG4gICAgICBkb21Ob2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tTm9kZSk7XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgdGVtcGxhdGUgY2xhc3NcbiAgICAgIGRvbU5vZGUuY2xhc3NOYW1lID0gZG9tTm9kZS5jbGFzc05hbWUucmVwbGFjZSgndGVtcGxhdGUnLCAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgcXVlc3Rpb24gdXNpbmcgdGhlIGdsb2JhbCBxdWVzdGlvbiB0ZW1wbGF0ZSB0byBhbiBFbGVtZW50LCBhcHBlbmRUby5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlc3Rpb24gcXVlc3Rpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYW5zd2VyIGFuc3dlclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gYXBwZW5kVG8gRWxlbWVudCB0byBhcHBlbmQgdGhlIHF1ZXN0aW9uIHRvXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkUXVlc3Rpb24ocXVlc3Rpb24sIGFuc3dlciwgYXBwZW5kVG8pIHtcbiAgICAgIGNvbnN0IF90aGlzUXVlc3Rpb24gPSBfcXVlc3Rpb24uY2xvbmVOb2RlKHRydWUpO1xuXG4gICAgICBfdGhpc1F1ZXN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ2gzJylbMF0uaW5uZXJIVE1MID0gcXVlc3Rpb247XG4gICAgICBfdGhpc1F1ZXN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ3AnKVswXS5pbm5lckhUTUwgPSBhbnN3ZXI7XG5cbiAgICAgIGFwcGVuZFRvLmFwcGVuZENoaWxkKF90aGlzUXVlc3Rpb24pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQmluZCBjbGljayBldmVudHMgYW5kIGhpZGUgZWxlbWVudHMgZnJvbSB0aGUgRkFRXG4gICAqL1xuICB3aW5kb3cuYmluZEZBUSA9ICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3QgPSAnLmZhcS1jb250ZW50JztcblxuICAgIGNvbnN0IGFsbEVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3QpO1xuICAgIGhpZGUoYWxsRWxlbWVudHMpO1xuXG4gICAgYWxsRWxlbWVudHMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZS5zdHlsZS5jdXJzb3IgPSAnYXV0byc7XG5cbiAgICAgIC8vIFByZXZlbnQgdGhlIGNsaWNrIGxpc3RlbmVyIG9uIHRoZSBwYXJlbnQgZnJvbSBhZmZlY3RpbmcgdGhpcyAoaS5lLiByZS1oaWRpbmcgdGhpcyBlbGVtZW50KVxuICAgICAgZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBzZWN0aW9ucyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5mYXEtc2VjdGlvbicpO1xuICAgIHNlY3Rpb25zLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGUuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuXG4gICAgICBlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucXVlcnlTZWxlY3RvckFsbChzZWxlY3QpLmZvckVhY2godG9nZ2xlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufSkoKTtcbiJdfQ==\n\n/* global\n    Carousel\n */\n'use strict';\n\n(function () {\n  /**\n               * Render the carousel.\n               */\n  window.renderCarousel = function () {\n    new Carousel({\n      panels: document.getElementsByClassName('carousel-panel'),\n      leftArrow: document.getElementsByClassName('carousel-left')[0],\n      rightArrow: document.getElementsByClassName('carousel-right')[0] });\n\n\n    // setInterval(() => {\n    //   carousel.next();\n    // }, 5000);\n  };\n})();\n//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImltYWdlLWNhcm91c2VsLmpzIl0sIm5hbWVzIjpbIndpbmRvdyIsInJlbmRlckNhcm91c2VsIiwiQ2Fyb3VzZWwiLCJwYW5lbHMiLCJkb2N1bWVudCIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJsZWZ0QXJyb3ciLCJyaWdodEFycm93Il0sIm1hcHBpbmdzIjoiQUFBQTs7O0FBR0E7O0FBRUEsQ0FBQyxZQUFXO0FBQ1Y7OztBQUdBQSxTQUFPQyxjQUFQLEdBQXdCLFlBQU07QUFDNUIsUUFBSUMsUUFBSixDQUFhO0FBQ1hDLGNBQVFDLFNBQVNDLHNCQUFULENBQWdDLGdCQUFoQyxDQURHO0FBRVhDLGlCQUFXRixTQUFTQyxzQkFBVCxDQUFnQyxlQUFoQyxFQUFpRCxDQUFqRCxDQUZBO0FBR1hFLGtCQUFZSCxTQUFTQyxzQkFBVCxDQUFnQyxnQkFBaEMsRUFBa0QsQ0FBbEQsQ0FIRCxFQUFiOzs7QUFNQTtBQUNBO0FBQ0E7QUFDRCxHQVZEO0FBV0QsQ0FmRCIsImZpbGUiOiJpbWFnZS1jYXJvdXNlbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbFxuICAgIENhcm91c2VsXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuKGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICogUmVuZGVyIHRoZSBjYXJvdXNlbC5cbiAgICovXG4gIHdpbmRvdy5yZW5kZXJDYXJvdXNlbCA9ICgpID0+IHtcbiAgICBuZXcgQ2Fyb3VzZWwoe1xuICAgICAgcGFuZWxzOiBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjYXJvdXNlbC1wYW5lbCcpLFxuICAgICAgbGVmdEFycm93OiBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjYXJvdXNlbC1sZWZ0JylbMF0sXG4gICAgICByaWdodEFycm93OiBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjYXJvdXNlbC1yaWdodCcpWzBdLFxuICAgIH0pO1xuXG4gICAgLy8gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgIC8vICAgY2Fyb3VzZWwubmV4dCgpO1xuICAgIC8vIH0sIDUwMDApO1xuICB9O1xufSkoKTtcbiJdfQ==\n\n'use strict';\n\n(function () {\n  var MESSAGE_URL = 'http://www.crisistextline.org/trends/data/messages.txt';\n  var messageDiv = document.getElementById('message-count');\n\n  var currentVal = parseInt(messageDiv.innerHTML.replace(/,/g, ''), 10);\n\n  window.getMessageCount = function () {\n    var xhr = new XMLHttpRequest();\n\n    xhr.addEventListener('load', function () {\n      if (xhr.status === 200) {\n        incrementValue(xhr.responseText);\n      } else {\n        fail();\n      }\n    });\n\n    xhr.addEventListener('error', function () {\n      fail();\n    });\n\n    xhr.open('GET', MESSAGE_URL);\n    xhr.send();\n  };\n\n  /**\n      * Failure handler for a failed XHR request. Let's just populate with a sane,\n      * true-enough value.\n      */\n  function fail() {\n    incrementValue('27212575');\n  }\n\n  /**\n     * Increment the current value by the difference from current to desired / 2.\n     *\n     * @param  {integer} intVal Value we're shooting for\n     */\n  function incrementValue(intVal) {\n    intVal = parseInt(intVal, 10);\n\n    var difference = intVal - currentVal;\n\n    currentVal += Math.ceil(difference / 2);\n\n    updateDisplay();\n\n    if (currentVal !== intVal) {\n      setTimeout(function () {\n        incrementValue(intVal);\n      }, 125 - Math.log(difference) * 5);\n    }\n  }\n\n  /**\n     * Update the display to currentValue, formatted in 1,231,131,232 format\n     */\n  function updateDisplay() {\n    // format the string with commas every 3 places\n    messageDiv.innerHTML = currentVal.\n    toString().\n    replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');\n  }\n})();\n//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1lc3NhZ2UtY291bnQuanMiXSwibmFtZXMiOlsiTUVTU0FHRV9VUkwiLCJtZXNzYWdlRGl2IiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsImN1cnJlbnRWYWwiLCJwYXJzZUludCIsImlubmVySFRNTCIsInJlcGxhY2UiLCJ3aW5kb3ciLCJnZXRNZXNzYWdlQ291bnQiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJzdGF0dXMiLCJpbmNyZW1lbnRWYWx1ZSIsInJlc3BvbnNlVGV4dCIsImZhaWwiLCJvcGVuIiwic2VuZCIsImludFZhbCIsImRpZmZlcmVuY2UiLCJNYXRoIiwiY2VpbCIsInVwZGF0ZURpc3BsYXkiLCJzZXRUaW1lb3V0IiwibG9nIiwidG9TdHJpbmciXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLENBQUMsWUFBVztBQUNWLE1BQU1BLGNBQWMsd0RBQXBCO0FBQ0EsTUFBTUMsYUFBYUMsU0FBU0MsY0FBVCxDQUF3QixlQUF4QixDQUFuQjs7QUFFQSxNQUFJQyxhQUFhQyxTQUFTSixXQUFXSyxTQUFYLENBQXFCQyxPQUFyQixDQUE2QixJQUE3QixFQUFtQyxFQUFuQyxDQUFULEVBQWlELEVBQWpELENBQWpCOztBQUVBQyxTQUFPQyxlQUFQLEdBQXlCLFlBQU07QUFDN0IsUUFBTUMsTUFBTSxJQUFJQyxjQUFKLEVBQVo7O0FBRUFELFFBQUlFLGdCQUFKLENBQXFCLE1BQXJCLEVBQTZCLFlBQU07QUFDakMsVUFBSUYsSUFBSUcsTUFBSixLQUFlLEdBQW5CLEVBQXdCO0FBQ3RCQyx1QkFBZUosSUFBSUssWUFBbkI7QUFDRCxPQUZELE1BRU87QUFDTEM7QUFDRDtBQUNGLEtBTkQ7O0FBUUFOLFFBQUlFLGdCQUFKLENBQXFCLE9BQXJCLEVBQThCLFlBQU07QUFDbENJO0FBQ0QsS0FGRDs7QUFJQU4sUUFBSU8sSUFBSixDQUFTLEtBQVQsRUFBZ0JqQixXQUFoQjtBQUNBVSxRQUFJUSxJQUFKO0FBQ0QsR0FqQkQ7O0FBbUJBOzs7O0FBSUEsV0FBU0YsSUFBVCxHQUFnQjtBQUNkRixtQkFBZSxVQUFmO0FBQ0Q7O0FBRUQ7Ozs7O0FBS0EsV0FBU0EsY0FBVCxDQUF3QkssTUFBeEIsRUFBZ0M7QUFDOUJBLGFBQVNkLFNBQVNjLE1BQVQsRUFBaUIsRUFBakIsQ0FBVDs7QUFFQSxRQUFNQyxhQUFhRCxTQUFTZixVQUE1Qjs7QUFFQUEsa0JBQWNpQixLQUFLQyxJQUFMLENBQVVGLGFBQWEsQ0FBdkIsQ0FBZDs7QUFFQUc7O0FBRUEsUUFBSW5CLGVBQWVlLE1BQW5CLEVBQTJCO0FBQ3pCSyxpQkFBVyxZQUFNO0FBQ2ZWLHVCQUFlSyxNQUFmO0FBQ0QsT0FGRCxFQUVHLE1BQU1FLEtBQUtJLEdBQUwsQ0FBU0wsVUFBVCxJQUF1QixDQUZoQztBQUdEO0FBQ0Y7O0FBRUQ7OztBQUdBLFdBQVNHLGFBQVQsR0FBeUI7QUFDdkI7QUFDQXRCLGVBQVdLLFNBQVgsR0FBdUJGO0FBQ3BCc0IsWUFEb0I7QUFFcEJuQixXQUZvQixDQUVaLHVCQUZZLEVBRWEsR0FGYixDQUF2QjtBQUdEO0FBQ0YsQ0EvREQiLCJmaWxlIjoibWVzc2FnZS1jb3VudC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuKGZ1bmN0aW9uKCkge1xuICBjb25zdCBNRVNTQUdFX1VSTCA9ICdodHRwOi8vd3d3LmNyaXNpc3RleHRsaW5lLm9yZy90cmVuZHMvZGF0YS9tZXNzYWdlcy50eHQnO1xuICBjb25zdCBtZXNzYWdlRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21lc3NhZ2UtY291bnQnKTtcblxuICBsZXQgY3VycmVudFZhbCA9IHBhcnNlSW50KG1lc3NhZ2VEaXYuaW5uZXJIVE1MLnJlcGxhY2UoLywvZywgJycpLCAxMCk7XG5cbiAgd2luZG93LmdldE1lc3NhZ2VDb3VudCA9ICgpID0+IHtcbiAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICBpbmNyZW1lbnRWYWx1ZSh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZhaWwoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsICgpID0+IHtcbiAgICAgIGZhaWwoKTtcbiAgICB9KTtcblxuICAgIHhoci5vcGVuKCdHRVQnLCBNRVNTQUdFX1VSTCk7XG4gICAgeGhyLnNlbmQoKTtcbiAgfTtcblxuICAvKipcbiAgICogRmFpbHVyZSBoYW5kbGVyIGZvciBhIGZhaWxlZCBYSFIgcmVxdWVzdC4gTGV0J3MganVzdCBwb3B1bGF0ZSB3aXRoIGEgc2FuZSxcbiAgICogdHJ1ZS1lbm91Z2ggdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBmYWlsKCkge1xuICAgIGluY3JlbWVudFZhbHVlKCcyNzIxMjU3NScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluY3JlbWVudCB0aGUgY3VycmVudCB2YWx1ZSBieSB0aGUgZGlmZmVyZW5jZSBmcm9tIGN1cnJlbnQgdG8gZGVzaXJlZCAvIDIuXG4gICAqXG4gICAqIEBwYXJhbSAge2ludGVnZXJ9IGludFZhbCBWYWx1ZSB3ZSdyZSBzaG9vdGluZyBmb3JcbiAgICovXG4gIGZ1bmN0aW9uIGluY3JlbWVudFZhbHVlKGludFZhbCkge1xuICAgIGludFZhbCA9IHBhcnNlSW50KGludFZhbCwgMTApO1xuXG4gICAgY29uc3QgZGlmZmVyZW5jZSA9IGludFZhbCAtIGN1cnJlbnRWYWw7XG5cbiAgICBjdXJyZW50VmFsICs9IE1hdGguY2VpbChkaWZmZXJlbmNlIC8gMik7XG5cbiAgICB1cGRhdGVEaXNwbGF5KCk7XG5cbiAgICBpZiAoY3VycmVudFZhbCAhPT0gaW50VmFsKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaW5jcmVtZW50VmFsdWUoaW50VmFsKTtcbiAgICAgIH0sIDEyNSAtIE1hdGgubG9nKGRpZmZlcmVuY2UpICogNSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgZGlzcGxheSB0byBjdXJyZW50VmFsdWUsIGZvcm1hdHRlZCBpbiAxLDIzMSwxMzEsMjMyIGZvcm1hdFxuICAgKi9cbiAgZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICAvLyBmb3JtYXQgdGhlIHN0cmluZyB3aXRoIGNvbW1hcyBldmVyeSAzIHBsYWNlc1xuICAgIG1lc3NhZ2VEaXYuaW5uZXJIVE1MID0gY3VycmVudFZhbFxuICAgICAgLnRvU3RyaW5nKClcbiAgICAgIC5yZXBsYWNlKC9cXEIoPz0oXFxkezN9KSsoPyFcXGQpKS9nLCAnLCcpO1xuICB9XG59KSgpO1xuIl19\n\n'use strict';(function () {\n  var DASHBOARD_URL = 'http://public.tableausoftware.com/views/crisistrends2dec132016/WorkingDashMobile?:embed=y&:showVizHome=no&:host_url=https%3A%2F%2Fpublic.tableausoftware.com%2F&:tabs=no&:toolbar=top&:animate_transition=yes&:display_static_image=no&:display_spinner=yes&:display_overlay=yes&:display_count=yes&:loadOrderID=0';\n\n  var loaded = false;\n\n  window.addEventListener('scroll', loadDashboard);\n  window.addEventListener('resize-complete', reflowDashboard);\n\n  adjustHeight();\n\n  /**\n                   * Load the dashboard if it hasn't been loaded yet.\n                   *\n                   * @param {boolean} reload true if we want to force reloading the dashboard\n                   */\n  function loadDashboard(reload) {\n    if (!loaded || reload === true) {\n      document.getElementById('viz').src = DASHBOARD_URL;\n      loaded = true;\n    }\n  }\n\n  /**\n     * Reload the dashboard in response to screen size change.\n     */\n  function reflowDashboard() {\n    loadDashboard(true);\n    adjustHeight();\n  }\n\n  /**\n     * Adjust the height of the data viz.\n     */\n  function adjustHeight() {\n    var viz = document.getElementById('viz');\n\n    if (viz.offsetWidth <= 500) {\n      viz.height = 1950;\n    } else {\n      viz.height = 2600;\n    }\n  }\n})();\n//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInZpc3VhbGl6YXRpb25zLmpzIl0sIm5hbWVzIjpbIkRBU0hCT0FSRF9VUkwiLCJsb2FkZWQiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwibG9hZERhc2hib2FyZCIsInJlZmxvd0Rhc2hib2FyZCIsImFkanVzdEhlaWdodCIsInJlbG9hZCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJzcmMiLCJ2aXoiLCJvZmZzZXRXaWR0aCIsImhlaWdodCJdLCJtYXBwaW5ncyI6ImFBQUEsQ0FBQyxZQUFXO0FBQ1YsTUFBTUEsZ0JBQWdCLG9UQUF0Qjs7QUFFQSxNQUFJQyxTQUFTLEtBQWI7O0FBRUFDLFNBQU9DLGdCQUFQLENBQXdCLFFBQXhCLEVBQWtDQyxhQUFsQztBQUNBRixTQUFPQyxnQkFBUCxDQUF3QixpQkFBeEIsRUFBMkNFLGVBQTNDOztBQUVBQzs7QUFFQTs7Ozs7QUFLQSxXQUFTRixhQUFULENBQXVCRyxNQUF2QixFQUErQjtBQUM3QixRQUFJLENBQUNOLE1BQUQsSUFBV00sV0FBVyxJQUExQixFQUFnQztBQUM5QkMsZUFBU0MsY0FBVCxDQUF3QixLQUF4QixFQUErQkMsR0FBL0IsR0FBcUNWLGFBQXJDO0FBQ0FDLGVBQVMsSUFBVDtBQUNEO0FBQ0Y7O0FBRUQ7OztBQUdBLFdBQVNJLGVBQVQsR0FBMkI7QUFDekJELGtCQUFjLElBQWQ7QUFDQUU7QUFDRDs7QUFFRDs7O0FBR0EsV0FBU0EsWUFBVCxHQUF3QjtBQUN0QixRQUFNSyxNQUFNSCxTQUFTQyxjQUFULENBQXdCLEtBQXhCLENBQVo7O0FBRUEsUUFBSUUsSUFBSUMsV0FBSixJQUFtQixHQUF2QixFQUE0QjtBQUMxQkQsVUFBSUUsTUFBSixHQUFhLElBQWI7QUFDRCxLQUZELE1BRU87QUFDTEYsVUFBSUUsTUFBSixHQUFhLElBQWI7QUFDRDtBQUNGO0FBQ0YsQ0ExQ0QiLCJmaWxlIjoidmlzdWFsaXphdGlvbnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKSB7XG4gIGNvbnN0IERBU0hCT0FSRF9VUkwgPSAnaHR0cDovL3B1YmxpYy50YWJsZWF1c29mdHdhcmUuY29tL3ZpZXdzL2NyaXNpc3RyZW5kczJkZWMxMzIwMTYvV29ya2luZ0Rhc2hNb2JpbGU/OmVtYmVkPXkmOnNob3dWaXpIb21lPW5vJjpob3N0X3VybD1odHRwcyUzQSUyRiUyRnB1YmxpYy50YWJsZWF1c29mdHdhcmUuY29tJTJGJjp0YWJzPW5vJjp0b29sYmFyPXRvcCY6YW5pbWF0ZV90cmFuc2l0aW9uPXllcyY6ZGlzcGxheV9zdGF0aWNfaW1hZ2U9bm8mOmRpc3BsYXlfc3Bpbm5lcj15ZXMmOmRpc3BsYXlfb3ZlcmxheT15ZXMmOmRpc3BsYXlfY291bnQ9eWVzJjpsb2FkT3JkZXJJRD0wJztcblxuICBsZXQgbG9hZGVkID0gZmFsc2U7XG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGxvYWREYXNoYm9hcmQpO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplLWNvbXBsZXRlJywgcmVmbG93RGFzaGJvYXJkKTtcblxuICBhZGp1c3RIZWlnaHQoKTtcblxuICAvKipcbiAgICogTG9hZCB0aGUgZGFzaGJvYXJkIGlmIGl0IGhhc24ndCBiZWVuIGxvYWRlZCB5ZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVsb2FkIHRydWUgaWYgd2Ugd2FudCB0byBmb3JjZSByZWxvYWRpbmcgdGhlIGRhc2hib2FyZFxuICAgKi9cbiAgZnVuY3Rpb24gbG9hZERhc2hib2FyZChyZWxvYWQpIHtcbiAgICBpZiAoIWxvYWRlZCB8fCByZWxvYWQgPT09IHRydWUpIHtcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd2aXonKS5zcmMgPSBEQVNIQk9BUkRfVVJMO1xuICAgICAgbG9hZGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVsb2FkIHRoZSBkYXNoYm9hcmQgaW4gcmVzcG9uc2UgdG8gc2NyZWVuIHNpemUgY2hhbmdlLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVmbG93RGFzaGJvYXJkKCkge1xuICAgIGxvYWREYXNoYm9hcmQodHJ1ZSk7XG4gICAgYWRqdXN0SGVpZ2h0KCk7XG4gIH1cblxuICAvKipcbiAgICogQWRqdXN0IHRoZSBoZWlnaHQgb2YgdGhlIGRhdGEgdml6LlxuICAgKi9cbiAgZnVuY3Rpb24gYWRqdXN0SGVpZ2h0KCkge1xuICAgIGNvbnN0IHZpeiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd2aXonKTtcblxuICAgIGlmICh2aXoub2Zmc2V0V2lkdGggPD0gNTAwKSB7XG4gICAgICB2aXouaGVpZ2h0ID0gMTk1MDtcbiAgICB9IGVsc2Uge1xuICAgICAgdml6LmhlaWdodCA9IDI2MDA7XG4gICAgfVxuICB9XG59KSgpO1xuIl19\n\n'use strict'; /* global d3 */\n\n(function () {\n  var wordCloudDiv = document.getElementById('wordcloud');\n  var quoteDiv = document.getElementById('wordcloud-quote');\n  var CLOUD_HEIGHT = 500;\n  var svg = d3.select(wordCloudDiv).append('svg');\n\n  var quotes = void 0;\n  var cloudWidth = void 0;\n  var cloudHeight = CLOUD_HEIGHT;\n  var vis = void 0;\n  var lastWords = void 0;\n\n  window.bootstrapWordCloud = function () {\n    getQuotes();\n    initializeD3();\n\n    window.addEventListener('resize-complete', setSVGWidth);\n  };\n\n  function getQuotes() {\n    var xhr = new XMLHttpRequest();\n\n    xhr.addEventListener('load', function () {\n      if (xhr.status === 200) {\n        quotes = JSON.parse(xhr.responseText);\n      }\n    });\n\n    xhr.open('GET', 'data/quotes.json');\n    xhr.send();\n  }\n\n  function initializeD3() {\n    svg.attr('height', cloudHeight);\n    setSVGWidth();\n    wordCloudDiv.style.display = 'none';\n  }\n\n  function setSVGWidth(skipRedraw) {\n    cloudWidth = wordCloudDiv.offsetWidth;\n    svg.attr('width', cloudWidth);\n\n    if (skipRedraw !== true) {\n      doViz();\n    }\n  }\n\n  function doViz(words) {\n    if (words === undefined) {\n      if (lastWords === undefined) {\n        return;\n      }\n\n      words = lastWords;\n    } else {\n      lastWords = words;\n    }\n\n    svg.selectAll('g').remove();\n\n    vis = svg.\n    append('g').\n    attr('transform', 'translate(' +\n    [cloudWidth >> 1, cloudHeight >> 1] +\n    ')');\n\n    var max = 0;\n    var min = 1000000;\n\n    for (var i in words) {\n      if (words[i].c > max) {\n        max = words[i].c;\n      }\n\n      if (words[i].c < min) {\n        min = words[i].c;\n      }\n    }\n\n    var maxscale = d3.scale.linear().range([50, 120]).domain([10, 960])(cloudWidth);\n    var sizeScale = d3.scale.linear().range([12, maxscale]).domain([min, max]);\n\n    d3.layout.cloud().\n    size([cloudWidth, cloudHeight]).\n    words(words).\n    rotate(function () {\n      return 0;\n    }).\n    font('Impact').\n    fontSize(function (d) {\n      return sizeScale(d.c);\n    }).\n    text(function (d) {\n      return d.w;\n    }).\n    on('end', draw).\n    start();\n  }\n\n  function draw(words, bounds) {\n    var scale = bounds ? Math.min(\n    cloudWidth / Math.abs(bounds[1].x - cloudWidth / 2),\n    cloudWidth / Math.abs(bounds[0].x - cloudWidth / 2),\n    cloudHeight / Math.abs(bounds[1].y - cloudHeight / 2),\n    cloudHeight / Math.abs(bounds[0].y - cloudHeight / 2)) / 2 : 1;\n\n    vis.\n    selectAll('text').\n    data(words).\n    enter().append('text').\n    attr('text-anchor', 'middle').\n    style('font-size', function (d) {\n      return d.size + 'px';\n    }).\n    style('font-family', 'Impact').\n    style('fill', function () {\n      return 'rgba(0,0,0,' + (Math.random() * 0.50 + 0.25) + ')';\n    }).\n    attr('text-anchor', 'middle').\n    attr('transform', function (d) {\n      return 'translate(' + [d.x, d.y] + ')rotate(' + d.rotate + ')';\n    }).\n    text(function (d) {\n      return d.w;\n    });\n\n\n    vis.attr('transform', 'translate(' + [cloudWidth >> 1, cloudHeight >> 1] + ')scale(' + scale + ')');\n  }\n\n  document.getElementById('wordcloud-select').addEventListener('change', function () {\n    var issue = this.value;\n\n    wordCloudDiv.style.display = 'block';\n    setSVGWidth(true);\n\n    d3.json('data/words/' + issue + '.json', function (error, json) {\n      if (error) {\n        return console.warn(error);\n      }\n\n      if (quotes !== undefined) {\n        quoteDiv.innerHTML = '<p>' + quotes[issue] + '</p>';\n      }\n\n      doViz(json);\n    });\n  });\n})();\n//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndvcmQtY2xvdWQuanMiXSwibmFtZXMiOlsid29yZENsb3VkRGl2IiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsInF1b3RlRGl2IiwiQ0xPVURfSEVJR0hUIiwic3ZnIiwiZDMiLCJzZWxlY3QiLCJhcHBlbmQiLCJxdW90ZXMiLCJjbG91ZFdpZHRoIiwiY2xvdWRIZWlnaHQiLCJ2aXMiLCJsYXN0V29yZHMiLCJ3aW5kb3ciLCJib290c3RyYXBXb3JkQ2xvdWQiLCJnZXRRdW90ZXMiLCJpbml0aWFsaXplRDMiLCJhZGRFdmVudExpc3RlbmVyIiwic2V0U1ZHV2lkdGgiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsInN0YXR1cyIsIkpTT04iLCJwYXJzZSIsInJlc3BvbnNlVGV4dCIsIm9wZW4iLCJzZW5kIiwiYXR0ciIsInN0eWxlIiwiZGlzcGxheSIsInNraXBSZWRyYXciLCJvZmZzZXRXaWR0aCIsImRvVml6Iiwid29yZHMiLCJ1bmRlZmluZWQiLCJzZWxlY3RBbGwiLCJyZW1vdmUiLCJtYXgiLCJtaW4iLCJpIiwiYyIsIm1heHNjYWxlIiwic2NhbGUiLCJsaW5lYXIiLCJyYW5nZSIsImRvbWFpbiIsInNpemVTY2FsZSIsImxheW91dCIsImNsb3VkIiwic2l6ZSIsInJvdGF0ZSIsImZvbnQiLCJmb250U2l6ZSIsImQiLCJ0ZXh0IiwidyIsIm9uIiwiZHJhdyIsInN0YXJ0IiwiYm91bmRzIiwiTWF0aCIsImFicyIsIngiLCJ5IiwiZGF0YSIsImVudGVyIiwicmFuZG9tIiwiaXNzdWUiLCJ2YWx1ZSIsImpzb24iLCJlcnJvciIsImNvbnNvbGUiLCJ3YXJuIiwiaW5uZXJIVE1MIl0sIm1hcHBpbmdzIjoiY0FBQTs7QUFFQSxDQUFDLFlBQVc7QUFDVixNQUFNQSxlQUFlQyxTQUFTQyxjQUFULENBQXdCLFdBQXhCLENBQXJCO0FBQ0EsTUFBTUMsV0FBV0YsU0FBU0MsY0FBVCxDQUF3QixpQkFBeEIsQ0FBakI7QUFDQSxNQUFNRSxlQUFlLEdBQXJCO0FBQ0Es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N0M7QUFDRDs7QUFFRG5DLFlBQU1xQyxJQUFOO0FBQ0QsS0FWRDtBQVdELEdBakJEO0FBa0JELENBcEpEIiwiZmlsZSI6IndvcmQtY2xvdWQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgZDMgKi9cblxuKGZ1bmN0aW9uKCkge1xuICBjb25zdCB3b3JkQ2xvdWREaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd29yZGNsb3VkJyk7XG4gIGNvbnN0IHF1b3RlRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dvcmRjbG91ZC1xdW90ZScpO1xuICBjb25zdCBDTE9VRF9IRUlHSFQgPSA1MDA7XG4gIGNvbnN0IHN2ZyA9IGQzLnNlbGVjdCh3b3JkQ2xvdWREaXYpLmFwcGVuZCgnc3ZnJyk7XG5cbiAgbGV0IHF1b3RlcztcbiAgbGV0IGNsb3VkV2lkdGg7XG4gIGxldCBjbG91ZEhlaWdodCA9IENMT1VEX0hFSUdIVDtcbiAgbGV0IHZpcztcbiAgbGV0IGxhc3RXb3JkcztcblxuICB3aW5kb3cuYm9vdHN0cmFwV29yZENsb3VkID0gKCkgPT4ge1xuICAgIGdldFF1b3RlcygpO1xuICAgIGluaXRpYWxpemVEMygpO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZS1jb21wbGV0ZScsIHNldFNWR1dpZHRoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRRdW90ZXMoKSB7XG4gICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgIGlmICh4aHIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgcXVvdGVzID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHhoci5vcGVuKCdHRVQnLCAnZGF0YS9xdW90ZXMuanNvbicpO1xuICAgIHhoci5zZW5kKCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplRDMoKSB7XG4gICAgc3ZnLmF0dHIoJ2hlaWdodCcsIGNsb3VkSGVpZ2h0KTtcbiAgICBzZXRTVkdXaWR0aCgpO1xuICAgIHdvcmRDbG91ZERpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0U1ZHV2lkdGgoc2tpcFJlZHJhdykge1xuICAgIGNsb3VkV2lkdGggPSB3b3JkQ2xvdWREaXYub2Zmc2V0V2lkdGg7XG4gICAgc3ZnLmF0dHIoJ3dpZHRoJywgY2xvdWRXaWR0aCk7XG5cbiAgICBpZiAoc2tpcFJlZHJhdyAhPT0gdHJ1ZSkge1xuICAgICAgZG9WaXooKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkb1Zpeih3b3Jkcykge1xuICAgIGlmICh3b3JkcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAobGFzdFdvcmRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB3b3JkcyA9IGxhc3RXb3JkcztcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdFdvcmRzID0gd29yZHM7XG4gICAgfVxuXG4gICAgc3ZnLnNlbGVjdEFsbCgnZycpLnJlbW92ZSgpO1xuXG4gICAgdmlzID0gc3ZnXG4gICAgICAuYXBwZW5kKCdnJylcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgK1xuICAgICAgICBbY2xvdWRXaWR0aCA+PiAxLCBjbG91ZEhlaWdodCA+PiAxXSArXG4gICAgICAgICcpJyk7XG5cbiAgICBsZXQgbWF4ID0gMDtcbiAgICBsZXQgbWluID0gMTAwMDAwMDtcblxuICAgIGZvciAobGV0IGkgaW4gd29yZHMpIHtcbiAgICAgIGlmICh3b3Jkc1tpXS5jID4gbWF4KSB7XG4gICAgICAgIG1heCA9IHdvcmRzW2ldLmM7XG4gICAgICB9XG5cbiAgICAgIGlmICh3b3Jkc1tpXS5jIDwgbWluKSB7XG4gICAgICAgIG1pbiA9IHdvcmRzW2ldLmM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbWF4c2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKS5yYW5nZShbNTAsIDEyMF0pLmRvbWFpbihbMTAsIDk2MF0pKGNsb3VkV2lkdGgpO1xuICAgIGNvbnN0IHNpemVTY2FsZSA9IGQzLnNjYWxlLmxpbmVhcigpLnJhbmdlKFsxMiwgbWF4c2NhbGVdKS5kb21haW4oW21pbiwgbWF4XSk7XG5cbiAgICBkMy5sYXlvdXQuY2xvdWQoKVxuICAgICAgLnNpemUoW2Nsb3VkV2lkdGgsIGNsb3VkSGVpZ2h0XSlcbiAgICAgIC53b3Jkcyh3b3JkcylcbiAgICAgIC5yb3RhdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSlcbiAgICAgIC5mb250KCdJbXBhY3QnKVxuICAgICAgLmZvbnRTaXplKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIHNpemVTY2FsZShkLmMpO1xuICAgICAgfSlcbiAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGQudztcbiAgICAgIH0pXG4gICAgICAub24oJ2VuZCcsIGRyYXcpXG4gICAgICAuc3RhcnQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYXcod29yZHMsIGJvdW5kcykge1xuICAgIGNvbnN0IHNjYWxlID0gYm91bmRzID8gTWF0aC5taW4oXG4gICAgICBjbG91ZFdpZHRoIC8gTWF0aC5hYnMoYm91bmRzWzFdLnggLSBjbG91ZFdpZHRoIC8gMiksXG4gICAgICBjbG91ZFdpZHRoIC8gTWF0aC5hYnMoYm91bmRzWzBdLnggLSBjbG91ZFdpZHRoIC8gMiksXG4gICAgICBjbG91ZEhlaWdodCAvIE1hdGguYWJzKGJvdW5kc1sxXS55IC0gY2xvdWRIZWlnaHQgLyAyKSxcbiAgICAgIGNsb3VkSGVpZ2h0IC8gTWF0aC5hYnMoYm91bmRzWzBdLnkgLSBjbG91ZEhlaWdodCAvIDIpKSAvIDIgOiAxO1xuXG4gICAgdmlzXG4gICAgICAuc2VsZWN0QWxsKCd0ZXh0JylcbiAgICAgIC5kYXRhKHdvcmRzKVxuICAgICAgLmVudGVyKCkuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXG4gICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgIHJldHVybiBkLnNpemUgKyAncHgnO1xuICAgICAgICB9KVxuICAgICAgICAuc3R5bGUoJ2ZvbnQtZmFtaWx5JywgJ0ltcGFjdCcpXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiAncmdiYSgwLDAsMCwnICsgKE1hdGgucmFuZG9tKCkgKiAwLjUwICsgMC4yNSkgKyAnKSc7XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyBbZC54LCBkLnldICsgJylyb3RhdGUoJyArIGQucm90YXRlICsgJyknO1xuICAgICAgICB9KVxuICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgcmV0dXJuIGQudztcbiAgICAgICAgfSlcbiAgICA7XG5cbiAgICB2aXMuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgW2Nsb3VkV2lkdGggPj4gMSwgY2xvdWRIZWlnaHQgPj4gMV0gKyAnKXNjYWxlKCcgKyBzY2FsZSArICcpJyk7XG4gIH1cblxuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd29yZGNsb3VkLXNlbGVjdCcpLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGlzc3VlID0gdGhpcy52YWx1ZTtcblxuICAgIHdvcmRDbG91ZERpdi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICBzZXRTVkdXaWR0aCh0cnVlKTtcblxuICAgIGQzLmpzb24oJ2RhdGEvd29yZHMvJyArIGlzc3VlICsgJy5qc29uJywgZnVuY3Rpb24oZXJyb3IsIGpzb24pIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHF1b3RlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHF1b3RlRGl2LmlubmVySFRNTCA9ICc8cD4nICsgcXVvdGVzW2lzc3VlXSArICc8L3A+JztcbiAgICAgIH1cblxuICAgICAgZG9WaXooanNvbik7XG4gICAgfSk7XG4gIH0pO1xufSkoKTtcbiJdfQ==\n\n/* global\n    getMessageCount\n    renderFAQ\n    bindFAQ\n    bootstrapWordCloud\n    toggle\n    hide\n */\n'use strict';\n\n(function () {\n  polyfill();\n  attachHamburger();\n  getMessageCount();\n  renderCarousel();\n  renderFAQ();\n  bindFAQ();\n  bootstrapWordCloud();\n  scrollToTop();\n\n  var resizeTimer = void 0;\n  var w = window.outerWidth;\n  window.addEventListener('resize', function (e) {\n    clearTimeout(resizeTimer);\n\n    resizeTimer = setTimeout(function () {\n      if (window.outerWidth === w) {\n        return;\n      }\n\n      w = window.outerWidth;\n      var newEvent = new Event('resize-complete');\n      newEvent.originalEvent = e;\n      window.dispatchEvent(newEvent);\n    }, 500);\n  });\n\n  /**\n       * Attach the hamburger click binders.\n       */\n  function attachHamburger() {\n    document.querySelectorAll('.hamburger')[0].addEventListener('click', function () {\n      toggle(document.querySelectorAll('.hamburger-menu'));\n    });\n\n    document.querySelectorAll('.hamburger-menu a').forEach(function (element) {\n      element.addEventListener('click', function () {\n        hide(document.querySelectorAll('.hamburger-menu'));\n      });\n    });\n  }\n\n  /**\n     * Custom polyfills that aren't included in es5-shim.\n     */\n  function polyfill() {\n    if (NodeList.prototype.forEach === undefined) {\n      NodeList.prototype.forEach = Array.prototype.forEach;\n    }\n  }\n\n  /**\n     * Attach click binder to make #top scroll ALL THE WAY to the top\n     */\n  function scrollToTop() {\n    document.querySelectorAll('a[href=\"#top\"]').forEach(function (element) {\n      element.addEventListener('click', function (event) {\n        window.scrollTo(0, 0);\n        event.preventDefault();\n      });\n    });\n  }\n})();\n//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1haW4uanMiXSwibmFtZXMiOlsicG9seWZpbGwiLCJhdHRhY2hIYW1idXJnZXIiLCJnZXRNZXNzYWdlQ291bnQiLCJyZW5kZXJDYXJvdXNlbCIsInJlbmRlckZBUSIsImJpbmRGQVEiLCJib290c3RyYXBXb3JkQ2xvdWQiLCJzY3JvbGxUb1RvcCIsInJlc2l6ZVRpbWVyIiwidyIsIndpbmRvdyIsIm91dGVyV2lkdGgiLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJuZXdFdmVudCIsIkV2ZW50Iiwib3JpZ2luYWxFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJ0b2dnbGUiLCJmb3JFYWNoIiwiZWxlbWVudCIsImhpZGUiLCJOb2RlTGlzdCIsInByb3RvdHlwZSIsInVuZGVmaW5lZCIsIkFycmF5IiwiZXZlbnQiLCJzY3JvbGxUbyIsInByZXZlbnREZWZhdWx0Il0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7QUFRQTs7QUFFQSxDQUFDLFlBQVc7QUFDVkE7QUFDQUM7QUFDQUM7QUFDQUM7QUFDQUM7QUFDQUM7QUFDQUM7QUFDQUM7O0FBRUEsTUFBSUMsb0JBQUo7QUFDQSxNQUFJQyxJQUFJQyxPQUFPQyxVQUFmO0FBQ0FELFNBQU9FLGdCQUFQLENBQXdCLFFBQXhCLEVBQWtDLFVBQVNDLENBQVQsRUFBWTtBQUM1Q0MsaUJBQWFOLFdBQWI7O0FBRUFBLGtCQUFjTyxXQUFXLFlBQU07QUFDN0IsVUFBSUwsT0FBT0MsVUFBUCxLQUFzQkYsQ0FBMUIsRUFBNkI7QUFDM0I7QUFDRDs7QUFFREEsVUFBSUMsT0FBT0MsVUFBWDtBQUNBLFVBQU1LLFdBQVcsSUFBSUMsS0FBSixDQUFVLGlCQUFWLENBQWpCO0FBQ0FELGVBQVNFLGFBQVQsR0FBeUJMLENBQXpCO0FBQ0FILGFBQU9TLGFBQVAsQ0FBcUJILFFBQXJCO0FBQ0QsS0FUYSxFQVNYLEdBVFcsQ0FBZDtBQVVELEdBYkQ7O0FBZUE7OztBQUdBLFdBQVNmLGVBQVQsR0FBMkI7QUFDekJtQixhQUFTQyxnQkFBVCxDQUEwQixZQUExQixFQUF3QyxDQUF4QyxFQUEyQ1QsZ0JBQTNDLENBQTRELE9BQTVELEVBQXFFLFlBQU07QUFDekVVLGFBQU9GLFNBQVNDLGdCQUFULENBQTBCLGlCQUExQixDQUFQO0FBQ0QsS0FGRDs7QUFJQUQsYUFBU0MsZ0JBQVQsQ0FBMEIsbUJBQTFCLEVBQStDRSxPQUEvQyxDQUF1RCxVQUFTQyxPQUFULEVBQWtCO0FBQ3ZFQSxjQUFRWixnQkFBUixDQUF5QixPQUF6QixFQUFrQyxZQUFXO0FBQzNDYSxhQUFLTCxTQUFTQyxnQkFBVCxDQUEwQixpQkFBMUIsQ0FBTDtBQUNELE9BRkQ7QUFHRCxLQUpEO0FBS0Q7O0FBRUQ7OztBQUdBLFdBQVNyQixRQUFULEdBQW9CO0FBQ2xCLFFBQUkwQixTQUFTQyxTQUFULENBQW1CSixPQUFuQixLQUErQkssU0FBbkMsRUFBOEM7QUFDNUNGLGVBQVNDLFNBQVQsQ0FBbUJKLE9BQW5CLEdBQTZCTSxNQUFNRixTQUFOLENBQWdCSixPQUE3QztBQUNEO0FBQ0Y7O0FBRUQ7OztBQUdBLFdBQVNoQixXQUFULEdBQXVCO0FBQ3JCYSxhQUFTQyxnQkFBVCxDQUEwQixnQkFBMUIsRUFBNENFLE9BQTVDLENBQW9ELFVBQVNDLE9BQVQsRUFBa0I7QUFDcEVBLGNBQVFaLGdCQUFSLENBQXlCLE9BQXpCLEVBQWtDLFVBQUNrQixLQUFELEVBQVc7QUFDM0NwQixlQUFPcUIsUUFBUCxDQUFnQixDQUFoQixFQUFtQixDQUFuQjtBQUNBRCxjQUFNRSxjQUFOO0FBQ0QsT0FIRDtBQUlELEtBTEQ7QUFNRDtBQUNGLENBOUREIiwiZmlsZSI6Im1haW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWxcbiAgICBnZXRNZXNzYWdlQ291bnRcbiAgICByZW5kZXJGQVFcbiAgICBiaW5kRkFRXG4gICAgYm9vdHN0cmFwV29yZENsb3VkXG4gICAgdG9nZ2xlXG4gICAgaGlkZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbihmdW5jdGlvbigpIHtcbiAgcG9seWZpbGwoKTtcbiAgYXR0YWNoSGFtYnVyZ2VyKCk7XG4gIGdldE1lc3NhZ2VDb3VudCgpO1xuICByZW5kZXJDYXJvdXNlbCgpO1xuICByZW5kZXJGQVEoKTtcbiAgYmluZEZBUSgpO1xuICBib290c3RyYXBXb3JkQ2xvdWQoKTtcbiAgc2Nyb2xsVG9Ub3AoKTtcblxuICBsZXQgcmVzaXplVGltZXI7XG4gIGxldCB3ID0gd2luZG93Lm91dGVyV2lkdGg7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbihlKSB7XG4gICAgY2xlYXJUaW1lb3V0KHJlc2l6ZVRpbWVyKTtcblxuICAgIHJlc2l6ZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAod2luZG93Lm91dGVyV2lkdGggPT09IHcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB3ID0gd2luZG93Lm91dGVyV2lkdGg7XG4gICAgICBjb25zdCBuZXdFdmVudCA9IG5ldyBFdmVudCgncmVzaXplLWNvbXBsZXRlJyk7XG4gICAgICBuZXdFdmVudC5vcmlnaW5hbEV2ZW50ID0gZTtcbiAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcbiAgICB9LCA1MDApO1xuICB9KTtcblxuICAvKipcbiAgICogQXR0YWNoIHRoZSBoYW1idXJnZXIgY2xpY2sgYmluZGVycy5cbiAgICovXG4gIGZ1bmN0aW9uIGF0dGFjaEhhbWJ1cmdlcigpIHtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuaGFtYnVyZ2VyJylbMF0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICB0b2dnbGUoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmhhbWJ1cmdlci1tZW51JykpO1xuICAgIH0pO1xuXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmhhbWJ1cmdlci1tZW51IGEnKS5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaGlkZShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuaGFtYnVyZ2VyLW1lbnUnKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDdXN0b20gcG9seWZpbGxzIHRoYXQgYXJlbid0IGluY2x1ZGVkIGluIGVzNS1zaGltLlxuICAgKi9cbiAgZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gICAgaWYgKE5vZGVMaXN0LnByb3RvdHlwZS5mb3JFYWNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIE5vZGVMaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2g7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaCBjbGljayBiaW5kZXIgdG8gbWFrZSAjdG9wIHNjcm9sbCBBTEwgVEhFIFdBWSB0byB0aGUgdG9wXG4gICAqL1xuICBmdW5jdGlvbiBzY3JvbGxUb1RvcCgpIHtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdhW2hyZWY9XCIjdG9wXCJdJykuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59KSgpO1xuIl19\n","/*\n *\n *  Web Starter Kit\n *  Copyright 2015 Google Inc. All rights reserved.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *    https://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License\n *\n */\n\n(function() {\n  'use strict';\n\n  // Check to make sure service workers are supported in the current browser,\n  // and that the current page is accessed from a secure origin. Using a\n  // service worker from an insecure origin will trigger JS console errors. See\n  // http://www.chromium.org/Home/chromium-security/prefer-secure-origins-for-powerful-new-features\n  const isLocalhost = Boolean(window.location.hostname === 'localhost' ||\n      // [::1] is the IPv6 localhost address.\n      window.location.hostname === '[::1]' ||\n      // 127.0.0.1/8 is considered localhost for IPv4.\n      window.location.hostname.match(\n        /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n      )\n    );\n\n  if ('serviceWorker' in navigator &&\n      (window.location.protocol === 'https:' || isLocalhost)) {\n    navigator.serviceWorker.register('service-worker.js')\n    .then(function(registration) {\n      // updatefound is fired if service-worker.js changes.\n      registration.onupdatefound = function() {\n        // updatefound is also fired the very first time the SW is installed,\n        // and there's no need to prompt for a reload at that point.\n        // So check here to see if the page is already controlled,\n        // i.e. whether there's an existing service worker.\n        if (navigator.serviceWorker.controller) {\n          // The updatefound event implies that registration.installing is set:\n          // https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#service-worker-container-updatefound-event\n          const installingWorker = registration.installing;\n\n          installingWorker.onstatechange = function() {\n            switch (installingWorker.state) {\n              case 'installed':\n                // At this point, the old content will have been purged and the\n                // fresh content will have been added to the cache.\n                // It's the perfect time to display a \"New content is\n                // available; please refresh.\" message in the page's interface.\n                break;\n\n              case 'redundant':\n                throw new Error('The installing ' +\n                                'service worker became redundant.');\n\n              default:\n                // Ignore\n            }\n          };\n        }\n      };\n    }).catch(function(e) {\n      console.error('Error during service worker registration:', e);\n    });\n  }\n\n  // Your custom JavaScript goes here\n})();\n","// Word cloud layout by Jason Davies, http://www.jasondavies.com/word-cloud/\n// Algorithm due to Jonathan Feinberg, http://static.mrfeinberg.com/bv_ch03.pdf\n(function() {\n  function cloud() {\n    var size = [256, 256],\n        text = cloudText,\n        font = cloudFont,\n        fontSize = cloudFontSize,\n        fontStyle = cloudFontNormal,\n        fontWeight = cloudFontNormal,\n        rotate = cloudRotate,\n        padding = cloudPadding,\n        spiral = archimedeanSpiral,\n        words = [],\n        timeInterval = Infinity,\n        event = d3.dispatch(\"word\", \"end\"),\n        timer = null,\n        cloud = {};\n\n    cloud.start = function() {\n      var board = zeroArray((size[0] >> 5) * size[1]),\n          bounds = null,\n          n = words.length,\n          i = -1,\n          tags = [],\n          data = words.map(function(d, i) {\n            d.text = text.call(this, d, i);\n            d.font = font.call(this, d, i);\n            d.style = fontStyle.call(this, d, i);\n            d.weight = fontWeight.call(this, d, i);\n            d.rotate = rotate.call(this, d, i);\n            d.size = ~~fontSize.call(this, d, i);\n            d.padding = padding.call(this, d, i);\n            return d;\n          }).sort(function(a, b) { return b.size - a.size; });\n\n      if (timer) clearInterval(timer);\n      timer = setInterval(step, 0);\n      step();\n\n      return cloud;\n\n      function step() {\n        var start = +new Date,\n            d;\n        while (+new Date - start < timeInterval && ++i < n && timer) {\n          d = data[i];\n          d.x = (size[0] * (Math.random() + .5)) >> 1;\n          d.y = (size[1] * (Math.random() + .5)) >> 1;\n          cloudSprite(d, data, i);\n          if (d.hasText && place(board, d, bounds)) {\n            tags.push(d);\n            event.word(d);\n            if (bounds) cloudBounds(bounds, d);\n            else bounds = [{x: d.x + d.x0, y: d.y + d.y0}, {x: d.x + d.x1, y: d.y + d.y1}];\n            // Temporary hack\n            d.x -= size[0] >> 1;\n            d.y -= size[1] >> 1;\n          }\n        }\n        if (i >= n) {\n          cloud.stop();\n          event.end(tags, bounds);\n        }\n      }\n    }\n\n    cloud.stop = function() {\n      if (timer) {\n        clearInterval(timer);\n        timer = null;\n      }\n      return cloud;\n    };\n\n    cloud.timeInterval = function(x) {\n      if (!arguments.length) return timeInterval;\n      timeInterval = x == null ? Infinity : x;\n      return cloud;\n    };\n\n    function place(board, tag, bounds) {\n      var perimeter = [{x: 0, y: 0}, {x: size[0], y: size[1]}],\n          startX = tag.x,\n          startY = tag.y,\n          maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),\n          s = spiral(size),\n          dt = Math.random() < .5 ? 1 : -1,\n          t = -dt,\n          dxdy,\n          dx,\n          dy;\n\n      while (dxdy = s(t += dt)) {\n        dx = ~~dxdy[0];\n        dy = ~~dxdy[1];\n\n        if (Math.min(dx, dy) > maxDelta) break;\n\n        tag.x = startX + dx;\n        tag.y = startY + dy;\n\n        if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 ||\n            tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue;\n        // TODO only check for collisions within current bounds.\n        if (!bounds || !cloudCollide(tag, board, size[0])) {\n          if (!bounds || collideRects(tag, bounds)) {\n            var sprite = tag.sprite,\n                w = tag.width >> 5,\n                sw = size[0] >> 5,\n                lx = tag.x - (w << 4),\n                sx = lx & 0x7f,\n                msx = 32 - sx,\n                h = tag.y1 - tag.y0,\n                x = (tag.y + tag.y0) * sw + (lx >> 5),\n                last;\n            for (var j = 0; j < h; j++) {\n              last = 0;\n              for (var i = 0; i <= w; i++) {\n                board[x + i] |= (last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);\n              }\n              x += sw;\n            }\n            delete tag.sprite;\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    cloud.words = function(x) {\n      if (!arguments.length) return words;\n      words = x;\n      return cloud;\n    };\n\n    cloud.size = function(x) {\n      if (!arguments.length) return size;\n      size = [+x[0], +x[1]];\n      return cloud;\n    };\n\n    cloud.font = function(x) {\n      if (!arguments.length) return font;\n      font = d3.functor(x);\n      return cloud;\n    };\n\n    cloud.fontStyle = function(x) {\n      if (!arguments.length) return fontStyle;\n      fontStyle = d3.functor(x);\n      return cloud;\n    };\n\n    cloud.fontWeight = function(x) {\n      if (!arguments.length) return fontWeight;\n      fontWeight = d3.functor(x);\n      return cloud;\n    };\n\n    cloud.rotate = function(x) {\n      if (!arguments.length) return rotate;\n      rotate = d3.functor(x);\n      return cloud;\n    };\n\n    cloud.text = function(x) {\n      if (!arguments.length) return text;\n      text = d3.functor(x);\n      return cloud;\n    };\n\n    cloud.spiral = function(x) {\n      if (!arguments.length) return spiral;\n      spiral = spirals[x + \"\"] || x;\n      return cloud;\n    };\n\n    cloud.fontSize = function(x) {\n      if (!arguments.length) return fontSize;\n      fontSize = d3.functor(x);\n      return cloud;\n    };\n\n    cloud.padding = function(x) {\n      if (!arguments.length) return padding;\n      padding = d3.functor(x);\n      return cloud;\n    };\n\n    return d3.rebind(cloud, event, \"on\");\n  }\n\n  function cloudText(d) {\n    return d.text;\n  }\n\n  function cloudFont() {\n    return \"serif\";\n  }\n\n  function cloudFontNormal() {\n    return \"normal\";\n  }\n\n  function cloudFontSize(d) {\n    return Math.sqrt(d.value);\n  }\n\n  function cloudRotate() {\n    return (~~(Math.random() * 6) - 3) * 30;\n  }\n\n  function cloudPadding() {\n    return 1;\n  }\n\n  // Fetches a monochrome sprite bitmap for the specified text.\n  // Load in batches for speed.\n  function cloudSprite(d, data, di) {\n    if (d.sprite) return;\n    c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);\n    var x = 0,\n        y = 0,\n        maxh = 0,\n        n = data.length;\n    --di;\n    while (++di < n) {\n      d = data[di];\n      c.save();\n      c.font = d.style + \" \" + d.weight + \" \" + ~~((d.size + 1) / ratio) + \"px \" + d.font;\n      var w = c.measureText(d.text + \"m\").width * ratio,\n          h = d.size << 1;\n      if (d.rotate) {\n        var sr = Math.sin(d.rotate * cloudRadians),\n            cr = Math.cos(d.rotate * cloudRadians),\n            wcr = w * cr,\n            wsr = w * sr,\n            hcr = h * cr,\n            hsr = h * sr;\n        w = (Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f) >> 5 << 5;\n        h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));\n      } else {\n        w = (w + 0x1f) >> 5 << 5;\n      }\n      if (h > maxh) maxh = h;\n      if (x + w >= (cw << 5)) {\n        x = 0;\n        y += maxh;\n        maxh = 0;\n      }\n      if (y + h >= ch) break;\n      c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);\n      if (d.rotate) c.rotate(d.rotate * cloudRadians);\n      c.fillText(d.text, 0, 0);\n      if (d.padding) c.lineWidth = 2 * d.padding, c.strokeText(d.text, 0, 0);\n      c.restore();\n      d.width = w;\n      d.height = h;\n      d.xoff = x;\n      d.yoff = y;\n      d.x1 = w >> 1;\n      d.y1 = h >> 1;\n      d.x0 = -d.x1;\n      d.y0 = -d.y1;\n      d.hasText = true;\n      x += w;\n    }\n    var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,\n        sprite = [];\n    while (--di >= 0) {\n      d = data[di];\n      if (!d.hasText) continue;\n      var w = d.width,\n          w32 = w >> 5,\n          h = d.y1 - d.y0;\n      // Zero the buffer\n      for (var i = 0; i < h * w32; i++) sprite[i] = 0;\n      x = d.xoff;\n      if (x == null) return;\n      y = d.yoff;\n      var seen = 0,\n          seenRow = -1;\n      for (var j = 0; j < h; j++) {\n        for (var i = 0; i < w; i++) {\n          var k = w32 * j + (i >> 5),\n              m = pixels[((y + j) * (cw << 5) + (x + i)) << 2] ? 1 << (31 - (i % 32)) : 0;\n          sprite[k] |= m;\n          seen |= m;\n        }\n        if (seen) seenRow = j;\n        else {\n          d.y0++;\n          h--;\n          j--;\n          y++;\n        }\n      }\n      d.y1 = d.y0 + seenRow;\n      d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);\n    }\n  }\n\n  // Use mask-based collision detection.\n  function cloudCollide(tag, board, sw) {\n    sw >>= 5;\n    var sprite = tag.sprite,\n        w = tag.width >> 5,\n        lx = tag.x - (w << 4),\n        sx = lx & 0x7f,\n        msx = 32 - sx,\n        h = tag.y1 - tag.y0,\n        x = (tag.y + tag.y0) * sw + (lx >> 5),\n        last;\n    for (var j = 0; j < h; j++) {\n      last = 0;\n      for (var i = 0; i <= w; i++) {\n        if (((last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0))\n            & board[x + i]) return true;\n      }\n      x += sw;\n    }\n    return false;\n  }\n\n  function cloudBounds(bounds, d) {\n    var b0 = bounds[0],\n        b1 = bounds[1];\n    if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;\n    if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;\n    if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;\n    if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;\n  }\n\n  function collideRects(a, b) {\n    return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;\n  }\n\n  function archimedeanSpiral(size) {\n    var e = size[0] / size[1];\n    return function(t) {\n      return [e * (t *= .1) * Math.cos(t), t * Math.sin(t)];\n    };\n  }\n\n  function rectangularSpiral(size) {\n    var dy = 4,\n        dx = dy * size[0] / size[1],\n        x = 0,\n        y = 0;\n    return function(t) {\n      var sign = t < 0 ? -1 : 1;\n      // See triangular numbers: T_n = n * (n + 1) / 2.\n      switch ((Math.sqrt(1 + 4 * sign * t) - sign) & 3) {\n        case 0:  x += dx; break;\n        case 1:  y += dy; break;\n        case 2:  x -= dx; break;\n        default: y -= dy; break;\n      }\n      return [x, y];\n    };\n  }\n\n  // TODO reuse arrays?\n  function zeroArray(n) {\n    var a = [],\n        i = -1;\n    while (++i < n) a[i] = 0;\n    return a;\n  }\n\n  var cloudRadians = Math.PI / 180,\n      cw = 1 << 11 >> 5,\n      ch = 1 << 11,\n      canvas,\n      ratio = 1;\n\n  if (typeof document !== \"undefined\") {\n    canvas = document.createElement(\"canvas\");\n    canvas.width = 1;\n    canvas.height = 1;\n    ratio = Math.sqrt(canvas.getContext(\"2d\").getImageData(0, 0, 1, 1).data.length >> 2);\n    canvas.width = (cw << 5) / ratio;\n    canvas.height = ch / ratio;\n  } else {\n    // Attempt to use node-canvas.\n    canvas = new Canvas(cw << 5, ch);\n  }\n\n  var c = canvas.getContext(\"2d\"),\n      spirals = {\n        archimedean: archimedeanSpiral,\n        rectangular: rectangularSpiral\n      };\n  c.fillStyle = c.strokeStyle = \"red\";\n  c.textAlign = \"center\";\n\n  if (typeof module === \"object\" && module.exports) module.exports = cloud;\n  else (d3.layout || (d3.layout = {})).cloud = cloud;\n})();","/* eslint-env browser */\n/**\n * Toggle the display of an element.\n *\n * @param  {element} e The element to toggle.\n *\n * @return {element}   The element that was toggled.\n */\nwindow.toggle = function(e) {\n  if (e instanceof NodeList) {\n    e.forEach(toggle);\n    return e;\n  }\n\n  if (e.style.display === 'inherit') {\n    return hide(e);\n  }\n\n  return show(e);\n}\n\n/**\n * Hide an element or elements.\n *\n * @param  {element|NodeList} e The element(s) to hide\n *\n * @return {element} The element hidden\n */\nwindow.hide = function(e) {\n  if (e instanceof NodeList) {\n    e.forEach(hide);\n  } else {\n    e.style.display = 'none';\n  }\n\n  return e;\n}\n\n/**\n * Unhide an element.\n *\n * @param  {element} e The element to unhide.\n *\n * @return {element} The element unhidden\n */\nwindow.show = function(e) {\n  if (e instanceof NodeList) {\n    e.forEach(hide);\n  } else {\n    e.style.display = 'inherit';\n  }\n\n  return e;\n}\n","/** \n* carousel-js - v3.1.1.\n* git://github.com/mkay581/carousel-js.git\n* Copyright 2016 Mark Kennedy. Licensed MIT.\n*/\n\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.Carousel = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function (process,__filename){\n/** vim: et:ts=4:sw=4:sts=4\n * @license amdefine 1.0.1 Copyright (c) 2011-2016, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/amdefine for details\n */\n\n/*jslint node: true */\n/*global module, process */\n'use strict';\n\n/**\n * Creates a define for node.\n * @param {Object} module the \"module\" object that is defined by Node for the\n * current module.\n * @param {Function} [requireFn]. Node's require function for the current module.\n * It only needs to be passed in Node versions before 0.5, when module.require\n * did not exist.\n * @returns {Function} a define function that is usable for the current node\n * module.\n */\nfunction amdefine(module, requireFn) {\n    'use strict';\n    var defineCache = {},\n        loaderCache = {},\n        alreadyCalled = false,\n        path = require('path'),\n        makeRequire, stringRequire;\n\n    /**\n     * Trims the . and .. from an array of path segments.\n     * It will keep a leading path segment if a .. will become\n     * the first path segment, to help with module name lookups,\n     * which act like paths, but can be remapped. But the end result,\n     * all paths that use this function should look normalized.\n     * NOTE: this method MODIFIES the input array.\n     * @param {Array} ary the array of path segments.\n     */\n    function trimDots(ary) {\n        var i, part;\n        for (i = 0; ary[i]; i+= 1) {\n            part = ary[i];\n            if (part === '.') {\n                ary.splice(i, 1);\n                i -= 1;\n            } else if (part === '..') {\n                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {\n                    //End of the line. Keep at least one non-dot\n                    //path segment at the front so it can be mapped\n                    //correctly to disk. Otherwise, there is likely\n                    //no path mapping for a path starting with '..'.\n                    //This can still fail, but catches the most reasonable\n                    //uses of ..\n                    break;\n                } else if (i > 0) {\n                    ary.splice(i - 1, 2);\n                    i -= 2;\n                }\n            }\n        }\n    }\n\n    function normalize(name, baseName) {\n        var baseParts;\n\n        //Adjust any relative paths.\n        if (name && name.charAt(0) === '.') {\n            //If have a base name, try to normalize against it,\n            //otherwise, assume it is a top-level require that will\n            //be relative to baseUrl in the end.\n            if (baseName) {\n                baseParts = baseName.split('/');\n                baseParts = baseParts.slice(0, baseParts.length - 1);\n                baseParts = baseParts.concat(name.split('/'));\n                trimDots(baseParts);\n                name = baseParts.join('/');\n            }\n        }\n\n        return name;\n    }\n\n    /**\n     * Create the normalize() function passed to a loader plugin's\n     * normalize method.\n     */\n    function makeNormalize(relName) {\n        return function (name) {\n            return normalize(name, relName);\n        };\n    }\n\n    function makeLoad(id) {\n        function load(value) {\n            loaderCache[id] = value;\n        }\n\n        load.fromText = function (id, text) {\n            //This one is difficult because the text can/probably uses\n            //define, and any relative paths and requires should be relative\n            //to that id was it would be found on disk. But this would require\n            //bootstrapping a module/require fairly deeply from node core.\n            //Not sure how best to go about that yet.\n            throw new Error('amdefine does not implement load.fromText');\n        };\n\n        return load;\n    }\n\n    makeRequire = function (systemRequire, exports, module, relId) {\n        function amdRequire(deps, callback) {\n            if (typeof deps === 'string') {\n                //Synchronous, single module require('')\n                return stringRequire(systemRequire, exports, module, deps, relId);\n            } else {\n                //Array of dependencies with a callback.\n\n                //Convert the dependencies to modules.\n                deps = deps.map(function (depName) {\n                    return stringRequire(systemRequire, exports, module, depName, relId);\n                });\n\n                //Wait for next tick to call back the require call.\n                if (callback) {\n                    process.nextTick(function () {\n                        callback.apply(null, deps);\n                    });\n                }\n            }\n        }\n\n        amdRequire.toUrl = function (filePath) {\n            if (filePath.indexOf('.') === 0) {\n                return normalize(filePath, path.dirname(module.filename));\n            } else {\n                return filePath;\n            }\n        };\n\n        return amdRequire;\n    };\n\n    //Favor explicit value, passed in if the module wants to support Node 0.4.\n    requireFn = requireFn || function req() {\n        return module.require.apply(module, arguments);\n    };\n\n    function runFactory(id, deps, factory) {\n        var r, e, m, result;\n\n        if (id) {\n            e = loaderCache[id] = {};\n            m = {\n                id: id,\n                uri: __filename,\n                exports: e\n            };\n            r = makeRequire(requireFn, e, m, id);\n        } else {\n            //Only support one define call per file\n            if (alreadyCalled) {\n                throw new Error('amdefine with no module ID cannot be called more than once per file.');\n            }\n            alreadyCalled = true;\n\n            //Use the real variables from node\n            //Use module.exports for exports, since\n            //the exports in here is amdefine exports.\n            e = module.exports;\n            m = module;\n            r = makeRequire(requireFn, e, m, module.id);\n        }\n\n        //If there are dependencies, they are strings, so need\n        //to convert them to dependency values.\n        if (deps) {\n            deps = deps.map(function (depName) {\n                return r(depName);\n            });\n        }\n\n        //Call the factory with the right dependencies.\n        if (typeof factory === 'function') {\n            result = factory.apply(m.exports, deps);\n        } else {\n            result = factory;\n        }\n\n        if (result !== undefined) {\n            m.exports = result;\n            if (id) {\n                loaderCache[id] = m.exports;\n            }\n        }\n    }\n\n    stringRequire = function (systemRequire, exports, module, id, relId) {\n        //Split the ID by a ! so that\n        var index = id.indexOf('!'),\n            originalId = id,\n            prefix, plugin;\n\n        if (index === -1) {\n            id = normalize(id, relId);\n\n            //Straight module lookup. If it is one of the special dependencies,\n            //deal with it, otherwise, delegate to node.\n            if (id === 'require') {\n                return makeRequire(systemRequire, exports, module, relId);\n            } else if (id === 'exports') {\n                return exports;\n            } else if (id === 'module') {\n                return module;\n            } else if (loaderCache.hasOwnProperty(id)) {\n                return loaderCache[id];\n            } else if (defineCache[id]) {\n                runFactory.apply(null, defineCache[id]);\n                return loaderCache[id];\n            } else {\n                if(systemRequire) {\n                    return systemRequire(originalId);\n                } else {\n                    throw new Error('No module with ID: ' + id);\n                }\n            }\n        } else {\n            //There is a plugin in play.\n            prefix = id.substring(0, index);\n            id = id.substring(index + 1, id.length);\n\n            plugin = stringRequire(systemRequire, exports, module, prefix, relId);\n\n            if (plugin.normalize) {\n                id = plugin.normalize(id, makeNormalize(relId));\n            } else {\n                //Normalize the ID normally.\n                id = normalize(id, relId);\n            }\n\n            if (loaderCache[id]) {\n                return loaderCache[id];\n            } else {\n                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});\n\n                return loaderCache[id];\n            }\n        }\n    };\n\n    //Create a define function specific to the module asking for amdefine.\n    function define(id, deps, factory) {\n        if (Array.isArray(id)) {\n            factory = deps;\n            deps = id;\n            id = undefined;\n        } else if (typeof id !== 'string') {\n            factory = id;\n            id = deps = undefined;\n        }\n\n        if (deps && !Array.isArray(deps)) {\n            factory = deps;\n            deps = undefined;\n        }\n\n        if (!deps) {\n            deps = ['require', 'exports', 'module'];\n        }\n\n        //Set up properties for this module. If an ID, then use\n        //internal cache. If no ID, then use the external variables\n        //for this node module.\n        if (id) {\n            //Put the module in deep freeze until there is a\n            //require call for it.\n            defineCache[id] = [id, deps, factory];\n        } else {\n            runFactory(id, deps, factory);\n        }\n    }\n\n    //define.require, which has access to all the values in the\n    //cache. Useful for AMD modules that all have IDs in the file,\n    //but need to finally export a value to node based on one of those\n    //IDs.\n    define.require = function (id) {\n        if (loaderCache[id]) {\n            return loaderCache[id];\n        }\n\n        if (defineCache[id]) {\n            runFactory.apply(null, defineCache[id]);\n            return loaderCache[id];\n        }\n    };\n\n    define.amd = {};\n\n    return define;\n}\n\nmodule.exports = amdefine;\n\n}).call(this,require('_process'),\"/node_modules/amdefine/amdefine.js\")\n},{\"_process\":65,\"path\":64}],2:[function(require,module,exports){\n\"use strict\";\n\n// rawAsap provides everything we need except exception management.\nvar rawAsap = require(\"./raw\");\n// RawTasks are recycled to reduce GC churn.\nvar freeTasks = [];\n// We queue errors to ensure they are thrown in right order (FIFO).\n// Array-as-queue is good enough here, since we are just dealing with exceptions.\nvar pendingErrors = [];\nvar requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);\n\nfunction throwFirstError() {\n    if (pendingErrors.length) {\n        throw pendingErrors.shift();\n    }\n}\n\n/**\n * Calls a task as soon as possible after returning, in its own event, with priority\n * over other events like animation, reflow, and repaint. An error thrown from an\n * event will not interrupt, nor even substantially slow down the processing of\n * other events, but will be rather postponed to a lower priority event.\n * @param {{call}} task A callable object, typically a function that takes no\n * arguments.\n */\nmodule.exports = asap;\nfunction asap(task) {\n    var rawTask;\n    if (freeTasks.length) {\n        rawTask = freeTasks.pop();\n    } else {\n        rawTask = new RawTask();\n    }\n    rawTask.task = task;\n    rawAsap(rawTask);\n}\n\n// We wrap tasks with recyclable task objects.  A task object implements\n// `call`, just like a function.\nfunction RawTask() {\n    this.task = null;\n}\n\n// The sole purpose of wrapping the task is to catch the exception and recycle\n// the task object after its single use.\nRawTask.prototype.call = function () {\n    try {\n        this.task.call();\n    } catch (error) {\n        if (asap.onerror) {\n            // This hook exists purely for testing purposes.\n            // Its name will be periodically randomized to break any code that\n            // depends on its existence.\n            asap.onerror(error);\n        } else {\n            // In a web browser, exceptions are not fatal. However, to avoid\n            // slowing down the queue of pending tasks, we rethrow the error in a\n            // lower priority turn.\n            pendingErrors.push(error);\n            requestErrorThrow();\n        }\n    } finally {\n        this.task = null;\n        freeTasks[freeTasks.length] = this;\n    }\n};\n\n},{\"./raw\":3}],3:[function(require,module,exports){\n(function (global){\n\"use strict\";\n\n// Use the fastest means possible to execute a task in its own turn, with\n// priority over other events including IO, animation, reflow, and redraw\n// events in browsers.\n//\n// An exception thrown by a task will permanently interrupt the processing of\n// subsequent tasks. The higher level `asap` function ensures that if an\n// exception is thrown by a task, that the task queue will continue flushing as\n// soon as possible, but if you use `rawAsap` directly, you are responsible to\n// either ensure that no exceptions are thrown from your task, or to manually\n// call `rawAsap.requestFlush` if an exception is thrown.\nmodule.exports = rawAsap;\nfunction rawAsap(task) {\n    if (!queue.length) {\n        requestFlush();\n        flushing = true;\n    }\n    // Equivalent to push, but avoids a function call.\n    queue[queue.length] = task;\n}\n\nvar queue = [];\n// Once a flush has been requested, no further calls to `requestFlush` are\n// necessary until the next `flush` completes.\nvar flushing = false;\n// `requestFlush` is an implementation-specific method that attempts to kick\n// off a `flush` event as quickly as possible. `flush` will attempt to exhaust\n// the event queue before yielding to the browser's own event loop.\nvar requestFlush;\n// The position of the next task to execute in the task queue. This is\n// preserved between calls to `flush` so that it can be resumed if\n// a task throws an exception.\nvar index = 0;\n// If a task schedules additional tasks recursively, the task queue can grow\n// unbounded. To prevent memory exhaustion, the task queue will periodically\n// truncate already-completed tasks.\nvar capacity = 1024;\n\n// The flush function processes all tasks that have been scheduled with\n// `rawAsap` unless and until one of those tasks throws an exception.\n// If a task throws an exception, `flush` ensures that its state will remain\n// consistent and will resume where it left off when called again.\n// However, `flush` does not make any arrangements to be called again if an\n// exception is thrown.\nfunction flush() {\n    while (index < queue.length) {\n        var currentIndex = index;\n        // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n        index = index + 1;\n        queue[currentIndex].call();\n        // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don't\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n        if (index > capacity) {\n            // Manually shift all values starting at the index back to the\n            // beginning of the queue.\n            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n            }\n            queue.length -= index;\n            index = 0;\n        }\n    }\n    queue.length = 0;\n    index = 0;\n    flushing = false;\n}\n\n// `requestFlush` is implemented using a strategy based on data collected from\n// every available SauceLabs Selenium web driver worker at time of writing.\n// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\n// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n// have WebKitMutationObserver but not un-prefixed MutationObserver.\n// Must use `global` or `self` instead of `window` to work in both frames and web\n// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n\n/* globals self */\nvar scope = typeof global !== \"undefined\" ? global : self;\nvar BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;\n\n// MutationObservers are desirable because they have high priority and work\n// reliably everywhere they are implemented.\n// They are implemented in all modern browsers.\n//\n// - Android 4-4.3\n// - Chrome 26-34\n// - Firefox 14-29\n// - Internet Explorer 11\n// - iPad Safari 6-7.1\n// - iPhone Safari 7-7.1\n// - Safari 6-7\nif (typeof BrowserMutationObserver === \"function\") {\n    requestFlush = makeRequestCallFromMutationObserver(flush);\n\n// MessageChannels are desirable because they give direct access to the HTML\n// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n// 11-12, and in web workers in many engines.\n// Although message channels yield to any queued rendering and IO tasks, they\n// would be better than imposing the 4ms delay of timers.\n// However, they do not work reliably in Internet Explorer or Safari.\n\n// Internet Explorer 10 is the only browser that has setImmediate but does\n// not have MutationObservers.\n// Although setImmediate yields to the browser's renderer, it would be\n// preferrable to falling back to setTimeout since it does not have\n// the minimum 4ms penalty.\n// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n// Desktop to a lesser extent) that renders both setImmediate and\n// MessageChannel useless for the purposes of ASAP.\n// https://github.com/kriskowal/q/issues/396\n\n// Timers are implemented universally.\n// We fall back to timers in workers in most engines, and in foreground\n// contexts in the following browsers.\n// However, note that even this simple case requires nuances to operate in a\n// broad spectrum of browsers.\n//\n// - Firefox 3-13\n// - Internet Explorer 6-9\n// - iPad Safari 4.3\n// - Lynx 2.8.7\n} else {\n    requestFlush = makeRequestCallFromTimer(flush);\n}\n\n// `requestFlush` requests that the high priority event queue be flushed as\n// soon as possible.\n// This is useful to prevent an error thrown in a task from stalling the event\n// queue if the exception handled by Node.js’s\n// `process.on(\"uncaughtException\")` or by a domain.\nrawAsap.requestFlush = requestFlush;\n\n// To request a high priority event, we induce a mutation observer by toggling\n// the text of a text node between \"1\" and \"-1\".\nfunction makeRequestCallFromMutationObserver(callback) {\n    var toggle = 1;\n    var observer = new BrowserMutationObserver(callback);\n    var node = document.createTextNode(\"\");\n    observer.observe(node, {characterData: true});\n    return function requestCall() {\n        toggle = -toggle;\n        node.data = toggle;\n    };\n}\n\n// The message channel technique was discovered by Malte Ubl and was the\n// original foundation for this library.\n// http://www.nonblocking.io/2011/06/windownexttick.html\n\n// Safari 6.0.5 (at least) intermittently fails to create message ports on a\n// page's first load. Thankfully, this version of Safari supports\n// MutationObservers, so we don't need to fall back in that case.\n\n// function makeRequestCallFromMessageChannel(callback) {\n//     var channel = new MessageChannel();\n//     channel.port1.onmessage = callback;\n//     return function requestCall() {\n//         channel.port2.postMessage(0);\n//     };\n// }\n\n// For reasons explained above, we are also unable to use `setImmediate`\n// under any circumstances.\n// Even if we were, there is another bug in Internet Explorer 10.\n// It is not sufficient to assign `setImmediate` to `requestFlush` because\n// `setImmediate` must be called *by name* and therefore must be wrapped in a\n// closure.\n// Never forget.\n\n// function makeRequestCallFromSetImmediate(callback) {\n//     return function requestCall() {\n//         setImmediate(callback);\n//     };\n// }\n\n// Safari 6.0 has a problem where timers will get lost while the user is\n// scrolling. This problem does not impact ASAP because Safari 6.0 supports\n// mutation observers, so that implementation is used instead.\n// However, if we ever elect to use timers in Safari, the prevalent work-around\n// is to add a scroll event listener that calls for a flush.\n\n// `setTimeout` does not call the passed callback if the delay is less than\n// approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n// even then.\n\nfunction makeRequestCallFromTimer(callback) {\n    return function requestCall() {\n        // We dispatch a timeout with a specified delay of 0 for engines that\n        // can reliably accommodate that request. This will usually be snapped\n        // to a 4 milisecond delay, but once we're flushing, there's no delay\n        // between events.\n        var timeoutHandle = setTimeout(handleTimer, 0);\n        // However, since this timer gets frequently dropped in Firefox\n        // workers, we enlist an interval handle that will try to fire\n        // an event 20 times per second until it succeeds.\n        var intervalHandle = setInterval(handleTimer, 50);\n\n        function handleTimer() {\n            // Whichever timer succeeds will cancel both timers and\n            // execute the callback.\n            clearTimeout(timeoutHandle);\n            clearInterval(intervalHandle);\n            callback();\n        }\n    };\n}\n\n// This is for `asap.js` only.\n// Its name will be periodically randomized to break any code that depends on\n// its existence.\nrawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;\n\n// ASAP was originally a nextTick shim included in Q. This was factored out\n// into this ASAP package. It was later adapted to RSVP which made further\n// amendments. These decisions, particularly to marginalize MessageChannel and\n// to capture the MutationObserver implementation in a closure, were integrated\n// back into ASAP proper.\n// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],4:[function(require,module,exports){\n(function (process,global){\n/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE\n * @version   4.0.5\n */\n\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global.ES6Promise = factory());\n}(this, (function () { 'use strict';\n\nfunction objectOrFunction(x) {\n  return typeof x === 'function' || typeof x === 'object' && x !== null;\n}\n\nfunction isFunction(x) {\n  return typeof x === 'function';\n}\n\nvar _isArray = undefined;\nif (!Array.isArray) {\n  _isArray = function (x) {\n    return Object.prototype.toString.call(x) === '[object Array]';\n  };\n} else {\n  _isArray = Array.isArray;\n}\n\nvar isArray = _isArray;\n\nvar len = 0;\nvar vertxNext = undefined;\nvar customSchedulerFn = undefined;\n\nvar asap = function asap(callback, arg) {\n  queue[len] = callback;\n  queue[len + 1] = arg;\n  len += 2;\n  if (len === 2) {\n    // If len is 2, that means that we need to schedule an async flush.\n    // If additional callbacks are queued before the queue is flushed, they\n    // will be processed by this flush that we are scheduling.\n    if (customSchedulerFn) {\n      customSchedulerFn(flush);\n    } else {\n      scheduleFlush();\n    }\n  }\n};\n\nfunction setScheduler(scheduleFn) {\n  customSchedulerFn = scheduleFn;\n}\n\nfunction setAsap(asapFn) {\n  asap = asapFn;\n}\n\nvar browserWindow = typeof window !== 'undefined' ? window : undefined;\nvar browserGlobal = browserWindow || {};\nvar BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\nvar isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';\n\n// test for web worker but not in IE10\nvar isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';\n\n// node\nfunction useNextTick() {\n  // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n  // see https://github.com/cujojs/when/issues/410 for details\n  return function () {\n    return process.nextTick(flush);\n  };\n}\n\n// vertx\nfunction useVertxTimer() {\n  if (typeof vertxNext !== 'undefined') {\n    return function () {\n      vertxNext(flush);\n    };\n  }\n\n  return useSetTimeout();\n}\n\nfunction useMutationObserver() {\n  var iterations = 0;\n  var observer = new BrowserMutationObserver(flush);\n  var node = document.createTextNode('');\n  observer.observe(node, { characterData: true });\n\n  return function () {\n    node.data = iterations = ++iterations % 2;\n  };\n}\n\n// web worker\nfunction useMessageChannel() {\n  var channel = new MessageChannel();\n  channel.port1.onmessage = flush;\n  return function () {\n    return channel.port2.postMessage(0);\n  };\n}\n\nfunction useSetTimeout() {\n  // Store setTimeout reference so es6-promise will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  var globalSetTimeout = setTimeout;\n  return function () {\n    return globalSetTimeout(flush, 1);\n  };\n}\n\nvar queue = new Array(1000);\nfunction flush() {\n  for (var i = 0; i < len; i += 2) {\n    var callback = queue[i];\n    var arg = queue[i + 1];\n\n    callback(arg);\n\n    queue[i] = undefined;\n    queue[i + 1] = undefined;\n  }\n\n  len = 0;\n}\n\nfunction attemptVertx() {\n  try {\n    var r = require;\n    var vertx = r('vertx');\n    vertxNext = vertx.runOnLoop || vertx.runOnContext;\n    return useVertxTimer();\n  } catch (e) {\n    return useSetTimeout();\n  }\n}\n\nvar scheduleFlush = undefined;\n// Decide what async method to use to triggering processing of queued callbacks:\nif (isNode) {\n  scheduleFlush = useNextTick();\n} else if (BrowserMutationObserver) {\n  scheduleFlush = useMutationObserver();\n} else if (isWorker) {\n  scheduleFlush = useMessageChannel();\n} else if (browserWindow === undefined && typeof require === 'function') {\n  scheduleFlush = attemptVertx();\n} else {\n  scheduleFlush = useSetTimeout();\n}\n\nfunction then(onFulfillment, onRejection) {\n  var _arguments = arguments;\n\n  var parent = this;\n\n  var child = new this.constructor(noop);\n\n  if (child[PROMISE_ID] === undefined) {\n    makePromise(child);\n  }\n\n  var _state = parent._state;\n\n  if (_state) {\n    (function () {\n      var callback = _arguments[_state - 1];\n      asap(function () {\n        return invokeCallback(_state, child, callback, parent._result);\n      });\n    })();\n  } else {\n    subscribe(parent, child, onFulfillment, onRejection);\n  }\n\n  return child;\n}\n\n/**\n  `Promise.resolve` returns a promise that will become resolved with the\n  passed `value`. It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    resolve(1);\n  });\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.resolve(1);\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  @method resolve\n  @static\n  @param {Any} value value that the returned promise will be resolved with\n  Useful for tooling.\n  @return {Promise} a promise that will become fulfilled with the given\n  `value`\n*/\nfunction resolve(object) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (object && typeof object === 'object' && object.constructor === Constructor) {\n    return object;\n  }\n\n  var promise = new Constructor(noop);\n  _resolve(promise, object);\n  return promise;\n}\n\nvar PROMISE_ID = Math.random().toString(36).substring(16);\n\nfunction noop() {}\n\nvar PENDING = void 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nvar GET_THEN_ERROR = new ErrorObject();\n\nfunction selfFulfillment() {\n  return new TypeError(\"You cannot resolve a promise with itself\");\n}\n\nfunction cannotReturnOwn() {\n  return new TypeError('A promises callback cannot return that same promise.');\n}\n\nfunction getThen(promise) {\n  try {\n    return promise.then;\n  } catch (error) {\n    GET_THEN_ERROR.error = error;\n    return GET_THEN_ERROR;\n  }\n}\n\nfunction tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n  try {\n    then.call(value, fulfillmentHandler, rejectionHandler);\n  } catch (e) {\n    return e;\n  }\n}\n\nfunction handleForeignThenable(promise, thenable, then) {\n  asap(function (promise) {\n    var sealed = false;\n    var error = tryThen(then, thenable, function (value) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n      if (thenable !== value) {\n        _resolve(promise, value);\n      } else {\n        fulfill(promise, value);\n      }\n    }, function (reason) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n\n      _reject(promise, reason);\n    }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n    if (!sealed && error) {\n      sealed = true;\n      _reject(promise, error);\n    }\n  }, promise);\n}\n\nfunction handleOwnThenable(promise, thenable) {\n  if (thenable._state === FULFILLED) {\n    fulfill(promise, thenable._result);\n  } else if (thenable._state === REJECTED) {\n    _reject(promise, thenable._result);\n  } else {\n    subscribe(thenable, undefined, function (value) {\n      return _resolve(promise, value);\n    }, function (reason) {\n      return _reject(promise, reason);\n    });\n  }\n}\n\nfunction handleMaybeThenable(promise, maybeThenable, then$$) {\n  if (maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve) {\n    handleOwnThenable(promise, maybeThenable);\n  } else {\n    if (then$$ === GET_THEN_ERROR) {\n      _reject(promise, GET_THEN_ERROR.error);\n    } else if (then$$ === undefined) {\n      fulfill(promise, maybeThenable);\n    } else if (isFunction(then$$)) {\n      handleForeignThenable(promise, maybeThenable, then$$);\n    } else {\n      fulfill(promise, maybeThenable);\n    }\n  }\n}\n\nfunction _resolve(promise, value) {\n  if (promise === value) {\n    _reject(promise, selfFulfillment());\n  } else if (objectOrFunction(value)) {\n    handleMaybeThenable(promise, value, getThen(value));\n  } else {\n    fulfill(promise, value);\n  }\n}\n\nfunction publishRejection(promise) {\n  if (promise._onerror) {\n    promise._onerror(promise._result);\n  }\n\n  publish(promise);\n}\n\nfunction fulfill(promise, value) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n\n  promise._result = value;\n  promise._state = FULFILLED;\n\n  if (promise._subscribers.length !== 0) {\n    asap(publish, promise);\n  }\n}\n\nfunction _reject(promise, reason) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n  promise._state = REJECTED;\n  promise._result = reason;\n\n  asap(publishRejection, promise);\n}\n\nfunction subscribe(parent, child, onFulfillment, onRejection) {\n  var _subscribers = parent._subscribers;\n  var length = _subscribers.length;\n\n  parent._onerror = null;\n\n  _subscribers[length] = child;\n  _subscribers[length + FULFILLED] = onFulfillment;\n  _subscribers[length + REJECTED] = onRejection;\n\n  if (length === 0 && parent._state) {\n    asap(publish, parent);\n  }\n}\n\nfunction publish(promise) {\n  var subscribers = promise._subscribers;\n  var settled = promise._state;\n\n  if (subscribers.length === 0) {\n    return;\n  }\n\n  var child = undefined,\n      callback = undefined,\n      detail = promise._result;\n\n  for (var i = 0; i < subscribers.length; i += 3) {\n    child = subscribers[i];\n    callback = subscribers[i + settled];\n\n    if (child) {\n      invokeCallback(settled, child, callback, detail);\n    } else {\n      callback(detail);\n    }\n  }\n\n  promise._subscribers.length = 0;\n}\n\nfunction ErrorObject() {\n  this.error = null;\n}\n\nvar TRY_CATCH_ERROR = new ErrorObject();\n\nfunction tryCatch(callback, detail) {\n  try {\n    return callback(detail);\n  } catch (e) {\n    TRY_CATCH_ERROR.error = e;\n    return TRY_CATCH_ERROR;\n  }\n}\n\nfunction invokeCallback(settled, promise, callback, detail) {\n  var hasCallback = isFunction(callback),\n      value = undefined,\n      error = undefined,\n      succeeded = undefined,\n      failed = undefined;\n\n  if (hasCallback) {\n    value = tryCatch(callback, detail);\n\n    if (value === TRY_CATCH_ERROR) {\n      failed = true;\n      error = value.error;\n      value = null;\n    } else {\n      succeeded = true;\n    }\n\n    if (promise === value) {\n      _reject(promise, cannotReturnOwn());\n      return;\n    }\n  } else {\n    value = detail;\n    succeeded = true;\n  }\n\n  if (promise._state !== PENDING) {\n    // noop\n  } else if (hasCallback && succeeded) {\n      _resolve(promise, value);\n    } else if (failed) {\n      _reject(promise, error);\n    } else if (settled === FULFILLED) {\n      fulfill(promise, value);\n    } else if (settled === REJECTED) {\n      _reject(promise, value);\n    }\n}\n\nfunction initializePromise(promise, resolver) {\n  try {\n    resolver(function resolvePromise(value) {\n      _resolve(promise, value);\n    }, function rejectPromise(reason) {\n      _reject(promise, reason);\n    });\n  } catch (e) {\n    _reject(promise, e);\n  }\n}\n\nvar id = 0;\nfunction nextId() {\n  return id++;\n}\n\nfunction makePromise(promise) {\n  promise[PROMISE_ID] = id++;\n  promise._state = undefined;\n  promise._result = undefined;\n  promise._subscribers = [];\n}\n\nfunction Enumerator(Constructor, input) {\n  this._instanceConstructor = Constructor;\n  this.promise = new Constructor(noop);\n\n  if (!this.promise[PROMISE_ID]) {\n    makePromise(this.promise);\n  }\n\n  if (isArray(input)) {\n    this._input = input;\n    this.length = input.length;\n    this._remaining = input.length;\n\n    this._result = new Array(this.length);\n\n    if (this.length === 0) {\n      fulfill(this.promise, this._result);\n    } else {\n      this.length = this.length || 0;\n      this._enumerate();\n      if (this._remaining === 0) {\n        fulfill(this.promise, this._result);\n      }\n    }\n  } else {\n    _reject(this.promise, validationError());\n  }\n}\n\nfunction validationError() {\n  return new Error('Array Methods must be provided an Array');\n};\n\nEnumerator.prototype._enumerate = function () {\n  var length = this.length;\n  var _input = this._input;\n\n  for (var i = 0; this._state === PENDING && i < length; i++) {\n    this._eachEntry(_input[i], i);\n  }\n};\n\nEnumerator.prototype._eachEntry = function (entry, i) {\n  var c = this._instanceConstructor;\n  var resolve$$ = c.resolve;\n\n  if (resolve$$ === resolve) {\n    var _then = getThen(entry);\n\n    if (_then === then && entry._state !== PENDING) {\n      this._settledAt(entry._state, i, entry._result);\n    } else if (typeof _then !== 'function') {\n      this._remaining--;\n      this._result[i] = entry;\n    } else if (c === Promise) {\n      var promise = new c(noop);\n      handleMaybeThenable(promise, entry, _then);\n      this._willSettleAt(promise, i);\n    } else {\n      this._willSettleAt(new c(function (resolve$$) {\n        return resolve$$(entry);\n      }), i);\n    }\n  } else {\n    this._willSettleAt(resolve$$(entry), i);\n  }\n};\n\nEnumerator.prototype._settledAt = function (state, i, value) {\n  var promise = this.promise;\n\n  if (promise._state === PENDING) {\n    this._remaining--;\n\n    if (state === REJECTED) {\n      _reject(promise, value);\n    } else {\n      this._result[i] = value;\n    }\n  }\n\n  if (this._remaining === 0) {\n    fulfill(promise, this._result);\n  }\n};\n\nEnumerator.prototype._willSettleAt = function (promise, i) {\n  var enumerator = this;\n\n  subscribe(promise, undefined, function (value) {\n    return enumerator._settledAt(FULFILLED, i, value);\n  }, function (reason) {\n    return enumerator._settledAt(REJECTED, i, reason);\n  });\n};\n\n/**\n  `Promise.all` accepts an array of promises, and returns a new promise which\n  is fulfilled with an array of fulfillment values for the passed promises, or\n  rejected with the reason of the first passed promise to be rejected. It casts all\n  elements of the passed iterable to promises as it runs this algorithm.\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = resolve(2);\n  let promise3 = resolve(3);\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // The array here would be [ 1, 2, 3 ];\n  });\n  ```\n\n  If any of the `promises` given to `all` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promises's\n  rejection handler. For example:\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = reject(new Error(\"2\"));\n  let promise3 = reject(new Error(\"3\"));\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(error) {\n    // error.message === \"2\"\n  });\n  ```\n\n  @method all\n  @static\n  @param {Array} entries array of promises\n  @param {String} label optional string for labeling the promise.\n  Useful for tooling.\n  @return {Promise} promise that is fulfilled when all `promises` have been\n  fulfilled, or rejected if any of them become rejected.\n  @static\n*/\nfunction all(entries) {\n  return new Enumerator(this, entries).promise;\n}\n\n/**\n  `Promise.race` returns a new promise which is settled in the same way as the\n  first passed promise to settle.\n\n  Example:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 2');\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // result === 'promise 2' because it was resolved before promise1\n    // was resolved.\n  });\n  ```\n\n  `Promise.race` is deterministic in that only the state of the first\n  settled promise matters. For example, even if other promises given to the\n  `promises` array argument are resolved, but the first settled promise has\n  become rejected before the other promises became fulfilled, the returned\n  promise will become rejected:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      reject(new Error('promise 2'));\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // Code here never runs\n  }, function(reason){\n    // reason.message === 'promise 2' because promise 2 became rejected before\n    // promise 1 became fulfilled\n  });\n  ```\n\n  An example real-world use case is implementing timeouts:\n\n  ```javascript\n  Promise.race([ajax('foo.json'), timeout(5000)])\n  ```\n\n  @method race\n  @static\n  @param {Array} promises array of promises to observe\n  Useful for tooling.\n  @return {Promise} a promise which settles in the same way as the first passed\n  promise to settle.\n*/\nfunction race(entries) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (!isArray(entries)) {\n    return new Constructor(function (_, reject) {\n      return reject(new TypeError('You must pass an array to race.'));\n    });\n  } else {\n    return new Constructor(function (resolve, reject) {\n      var length = entries.length;\n      for (var i = 0; i < length; i++) {\n        Constructor.resolve(entries[i]).then(resolve, reject);\n      }\n    });\n  }\n}\n\n/**\n  `Promise.reject` returns a promise rejected with the passed `reason`.\n  It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    reject(new Error('WHOOPS'));\n  });\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.reject(new Error('WHOOPS'));\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  @method reject\n  @static\n  @param {Any} reason value that the returned promise will be rejected with.\n  Useful for tooling.\n  @return {Promise} a promise rejected with the given `reason`.\n*/\nfunction reject(reason) {\n  /*jshint validthis:true */\n  var Constructor = this;\n  var promise = new Constructor(noop);\n  _reject(promise, reason);\n  return promise;\n}\n\nfunction needsResolver() {\n  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n}\n\nfunction needsNew() {\n  throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n}\n\n/**\n  Promise objects represent the eventual result of an asynchronous operation. The\n  primary way of interacting with a promise is through its `then` method, which\n  registers callbacks to receive either a promise's eventual value or the reason\n  why the promise cannot be fulfilled.\n\n  Terminology\n  -----------\n\n  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n  - `thenable` is an object or function that defines a `then` method.\n  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n  - `exception` is a value that is thrown using the throw statement.\n  - `reason` is a value that indicates why a promise was rejected.\n  - `settled` the final resting state of a promise, fulfilled or rejected.\n\n  A promise can be in one of three states: pending, fulfilled, or rejected.\n\n  Promises that are fulfilled have a fulfillment value and are in the fulfilled\n  state.  Promises that are rejected have a rejection reason and are in the\n  rejected state.  A fulfillment value is never a thenable.\n\n  Promises can also be said to *resolve* a value.  If this value is also a\n  promise, then the original promise's settled state will match the value's\n  settled state.  So a promise that *resolves* a promise that rejects will\n  itself reject, and a promise that *resolves* a promise that fulfills will\n  itself fulfill.\n\n\n  Basic Usage:\n  ------------\n\n  ```js\n  let promise = new Promise(function(resolve, reject) {\n    // on success\n    resolve(value);\n\n    // on failure\n    reject(reason);\n  });\n\n  promise.then(function(value) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Advanced Usage:\n  ---------------\n\n  Promises shine when abstracting away asynchronous interactions such as\n  `XMLHttpRequest`s.\n\n  ```js\n  function getJSON(url) {\n    return new Promise(function(resolve, reject){\n      let xhr = new XMLHttpRequest();\n\n      xhr.open('GET', url);\n      xhr.onreadystatechange = handler;\n      xhr.responseType = 'json';\n      xhr.setRequestHeader('Accept', 'application/json');\n      xhr.send();\n\n      function handler() {\n        if (this.readyState === this.DONE) {\n          if (this.status === 200) {\n            resolve(this.response);\n          } else {\n            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n          }\n        }\n      };\n    });\n  }\n\n  getJSON('/posts.json').then(function(json) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Unlike callbacks, promises are great composable primitives.\n\n  ```js\n  Promise.all([\n    getJSON('/posts'),\n    getJSON('/comments')\n  ]).then(function(values){\n    values[0] // => postsJSON\n    values[1] // => commentsJSON\n\n    return values;\n  });\n  ```\n\n  @class Promise\n  @param {function} resolver\n  Useful for tooling.\n  @constructor\n*/\nfunction Promise(resolver) {\n  this[PROMISE_ID] = nextId();\n  this._result = this._state = undefined;\n  this._subscribers = [];\n\n  if (noop !== resolver) {\n    typeof resolver !== 'function' && needsResolver();\n    this instanceof Promise ? initializePromise(this, resolver) : needsNew();\n  }\n}\n\nPromise.all = all;\nPromise.race = race;\nPromise.resolve = resolve;\nPromise.reject = reject;\nPromise._setScheduler = setScheduler;\nPromise._setAsap = setAsap;\nPromise._asap = asap;\n\nPromise.prototype = {\n  constructor: Promise,\n\n  /**\n    The primary way of interacting with a promise is through its `then` method,\n    which registers callbacks to receive either a promise's eventual value or the\n    reason why the promise cannot be fulfilled.\n  \n    ```js\n    findUser().then(function(user){\n      // user is available\n    }, function(reason){\n      // user is unavailable, and you are given the reason why\n    });\n    ```\n  \n    Chaining\n    --------\n  \n    The return value of `then` is itself a promise.  This second, 'downstream'\n    promise is resolved with the return value of the first promise's fulfillment\n    or rejection handler, or rejected if the handler throws an exception.\n  \n    ```js\n    findUser().then(function (user) {\n      return user.name;\n    }, function (reason) {\n      return 'default name';\n    }).then(function (userName) {\n      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n      // will be `'default name'`\n    });\n  \n    findUser().then(function (user) {\n      throw new Error('Found user, but still unhappy');\n    }, function (reason) {\n      throw new Error('`findUser` rejected and we're unhappy');\n    }).then(function (value) {\n      // never reached\n    }, function (reason) {\n      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n    });\n    ```\n    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n  \n    ```js\n    findUser().then(function (user) {\n      throw new PedagogicalException('Upstream error');\n    }).then(function (value) {\n      // never reached\n    }).then(function (value) {\n      // never reached\n    }, function (reason) {\n      // The `PedgagocialException` is propagated all the way down to here\n    });\n    ```\n  \n    Assimilation\n    ------------\n  \n    Sometimes the value you want to propagate to a downstream promise can only be\n    retrieved asynchronously. This can be achieved by returning a promise in the\n    fulfillment or rejection handler. The downstream promise will then be pending\n    until the returned promise is settled. This is called *assimilation*.\n  \n    ```js\n    findUser().then(function (user) {\n      return findCommentsByAuthor(user);\n    }).then(function (comments) {\n      // The user's comments are now available\n    });\n    ```\n  \n    If the assimliated promise rejects, then the downstream promise will also reject.\n  \n    ```js\n    findUser().then(function (user) {\n      return findCommentsByAuthor(user);\n    }).then(function (comments) {\n      // If `findCommentsByAuthor` fulfills, we'll have the value here\n    }, function (reason) {\n      // If `findCommentsByAuthor` rejects, we'll have the reason here\n    });\n    ```\n  \n    Simple Example\n    --------------\n  \n    Synchronous Example\n  \n    ```javascript\n    let result;\n  \n    try {\n      result = findResult();\n      // success\n    } catch(reason) {\n      // failure\n    }\n    ```\n  \n    Errback Example\n  \n    ```js\n    findResult(function(result, err){\n      if (err) {\n        // failure\n      } else {\n        // success\n      }\n    });\n    ```\n  \n    Promise Example;\n  \n    ```javascript\n    findResult().then(function(result){\n      // success\n    }, function(reason){\n      // failure\n    });\n    ```\n  \n    Advanced Example\n    --------------\n  \n    Synchronous Example\n  \n    ```javascript\n    let author, books;\n  \n    try {\n      author = findAuthor();\n      books  = findBooksByAuthor(author);\n      // success\n    } catch(reason) {\n      // failure\n    }\n    ```\n  \n    Errback Example\n  \n    ```js\n  \n    function foundBooks(books) {\n  \n    }\n  \n    function failure(reason) {\n  \n    }\n  \n    findAuthor(function(author, err){\n      if (err) {\n        failure(err);\n        // failure\n      } else {\n        try {\n          findBoooksByAuthor(author, function(books, err) {\n            if (err) {\n              failure(err);\n            } else {\n              try {\n                foundBooks(books);\n              } catch(reason) {\n                failure(reason);\n              }\n            }\n          });\n        } catch(error) {\n          failure(err);\n        }\n        // success\n      }\n    });\n    ```\n  \n    Promise Example;\n  \n    ```javascript\n    findAuthor().\n      then(findBooksByAuthor).\n      then(function(books){\n        // found books\n    }).catch(function(reason){\n      // something went wrong\n    });\n    ```\n  \n    @method then\n    @param {Function} onFulfilled\n    @param {Function} onRejected\n    Useful for tooling.\n    @return {Promise}\n  */\n  then: then,\n\n  /**\n    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n    as the catch block of a try/catch statement.\n  \n    ```js\n    function findAuthor(){\n      throw new Error('couldn't find that author');\n    }\n  \n    // synchronous\n    try {\n      findAuthor();\n    } catch(reason) {\n      // something went wrong\n    }\n  \n    // async with promises\n    findAuthor().catch(function(reason){\n      // something went wrong\n    });\n    ```\n  \n    @method catch\n    @param {Function} onRejection\n    Useful for tooling.\n    @return {Promise}\n  */\n  'catch': function _catch(onRejection) {\n    return this.then(null, onRejection);\n  }\n};\n\nfunction polyfill() {\n    var local = undefined;\n\n    if (typeof global !== 'undefined') {\n        local = global;\n    } else if (typeof self !== 'undefined') {\n        local = self;\n    } else {\n        try {\n            local = Function('return this')();\n        } catch (e) {\n            throw new Error('polyfill failed because global object is unavailable in this environment');\n        }\n    }\n\n    var P = local.Promise;\n\n    if (P) {\n        var promiseToString = null;\n        try {\n            promiseToString = Object.prototype.toString.call(P.resolve());\n        } catch (e) {\n            // silently ignored\n        }\n\n        if (promiseToString === '[object Promise]' && !P.cast) {\n            return;\n        }\n    }\n\n    local.Promise = Promise;\n}\n\n// Strange compat..\nPromise.polyfill = polyfill;\nPromise.Promise = Promise;\n\nreturn Promise;\n\n})));\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"_process\":65}],5:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _handlebarsRuntime = require('./handlebars.runtime');\n\nvar _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);\n\n// Compiler imports\n\nvar _handlebarsCompilerAst = require('./handlebars/compiler/ast');\n\nvar _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);\n\nvar _handlebarsCompilerBase = require('./handlebars/compiler/base');\n\nvar _handlebarsCompilerCompiler = require('./handlebars/compiler/compiler');\n\nvar _handlebarsCompilerJavascriptCompiler = require('./handlebars/compiler/javascript-compiler');\n\nvar _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);\n\nvar _handlebarsCompilerVisitor = require('./handlebars/compiler/visitor');\n\nvar _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);\n\nvar _handlebarsNoConflict = require('./handlebars/no-conflict');\n\nvar _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);\n\nvar _create = _handlebarsRuntime2['default'].create;\nfunction create() {\n  var hb = _create();\n\n  hb.compile = function (input, options) {\n    return _handlebarsCompilerCompiler.compile(input, options, hb);\n  };\n  hb.precompile = function (input, options) {\n    return _handlebarsCompilerCompiler.precompile(input, options, hb);\n  };\n\n  hb.AST = _handlebarsCompilerAst2['default'];\n  hb.Compiler = _handlebarsCompilerCompiler.Compiler;\n  hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2['default'];\n  hb.Parser = _handlebarsCompilerBase.parser;\n  hb.parse = _handlebarsCompilerBase.parse;\n\n  return hb;\n}\n\nvar inst = create();\ninst.create = create;\n\n_handlebarsNoConflict2['default'](inst);\n\ninst.Visitor = _handlebarsCompilerVisitor2['default'];\n\ninst['default'] = inst;\n\nexports['default'] = inst;\nmodule.exports = exports['default'];\n\n\n},{\"./handlebars.runtime\":6,\"./handlebars/compiler/ast\":8,\"./handlebars/compiler/base\":9,\"./handlebars/compiler/compiler\":11,\"./handlebars/compiler/javascript-compiler\":13,\"./handlebars/compiler/visitor\":16,\"./handlebars/no-conflict\":30}],6:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nvar _handlebarsBase = require('./handlebars/base');\n\nvar base = _interopRequireWildcard(_handlebarsBase);\n\n// Each of these augment the Handlebars object. No need to setup here.\n// (This is done to easily share code between commonjs and browse envs)\n\nvar _handlebarsSafeString = require('./handlebars/safe-string');\n\nvar _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);\n\nvar _handlebarsException = require('./handlebars/exception');\n\nvar _handlebarsException2 = _interopRequireDefault(_handlebarsException);\n\nvar _handlebarsUtils = require('./handlebars/utils');\n\nvar Utils = _interopRequireWildcard(_handlebarsUtils);\n\nvar _handlebarsRuntime = require('./handlebars/runtime');\n\nvar runtime = _interopRequireWildcard(_handlebarsRuntime);\n\nvar _handlebarsNoConflict = require('./handlebars/no-conflict');\n\nvar _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);\n\n// For compatibility and usage outside of module systems, make the Handlebars object a namespace\nfunction create() {\n  var hb = new base.HandlebarsEnvironment();\n\n  Utils.extend(hb, base);\n  hb.SafeString = _handlebarsSafeString2['default'];\n  hb.Exception = _handlebarsException2['default'];\n  hb.Utils = Utils;\n  hb.escapeExpression = Utils.escapeExpression;\n\n  hb.VM = runtime;\n  hb.template = function (spec) {\n    return runtime.template(spec, hb);\n  };\n\n  return hb;\n}\n\nvar inst = create();\ninst.create = create;\n\n_handlebarsNoConflict2['default'](inst);\n\ninst['default'] = inst;\n\nexports['default'] = inst;\nmodule.exports = exports['default'];\n\n\n},{\"./handlebars/base\":7,\"./handlebars/exception\":20,\"./handlebars/no-conflict\":30,\"./handlebars/runtime\":31,\"./handlebars/safe-string\":32,\"./handlebars/utils\":33}],7:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\nexports.HandlebarsEnvironment = HandlebarsEnvironment;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _utils = require('./utils');\n\nvar _exception = require('./exception');\n\nvar _exception2 = _interopRequireDefault(_exception);\n\nvar _helpers = require('./helpers');\n\nvar _decorators = require('./decorators');\n\nvar _logger = require('./logger');\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nvar VERSION = '4.0.5';\nexports.VERSION = VERSION;\nvar COMPILER_REVISION = 7;\n\nexports.COMPILER_REVISION = COMPILER_REVISION;\nvar REVISION_CHANGES = {\n  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it\n  2: '== 1.0.0-rc.3',\n  3: '== 1.0.0-rc.4',\n  4: '== 1.x.x',\n  5: '== 2.0.0-alpha.x',\n  6: '>= 2.0.0-beta.1',\n  7: '>= 4.0.0'\n};\n\nexports.REVISION_CHANGES = REVISION_CHANGES;\nvar objectType = '[object Object]';\n\nfunction HandlebarsEnvironment(helpers, partials, decorators) {\n  this.helpers = helpers || {};\n  this.partials = partials || {};\n  this.decorators = decorators || {};\n\n  _helpers.registerDefaultHelpers(this);\n  _decorators.registerDefaultDecorators(this);\n}\n\nHandlebarsEnvironment.prototype = {\n  constructor: HandlebarsEnvironment,\n\n  logger: _logger2['default'],\n  log: _logger2['default'].log,\n\n  registerHelper: function registerHelper(name, fn) {\n    if (_utils.toString.call(name) === objectType) {\n      if (fn) {\n        throw new _exception2['default']('Arg not supported with multiple helpers');\n      }\n      _utils.extend(this.helpers, name);\n    } else {\n      this.helpers[name] = fn;\n    }\n  },\n  unregisterHelper: function unregisterHelper(name) {\n    delete this.helpers[name];\n  },\n\n  registerPartial: function registerPartial(name, partial) {\n    if (_utils.toString.call(name) === objectType) {\n      _utils.extend(this.partials, name);\n    } else {\n      if (typeof partial === 'undefined') {\n        throw new _exception2['default']('Attempting to register a partial called \"' + name + '\" as undefined');\n      }\n      this.partials[name] = partial;\n    }\n  },\n  unregisterPartial: function unregisterPartial(name) {\n    delete this.partials[name];\n  },\n\n  registerDecorator: function registerDecorator(name, fn) {\n    if (_utils.toString.call(name) === objectType) {\n      if (fn) {\n        throw new _exception2['default']('Arg not supported with multiple decorators');\n      }\n      _utils.extend(this.decorators, name);\n    } else {\n      this.decorators[name] = fn;\n    }\n  },\n  unregisterDecorator: function unregisterDecorator(name) {\n    delete this.decorators[name];\n  }\n};\n\nvar log = _logger2['default'].log;\n\nexports.log = log;\nexports.createFrame = _utils.createFrame;\nexports.logger = _logger2['default'];\n\n\n},{\"./decorators\":18,\"./exception\":20,\"./helpers\":21,\"./logger\":29,\"./utils\":33}],8:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\nvar AST = {\n  // Public API used to evaluate derived attributes regarding AST nodes\n  helpers: {\n    // a mustache is definitely a helper if:\n    // * it is an eligible helper, and\n    // * it has at least one parameter or hash segment\n    helperExpression: function helperExpression(node) {\n      return node.type === 'SubExpression' || (node.type === 'MustacheStatement' || node.type === 'BlockStatement') && !!(node.params && node.params.length || node.hash);\n    },\n\n    scopedId: function scopedId(path) {\n      return (/^\\.|this\\b/.test(path.original)\n      );\n    },\n\n    // an ID is simple if it only has one part, and that part is not\n    // `..` or `this`.\n    simpleId: function simpleId(path) {\n      return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;\n    }\n  }\n};\n\n// Must be exported as an object rather than the root of the module as the jison lexer\n// must modify the object to operate properly.\nexports['default'] = AST;\nmodule.exports = exports['default'];\n\n\n},{}],9:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\nexports.parse = parse;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _parser = require('./parser');\n\nvar _parser2 = _interopRequireDefault(_parser);\n\nvar _whitespaceControl = require('./whitespace-control');\n\nvar _whitespaceControl2 = _interopRequireDefault(_whitespaceControl);\n\nvar _helpers = require('./helpers');\n\nvar Helpers = _interopRequireWildcard(_helpers);\n\nvar _utils = require('../utils');\n\nexports.parser = _parser2['default'];\n\nvar yy = {};\n_utils.extend(yy, Helpers);\n\nfunction parse(input, options) {\n  // Just return if an already-compiled AST was passed in.\n  if (input.type === 'Program') {\n    return input;\n  }\n\n  _parser2['default'].yy = yy;\n\n  // Altering the shared object here, but this is ok as parser is a sync operation\n  yy.locInfo = function (locInfo) {\n    return new yy.SourceLocation(options && options.srcName, locInfo);\n  };\n\n  var strip = new _whitespaceControl2['default'](options);\n  return strip.accept(_parser2['default'].parse(input));\n}\n\n\n},{\"../utils\":33,\"./helpers\":12,\"./parser\":14,\"./whitespace-control\":17}],10:[function(require,module,exports){\n/* global define */\n'use strict';\n\nexports.__esModule = true;\n\nvar _utils = require('../utils');\n\nvar SourceNode = undefined;\n\ntry {\n  /* istanbul ignore next */\n  if (typeof define !== 'function' || !define.amd) {\n    // We don't support this in AMD environments. For these environments, we asusme that\n    // they are running on the browser and thus have no need for the source-map library.\n    var SourceMap = require('source-map');\n    SourceNode = SourceMap.SourceNode;\n  }\n} catch (err) {}\n/* NOP */\n\n/* istanbul ignore if: tested but not covered in istanbul due to dist build  */\nif (!SourceNode) {\n  SourceNode = function (line, column, srcFile, chunks) {\n    this.src = '';\n    if (chunks) {\n      this.add(chunks);\n    }\n  };\n  /* istanbul ignore next */\n  SourceNode.prototype = {\n    add: function add(chunks) {\n      if (_utils.isArray(chunks)) {\n        chunks = chunks.join('');\n      }\n      this.src += chunks;\n    },\n    prepend: function prepend(chunks) {\n      if (_utils.isArray(chunks)) {\n        chunks = chunks.join('');\n      }\n      this.src = chunks + this.src;\n    },\n    toStringWithSourceMap: function toStringWithSourceMap() {\n      return { code: this.toString() };\n    },\n    toString: function toString() {\n      return this.src;\n    }\n  };\n}\n\nfunction castChunk(chunk, codeGen, loc) {\n  if (_utils.isArray(chunk)) {\n    var ret = [];\n\n    for (var i = 0, len = chunk.length; i < len; i++) {\n      ret.push(codeGen.wrap(chunk[i], loc));\n    }\n    return ret;\n  } else if (typeof chunk === 'boolean' || typeof chunk === 'number') {\n    // Handle primitives that the SourceNode will throw up on\n    return chunk + '';\n  }\n  return chunk;\n}\n\nfunction CodeGen(srcFile) {\n  this.srcFile = srcFile;\n  this.source = [];\n}\n\nCodeGen.prototype = {\n  isEmpty: function isEmpty() {\n    return !this.source.length;\n  },\n  prepend: function prepend(source, loc) {\n    this.source.unshift(this.wrap(source, loc));\n  },\n  push: function push(source, loc) {\n    this.source.push(this.wrap(source, loc));\n  },\n\n  merge: function merge() {\n    var source = this.empty();\n    this.each(function (line) {\n      source.add(['  ', line, '\\n']);\n    });\n    return source;\n  },\n\n  each: function each(iter) {\n    for (var i = 0, len = this.source.length; i < len; i++) {\n      iter(this.source[i]);\n    }\n  },\n\n  empty: function empty() {\n    var loc = this.currentLocation || { start: {} };\n    return new SourceNode(loc.start.line, loc.start.column, this.srcFile);\n  },\n  wrap: function wrap(chunk) {\n    var loc = arguments.length <= 1 || arguments[1] === undefined ? this.currentLocation || { start: {} } : arguments[1];\n\n    if (chunk instanceof SourceNode) {\n      return chunk;\n    }\n\n    chunk = castChunk(chunk, this, loc);\n\n    return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);\n  },\n\n  functionCall: function functionCall(fn, type, params) {\n    params = this.generateList(params);\n    return this.wrap([fn, type ? '.' + type + '(' : '(', params, ')']);\n  },\n\n  quotedString: function quotedString(str) {\n    return '\"' + (str + '').replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r').replace(/\\u2028/g, '\\\\u2028') // Per Ecma-262 7.3 + 7.8.4\n    .replace(/\\u2029/g, '\\\\u2029') + '\"';\n  },\n\n  objectLiteral: function objectLiteral(obj) {\n    var pairs = [];\n\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        var value = castChunk(obj[key], this);\n        if (value !== 'undefined') {\n          pairs.push([this.quotedString(key), ':', value]);\n        }\n      }\n    }\n\n    var ret = this.generateList(pairs);\n    ret.prepend('{');\n    ret.add('}');\n    return ret;\n  },\n\n  generateList: function generateList(entries) {\n    var ret = this.empty();\n\n    for (var i = 0, len = entries.length; i < len; i++) {\n      if (i) {\n        ret.add(',');\n      }\n\n      ret.add(castChunk(entries[i], this));\n    }\n\n    return ret;\n  },\n\n  generateArray: function generateArray(entries) {\n    var ret = this.generateList(entries);\n    ret.prepend('[');\n    ret.add(']');\n\n    return ret;\n  }\n};\n\nexports['default'] = CodeGen;\nmodule.exports = exports['default'];\n\n\n},{\"../utils\":33,\"source-map\":46}],11:[function(require,module,exports){\n/* eslint-disable new-cap */\n\n'use strict';\n\nexports.__esModule = true;\nexports.Compiler = Compiler;\nexports.precompile = precompile;\nexports.compile = compile;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _exception = require('../exception');\n\nvar _exception2 = _interopRequireDefault(_exception);\n\nvar _utils = require('../utils');\n\nvar _ast = require('./ast');\n\nvar _ast2 = _interopRequireDefault(_ast);\n\nvar slice = [].slice;\n\nfunction Compiler() {}\n\n// the foundHelper register will disambiguate helper lookup from finding a\n// function in a context. This is necessary for mustache compatibility, which\n// requires that context functions in blocks are evaluated by blockHelperMissing,\n// and then proceed as if the resulting value was provided to blockHelperMissing.\n\nCompiler.prototype = {\n  compiler: Compiler,\n\n  equals: function equals(other) {\n    var len = this.opcodes.length;\n    if (other.opcodes.length !== len) {\n      return false;\n    }\n\n    for (var i = 0; i < len; i++) {\n      var opcode = this.opcodes[i],\n          otherOpcode = other.opcodes[i];\n      if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {\n        return false;\n      }\n    }\n\n    // We know that length is the same between the two arrays because they are directly tied\n    // to the opcode behavior above.\n    len = this.children.length;\n    for (var i = 0; i < len; i++) {\n      if (!this.children[i].equals(other.children[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  guid: 0,\n\n  compile: function compile(program, options) {\n    this.sourceNode = [];\n    this.opcodes = [];\n    this.children = [];\n    this.options = options;\n    this.stringParams = options.stringParams;\n    this.trackIds = options.trackIds;\n\n    options.blockParams = options.blockParams || [];\n\n    // These changes will propagate to the other compiler components\n    var knownHelpers = options.knownHelpers;\n    options.knownHelpers = {\n      'helperMissing': true,\n      'blockHelperMissing': true,\n      'each': true,\n      'if': true,\n      'unless': true,\n      'with': true,\n      'log': true,\n      'lookup': true\n    };\n    if (knownHelpers) {\n      for (var _name in knownHelpers) {\n        /* istanbul ignore else */\n        if (_name in knownHelpers) {\n          options.knownHelpers[_name] = knownHelpers[_name];\n        }\n      }\n    }\n\n    return this.accept(program);\n  },\n\n  compileProgram: function compileProgram(program) {\n    var childCompiler = new this.compiler(),\n        // eslint-disable-line new-cap\n    result = childCompiler.compile(program, this.options),\n        guid = this.guid++;\n\n    this.usePartial = this.usePartial || result.usePartial;\n\n    this.children[guid] = result;\n    this.useDepths = this.useDepths || result.useDepths;\n\n    return guid;\n  },\n\n  accept: function accept(node) {\n    /* istanbul ignore next: Sanity code */\n    if (!this[node.type]) {\n      throw new _exception2['default']('Unknown type: ' + node.type, node);\n    }\n\n    this.sourceNode.unshift(node);\n    var ret = this[node.type](node);\n    this.sourceNode.shift();\n    return ret;\n  },\n\n  Program: function Program(program) {\n    this.options.blockParams.unshift(program.blockParams);\n\n    var body = program.body,\n        bodyLength = body.length;\n    for (var i = 0; i < bodyLength; i++) {\n      this.accept(body[i]);\n    }\n\n    this.options.blockParams.shift();\n\n    this.isSimple = bodyLength === 1;\n    this.blockParams = program.blockParams ? program.blockParams.length : 0;\n\n    return this;\n  },\n\n  BlockStatement: function BlockStatement(block) {\n    transformLiteralToPath(block);\n\n    var program = block.program,\n        inverse = block.inverse;\n\n    program = program && this.compileProgram(program);\n    inverse = inverse && this.compileProgram(inverse);\n\n    var type = this.classifySexpr(block);\n\n    if (type === 'helper') {\n      this.helperSexpr(block, program, inverse);\n    } else if (type === 'simple') {\n      this.simpleSexpr(block);\n\n      // now that the simple mustache is resolved, we need to\n      // evaluate it by executing `blockHelperMissing`\n      this.opcode('pushProgram', program);\n      this.opcode('pushProgram', inverse);\n      this.opcode('emptyHash');\n      this.opcode('blockValue', block.path.original);\n    } else {\n      this.ambiguousSexpr(block, program, inverse);\n\n      // now that the simple mustache is resolved, we need to\n      // evaluate it by executing `blockHelperMissing`\n      this.opcode('pushProgram', program);\n      this.opcode('pushProgram', inverse);\n      this.opcode('emptyHash');\n      this.opcode('ambiguousBlockValue');\n    }\n\n    this.opcode('append');\n  },\n\n  DecoratorBlock: function DecoratorBlock(decorator) {\n    var program = decorator.program && this.compileProgram(decorator.program);\n    var params = this.setupFullMustacheParams(decorator, program, undefined),\n        path = decorator.path;\n\n    this.useDecorators = true;\n    this.opcode('registerDecorator', params.length, path.original);\n  },\n\n  PartialStatement: function PartialStatement(partial) {\n    this.usePartial = true;\n\n    var program = partial.program;\n    if (program) {\n      program = this.compileProgram(partial.program);\n    }\n\n    var params = partial.params;\n    if (params.length > 1) {\n      throw new _exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);\n    } else if (!params.length) {\n      if (this.options.explicitPartialContext) {\n        this.opcode('pushLiteral', 'undefined');\n      } else {\n        params.push({ type: 'PathExpression', parts: [], depth: 0 });\n      }\n    }\n\n    var partialName = partial.name.original,\n        isDynamic = partial.name.type === 'SubExpression';\n    if (isDynamic) {\n      this.accept(partial.name);\n    }\n\n    this.setupFullMustacheParams(partial, program, undefined, true);\n\n    var indent = partial.indent || '';\n    if (this.options.preventIndent && indent) {\n      this.opcode('appendContent', indent);\n      indent = '';\n    }\n\n    this.opcode('invokePartial', isDynamic, partialName, indent);\n    this.opcode('append');\n  },\n  PartialBlockStatement: function PartialBlockStatement(partialBlock) {\n    this.PartialStatement(partialBlock);\n  },\n\n  MustacheStatement: function MustacheStatement(mustache) {\n    this.SubExpression(mustache);\n\n    if (mustache.escaped && !this.options.noEscape) {\n      this.opcode('appendEscaped');\n    } else {\n      this.opcode('append');\n    }\n  },\n  Decorator: function Decorator(decorator) {\n    this.DecoratorBlock(decorator);\n  },\n\n  ContentStatement: function ContentStatement(content) {\n    if (content.value) {\n      this.opcode('appendContent', content.value);\n    }\n  },\n\n  CommentStatement: function CommentStatement() {},\n\n  SubExpression: function SubExpression(sexpr) {\n    transformLiteralToPath(sexpr);\n    var type = this.classifySexpr(sexpr);\n\n    if (type === 'simple') {\n      this.simpleSexpr(sexpr);\n    } else if (type === 'helper') {\n      this.helperSexpr(sexpr);\n    } else {\n      this.ambiguousSexpr(sexpr);\n    }\n  },\n  ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {\n    var path = sexpr.path,\n        name = path.parts[0],\n        isBlock = program != null || inverse != null;\n\n    this.opcode('getContext', path.depth);\n\n    this.opcode('pushProgram', program);\n    this.opcode('pushProgram', inverse);\n\n    path.strict = true;\n    this.accept(path);\n\n    this.opcode('invokeAmbiguous', name, isBlock);\n  },\n\n  simpleSexpr: function simpleSexpr(sexpr) {\n    var path = sexpr.path;\n    path.strict = true;\n    this.accept(path);\n    this.opcode('resolvePossibleLambda');\n  },\n\n  helperSexpr: function helperSexpr(sexpr, program, inverse) {\n    var params = this.setupFullMustacheParams(sexpr, program, inverse),\n        path = sexpr.path,\n        name = path.parts[0];\n\n    if (this.options.knownHelpers[name]) {\n      this.opcode('invokeKnownHelper', params.length, name);\n    } else if (this.options.knownHelpersOnly) {\n      throw new _exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);\n    } else {\n      path.strict = true;\n      path.falsy = true;\n\n      this.accept(path);\n      this.opcode('invokeHelper', params.length, path.original, _ast2['default'].helpers.simpleId(path));\n    }\n  },\n\n  PathExpression: function PathExpression(path) {\n    this.addDepth(path.depth);\n    this.opcode('getContext', path.depth);\n\n    var name = path.parts[0],\n        scoped = _ast2['default'].helpers.scopedId(path),\n        blockParamId = !path.depth && !scoped && this.blockParamIndex(name);\n\n    if (blockParamId) {\n      this.opcode('lookupBlockParam', blockParamId, path.parts);\n    } else if (!name) {\n      // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`\n      this.opcode('pushContext');\n    } else if (path.data) {\n      this.options.data = true;\n      this.opcode('lookupData', path.depth, path.parts, path.strict);\n    } else {\n      this.opcode('lookupOnContext', path.parts, path.falsy, path.strict, scoped);\n    }\n  },\n\n  StringLiteral: function StringLiteral(string) {\n    this.opcode('pushString', string.value);\n  },\n\n  NumberLiteral: function NumberLiteral(number) {\n    this.opcode('pushLiteral', number.value);\n  },\n\n  BooleanLiteral: function BooleanLiteral(bool) {\n    this.opcode('pushLiteral', bool.value);\n  },\n\n  UndefinedLiteral: function UndefinedLiteral() {\n    this.opcode('pushLiteral', 'undefined');\n  },\n\n  NullLiteral: function NullLiteral() {\n    this.opcode('pushLiteral', 'null');\n  },\n\n  Hash: function Hash(hash) {\n    var pairs = hash.pairs,\n        i = 0,\n        l = pairs.length;\n\n    this.opcode('pushHash');\n\n    for (; i < l; i++) {\n      this.pushParam(pairs[i].value);\n    }\n    while (i--) {\n      this.opcode('assignToHash', pairs[i].key);\n    }\n    this.opcode('popHash');\n  },\n\n  // HELPERS\n  opcode: function opcode(name) {\n    this.opcodes.push({ opcode: name, args: slice.call(arguments, 1), loc: this.sourceNode[0].loc });\n  },\n\n  addDepth: function addDepth(depth) {\n    if (!depth) {\n      return;\n    }\n\n    this.useDepths = true;\n  },\n\n  classifySexpr: function classifySexpr(sexpr) {\n    var isSimple = _ast2['default'].helpers.simpleId(sexpr.path);\n\n    var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);\n\n    // a mustache is an eligible helper if:\n    // * its id is simple (a single part, not `this` or `..`)\n    var isHelper = !isBlockParam && _ast2['default'].helpers.helperExpression(sexpr);\n\n    // if a mustache is an eligible helper but not a definite\n    // helper, it is ambiguous, and will be resolved in a later\n    // pass or at runtime.\n    var isEligible = !isBlockParam && (isHelper || isSimple);\n\n    // if ambiguous, we can possibly resolve the ambiguity now\n    // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.\n    if (isEligible && !isHelper) {\n      var _name2 = sexpr.path.parts[0],\n          options = this.options;\n\n      if (options.knownHelpers[_name2]) {\n        isHelper = true;\n      } else if (options.knownHelpersOnly) {\n        isEligible = false;\n      }\n    }\n\n    if (isHelper) {\n      return 'helper';\n    } else if (isEligible) {\n      return 'ambiguous';\n    } else {\n      return 'simple';\n    }\n  },\n\n  pushParams: function pushParams(params) {\n    for (var i = 0, l = params.length; i < l; i++) {\n      this.pushParam(params[i]);\n    }\n  },\n\n  pushParam: function pushParam(val) {\n    var value = val.value != null ? val.value : val.original || '';\n\n    if (this.stringParams) {\n      if (value.replace) {\n        value = value.replace(/^(\\.?\\.\\/)*/g, '').replace(/\\//g, '.');\n      }\n\n      if (val.depth) {\n        this.addDepth(val.depth);\n      }\n      this.opcode('getContext', val.depth || 0);\n      this.opcode('pushStringParam', value, val.type);\n\n      if (val.type === 'SubExpression') {\n        // SubExpressions get evaluated and passed in\n        // in string params mode.\n        this.accept(val);\n      }\n    } else {\n      if (this.trackIds) {\n        var blockParamIndex = undefined;\n        if (val.parts && !_ast2['default'].helpers.scopedId(val) && !val.depth) {\n          blockParamIndex = this.blockParamIndex(val.parts[0]);\n        }\n        if (blockParamIndex) {\n          var blockParamChild = val.parts.slice(1).join('.');\n          this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);\n        } else {\n          value = val.original || value;\n          if (value.replace) {\n            value = value.replace(/^this(?:\\.|$)/, '').replace(/^\\.\\//, '').replace(/^\\.$/, '');\n          }\n\n          this.opcode('pushId', val.type, value);\n        }\n      }\n      this.accept(val);\n    }\n  },\n\n  setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {\n    var params = sexpr.params;\n    this.pushParams(params);\n\n    this.opcode('pushProgram', program);\n    this.opcode('pushProgram', inverse);\n\n    if (sexpr.hash) {\n      this.accept(sexpr.hash);\n    } else {\n      this.opcode('emptyHash', omitEmpty);\n    }\n\n    return params;\n  },\n\n  blockParamIndex: function blockParamIndex(name) {\n    for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {\n      var blockParams = this.options.blockParams[depth],\n          param = blockParams && _utils.indexOf(blockParams, name);\n      if (blockParams && param >= 0) {\n        return [depth, param];\n      }\n    }\n  }\n};\n\nfunction precompile(input, options, env) {\n  if (input == null || typeof input !== 'string' && input.type !== 'Program') {\n    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);\n  }\n\n  options = options || {};\n  if (!('data' in options)) {\n    options.data = true;\n  }\n  if (options.compat) {\n    options.useDepths = true;\n  }\n\n  var ast = env.parse(input, options),\n      environment = new env.Compiler().compile(ast, options);\n  return new env.JavaScriptCompiler().compile(environment, options);\n}\n\nfunction compile(input, options, env) {\n  if (options === undefined) options = {};\n\n  if (input == null || typeof input !== 'string' && input.type !== 'Program') {\n    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);\n  }\n\n  if (!('data' in options)) {\n    options.data = true;\n  }\n  if (options.compat) {\n    options.useDepths = true;\n  }\n\n  var compiled = undefined;\n\n  function compileInput() {\n    var ast = env.parse(input, options),\n        environment = new env.Compiler().compile(ast, options),\n        templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);\n    return env.template(templateSpec);\n  }\n\n  // Template is only compiled on first use and cached after that point.\n  function ret(context, execOptions) {\n    if (!compiled) {\n      compiled = compileInput();\n    }\n    return compiled.call(this, context, execOptions);\n  }\n  ret._setup = function (setupOptions) {\n    if (!compiled) {\n      compiled = compileInput();\n    }\n    return compiled._setup(setupOptions);\n  };\n  ret._child = function (i, data, blockParams, depths) {\n    if (!compiled) {\n      compiled = compileInput();\n    }\n    return compiled._child(i, data, blockParams, depths);\n  };\n  return ret;\n}\n\nfunction argEquals(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {\n    for (var i = 0; i < a.length; i++) {\n      if (!argEquals(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\nfunction transformLiteralToPath(sexpr) {\n  if (!sexpr.path.parts) {\n    var literal = sexpr.path;\n    // Casting to string here to make false and 0 literal values play nicely with the rest\n    // of the system.\n    sexpr.path = {\n      type: 'PathExpression',\n      data: false,\n      depth: 0,\n      parts: [literal.original + ''],\n      original: literal.original + '',\n      loc: literal.loc\n    };\n  }\n}\n\n\n},{\"../exception\":20,\"../utils\":33,\"./ast\":8}],12:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\nexports.SourceLocation = SourceLocation;\nexports.id = id;\nexports.stripFlags = stripFlags;\nexports.stripComment = stripComment;\nexports.preparePath = preparePath;\nexports.prepareMustache = prepareMustache;\nexports.prepareRawBlock = prepareRawBlock;\nexports.prepareBlock = prepareBlock;\nexports.prepareProgram = prepareProgram;\nexports.preparePartialBlock = preparePartialBlock;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _exception = require('../exception');\n\nvar _exception2 = _interopRequireDefault(_exception);\n\nfunction validateClose(open, close) {\n  close = close.path ? close.path.original : close;\n\n  if (open.path.original !== close) {\n    var errorNode = { loc: open.path.loc };\n\n    throw new _exception2['default'](open.path.original + \" doesn't match \" + close, errorNode);\n  }\n}\n\nfunction SourceLocation(source, locInfo) {\n  this.source = source;\n  this.start = {\n    line: locInfo.first_line,\n    column: locInfo.first_column\n  };\n  this.end = {\n    line: locInfo.last_line,\n    column: locInfo.last_column\n  };\n}\n\nfunction id(token) {\n  if (/^\\[.*\\]$/.test(token)) {\n    return token.substr(1, token.length - 2);\n  } else {\n    return token;\n  }\n}\n\nfunction stripFlags(open, close) {\n  return {\n    open: open.charAt(2) === '~',\n    close: close.charAt(close.length - 3) === '~'\n  };\n}\n\nfunction stripComment(comment) {\n  return comment.replace(/^\\{\\{~?\\!-?-?/, '').replace(/-?-?~?\\}\\}$/, '');\n}\n\nfunction preparePath(data, parts, loc) {\n  loc = this.locInfo(loc);\n\n  var original = data ? '@' : '',\n      dig = [],\n      depth = 0,\n      depthString = '';\n\n  for (var i = 0, l = parts.length; i < l; i++) {\n    var part = parts[i].part,\n\n    // If we have [] syntax then we do not treat path references as operators,\n    // i.e. foo.[this] resolves to approximately context.foo['this']\n    isLiteral = parts[i].original !== part;\n    original += (parts[i].separator || '') + part;\n\n    if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {\n      if (dig.length > 0) {\n        throw new _exception2['default']('Invalid path: ' + original, { loc: loc });\n      } else if (part === '..') {\n        depth++;\n        depthString += '../';\n      }\n    } else {\n      dig.push(part);\n    }\n  }\n\n  return {\n    type: 'PathExpression',\n    data: data,\n    depth: depth,\n    parts: dig,\n    original: original,\n    loc: loc\n  };\n}\n\nfunction prepareMustache(path, params, hash, open, strip, locInfo) {\n  // Must use charAt to support IE pre-10\n  var escapeFlag = open.charAt(3) || open.charAt(2),\n      escaped = escapeFlag !== '{' && escapeFlag !== '&';\n\n  var decorator = /\\*/.test(open);\n  return {\n    type: decorator ? 'Decorator' : 'MustacheStatement',\n    path: path,\n    params: params,\n    hash: hash,\n    escaped: escaped,\n    strip: strip,\n    loc: this.locInfo(locInfo)\n  };\n}\n\nfunction prepareRawBlock(openRawBlock, contents, close, locInfo) {\n  validateClose(openRawBlock, close);\n\n  locInfo = this.locInfo(locInfo);\n  var program = {\n    type: 'Program',\n    body: contents,\n    strip: {},\n    loc: locInfo\n  };\n\n  return {\n    type: 'BlockStatement',\n    path: openRawBlock.path,\n    params: openRawBlock.params,\n    hash: openRawBlock.hash,\n    program: program,\n    openStrip: {},\n    inverseStrip: {},\n    closeStrip: {},\n    loc: locInfo\n  };\n}\n\nfunction prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {\n  if (close && close.path) {\n    validateClose(openBlock, close);\n  }\n\n  var decorator = /\\*/.test(openBlock.open);\n\n  program.blockParams = openBlock.blockParams;\n\n  var inverse = undefined,\n      inverseStrip = undefined;\n\n  if (inverseAndProgram) {\n    if (decorator) {\n      throw new _exception2['default']('Unexpected inverse block on decorator', inverseAndProgram);\n    }\n\n    if (inverseAndProgram.chain) {\n      inverseAndProgram.program.body[0].closeStrip = close.strip;\n    }\n\n    inverseStrip = inverseAndProgram.strip;\n    inverse = inverseAndProgram.program;\n  }\n\n  if (inverted) {\n    inverted = inverse;\n    inverse = program;\n    program = inverted;\n  }\n\n  return {\n    type: decorator ? 'DecoratorBlock' : 'BlockStatement',\n    path: openBlock.path,\n    params: openBlock.params,\n    hash: openBlock.hash,\n    program: program,\n    inverse: inverse,\n    openStrip: openBlock.strip,\n    inverseStrip: inverseStrip,\n    closeStrip: close && close.strip,\n    loc: this.locInfo(locInfo)\n  };\n}\n\nfunction prepareProgram(statements, loc) {\n  if (!loc && statements.length) {\n    var firstLoc = statements[0].loc,\n        lastLoc = statements[statements.length - 1].loc;\n\n    /* istanbul ignore else */\n    if (firstLoc && lastLoc) {\n      loc = {\n        source: firstLoc.source,\n        start: {\n          line: firstLoc.start.line,\n          column: firstLoc.start.column\n        },\n        end: {\n          line: lastLoc.end.line,\n          column: lastLoc.end.column\n        }\n      };\n    }\n  }\n\n  return {\n    type: 'Program',\n    body: statements,\n    strip: {},\n    loc: loc\n  };\n}\n\nfunction preparePartialBlock(open, program, close, locInfo) {\n  validateClose(open, close);\n\n  return {\n    type: 'PartialBlockStatement',\n    name: open.path,\n    params: open.params,\n    hash: open.hash,\n    program: program,\n    openStrip: open.strip,\n    closeStrip: close && close.strip,\n    loc: this.locInfo(locInfo)\n  };\n}\n\n\n},{\"../exception\":20}],13:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _base = require('../base');\n\nvar _exception = require('../exception');\n\nvar _exception2 = _interopRequireDefault(_exception);\n\nvar _utils = require('../utils');\n\nvar _codeGen = require('./code-gen');\n\nvar _codeGen2 = _interopRequireDefault(_codeGen);\n\nfunction Literal(value) {\n  this.value = value;\n}\n\nfunction JavaScriptCompiler() {}\n\nJavaScriptCompiler.prototype = {\n  // PUBLIC API: You can override these methods in a subclass to provide\n  // alternative compiled forms for name lookup and buffering semantics\n  nameLookup: function nameLookup(parent, name /* , type*/) {\n    if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {\n      return [parent, '.', name];\n    } else {\n      return [parent, '[', JSON.stringify(name), ']'];\n    }\n  },\n  depthedLookup: function depthedLookup(name) {\n    return [this.aliasable('container.lookup'), '(depths, \"', name, '\")'];\n  },\n\n  compilerInfo: function compilerInfo() {\n    var revision = _base.COMPILER_REVISION,\n        versions = _base.REVISION_CHANGES[revision];\n    return [revision, versions];\n  },\n\n  appendToBuffer: function appendToBuffer(source, location, explicit) {\n    // Force a source as this simplifies the merge logic.\n    if (!_utils.isArray(source)) {\n      source = [source];\n    }\n    source = this.source.wrap(source, location);\n\n    if (this.environment.isSimple) {\n      return ['return ', source, ';'];\n    } else if (explicit) {\n      // This is a case where the buffer operation occurs as a child of another\n      // construct, generally braces. We have to explicitly output these buffer\n      // operations to ensure that the emitted code goes in the correct location.\n      return ['buffer += ', source, ';'];\n    } else {\n      source.appendToBuffer = true;\n      return source;\n    }\n  },\n\n  initializeBuffer: function initializeBuffer() {\n    return this.quotedString('');\n  },\n  // END PUBLIC API\n\n  compile: function compile(environment, options, context, asObject) {\n    this.environment = environment;\n    this.options = options;\n    this.stringParams = this.options.stringParams;\n    this.trackIds = this.options.trackIds;\n    this.precompile = !asObject;\n\n    this.name = this.environment.name;\n    this.isChild = !!context;\n    this.context = context || {\n      decorators: [],\n      programs: [],\n      environments: []\n    };\n\n    this.preamble();\n\n    this.stackSlot = 0;\n    this.stackVars = [];\n    this.aliases = {};\n    this.registers = { list: [] };\n    this.hashes = [];\n    this.compileStack = [];\n    this.inlineStack = [];\n    this.blockParams = [];\n\n    this.compileChildren(environment, options);\n\n    this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;\n    this.useBlockParams = this.useBlockParams || environment.useBlockParams;\n\n    var opcodes = environment.opcodes,\n        opcode = undefined,\n        firstLoc = undefined,\n        i = undefined,\n        l = undefined;\n\n    for (i = 0, l = opcodes.length; i < l; i++) {\n      opcode = opcodes[i];\n\n      this.source.currentLocation = opcode.loc;\n      firstLoc = firstLoc || opcode.loc;\n      this[opcode.opcode].apply(this, opcode.args);\n    }\n\n    // Flush any trailing content that might be pending.\n    this.source.currentLocation = firstLoc;\n    this.pushSource('');\n\n    /* istanbul ignore next */\n    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {\n      throw new _exception2['default']('Compile completed with content left on stack');\n    }\n\n    if (!this.decorators.isEmpty()) {\n      this.useDecorators = true;\n\n      this.decorators.prepend('var decorators = container.decorators;\\n');\n      this.decorators.push('return fn;');\n\n      if (asObject) {\n        this.decorators = Function.apply(this, ['fn', 'props', 'container', 'depth0', 'data', 'blockParams', 'depths', this.decorators.merge()]);\n      } else {\n        this.decorators.prepend('function(fn, props, container, depth0, data, blockParams, depths) {\\n');\n        this.decorators.push('}\\n');\n        this.decorators = this.decorators.merge();\n      }\n    } else {\n      this.decorators = undefined;\n    }\n\n    var fn = this.createFunctionContext(asObject);\n    if (!this.isChild) {\n      var ret = {\n        compiler: this.compilerInfo(),\n        main: fn\n      };\n\n      if (this.decorators) {\n        ret.main_d = this.decorators; // eslint-disable-line camelcase\n        ret.useDecorators = true;\n      }\n\n      var _context = this.context;\n      var programs = _context.programs;\n      var decorators = _context.decorators;\n\n      for (i = 0, l = programs.length; i < l; i++) {\n        if (programs[i]) {\n          ret[i] = programs[i];\n          if (decorators[i]) {\n            ret[i + '_d'] = decorators[i];\n            ret.useDecorators = true;\n          }\n        }\n      }\n\n      if (this.environment.usePartial) {\n        ret.usePartial = true;\n      }\n      if (this.options.data) {\n        ret.useData = true;\n      }\n      if (this.useDepths) {\n        ret.useDepths = true;\n      }\n      if (this.useBlockParams) {\n        ret.useBlockParams = true;\n      }\n      if (this.options.compat) {\n        ret.compat = true;\n      }\n\n      if (!asObject) {\n        ret.compiler = JSON.stringify(ret.compiler);\n\n        this.source.currentLocation = { start: { line: 1, column: 0 } };\n        ret = this.objectLiteral(ret);\n\n        if (options.srcName) {\n          ret = ret.toStringWithSourceMap({ file: options.destName });\n          ret.map = ret.map && ret.map.toString();\n        } else {\n          ret = ret.toString();\n        }\n      } else {\n        ret.compilerOptions = this.options;\n      }\n\n      return ret;\n    } else {\n      return fn;\n    }\n  },\n\n  preamble: function preamble() {\n    // track the last context pushed into place to allow skipping the\n    // getContext opcode when it would be a noop\n    this.lastContext = 0;\n    this.source = new _codeGen2['default'](this.options.srcName);\n    this.decorators = new _codeGen2['default'](this.options.srcName);\n  },\n\n  createFunctionContext: function createFunctionContext(asObject) {\n    var varDeclarations = '';\n\n    var locals = this.stackVars.concat(this.registers.list);\n    if (locals.length > 0) {\n      varDeclarations += ', ' + locals.join(', ');\n    }\n\n    // Generate minimizer alias mappings\n    //\n    // When using true SourceNodes, this will update all references to the given alias\n    // as the source nodes are reused in situ. For the non-source node compilation mode,\n    // aliases will not be used, but this case is already being run on the client and\n    // we aren't concern about minimizing the template size.\n    var aliasCount = 0;\n    for (var alias in this.aliases) {\n      // eslint-disable-line guard-for-in\n      var node = this.aliases[alias];\n\n      if (this.aliases.hasOwnProperty(alias) && node.children && node.referenceCount > 1) {\n        varDeclarations += ', alias' + ++aliasCount + '=' + alias;\n        node.children[0] = 'alias' + aliasCount;\n      }\n    }\n\n    var params = ['container', 'depth0', 'helpers', 'partials', 'data'];\n\n    if (this.useBlockParams || this.useDepths) {\n      params.push('blockParams');\n    }\n    if (this.useDepths) {\n      params.push('depths');\n    }\n\n    // Perform a second pass over the output to merge content when possible\n    var source = this.mergeSource(varDeclarations);\n\n    if (asObject) {\n      params.push(source);\n\n      return Function.apply(this, params);\n    } else {\n      return this.source.wrap(['function(', params.join(','), ') {\\n  ', source, '}']);\n    }\n  },\n  mergeSource: function mergeSource(varDeclarations) {\n    var isSimple = this.environment.isSimple,\n        appendOnly = !this.forceBuffer,\n        appendFirst = undefined,\n        sourceSeen = undefined,\n        bufferStart = undefined,\n        bufferEnd = undefined;\n    this.source.each(function (line) {\n      if (line.appendToBuffer) {\n        if (bufferStart) {\n          line.prepend('  + ');\n        } else {\n          bufferStart = line;\n        }\n        bufferEnd = line;\n      } else {\n        if (bufferStart) {\n          if (!sourceSeen) {\n            appendFirst = true;\n          } else {\n            bufferStart.prepend('buffer += ');\n          }\n          bufferEnd.add(';');\n          bufferStart = bufferEnd = undefined;\n        }\n\n        sourceSeen = true;\n        if (!isSimple) {\n          appendOnly = false;\n        }\n      }\n    });\n\n    if (appendOnly) {\n      if (bufferStart) {\n        bufferStart.prepend('return ');\n        bufferEnd.add(';');\n      } else if (!sourceSeen) {\n        this.source.push('return \"\";');\n      }\n    } else {\n      varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());\n\n      if (bufferStart) {\n        bufferStart.prepend('return buffer + ');\n        bufferEnd.add(';');\n      } else {\n        this.source.push('return buffer;');\n      }\n    }\n\n    if (varDeclarations) {\n      this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\\n'));\n    }\n\n    return this.source.merge();\n  },\n\n  // [blockValue]\n  //\n  // On stack, before: hash, inverse, program, value\n  // On stack, after: return value of blockHelperMissing\n  //\n  // The purpose of this opcode is to take a block of the form\n  // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and\n  // replace it on the stack with the result of properly\n  // invoking blockHelperMissing.\n  blockValue: function blockValue(name) {\n    var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),\n        params = [this.contextName(0)];\n    this.setupHelperArgs(name, 0, params);\n\n    var blockName = this.popStack();\n    params.splice(1, 0, blockName);\n\n    this.push(this.source.functionCall(blockHelperMissing, 'call', params));\n  },\n\n  // [ambiguousBlockValue]\n  //\n  // On stack, before: hash, inverse, program, value\n  // Compiler value, before: lastHelper=value of last found helper, if any\n  // On stack, after, if no lastHelper: same as [blockValue]\n  // On stack, after, if lastHelper: value\n  ambiguousBlockValue: function ambiguousBlockValue() {\n    // We're being a bit cheeky and reusing the options value from the prior exec\n    var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),\n        params = [this.contextName(0)];\n    this.setupHelperArgs('', 0, params, true);\n\n    this.flushInline();\n\n    var current = this.topStack();\n    params.splice(1, 0, current);\n\n    this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);\n  },\n\n  // [appendContent]\n  //\n  // On stack, before: ...\n  // On stack, after: ...\n  //\n  // Appends the string value of `content` to the current buffer\n  appendContent: function appendContent(content) {\n    if (this.pendingContent) {\n      content = this.pendingContent + content;\n    } else {\n      this.pendingLocation = this.source.currentLocation;\n    }\n\n    this.pendingContent = content;\n  },\n\n  // [append]\n  //\n  // On stack, before: value, ...\n  // On stack, after: ...\n  //\n  // Coerces `value` to a String and appends it to the current buffer.\n  //\n  // If `value` is truthy, or 0, it is coerced into a string and appended\n  // Otherwise, the empty string is appended\n  append: function append() {\n    if (this.isInline()) {\n      this.replaceStack(function (current) {\n        return [' != null ? ', current, ' : \"\"'];\n      });\n\n      this.pushSource(this.appendToBuffer(this.popStack()));\n    } else {\n      var local = this.popStack();\n      this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);\n      if (this.environment.isSimple) {\n        this.pushSource(['else { ', this.appendToBuffer(\"''\", undefined, true), ' }']);\n      }\n    }\n  },\n\n  // [appendEscaped]\n  //\n  // On stack, before: value, ...\n  // On stack, after: ...\n  //\n  // Escape `value` and append it to the buffer\n  appendEscaped: function appendEscaped() {\n    this.pushSource(this.appendToBuffer([this.aliasable('container.escapeExpression'), '(', this.popStack(), ')']));\n  },\n\n  // [getContext]\n  //\n  // On stack, before: ...\n  // On stack, after: ...\n  // Compiler value, after: lastContext=depth\n  //\n  // Set the value of the `lastContext` compiler value to the depth\n  getContext: function getContext(depth) {\n    this.lastContext = depth;\n  },\n\n  // [pushContext]\n  //\n  // On stack, before: ...\n  // On stack, after: currentContext, ...\n  //\n  // Pushes the value of the current context onto the stack.\n  pushContext: function pushContext() {\n    this.pushStackLiteral(this.contextName(this.lastContext));\n  },\n\n  // [lookupOnContext]\n  //\n  // On stack, before: ...\n  // On stack, after: currentContext[name], ...\n  //\n  // Looks up the value of `name` on the current context and pushes\n  // it onto the stack.\n  lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {\n    var i = 0;\n\n    if (!scoped && this.options.compat && !this.lastContext) {\n      // The depthed query is expected to handle the undefined logic for the root level that\n      // is implemented below, so we evaluate that directly in compat mode\n      this.push(this.depthedLookup(parts[i++]));\n    } else {\n      this.pushContext();\n    }\n\n    this.resolvePath('context', parts, i, falsy, strict);\n  },\n\n  // [lookupBlockParam]\n  //\n  // On stack, before: ...\n  // On stack, after: blockParam[name], ...\n  //\n  // Looks up the value of `parts` on the given block param and pushes\n  // it onto the stack.\n  lookupBlockParam: function lookupBlockParam(blockParamId, parts) {\n    this.useBlockParams = true;\n\n    this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);\n    this.resolvePath('context', parts, 1);\n  },\n\n  // [lookupData]\n  //\n  // On stack, before: ...\n  // On stack, after: data, ...\n  //\n  // Push the data lookup operator\n  lookupData: function lookupData(depth, parts, strict) {\n    if (!depth) {\n      this.pushStackLiteral('data');\n    } else {\n      this.pushStackLiteral('container.data(data, ' + depth + ')');\n    }\n\n    this.resolvePath('data', parts, 0, true, strict);\n  },\n\n  resolvePath: function resolvePath(type, parts, i, falsy, strict) {\n    // istanbul ignore next\n\n    var _this = this;\n\n    if (this.options.strict || this.options.assumeObjects) {\n      this.push(strictLookup(this.options.strict && strict, this, parts, type));\n      return;\n    }\n\n    var len = parts.length;\n    for (; i < len; i++) {\n      /* eslint-disable no-loop-func */\n      this.replaceStack(function (current) {\n        var lookup = _this.nameLookup(current, parts[i], type);\n        // We want to ensure that zero and false are handled properly if the context (falsy flag)\n        // needs to have the special handling for these values.\n        if (!falsy) {\n          return [' != null ? ', lookup, ' : ', current];\n        } else {\n          // Otherwise we can use generic falsy handling\n          return [' && ', lookup];\n        }\n      });\n      /* eslint-enable no-loop-func */\n    }\n  },\n\n  // [resolvePossibleLambda]\n  //\n  // On stack, before: value, ...\n  // On stack, after: resolved value, ...\n  //\n  // If the `value` is a lambda, replace it on the stack by\n  // the return value of the lambda\n  resolvePossibleLambda: function resolvePossibleLambda() {\n    this.push([this.aliasable('container.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);\n  },\n\n  // [pushStringParam]\n  //\n  // On stack, before: ...\n  // On stack, after: string, currentContext, ...\n  //\n  // This opcode is designed for use in string mode, which\n  // provides the string value of a parameter along with its\n  // depth rather than resolving it immediately.\n  pushStringParam: function pushStringParam(string, type) {\n    this.pushContext();\n    this.pushString(type);\n\n    // If it's a subexpression, the string result\n    // will be pushed after this opcode.\n    if (type !== 'SubExpression') {\n      if (typeof string === 'string') {\n        this.pushString(string);\n      } else {\n        this.pushStackLiteral(string);\n      }\n    }\n  },\n\n  emptyHash: function emptyHash(omitEmpty) {\n    if (this.trackIds) {\n      this.push('{}'); // hashIds\n    }\n    if (this.stringParams) {\n      this.push('{}'); // hashContexts\n      this.push('{}'); // hashTypes\n    }\n    this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');\n  },\n  pushHash: function pushHash() {\n    if (this.hash) {\n      this.hashes.push(this.hash);\n    }\n    this.hash = { values: [], types: [], contexts: [], ids: [] };\n  },\n  popHash: function popHash() {\n    var hash = this.hash;\n    this.hash = this.hashes.pop();\n\n    if (this.trackIds) {\n      this.push(this.objectLiteral(hash.ids));\n    }\n    if (this.stringParams) {\n      this.push(this.objectLiteral(hash.contexts));\n      this.push(this.objectLiteral(hash.types));\n    }\n\n    this.push(this.objectLiteral(hash.values));\n  },\n\n  // [pushString]\n  //\n  // On stack, before: ...\n  // On stack, after: quotedString(string), ...\n  //\n  // Push a quoted version of `string` onto the stack\n  pushString: function pushString(string) {\n    this.pushStackLiteral(this.quotedString(string));\n  },\n\n  // [pushLiteral]\n  //\n  // On stack, before: ...\n  // On stack, after: value, ...\n  //\n  // Pushes a value onto the stack. This operation prevents\n  // the compiler from creating a temporary variable to hold\n  // it.\n  pushLiteral: function pushLiteral(value) {\n    this.pushStackLiteral(value);\n  },\n\n  // [pushProgram]\n  //\n  // On stack, before: ...\n  // On stack, after: program(guid), ...\n  //\n  // Push a program expression onto the stack. This takes\n  // a compile-time guid and converts it into a runtime-accessible\n  // expression.\n  pushProgram: function pushProgram(guid) {\n    if (guid != null) {\n      this.pushStackLiteral(this.programExpression(guid));\n    } else {\n      this.pushStackLiteral(null);\n    }\n  },\n\n  // [registerDecorator]\n  //\n  // On stack, before: hash, program, params..., ...\n  // On stack, after: ...\n  //\n  // Pops off the decorator's parameters, invokes the decorator,\n  // and inserts the decorator into the decorators list.\n  registerDecorator: function registerDecorator(paramSize, name) {\n    var foundDecorator = this.nameLookup('decorators', name, 'decorator'),\n        options = this.setupHelperArgs(name, paramSize);\n\n    this.decorators.push(['fn = ', this.decorators.functionCall(foundDecorator, '', ['fn', 'props', 'container', options]), ' || fn;']);\n  },\n\n  // [invokeHelper]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of helper invocation\n  //\n  // Pops off the helper's parameters, invokes the helper,\n  // and pushes the helper's return value onto the stack.\n  //\n  // If the helper is not found, `helperMissing` is called.\n  invokeHelper: function invokeHelper(paramSize, name, isSimple) {\n    var nonHelper = this.popStack(),\n        helper = this.setupHelper(paramSize, name),\n        simple = isSimple ? [helper.name, ' || '] : '';\n\n    var lookup = ['('].concat(simple, nonHelper);\n    if (!this.options.strict) {\n      lookup.push(' || ', this.aliasable('helpers.helperMissing'));\n    }\n    lookup.push(')');\n\n    this.push(this.source.functionCall(lookup, 'call', helper.callParams));\n  },\n\n  // [invokeKnownHelper]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of helper invocation\n  //\n  // This operation is used when the helper is known to exist,\n  // so a `helperMissing` fallback is not required.\n  invokeKnownHelper: function invokeKnownHelper(paramSize, name) {\n    var helper = this.setupHelper(paramSize, name);\n    this.push(this.source.functionCall(helper.name, 'call', helper.callParams));\n  },\n\n  // [invokeAmbiguous]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of disambiguation\n  //\n  // This operation is used when an expression like `{{foo}}`\n  // is provided, but we don't know at compile-time whether it\n  // is a helper or a path.\n  //\n  // This operation emits more code than the other options,\n  // and can be avoided by passing the `knownHelpers` and\n  // `knownHelpersOnly` flags at compile-time.\n  invokeAmbiguous: function invokeAmbiguous(name, helperCall) {\n    this.useRegister('helper');\n\n    var nonHelper = this.popStack();\n\n    this.emptyHash();\n    var helper = this.setupHelper(0, name, helperCall);\n\n    var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');\n\n    var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];\n    if (!this.options.strict) {\n      lookup[0] = '(helper = ';\n      lookup.push(' != null ? helper : ', this.aliasable('helpers.helperMissing'));\n    }\n\n    this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('\"function\"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);\n  },\n\n  // [invokePartial]\n  //\n  // On stack, before: context, ...\n  // On stack after: result of partial invocation\n  //\n  // This operation pops off a context, invokes a partial with that context,\n  // and pushes the result of the invocation back.\n  invokePartial: function invokePartial(isDynamic, name, indent) {\n    var params = [],\n        options = this.setupParams(name, 1, params);\n\n    if (isDynamic) {\n      name = this.popStack();\n      delete options.name;\n    }\n\n    if (indent) {\n      options.indent = JSON.stringify(indent);\n    }\n    options.helpers = 'helpers';\n    options.partials = 'partials';\n    options.decorators = 'container.decorators';\n\n    if (!isDynamic) {\n      params.unshift(this.nameLookup('partials', name, 'partial'));\n    } else {\n      params.unshift(name);\n    }\n\n    if (this.options.compat) {\n      options.depths = 'depths';\n    }\n    options = this.objectLiteral(options);\n    params.push(options);\n\n    this.push(this.source.functionCall('container.invokePartial', '', params));\n  },\n\n  // [assignToHash]\n  //\n  // On stack, before: value, ..., hash, ...\n  // On stack, after: ..., hash, ...\n  //\n  // Pops a value off the stack and assigns it to the current hash\n  assignToHash: function assignToHash(key) {\n    var value = this.popStack(),\n        context = undefined,\n        type = undefined,\n        id = undefined;\n\n    if (this.trackIds) {\n      id = this.popStack();\n    }\n    if (this.stringParams) {\n      type = this.popStack();\n      context = this.popStack();\n    }\n\n    var hash = this.hash;\n    if (context) {\n      hash.contexts[key] = context;\n    }\n    if (type) {\n      hash.types[key] = type;\n    }\n    if (id) {\n      hash.ids[key] = id;\n    }\n    hash.values[key] = value;\n  },\n\n  pushId: function pushId(type, name, child) {\n    if (type === 'BlockParam') {\n      this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));\n    } else if (type === 'PathExpression') {\n      this.pushString(name);\n    } else if (type === 'SubExpression') {\n      this.pushStackLiteral('true');\n    } else {\n      this.pushStackLiteral('null');\n    }\n  },\n\n  // HELPERS\n\n  compiler: JavaScriptCompiler,\n\n  compileChildren: function compileChildren(environment, options) {\n    var children = environment.children,\n        child = undefined,\n        compiler = undefined;\n\n    for (var i = 0, l = children.length; i < l; i++) {\n      child = children[i];\n      compiler = new this.compiler(); // eslint-disable-line new-cap\n\n      var existing = this.matchExistingProgram(child);\n\n      if (existing == null) {\n        this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children\n        var index = this.context.programs.length;\n        child.index = index;\n        child.name = 'program' + index;\n        this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);\n        this.context.decorators[index] = compiler.decorators;\n        this.context.environments[index] = child;\n\n        this.useDepths = this.useDepths || compiler.useDepths;\n        this.useBlockParams = this.useBlockParams || compiler.useBlockParams;\n        child.useDepths = this.useDepths;\n        child.useBlockParams = this.useBlockParams;\n      } else {\n        child.index = existing.index;\n        child.name = 'program' + existing.index;\n\n        this.useDepths = this.useDepths || existing.useDepths;\n        this.useBlockParams = this.useBlockParams || existing.useBlockParams;\n      }\n    }\n  },\n  matchExistingProgram: function matchExistingProgram(child) {\n    for (var i = 0, len = this.context.environments.length; i < len; i++) {\n      var environment = this.context.environments[i];\n      if (environment && environment.equals(child)) {\n        return environment;\n      }\n    }\n  },\n\n  programExpression: function programExpression(guid) {\n    var child = this.environment.children[guid],\n        programParams = [child.index, 'data', child.blockParams];\n\n    if (this.useBlockParams || this.useDepths) {\n      programParams.push('blockParams');\n    }\n    if (this.useDepths) {\n      programParams.push('depths');\n    }\n\n    return 'container.program(' + programParams.join(', ') + ')';\n  },\n\n  useRegister: function useRegister(name) {\n    if (!this.registers[name]) {\n      this.registers[name] = true;\n      this.registers.list.push(name);\n    }\n  },\n\n  push: function push(expr) {\n    if (!(expr instanceof Literal)) {\n      expr = this.source.wrap(expr);\n    }\n\n    this.inlineStack.push(expr);\n    return expr;\n  },\n\n  pushStackLiteral: function pushStackLiteral(item) {\n    this.push(new Literal(item));\n  },\n\n  pushSource: function pushSource(source) {\n    if (this.pendingContent) {\n      this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));\n      this.pendingContent = undefined;\n    }\n\n    if (source) {\n      this.source.push(source);\n    }\n  },\n\n  replaceStack: function replaceStack(callback) {\n    var prefix = ['('],\n        stack = undefined,\n        createdStack = undefined,\n        usedLiteral = undefined;\n\n    /* istanbul ignore next */\n    if (!this.isInline()) {\n      throw new _exception2['default']('replaceStack on non-inline');\n    }\n\n    // We want to merge the inline statement into the replacement statement via ','\n    var top = this.popStack(true);\n\n    if (top instanceof Literal) {\n      // Literals do not need to be inlined\n      stack = [top.value];\n      prefix = ['(', stack];\n      usedLiteral = true;\n    } else {\n      // Get or create the current stack name for use by the inline\n      createdStack = true;\n      var _name = this.incrStack();\n\n      prefix = ['((', this.push(_name), ' = ', top, ')'];\n      stack = this.topStack();\n    }\n\n    var item = callback.call(this, stack);\n\n    if (!usedLiteral) {\n      this.popStack();\n    }\n    if (createdStack) {\n      this.stackSlot--;\n    }\n    this.push(prefix.concat(item, ')'));\n  },\n\n  incrStack: function incrStack() {\n    this.stackSlot++;\n    if (this.stackSlot > this.stackVars.length) {\n      this.stackVars.push('stack' + this.stackSlot);\n    }\n    return this.topStackName();\n  },\n  topStackName: function topStackName() {\n    return 'stack' + this.stackSlot;\n  },\n  flushInline: function flushInline() {\n    var inlineStack = this.inlineStack;\n    this.inlineStack = [];\n    for (var i = 0, len = inlineStack.length; i < len; i++) {\n      var entry = inlineStack[i];\n      /* istanbul ignore if */\n      if (entry instanceof Literal) {\n        this.compileStack.push(entry);\n      } else {\n        var stack = this.incrStack();\n        this.pushSource([stack, ' = ', entry, ';']);\n        this.compileStack.push(stack);\n      }\n    }\n  },\n  isInline: function isInline() {\n    return this.inlineStack.length;\n  },\n\n  popStack: function popStack(wrapped) {\n    var inline = this.isInline(),\n        item = (inline ? this.inlineStack : this.compileStack).pop();\n\n    if (!wrapped && item instanceof Literal) {\n      return item.value;\n    } else {\n      if (!inline) {\n        /* istanbul ignore next */\n        if (!this.stackSlot) {\n          throw new _exception2['default']('Invalid stack pop');\n        }\n        this.stackSlot--;\n      }\n      return item;\n    }\n  },\n\n  topStack: function topStack() {\n    var stack = this.isInline() ? this.inlineStack : this.compileStack,\n        item = stack[stack.length - 1];\n\n    /* istanbul ignore if */\n    if (item instanceof Literal) {\n      return item.value;\n    } else {\n      return item;\n    }\n  },\n\n  contextName: function contextName(context) {\n    if (this.useDepths && context) {\n      return 'depths[' + context + ']';\n    } else {\n      return 'depth' + context;\n    }\n  },\n\n  quotedString: function quotedString(str) {\n    return this.source.quotedString(str);\n  },\n\n  objectLiteral: function objectLiteral(obj) {\n    return this.source.objectLiteral(obj);\n  },\n\n  aliasable: function aliasable(name) {\n    var ret = this.aliases[name];\n    if (ret) {\n      ret.referenceCount++;\n      return ret;\n    }\n\n    ret = this.aliases[name] = this.source.wrap(name);\n    ret.aliasable = true;\n    ret.referenceCount = 1;\n\n    return ret;\n  },\n\n  setupHelper: function setupHelper(paramSize, name, blockHelper) {\n    var params = [],\n        paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);\n    var foundHelper = this.nameLookup('helpers', name, 'helper'),\n        callContext = this.aliasable(this.contextName(0) + ' != null ? ' + this.contextName(0) + ' : {}');\n\n    return {\n      params: params,\n      paramsInit: paramsInit,\n      name: foundHelper,\n      callParams: [callContext].concat(params)\n    };\n  },\n\n  setupParams: function setupParams(helper, paramSize, params) {\n    var options = {},\n        contexts = [],\n        types = [],\n        ids = [],\n        objectArgs = !params,\n        param = undefined;\n\n    if (objectArgs) {\n      params = [];\n    }\n\n    options.name = this.quotedString(helper);\n    options.hash = this.popStack();\n\n    if (this.trackIds) {\n      options.hashIds = this.popStack();\n    }\n    if (this.stringParams) {\n      options.hashTypes = this.popStack();\n      options.hashContexts = this.popStack();\n    }\n\n    var inverse = this.popStack(),\n        program = this.popStack();\n\n    // Avoid setting fn and inverse if neither are set. This allows\n    // helpers to do a check for `if (options.fn)`\n    if (program || inverse) {\n      options.fn = program || 'container.noop';\n      options.inverse = inverse || 'container.noop';\n    }\n\n    // The parameters go on to the stack in order (making sure that they are evaluated in order)\n    // so we need to pop them off the stack in reverse order\n    var i = paramSize;\n    while (i--) {\n      param = this.popStack();\n      params[i] = param;\n\n      if (this.trackIds) {\n        ids[i] = this.popStack();\n      }\n      if (this.stringParams) {\n        types[i] = this.popStack();\n        contexts[i] = this.popStack();\n      }\n    }\n\n    if (objectArgs) {\n      options.args = this.source.generateArray(params);\n    }\n\n    if (this.trackIds) {\n      options.ids = this.source.generateArray(ids);\n    }\n    if (this.stringParams) {\n      options.types = this.source.generateArray(types);\n      options.contexts = this.source.generateArray(contexts);\n    }\n\n    if (this.options.data) {\n      options.data = 'data';\n    }\n    if (this.useBlockParams) {\n      options.blockParams = 'blockParams';\n    }\n    return options;\n  },\n\n  setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {\n    var options = this.setupParams(helper, paramSize, params);\n    options = this.objectLiteral(options);\n    if (useRegister) {\n      this.useRegister('options');\n      params.push('options');\n      return ['options=', options];\n    } else if (params) {\n      params.push(options);\n      return '';\n    } else {\n      return options;\n    }\n  }\n};\n\n(function () {\n  var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');\n\n  var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};\n\n  for (var i = 0, l = reservedWords.length; i < l; i++) {\n    compilerWords[reservedWords[i]] = true;\n  }\n})();\n\nJavaScriptCompiler.isValidJavaScriptVariableName = function (name) {\n  return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);\n};\n\nfunction strictLookup(requireTerminal, compiler, parts, type) {\n  var stack = compiler.popStack(),\n      i = 0,\n      len = parts.length;\n  if (requireTerminal) {\n    len--;\n  }\n\n  for (; i < len; i++) {\n    stack = compiler.nameLookup(stack, parts[i], type);\n  }\n\n  if (requireTerminal) {\n    return [compiler.aliasable('container.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ')'];\n  } else {\n    return stack;\n  }\n}\n\nexports['default'] = JavaScriptCompiler;\nmodule.exports = exports['default'];\n\n\n},{\"../base\":7,\"../exception\":20,\"../utils\":33,\"./code-gen\":10}],14:[function(require,module,exports){\n/* istanbul ignore next */\n/* Jison generated parser */\n\"use strict\";\n\nvar handlebars = (function () {\n    var parser = { trace: function trace() {},\n        yy: {},\n        symbols_: { \"error\": 2, \"root\": 3, \"program\": 4, \"EOF\": 5, \"program_repetition0\": 6, \"statement\": 7, \"mustache\": 8, \"block\": 9, \"rawBlock\": 10, \"partial\": 11, \"partialBlock\": 12, \"content\": 13, \"COMMENT\": 14, \"CONTENT\": 15, \"openRawBlock\": 16, \"rawBlock_repetition_plus0\": 17, \"END_RAW_BLOCK\": 18, \"OPEN_RAW_BLOCK\": 19, \"helperName\": 20, \"openRawBlock_repetition0\": 21, \"openRawBlock_option0\": 22, \"CLOSE_RAW_BLOCK\": 23, \"openBlock\": 24, \"block_option0\": 25, \"closeBlock\": 26, \"openInverse\": 27, \"block_option1\": 28, \"OPEN_BLOCK\": 29, \"openBlock_repetition0\": 30, \"openBlock_option0\": 31, \"openBlock_option1\": 32, \"CLOSE\": 33, \"OPEN_INVERSE\": 34, \"openInverse_repetition0\": 35, \"openInverse_option0\": 36, \"openInverse_option1\": 37, \"openInverseChain\": 38, \"OPEN_INVERSE_CHAIN\": 39, \"openInverseChain_repetition0\": 40, \"openInverseChain_option0\": 41, \"openInverseChain_option1\": 42, \"inverseAndProgram\": 43, \"INVERSE\": 44, \"inverseChain\": 45, \"inverseChain_option0\": 46, \"OPEN_ENDBLOCK\": 47, \"OPEN\": 48, \"mustache_repetition0\": 49, \"mustache_option0\": 50, \"OPEN_UNESCAPED\": 51, \"mustache_repetition1\": 52, \"mustache_option1\": 53, \"CLOSE_UNESCAPED\": 54, \"OPEN_PARTIAL\": 55, \"partialName\": 56, \"partial_repetition0\": 57, \"partial_option0\": 58, \"openPartialBlock\": 59, \"OPEN_PARTIAL_BLOCK\": 60, \"openPartialBlock_repetition0\": 61, \"openPartialBlock_option0\": 62, \"param\": 63, \"sexpr\": 64, \"OPEN_SEXPR\": 65, \"sexpr_repetition0\": 66, \"sexpr_option0\": 67, \"CLOSE_SEXPR\": 68, \"hash\": 69, \"hash_repetition_plus0\": 70, \"hashSegment\": 71, \"ID\": 72, \"EQUALS\": 73, \"blockParams\": 74, \"OPEN_BLOCK_PARAMS\": 75, \"blockParams_repetition_plus0\": 76, \"CLOSE_BLOCK_PARAMS\": 77, \"path\": 78, \"dataName\": 79, \"STRING\": 80, \"NUMBER\": 81, \"BOOLEAN\": 82, \"UNDEFINED\": 83, \"NULL\": 84, \"DATA\": 85, \"pathSegments\": 86, \"SEP\": 87, \"$accept\": 0, \"$end\": 1 },\n        terminals_: { 2: \"error\", 5: \"EOF\", 14: \"COMMENT\", 15: \"CONTENT\", 18: \"END_RAW_BLOCK\", 19: \"OPEN_RAW_BLOCK\", 23: \"CLOSE_RAW_BLOCK\", 29: \"OPEN_BLOCK\", 33: \"CLOSE\", 34: \"OPEN_INVERSE\", 39: \"OPEN_INVERSE_CHAIN\", 44: \"INVERSE\", 47: \"OPEN_ENDBLOCK\", 48: \"OPEN\", 51: \"OPEN_UNESCAPED\", 54: \"CLOSE_UNESCAPED\", 55: \"OPEN_PARTIAL\", 60: \"OPEN_PARTIAL_BLOCK\", 65: \"OPEN_SEXPR\", 68: \"CLOSE_SEXPR\", 72: \"ID\", 73: \"EQUALS\", 75: \"OPEN_BLOCK_PARAMS\", 77: \"CLOSE_BLOCK_PARAMS\", 80: \"STRING\", 81: \"NUMBER\", 82: \"BOOLEAN\", 83: \"UNDEFINED\", 84: \"NULL\", 85: \"DATA\", 87: \"SEP\" },\n        productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 1], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],\n        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$\n        /**/) {\n\n            var $0 = $$.length - 1;\n            switch (yystate) {\n                case 1:\n                    return $$[$0 - 1];\n                    break;\n                case 2:\n                    this.$ = yy.prepareProgram($$[$0]);\n                    break;\n                case 3:\n                    this.$ = $$[$0];\n                    break;\n                case 4:\n                    this.$ = $$[$0];\n                    break;\n                case 5:\n                    this.$ = $$[$0];\n                    break;\n                case 6:\n                    this.$ = $$[$0];\n                    break;\n                case 7:\n                    this.$ = $$[$0];\n                    break;\n                case 8:\n                    this.$ = $$[$0];\n                    break;\n                case 9:\n                    this.$ = {\n                        type: 'CommentStatement',\n                        value: yy.stripComment($$[$0]),\n                        strip: yy.stripFlags($$[$0], $$[$0]),\n                        loc: yy.locInfo(this._$)\n                    };\n\n                    break;\n                case 10:\n                    this.$ = {\n                        type: 'ContentStatement',\n                        original: $$[$0],\n                        value: $$[$0],\n                        loc: yy.locInfo(this._$)\n                    };\n\n                    break;\n                case 11:\n                    this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);\n                    break;\n                case 12:\n                    this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };\n                    break;\n                case 13:\n                    this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);\n                    break;\n                case 14:\n                    this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);\n                    break;\n                case 15:\n                    this.$ = { open: $$[$0 - 5], path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };\n                    break;\n                case 16:\n                    this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };\n                    break;\n                case 17:\n                    this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };\n                    break;\n                case 18:\n                    this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };\n                    break;\n                case 19:\n                    var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$),\n                        program = yy.prepareProgram([inverse], $$[$0 - 1].loc);\n                    program.chained = true;\n\n                    this.$ = { strip: $$[$0 - 2].strip, program: program, chain: true };\n\n                    break;\n                case 20:\n                    this.$ = $$[$0];\n                    break;\n                case 21:\n                    this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };\n                    break;\n                case 22:\n                    this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);\n                    break;\n                case 23:\n                    this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);\n                    break;\n                case 24:\n                    this.$ = {\n                        type: 'PartialStatement',\n                        name: $$[$0 - 3],\n                        params: $$[$0 - 2],\n                        hash: $$[$0 - 1],\n                        indent: '',\n                        strip: yy.stripFlags($$[$0 - 4], $$[$0]),\n                        loc: yy.locInfo(this._$)\n                    };\n\n                    break;\n                case 25:\n                    this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);\n                    break;\n                case 26:\n                    this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 4], $$[$0]) };\n                    break;\n                case 27:\n                    this.$ = $$[$0];\n                    break;\n                case 28:\n                    this.$ = $$[$0];\n                    break;\n                case 29:\n                    this.$ = {\n                        type: 'SubExpression',\n                        path: $$[$0 - 3],\n                        params: $$[$0 - 2],\n                        hash: $$[$0 - 1],\n                        loc: yy.locInfo(this._$)\n                    };\n\n                    break;\n                case 30:\n                    this.$ = { type: 'Hash', pairs: $$[$0], loc: yy.locInfo(this._$) };\n                    break;\n                case 31:\n                    this.$ = { type: 'HashPair', key: yy.id($$[$0 - 2]), value: $$[$0], loc: yy.locInfo(this._$) };\n                    break;\n                case 32:\n                    this.$ = yy.id($$[$0 - 1]);\n                    break;\n                case 33:\n                    this.$ = $$[$0];\n                    break;\n                case 34:\n                    this.$ = $$[$0];\n                    break;\n                case 35:\n                    this.$ = { type: 'StringLiteral', value: $$[$0], original: $$[$0], loc: yy.locInfo(this._$) };\n                    break;\n                case 36:\n                    this.$ = { type: 'NumberLiteral', value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };\n                    break;\n                case 37:\n                    this.$ = { type: 'BooleanLiteral', value: $$[$0] === 'true', original: $$[$0] === 'true', loc: yy.locInfo(this._$) };\n                    break;\n                case 38:\n                    this.$ = { type: 'UndefinedLiteral', original: undefined, value: undefined, loc: yy.locInfo(this._$) };\n                    break;\n                case 39:\n                    this.$ = { type: 'NullLiteral', original: null, value: null, loc: yy.locInfo(this._$) };\n                    break;\n                case 40:\n                    this.$ = $$[$0];\n                    break;\n                case 41:\n                    this.$ = $$[$0];\n                    break;\n                case 42:\n                    this.$ = yy.preparePath(true, $$[$0], this._$);\n                    break;\n                case 43:\n                    this.$ = yy.preparePath(false, $$[$0], this._$);\n                    break;\n                case 44:\n                    $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });this.$ = $$[$0 - 2];\n                    break;\n                case 45:\n                    this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];\n                    break;\n                case 46:\n                    this.$ = [];\n                    break;\n                case 47:\n                    $$[$0 - 1].push($$[$0]);\n                    break;\n                case 48:\n                    this.$ = [$$[$0]];\n                    break;\n                case 49:\n                    $$[$0 - 1].push($$[$0]);\n                    break;\n                case 50:\n                    this.$ = [];\n                    break;\n                case 51:\n                    $$[$0 - 1].push($$[$0]);\n                    break;\n                case 58:\n                    this.$ = [];\n                    break;\n                case 59:\n                    $$[$0 - 1].push($$[$0]);\n                    break;\n                case 64:\n                    this.$ = [];\n                    break;\n                case 65:\n                    $$[$0 - 1].push($$[$0]);\n                    break;\n                case 70:\n                    this.$ = [];\n                    break;\n                case 71:\n                    $$[$0 - 1].push($$[$0]);\n                    break;\n                case 78:\n                    this.$ = [];\n                    break;\n                case 79:\n                    $$[$0 - 1].push($$[$0]);\n                    break;\n                case 82:\n                    this.$ = [];\n                    break;\n                case 83:\n                    $$[$0 - 1].push($$[$0]);\n                    break;\n                case 86:\n                    this.$ = [];\n                    break;\n                case 87:\n                    $$[$0 - 1].push($$[$0]);\n                    break;\n                case 90:\n                    this.$ = [];\n                    break;\n                case 91:\n                    $$[$0 - 1].push($$[$0]);\n                    break;\n                case 94:\n                    this.$ = [];\n                    break;\n                case 95:\n                    $$[$0 - 1].push($$[$0]);\n                    break;\n                case 98:\n                    this.$ = [$$[$0]];\n                    break;\n                case 99:\n                    $$[$0 - 1].push($$[$0]);\n                    break;\n                case 100:\n                    this.$ = [$$[$0]];\n                    break;\n                case 101:\n                    $$[$0 - 1].push($$[$0]);\n                    break;\n            }\n        },\n        table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 13: 40, 15: [1, 20], 17: 39 }, { 20: 42, 56: 41, 64: 43, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 45, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 48, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 42, 56: 49, 64: 43, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 50, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 51] }, { 72: [1, 35], 86: 52 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 53, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 54, 38: 56, 39: [1, 58], 43: 57, 44: [1, 59], 45: 55, 47: [2, 54] }, { 28: 60, 43: 61, 44: [1, 59], 47: [2, 56] }, { 13: 63, 15: [1, 20], 18: [1, 62] }, { 15: [2, 48], 18: [2, 48] }, { 33: [2, 86], 57: 64, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 65, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 66, 47: [1, 67] }, { 30: 68, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 69, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 70, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 71, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 75, 33: [2, 80], 50: 72, 63: 73, 64: 76, 65: [1, 44], 69: 74, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 80] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 51] }, { 20: 75, 53: 81, 54: [2, 84], 63: 82, 64: 76, 65: [1, 44], 69: 83, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 84, 47: [1, 67] }, { 47: [2, 55] }, { 4: 85, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 86, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 87, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 88, 47: [1, 67] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 75, 33: [2, 88], 58: 89, 63: 90, 64: 76, 65: [1, 44], 69: 91, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 92, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 93, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 31: 94, 33: [2, 60], 63: 95, 64: 76, 65: [1, 44], 69: 96, 70: 77, 71: 78, 72: [1, 79], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 33: [2, 66], 36: 97, 63: 98, 64: 76, 65: [1, 44], 69: 99, 70: 77, 71: 78, 72: [1, 79], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 22: 100, 23: [2, 52], 63: 101, 64: 76, 65: [1, 44], 69: 102, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 33: [2, 92], 62: 103, 63: 104, 64: 76, 65: [1, 44], 69: 105, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 106] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 107, 72: [1, 108], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 109], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 110] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 56, 39: [1, 58], 43: 57, 44: [1, 59], 45: 112, 46: 111, 47: [2, 76] }, { 33: [2, 70], 40: 113, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 114] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 75, 63: 116, 64: 76, 65: [1, 44], 67: 115, 68: [2, 96], 69: 117, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 118] }, { 32: 119, 33: [2, 62], 74: 120, 75: [1, 121] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 122, 74: 123, 75: [1, 121] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 124] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 125] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 109] }, { 20: 75, 63: 126, 64: 76, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 75, 33: [2, 72], 41: 127, 63: 128, 64: 76, 65: [1, 44], 69: 129, 70: 77, 71: 78, 72: [1, 79], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 130] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 131] }, { 33: [2, 63] }, { 72: [1, 133], 76: 132 }, { 33: [1, 134] }, { 33: [2, 69] }, { 15: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 135, 74: 136, 75: [1, 121] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 138], 77: [1, 137] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 139] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],\n        defaultActions: { 4: [2, 1], 55: [2, 55], 57: [2, 20], 61: [2, 57], 74: [2, 81], 83: [2, 85], 87: [2, 18], 91: [2, 89], 102: [2, 53], 105: [2, 93], 111: [2, 19], 112: [2, 77], 117: [2, 97], 120: [2, 63], 123: [2, 69], 124: [2, 12], 136: [2, 75], 137: [2, 32] },\n        parseError: function parseError(str, hash) {\n            throw new Error(str);\n        },\n        parse: function parse(input) {\n            var self = this,\n                stack = [0],\n                vstack = [null],\n                lstack = [],\n                table = this.table,\n                yytext = \"\",\n                yylineno = 0,\n                yyleng = 0,\n                recovering = 0,\n                TERROR = 2,\n                EOF = 1;\n            this.lexer.setInput(input);\n            this.lexer.yy = this.yy;\n            this.yy.lexer = this.lexer;\n            this.yy.parser = this;\n            if (typeof this.lexer.yylloc == \"undefined\") this.lexer.yylloc = {};\n            var yyloc = this.lexer.yylloc;\n            lstack.push(yyloc);\n            var ranges = this.lexer.options && this.lexer.options.ranges;\n            if (typeof this.yy.parseError === \"function\") this.parseError = this.yy.parseError;\n            function popStack(n) {\n                stack.length = stack.length - 2 * n;\n                vstack.length = vstack.length - n;\n                lstack.length = lstack.length - n;\n            }\n            function lex() {\n                var token;\n                token = self.lexer.lex() || 1;\n                if (typeof token !== \"number\") {\n                    token = self.symbols_[token] || token;\n                }\n                return token;\n            }\n            var symbol,\n                preErrorSymbol,\n                state,\n                action,\n                a,\n                r,\n                yyval = {},\n                p,\n                len,\n                newState,\n                expected;\n            while (true) {\n                state = stack[stack.length - 1];\n                if (this.defaultActions[state]) {\n                    action = this.defaultActions[state];\n                } else {\n                    if (symbol === null || typeof symbol == \"undefined\") {\n                        symbol = lex();\n                    }\n                    action = table[state] && table[state][symbol];\n                }\n                if (typeof action === \"undefined\" || !action.length || !action[0]) {\n                    var errStr = \"\";\n                    if (!recovering) {\n                        expected = [];\n                        for (p in table[state]) if (this.terminals_[p] && p > 2) {\n                            expected.push(\"'\" + this.terminals_[p] + \"'\");\n                        }\n                        if (this.lexer.showPosition) {\n                            errStr = \"Parse error on line \" + (yylineno + 1) + \":\\n\" + this.lexer.showPosition() + \"\\nExpecting \" + expected.join(\", \") + \", got '\" + (this.terminals_[symbol] || symbol) + \"'\";\n                        } else {\n                            errStr = \"Parse error on line \" + (yylineno + 1) + \": Unexpected \" + (symbol == 1 ? \"end of input\" : \"'\" + (this.terminals_[symbol] || symbol) + \"'\");\n                        }\n                        this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected });\n                    }\n                }\n                if (action[0] instanceof Array && action.length > 1) {\n                    throw new Error(\"Parse Error: multiple actions possible at state: \" + state + \", token: \" + symbol);\n                }\n                switch (action[0]) {\n                    case 1:\n                        stack.push(symbol);\n                        vstack.push(this.lexer.yytext);\n                        lstack.push(this.lexer.yylloc);\n                        stack.push(action[1]);\n                        symbol = null;\n                        if (!preErrorSymbol) {\n                            yyleng = this.lexer.yyleng;\n                            yytext = this.lexer.yytext;\n                            yylineno = this.lexer.yylineno;\n                            yyloc = this.lexer.yylloc;\n                            if (recovering > 0) recovering--;\n                        } else {\n                            symbol = preErrorSymbol;\n                            preErrorSymbol = null;\n                        }\n                        break;\n                    case 2:\n                        len = this.productions_[action[1]][1];\n                        yyval.$ = vstack[vstack.length - len];\n                        yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };\n                        if (ranges) {\n                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];\n                        }\n                        r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);\n                        if (typeof r !== \"undefined\") {\n                            return r;\n                        }\n                        if (len) {\n                            stack = stack.slice(0, -1 * len * 2);\n                            vstack = vstack.slice(0, -1 * len);\n                            lstack = lstack.slice(0, -1 * len);\n                        }\n                        stack.push(this.productions_[action[1]][0]);\n                        vstack.push(yyval.$);\n                        lstack.push(yyval._$);\n                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n                        stack.push(newState);\n                        break;\n                    case 3:\n                        return true;\n                }\n            }\n            return true;\n        }\n    };\n    /* Jison generated lexer */\n    var lexer = (function () {\n        var lexer = { EOF: 1,\n            parseError: function parseError(str, hash) {\n                if (this.yy.parser) {\n                    this.yy.parser.parseError(str, hash);\n                } else {\n                    throw new Error(str);\n                }\n            },\n            setInput: function setInput(input) {\n                this._input = input;\n                this._more = this._less = this.done = false;\n                this.yylineno = this.yyleng = 0;\n                this.yytext = this.matched = this.match = '';\n                this.conditionStack = ['INITIAL'];\n                this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };\n                if (this.options.ranges) this.yylloc.range = [0, 0];\n                this.offset = 0;\n                return this;\n            },\n            input: function input() {\n                var ch = this._input[0];\n                this.yytext += ch;\n                this.yyleng++;\n                this.offset++;\n                this.match += ch;\n                this.matched += ch;\n                var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n                if (lines) {\n                    this.yylineno++;\n                    this.yylloc.last_line++;\n                } else {\n                    this.yylloc.last_column++;\n                }\n                if (this.options.ranges) this.yylloc.range[1]++;\n\n                this._input = this._input.slice(1);\n                return ch;\n            },\n            unput: function unput(ch) {\n                var len = ch.length;\n                var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n                this._input = ch + this._input;\n                this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);\n                //this.yyleng -= len;\n                this.offset -= len;\n                var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n                this.match = this.match.substr(0, this.match.length - 1);\n                this.matched = this.matched.substr(0, this.matched.length - 1);\n\n                if (lines.length - 1) this.yylineno -= lines.length - 1;\n                var r = this.yylloc.range;\n\n                this.yylloc = { first_line: this.yylloc.first_line,\n                    last_line: this.yylineno + 1,\n                    first_column: this.yylloc.first_column,\n                    last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len\n                };\n\n                if (this.options.ranges) {\n                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n                }\n                return this;\n            },\n            more: function more() {\n                this._more = true;\n                return this;\n            },\n            less: function less(n) {\n                this.unput(this.match.slice(n));\n            },\n            pastInput: function pastInput() {\n                var past = this.matched.substr(0, this.matched.length - this.match.length);\n                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\\n/g, \"\");\n            },\n            upcomingInput: function upcomingInput() {\n                var next = this.match;\n                if (next.length < 20) {\n                    next += this._input.substr(0, 20 - next.length);\n                }\n                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n            },\n            showPosition: function showPosition() {\n                var pre = this.pastInput();\n                var c = new Array(pre.length + 1).join(\"-\");\n                return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n            },\n            next: function next() {\n                if (this.done) {\n                    return this.EOF;\n                }\n                if (!this._input) this.done = true;\n\n                var token, match, tempMatch, index, col, lines;\n                if (!this._more) {\n                    this.yytext = '';\n                    this.match = '';\n                }\n                var rules = this._currentRules();\n                for (var i = 0; i < rules.length; i++) {\n                    tempMatch = this._input.match(this.rules[rules[i]]);\n                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                        match = tempMatch;\n                        index = i;\n                        if (!this.options.flex) break;\n                    }\n                }\n                if (match) {\n                    lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n                    if (lines) this.yylineno += lines.length;\n                    this.yylloc = { first_line: this.yylloc.last_line,\n                        last_line: this.yylineno + 1,\n                        first_column: this.yylloc.last_column,\n                        last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length : this.yylloc.last_column + match[0].length };\n                    this.yytext += match[0];\n                    this.match += match[0];\n                    this.matches = match;\n                    this.yyleng = this.yytext.length;\n                    if (this.options.ranges) {\n                        this.yylloc.range = [this.offset, this.offset += this.yyleng];\n                    }\n                    this._more = false;\n                    this._input = this._input.slice(match[0].length);\n                    this.matched += match[0];\n                    token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);\n                    if (this.done && this._input) this.done = false;\n                    if (token) return token;else return;\n                }\n                if (this._input === \"\") {\n                    return this.EOF;\n                } else {\n                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), { text: \"\", token: null, line: this.yylineno });\n                }\n            },\n            lex: function lex() {\n                var r = this.next();\n                if (typeof r !== 'undefined') {\n                    return r;\n                } else {\n                    return this.lex();\n                }\n            },\n            begin: function begin(condition) {\n                this.conditionStack.push(condition);\n            },\n            popState: function popState() {\n                return this.conditionStack.pop();\n            },\n            _currentRules: function _currentRules() {\n                return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n            },\n            topState: function topState() {\n                return this.conditionStack[this.conditionStack.length - 2];\n            },\n            pushState: function begin(condition) {\n                this.begin(condition);\n            } };\n        lexer.options = {};\n        lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START\n        /**/) {\n\n            function strip(start, end) {\n                return yy_.yytext = yy_.yytext.substr(start, yy_.yyleng - end);\n            }\n\n            var YYSTATE = YY_START;\n            switch ($avoiding_name_collisions) {\n                case 0:\n                    if (yy_.yytext.slice(-2) === \"\\\\\\\\\") {\n                        strip(0, 1);\n                        this.begin(\"mu\");\n                    } else if (yy_.yytext.slice(-1) === \"\\\\\") {\n                        strip(0, 1);\n                        this.begin(\"emu\");\n                    } else {\n                        this.begin(\"mu\");\n                    }\n                    if (yy_.yytext) return 15;\n\n                    break;\n                case 1:\n                    return 15;\n                    break;\n                case 2:\n                    this.popState();\n                    return 15;\n\n                    break;\n                case 3:\n                    this.begin('raw');return 15;\n                    break;\n                case 4:\n                    this.popState();\n                    // Should be using `this.topState()` below, but it currently\n                    // returns the second top instead of the first top. Opened an\n                    // issue about it at https://github.com/zaach/jison/issues/291\n                    if (this.conditionStack[this.conditionStack.length - 1] === 'raw') {\n                        return 15;\n                    } else {\n                        yy_.yytext = yy_.yytext.substr(5, yy_.yyleng - 9);\n                        return 'END_RAW_BLOCK';\n                    }\n\n                    break;\n                case 5:\n                    return 15;\n                    break;\n                case 6:\n                    this.popState();\n                    return 14;\n\n                    break;\n                case 7:\n                    return 65;\n                    break;\n                case 8:\n                    return 68;\n                    break;\n                case 9:\n                    return 19;\n                    break;\n                case 10:\n                    this.popState();\n                    this.begin('raw');\n                    return 23;\n\n                    break;\n                case 11:\n                    return 55;\n                    break;\n                case 12:\n                    return 60;\n                    break;\n                case 13:\n                    return 29;\n                    break;\n                case 14:\n                    return 47;\n                    break;\n                case 15:\n                    this.popState();return 44;\n                    break;\n                case 16:\n                    this.popState();return 44;\n                    break;\n                case 17:\n                    return 34;\n                    break;\n                case 18:\n                    return 39;\n                    break;\n                case 19:\n                    return 51;\n                    break;\n                case 20:\n                    return 48;\n                    break;\n                case 21:\n                    this.unput(yy_.yytext);\n                    this.popState();\n                    this.begin('com');\n\n                    break;\n                case 22:\n                    this.popState();\n                    return 14;\n\n                    break;\n                case 23:\n                    return 48;\n                    break;\n                case 24:\n                    return 73;\n                    break;\n                case 25:\n                    return 72;\n                    break;\n                case 26:\n                    return 72;\n                    break;\n                case 27:\n                    return 87;\n                    break;\n                case 28:\n                    // ignore whitespace\n                    break;\n                case 29:\n                    this.popState();return 54;\n                    break;\n                case 30:\n                    this.popState();return 33;\n                    break;\n                case 31:\n                    yy_.yytext = strip(1, 2).replace(/\\\\\"/g, '\"');return 80;\n                    break;\n                case 32:\n                    yy_.yytext = strip(1, 2).replace(/\\\\'/g, \"'\");return 80;\n                    break;\n                case 33:\n                    return 85;\n                    break;\n                case 34:\n                    return 82;\n                    break;\n                case 35:\n                    return 82;\n                    break;\n                case 36:\n                    return 83;\n                    break;\n                case 37:\n                    return 84;\n                    break;\n                case 38:\n                    return 81;\n                    break;\n                case 39:\n                    return 75;\n                    break;\n                case 40:\n                    return 77;\n                    break;\n                case 41:\n                    return 72;\n                    break;\n                case 42:\n                    yy_.yytext = yy_.yytext.replace(/\\\\([\\\\\\]])/g, '$1');return 72;\n                    break;\n                case 43:\n                    return 'INVALID';\n                    break;\n                case 44:\n                    return 5;\n                    break;\n            }\n        };\n        lexer.rules = [/^(?:[^\\x00]*?(?=(\\{\\{)))/, /^(?:[^\\x00]+)/, /^(?:[^\\x00]{2,}?(?=(\\{\\{|\\\\\\{\\{|\\\\\\\\\\{\\{|$)))/, /^(?:\\{\\{\\{\\{(?=[^\\/]))/, /^(?:\\{\\{\\{\\{\\/[^\\s!\"#%-,\\.\\/;->@\\[-\\^`\\{-~]+(?=[=}\\s\\/.])\\}\\}\\}\\})/, /^(?:[^\\x00]*?(?=(\\{\\{\\{\\{)))/, /^(?:[\\s\\S]*?--(~)?\\}\\})/, /^(?:\\()/, /^(?:\\))/, /^(?:\\{\\{\\{\\{)/, /^(?:\\}\\}\\}\\})/, /^(?:\\{\\{(~)?>)/, /^(?:\\{\\{(~)?#>)/, /^(?:\\{\\{(~)?#\\*?)/, /^(?:\\{\\{(~)?\\/)/, /^(?:\\{\\{(~)?\\^\\s*(~)?\\}\\})/, /^(?:\\{\\{(~)?\\s*else\\s*(~)?\\}\\})/, /^(?:\\{\\{(~)?\\^)/, /^(?:\\{\\{(~)?\\s*else\\b)/, /^(?:\\{\\{(~)?\\{)/, /^(?:\\{\\{(~)?&)/, /^(?:\\{\\{(~)?!--)/, /^(?:\\{\\{(~)?![\\s\\S]*?\\}\\})/, /^(?:\\{\\{(~)?\\*?)/, /^(?:=)/, /^(?:\\.\\.)/, /^(?:\\.(?=([=~}\\s\\/.)|])))/, /^(?:[\\/.])/, /^(?:\\s+)/, /^(?:\\}(~)?\\}\\})/, /^(?:(~)?\\}\\})/, /^(?:\"(\\\\[\"]|[^\"])*\")/, /^(?:'(\\\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\\s)])))/, /^(?:false(?=([~}\\s)])))/, /^(?:undefined(?=([~}\\s)])))/, /^(?:null(?=([~}\\s)])))/, /^(?:-?[0-9]+(?:\\.[0-9]+)?(?=([~}\\s)])))/, /^(?:as\\s+\\|)/, /^(?:\\|)/, /^(?:([^\\s!\"#%-,\\.\\/;->@\\[-\\^`\\{-~]+(?=([=~}\\s\\/.)|]))))/, /^(?:\\[(\\\\\\]|[^\\]])*\\])/, /^(?:.)/, /^(?:$)/];\n        lexer.conditions = { \"mu\": { \"rules\": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], \"inclusive\": false }, \"emu\": { \"rules\": [2], \"inclusive\": false }, \"com\": { \"rules\": [6], \"inclusive\": false }, \"raw\": { \"rules\": [3, 4, 5], \"inclusive\": false }, \"INITIAL\": { \"rules\": [0, 1, 44], \"inclusive\": true } };\n        return lexer;\n    })();\n    parser.lexer = lexer;\n    function Parser() {\n        this.yy = {};\n    }Parser.prototype = parser;parser.Parser = Parser;\n    return new Parser();\n})();exports.__esModule = true;\nexports['default'] = handlebars;\n\n\n},{}],15:[function(require,module,exports){\n/* eslint-disable new-cap */\n'use strict';\n\nexports.__esModule = true;\nexports.print = print;\nexports.PrintVisitor = PrintVisitor;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _visitor = require('./visitor');\n\nvar _visitor2 = _interopRequireDefault(_visitor);\n\nfunction print(ast) {\n  return new PrintVisitor().accept(ast);\n}\n\nfunction PrintVisitor() {\n  this.padding = 0;\n}\n\nPrintVisitor.prototype = new _visitor2['default']();\n\nPrintVisitor.prototype.pad = function (string) {\n  var out = '';\n\n  for (var i = 0, l = this.padding; i < l; i++) {\n    out += '  ';\n  }\n\n  out += string + '\\n';\n  return out;\n};\n\nPrintVisitor.prototype.Program = function (program) {\n  var out = '',\n      body = program.body,\n      i = undefined,\n      l = undefined;\n\n  if (program.blockParams) {\n    var blockParams = 'BLOCK PARAMS: [';\n    for (i = 0, l = program.blockParams.length; i < l; i++) {\n      blockParams += ' ' + program.blockParams[i];\n    }\n    blockParams += ' ]';\n    out += this.pad(blockParams);\n  }\n\n  for (i = 0, l = body.length; i < l; i++) {\n    out += this.accept(body[i]);\n  }\n\n  this.padding--;\n\n  return out;\n};\n\nPrintVisitor.prototype.MustacheStatement = function (mustache) {\n  return this.pad('{{ ' + this.SubExpression(mustache) + ' }}');\n};\nPrintVisitor.prototype.Decorator = function (mustache) {\n  return this.pad('{{ DIRECTIVE ' + this.SubExpression(mustache) + ' }}');\n};\n\nPrintVisitor.prototype.BlockStatement = PrintVisitor.prototype.DecoratorBlock = function (block) {\n  var out = '';\n\n  out += this.pad((block.type === 'DecoratorBlock' ? 'DIRECTIVE ' : '') + 'BLOCK:');\n  this.padding++;\n  out += this.pad(this.SubExpression(block));\n  if (block.program) {\n    out += this.pad('PROGRAM:');\n    this.padding++;\n    out += this.accept(block.program);\n    this.padding--;\n  }\n  if (block.inverse) {\n    if (block.program) {\n      this.padding++;\n    }\n    out += this.pad('{{^}}');\n    this.padding++;\n    out += this.accept(block.inverse);\n    this.padding--;\n    if (block.program) {\n      this.padding--;\n    }\n  }\n  this.padding--;\n\n  return out;\n};\n\nPrintVisitor.prototype.PartialStatement = function (partial) {\n  var content = 'PARTIAL:' + partial.name.original;\n  if (partial.params[0]) {\n    content += ' ' + this.accept(partial.params[0]);\n  }\n  if (partial.hash) {\n    content += ' ' + this.accept(partial.hash);\n  }\n  return this.pad('{{> ' + content + ' }}');\n};\nPrintVisitor.prototype.PartialBlockStatement = function (partial) {\n  var content = 'PARTIAL BLOCK:' + partial.name.original;\n  if (partial.params[0]) {\n    content += ' ' + this.accept(partial.params[0]);\n  }\n  if (partial.hash) {\n    content += ' ' + this.accept(partial.hash);\n  }\n\n  content += ' ' + this.pad('PROGRAM:');\n  this.padding++;\n  content += this.accept(partial.program);\n  this.padding--;\n\n  return this.pad('{{> ' + content + ' }}');\n};\n\nPrintVisitor.prototype.ContentStatement = function (content) {\n  return this.pad(\"CONTENT[ '\" + content.value + \"' ]\");\n};\n\nPrintVisitor.prototype.CommentStatement = function (comment) {\n  return this.pad(\"{{! '\" + comment.value + \"' }}\");\n};\n\nPrintVisitor.prototype.SubExpression = function (sexpr) {\n  var params = sexpr.params,\n      paramStrings = [],\n      hash = undefined;\n\n  for (var i = 0, l = params.length; i < l; i++) {\n    paramStrings.push(this.accept(params[i]));\n  }\n\n  params = '[' + paramStrings.join(', ') + ']';\n\n  hash = sexpr.hash ? ' ' + this.accept(sexpr.hash) : '';\n\n  return this.accept(sexpr.path) + ' ' + params + hash;\n};\n\nPrintVisitor.prototype.PathExpression = function (id) {\n  var path = id.parts.join('/');\n  return (id.data ? '@' : '') + 'PATH:' + path;\n};\n\nPrintVisitor.prototype.StringLiteral = function (string) {\n  return '\"' + string.value + '\"';\n};\n\nPrintVisitor.prototype.NumberLiteral = function (number) {\n  return 'NUMBER{' + number.value + '}';\n};\n\nPrintVisitor.prototype.BooleanLiteral = function (bool) {\n  return 'BOOLEAN{' + bool.value + '}';\n};\n\nPrintVisitor.prototype.UndefinedLiteral = function () {\n  return 'UNDEFINED';\n};\n\nPrintVisitor.prototype.NullLiteral = function () {\n  return 'NULL';\n};\n\nPrintVisitor.prototype.Hash = function (hash) {\n  var pairs = hash.pairs,\n      joinedPairs = [];\n\n  for (var i = 0, l = pairs.length; i < l; i++) {\n    joinedPairs.push(this.accept(pairs[i]));\n  }\n\n  return 'HASH{' + joinedPairs.join(', ') + '}';\n};\nPrintVisitor.prototype.HashPair = function (pair) {\n  return pair.key + '=' + this.accept(pair.value);\n};\n/* eslint-enable new-cap */\n\n\n},{\"./visitor\":16}],16:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _exception = require('../exception');\n\nvar _exception2 = _interopRequireDefault(_exception);\n\nfunction Visitor() {\n  this.parents = [];\n}\n\nVisitor.prototype = {\n  constructor: Visitor,\n  mutating: false,\n\n  // Visits a given value. If mutating, will replace the value if necessary.\n  acceptKey: function acceptKey(node, name) {\n    var value = this.accept(node[name]);\n    if (this.mutating) {\n      // Hacky sanity check: This may have a few false positives for type for the helper\n      // methods but will generally do the right thing without a lot of overhead.\n      if (value && !Visitor.prototype[value.type]) {\n        throw new _exception2['default']('Unexpected node type \"' + value.type + '\" found when accepting ' + name + ' on ' + node.type);\n      }\n      node[name] = value;\n    }\n  },\n\n  // Performs an accept operation with added sanity check to ensure\n  // required keys are not removed.\n  acceptRequired: function acceptRequired(node, name) {\n    this.acceptKey(node, name);\n\n    if (!node[name]) {\n      throw new _exception2['default'](node.type + ' requires ' + name);\n    }\n  },\n\n  // Traverses a given array. If mutating, empty respnses will be removed\n  // for child elements.\n  acceptArray: function acceptArray(array) {\n    for (var i = 0, l = array.length; i < l; i++) {\n      this.acceptKey(array, i);\n\n      if (!array[i]) {\n        array.splice(i, 1);\n        i--;\n        l--;\n      }\n    }\n  },\n\n  accept: function accept(object) {\n    if (!object) {\n      return;\n    }\n\n    /* istanbul ignore next: Sanity code */\n    if (!this[object.type]) {\n      throw new _exception2['default']('Unknown type: ' + object.type, object);\n    }\n\n    if (this.current) {\n      this.parents.unshift(this.current);\n    }\n    this.current = object;\n\n    var ret = this[object.type](object);\n\n    this.current = this.parents.shift();\n\n    if (!this.mutating || ret) {\n      return ret;\n    } else if (ret !== false) {\n      return object;\n    }\n  },\n\n  Program: function Program(program) {\n    this.acceptArray(program.body);\n  },\n\n  MustacheStatement: visitSubExpression,\n  Decorator: visitSubExpression,\n\n  BlockStatement: visitBlock,\n  DecoratorBlock: visitBlock,\n\n  PartialStatement: visitPartial,\n  PartialBlockStatement: function PartialBlockStatement(partial) {\n    visitPartial.call(this, partial);\n\n    this.acceptKey(partial, 'program');\n  },\n\n  ContentStatement: function ContentStatement() /* content */{},\n  CommentStatement: function CommentStatement() /* comment */{},\n\n  SubExpression: visitSubExpression,\n\n  PathExpression: function PathExpression() /* path */{},\n\n  StringLiteral: function StringLiteral() /* string */{},\n  NumberLiteral: function NumberLiteral() /* number */{},\n  BooleanLiteral: function BooleanLiteral() /* bool */{},\n  UndefinedLiteral: function UndefinedLiteral() /* literal */{},\n  NullLiteral: function NullLiteral() /* literal */{},\n\n  Hash: function Hash(hash) {\n    this.acceptArray(hash.pairs);\n  },\n  HashPair: function HashPair(pair) {\n    this.acceptRequired(pair, 'value');\n  }\n};\n\nfunction visitSubExpression(mustache) {\n  this.acceptRequired(mustache, 'path');\n  this.acceptArray(mustache.params);\n  this.acceptKey(mustache, 'hash');\n}\nfunction visitBlock(block) {\n  visitSubExpression.call(this, block);\n\n  this.acceptKey(block, 'program');\n  this.acceptKey(block, 'inverse');\n}\nfunction visitPartial(partial) {\n  this.acceptRequired(partial, 'name');\n  this.acceptArray(partial.params);\n  this.acceptKey(partial, 'hash');\n}\n\nexports['default'] = Visitor;\nmodule.exports = exports['default'];\n\n\n},{\"../exception\":20}],17:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _visitor = require('./visitor');\n\nvar _visitor2 = _interopRequireDefault(_visitor);\n\nfunction WhitespaceControl() {\n  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n  this.options = options;\n}\nWhitespaceControl.prototype = new _visitor2['default']();\n\nWhitespaceControl.prototype.Program = function (program) {\n  var doStandalone = !this.options.ignoreStandalone;\n\n  var isRoot = !this.isRootSeen;\n  this.isRootSeen = true;\n\n  var body = program.body;\n  for (var i = 0, l = body.length; i < l; i++) {\n    var current = body[i],\n        strip = this.accept(current);\n\n    if (!strip) {\n      continue;\n    }\n\n    var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),\n        _isNextWhitespace = isNextWhitespace(body, i, isRoot),\n        openStandalone = strip.openStandalone && _isPrevWhitespace,\n        closeStandalone = strip.closeStandalone && _isNextWhitespace,\n        inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;\n\n    if (strip.close) {\n      omitRight(body, i, true);\n    }\n    if (strip.open) {\n      omitLeft(body, i, true);\n    }\n\n    if (doStandalone && inlineStandalone) {\n      omitRight(body, i);\n\n      if (omitLeft(body, i)) {\n        // If we are on a standalone node, save the indent info for partials\n        if (current.type === 'PartialStatement') {\n          // Pull out the whitespace from the final line\n          current.indent = /([ \\t]+$)/.exec(body[i - 1].original)[1];\n        }\n      }\n    }\n    if (doStandalone && openStandalone) {\n      omitRight((current.program || current.inverse).body);\n\n      // Strip out the previous content node if it's whitespace only\n      omitLeft(body, i);\n    }\n    if (doStandalone && closeStandalone) {\n      // Always strip the next node\n      omitRight(body, i);\n\n      omitLeft((current.inverse || current.program).body);\n    }\n  }\n\n  return program;\n};\n\nWhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function (block) {\n  this.accept(block.program);\n  this.accept(block.inverse);\n\n  // Find the inverse program that is involed with whitespace stripping.\n  var program = block.program || block.inverse,\n      inverse = block.program && block.inverse,\n      firstInverse = inverse,\n      lastInverse = inverse;\n\n  if (inverse && inverse.chained) {\n    firstInverse = inverse.body[0].program;\n\n    // Walk the inverse chain to find the last inverse that is actually in the chain.\n    while (lastInverse.chained) {\n      lastInverse = lastInverse.body[lastInverse.body.length - 1].program;\n    }\n  }\n\n  var strip = {\n    open: block.openStrip.open,\n    close: block.closeStrip.close,\n\n    // Determine the standalone candiacy. Basically flag our content as being possibly standalone\n    // so our parent can determine if we actually are standalone\n    openStandalone: isNextWhitespace(program.body),\n    closeStandalone: isPrevWhitespace((firstInverse || program).body)\n  };\n\n  if (block.openStrip.close) {\n    omitRight(program.body, null, true);\n  }\n\n  if (inverse) {\n    var inverseStrip = block.inverseStrip;\n\n    if (inverseStrip.open) {\n      omitLeft(program.body, null, true);\n    }\n\n    if (inverseStrip.close) {\n      omitRight(firstInverse.body, null, true);\n    }\n    if (block.closeStrip.open) {\n      omitLeft(lastInverse.body, null, true);\n    }\n\n    // Find standalone else statments\n    if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {\n      omitLeft(program.body);\n      omitRight(firstInverse.body);\n    }\n  } else if (block.closeStrip.open) {\n    omitLeft(program.body, null, true);\n  }\n\n  return strip;\n};\n\nWhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function (mustache) {\n  return mustache.strip;\n};\n\nWhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node) {\n  /* istanbul ignore next */\n  var strip = node.strip || {};\n  return {\n    inlineStandalone: true,\n    open: strip.open,\n    close: strip.close\n  };\n};\n\nfunction isPrevWhitespace(body, i, isRoot) {\n  if (i === undefined) {\n    i = body.length;\n  }\n\n  // Nodes that end with newlines are considered whitespace (but are special\n  // cased for strip operations)\n  var prev = body[i - 1],\n      sibling = body[i - 2];\n  if (!prev) {\n    return isRoot;\n  }\n\n  if (prev.type === 'ContentStatement') {\n    return (sibling || !isRoot ? /\\r?\\n\\s*?$/ : /(^|\\r?\\n)\\s*?$/).test(prev.original);\n  }\n}\nfunction isNextWhitespace(body, i, isRoot) {\n  if (i === undefined) {\n    i = -1;\n  }\n\n  var next = body[i + 1],\n      sibling = body[i + 2];\n  if (!next) {\n    return isRoot;\n  }\n\n  if (next.type === 'ContentStatement') {\n    return (sibling || !isRoot ? /^\\s*?\\r?\\n/ : /^\\s*?(\\r?\\n|$)/).test(next.original);\n  }\n}\n\n// Marks the node to the right of the position as omitted.\n// I.e. {{foo}}' ' will mark the ' ' node as omitted.\n//\n// If i is undefined, then the first child will be marked as such.\n//\n// If mulitple is truthy then all whitespace will be stripped out until non-whitespace\n// content is met.\nfunction omitRight(body, i, multiple) {\n  var current = body[i == null ? 0 : i + 1];\n  if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {\n    return;\n  }\n\n  var original = current.value;\n  current.value = current.value.replace(multiple ? /^\\s+/ : /^[ \\t]*\\r?\\n?/, '');\n  current.rightStripped = current.value !== original;\n}\n\n// Marks the node to the left of the position as omitted.\n// I.e. ' '{{foo}} will mark the ' ' node as omitted.\n//\n// If i is undefined then the last child will be marked as such.\n//\n// If mulitple is truthy then all whitespace will be stripped out until non-whitespace\n// content is met.\nfunction omitLeft(body, i, multiple) {\n  var current = body[i == null ? body.length - 1 : i - 1];\n  if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {\n    return;\n  }\n\n  // We omit the last node if it's whitespace only and not preceeded by a non-content node.\n  var original = current.value;\n  current.value = current.value.replace(multiple ? /\\s+$/ : /[ \\t]+$/, '');\n  current.leftStripped = current.value !== original;\n  return current.leftStripped;\n}\n\nexports['default'] = WhitespaceControl;\nmodule.exports = exports['default'];\n\n\n},{\"./visitor\":16}],18:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\nexports.registerDefaultDecorators = registerDefaultDecorators;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _decoratorsInline = require('./decorators/inline');\n\nvar _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);\n\nfunction registerDefaultDecorators(instance) {\n  _decoratorsInline2['default'](instance);\n}\n\n\n},{\"./decorators/inline\":19}],19:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\n\nvar _utils = require('../utils');\n\nexports['default'] = function (instance) {\n  instance.registerDecorator('inline', function (fn, props, container, options) {\n    var ret = fn;\n    if (!props.partials) {\n      props.partials = {};\n      ret = function (context, options) {\n        // Create a new partials stack frame prior to exec.\n        var original = container.partials;\n        container.partials = _utils.extend({}, original, props.partials);\n        var ret = fn(context, options);\n        container.partials = original;\n        return ret;\n      };\n    }\n\n    props.partials[options.args[0]] = options.fn;\n\n    return ret;\n  });\n};\n\nmodule.exports = exports['default'];\n\n\n},{\"../utils\":33}],20:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\n\nvar errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];\n\nfunction Exception(message, node) {\n  var loc = node && node.loc,\n      line = undefined,\n      column = undefined;\n  if (loc) {\n    line = loc.start.line;\n    column = loc.start.column;\n\n    message += ' - ' + line + ':' + column;\n  }\n\n  var tmp = Error.prototype.constructor.call(this, message);\n\n  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.\n  for (var idx = 0; idx < errorProps.length; idx++) {\n    this[errorProps[idx]] = tmp[errorProps[idx]];\n  }\n\n  /* istanbul ignore else */\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, Exception);\n  }\n\n  try {\n    if (loc) {\n      this.lineNumber = line;\n\n      // Work around issue under safari where we can't directly set the column value\n      /* istanbul ignore next */\n      if (Object.defineProperty) {\n        Object.defineProperty(this, 'column', { value: column });\n      } else {\n        this.column = column;\n      }\n    }\n  } catch (nop) {\n    /* Ignore if the browser is very particular */\n  }\n}\n\nException.prototype = new Error();\n\nexports['default'] = Exception;\nmodule.exports = exports['default'];\n\n\n},{}],21:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\nexports.registerDefaultHelpers = registerDefaultHelpers;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _helpersBlockHelperMissing = require('./helpers/block-helper-missing');\n\nvar _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);\n\nvar _helpersEach = require('./helpers/each');\n\nvar _helpersEach2 = _interopRequireDefault(_helpersEach);\n\nvar _helpersHelperMissing = require('./helpers/helper-missing');\n\nvar _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);\n\nvar _helpersIf = require('./helpers/if');\n\nvar _helpersIf2 = _interopRequireDefault(_helpersIf);\n\nvar _helpersLog = require('./helpers/log');\n\nvar _helpersLog2 = _interopRequireDefault(_helpersLog);\n\nvar _helpersLookup = require('./helpers/lookup');\n\nvar _helpersLookup2 = _interopRequireDefault(_helpersLookup);\n\nvar _helpersWith = require('./helpers/with');\n\nvar _helpersWith2 = _interopRequireDefault(_helpersWith);\n\nfunction registerDefaultHelpers(instance) {\n  _helpersBlockHelperMissing2['default'](instance);\n  _helpersEach2['default'](instance);\n  _helpersHelperMissing2['default'](instance);\n  _helpersIf2['default'](instance);\n  _helpersLog2['default'](instance);\n  _helpersLookup2['default'](instance);\n  _helpersWith2['default'](instance);\n}\n\n\n},{\"./helpers/block-helper-missing\":22,\"./helpers/each\":23,\"./helpers/helper-missing\":24,\"./helpers/if\":25,\"./helpers/log\":26,\"./helpers/lookup\":27,\"./helpers/with\":28}],22:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\n\nvar _utils = require('../utils');\n\nexports['default'] = function (instance) {\n  instance.registerHelper('blockHelperMissing', function (context, options) {\n    var inverse = options.inverse,\n        fn = options.fn;\n\n    if (context === true) {\n      return fn(this);\n    } else if (context === false || context == null) {\n      return inverse(this);\n    } else if (_utils.isArray(context)) {\n      if (context.length > 0) {\n        if (options.ids) {\n          options.ids = [options.name];\n        }\n\n        return instance.helpers.each(context, options);\n      } else {\n        return inverse(this);\n      }\n    } else {\n      if (options.data && options.ids) {\n        var data = _utils.createFrame(options.data);\n        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);\n        options = { data: data };\n      }\n\n      return fn(context, options);\n    }\n  });\n};\n\nmodule.exports = exports['default'];\n\n\n},{\"../utils\":33}],23:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _utils = require('../utils');\n\nvar _exception = require('../exception');\n\nvar _exception2 = _interopRequireDefault(_exception);\n\nexports['default'] = function (instance) {\n  instance.registerHelper('each', function (context, options) {\n    if (!options) {\n      throw new _exception2['default']('Must pass iterator to #each');\n    }\n\n    var fn = options.fn,\n        inverse = options.inverse,\n        i = 0,\n        ret = '',\n        data = undefined,\n        contextPath = undefined;\n\n    if (options.data && options.ids) {\n      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';\n    }\n\n    if (_utils.isFunction(context)) {\n      context = context.call(this);\n    }\n\n    if (options.data) {\n      data = _utils.createFrame(options.data);\n    }\n\n    function execIteration(field, index, last) {\n      if (data) {\n        data.key = field;\n        data.index = index;\n        data.first = index === 0;\n        data.last = !!last;\n\n        if (contextPath) {\n          data.contextPath = contextPath + field;\n        }\n      }\n\n      ret = ret + fn(context[field], {\n        data: data,\n        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])\n      });\n    }\n\n    if (context && typeof context === 'object') {\n      if (_utils.isArray(context)) {\n        for (var j = context.length; i < j; i++) {\n          if (i in context) {\n            execIteration(i, i, i === context.length - 1);\n          }\n        }\n      } else {\n        var priorKey = undefined;\n\n        for (var key in context) {\n          if (context.hasOwnProperty(key)) {\n            // We're running the iterations one step out of sync so we can detect\n            // the last iteration without have to scan the object twice and create\n            // an itermediate keys array.\n            if (priorKey !== undefined) {\n              execIteration(priorKey, i - 1);\n            }\n            priorKey = key;\n            i++;\n          }\n        }\n        if (priorKey !== undefined) {\n          execIteration(priorKey, i - 1, true);\n        }\n      }\n    }\n\n    if (i === 0) {\n      ret = inverse(this);\n    }\n\n    return ret;\n  });\n};\n\nmodule.exports = exports['default'];\n\n\n},{\"../exception\":20,\"../utils\":33}],24:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _exception = require('../exception');\n\nvar _exception2 = _interopRequireDefault(_exception);\n\nexports['default'] = function (instance) {\n  instance.registerHelper('helperMissing', function () /* [args, ]options */{\n    if (arguments.length === 1) {\n      // A missing field in a {{foo}} construct.\n      return undefined;\n    } else {\n      // Someone is actually trying to call something, blow up.\n      throw new _exception2['default']('Missing helper: \"' + arguments[arguments.length - 1].name + '\"');\n    }\n  });\n};\n\nmodule.exports = exports['default'];\n\n\n},{\"../exception\":20}],25:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\n\nvar _utils = require('../utils');\n\nexports['default'] = function (instance) {\n  instance.registerHelper('if', function (conditional, options) {\n    if (_utils.isFunction(conditional)) {\n      conditional = conditional.call(this);\n    }\n\n    // Default behavior is to render the positive path if the value is truthy and not empty.\n    // The `includeZero` option may be set to treat the condtional as purely not empty based on the\n    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.\n    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {\n      return options.inverse(this);\n    } else {\n      return options.fn(this);\n    }\n  });\n\n  instance.registerHelper('unless', function (conditional, options) {\n    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });\n  });\n};\n\nmodule.exports = exports['default'];\n\n\n},{\"../utils\":33}],26:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\n\nexports['default'] = function (instance) {\n  instance.registerHelper('log', function () /* message, options */{\n    var args = [undefined],\n        options = arguments[arguments.length - 1];\n    for (var i = 0; i < arguments.length - 1; i++) {\n      args.push(arguments[i]);\n    }\n\n    var level = 1;\n    if (options.hash.level != null) {\n      level = options.hash.level;\n    } else if (options.data && options.data.level != null) {\n      level = options.data.level;\n    }\n    args[0] = level;\n\n    instance.log.apply(instance, args);\n  });\n};\n\nmodule.exports = exports['default'];\n\n\n},{}],27:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\n\nexports['default'] = function (instance) {\n  instance.registerHelper('lookup', function (obj, field) {\n    return obj && obj[field];\n  });\n};\n\nmodule.exports = exports['default'];\n\n\n},{}],28:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\n\nvar _utils = require('../utils');\n\nexports['default'] = function (instance) {\n  instance.registerHelper('with', function (context, options) {\n    if (_utils.isFunction(context)) {\n      context = context.call(this);\n    }\n\n    var fn = options.fn;\n\n    if (!_utils.isEmpty(context)) {\n      var data = options.data;\n      if (options.data && options.ids) {\n        data = _utils.createFrame(options.data);\n        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);\n      }\n\n      return fn(context, {\n        data: data,\n        blockParams: _utils.blockParams([context], [data && data.contextPath])\n      });\n    } else {\n      return options.inverse(this);\n    }\n  });\n};\n\nmodule.exports = exports['default'];\n\n\n},{\"../utils\":33}],29:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\n\nvar _utils = require('./utils');\n\nvar logger = {\n  methodMap: ['debug', 'info', 'warn', 'error'],\n  level: 'info',\n\n  // Maps a given level value to the `methodMap` indexes above.\n  lookupLevel: function lookupLevel(level) {\n    if (typeof level === 'string') {\n      var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());\n      if (levelMap >= 0) {\n        level = levelMap;\n      } else {\n        level = parseInt(level, 10);\n      }\n    }\n\n    return level;\n  },\n\n  // Can be overridden in the host environment\n  log: function log(level) {\n    level = logger.lookupLevel(level);\n\n    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {\n      var method = logger.methodMap[level];\n      if (!console[method]) {\n        // eslint-disable-line no-console\n        method = 'log';\n      }\n\n      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        message[_key - 1] = arguments[_key];\n      }\n\n      console[method].apply(console, message); // eslint-disable-line no-console\n    }\n  }\n};\n\nexports['default'] = logger;\nmodule.exports = exports['default'];\n\n\n},{\"./utils\":33}],30:[function(require,module,exports){\n(function (global){\n/* global window */\n'use strict';\n\nexports.__esModule = true;\n\nexports['default'] = function (Handlebars) {\n  /* istanbul ignore next */\n  var root = typeof global !== 'undefined' ? global : window,\n      $Handlebars = root.Handlebars;\n  /* istanbul ignore next */\n  Handlebars.noConflict = function () {\n    if (root.Handlebars === Handlebars) {\n      root.Handlebars = $Handlebars;\n    }\n    return Handlebars;\n  };\n};\n\nmodule.exports = exports['default'];\n\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],31:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\nexports.checkRevision = checkRevision;\nexports.template = template;\nexports.wrapProgram = wrapProgram;\nexports.resolvePartial = resolvePartial;\nexports.invokePartial = invokePartial;\nexports.noop = noop;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nvar _utils = require('./utils');\n\nvar Utils = _interopRequireWildcard(_utils);\n\nvar _exception = require('./exception');\n\nvar _exception2 = _interopRequireDefault(_exception);\n\nvar _base = require('./base');\n\nfunction checkRevision(compilerInfo) {\n  var compilerRevision = compilerInfo && compilerInfo[0] || 1,\n      currentRevision = _base.COMPILER_REVISION;\n\n  if (compilerRevision !== currentRevision) {\n    if (compilerRevision < currentRevision) {\n      var runtimeVersions = _base.REVISION_CHANGES[currentRevision],\n          compilerVersions = _base.REVISION_CHANGES[compilerRevision];\n      throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');\n    } else {\n      // Use the embedded version info since the runtime doesn't know about this revision yet\n      throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');\n    }\n  }\n}\n\nfunction template(templateSpec, env) {\n  /* istanbul ignore next */\n  if (!env) {\n    throw new _exception2['default']('No environment passed to template');\n  }\n  if (!templateSpec || !templateSpec.main) {\n    throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);\n  }\n\n  templateSpec.main.decorator = templateSpec.main_d;\n\n  // Note: Using env.VM references rather than local var references throughout this section to allow\n  // for external users to override these as psuedo-supported APIs.\n  env.VM.checkRevision(templateSpec.compiler);\n\n  function invokePartialWrapper(partial, context, options) {\n    if (options.hash) {\n      context = Utils.extend({}, context, options.hash);\n      if (options.ids) {\n        options.ids[0] = true;\n      }\n    }\n\n    partial = env.VM.resolvePartial.call(this, partial, context, options);\n    var result = env.VM.invokePartial.call(this, partial, context, options);\n\n    if (result == null && env.compile) {\n      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);\n      result = options.partials[options.name](context, options);\n    }\n    if (result != null) {\n      if (options.indent) {\n        var lines = result.split('\\n');\n        for (var i = 0, l = lines.length; i < l; i++) {\n          if (!lines[i] && i + 1 === l) {\n            break;\n          }\n\n          lines[i] = options.indent + lines[i];\n        }\n        result = lines.join('\\n');\n      }\n      return result;\n    } else {\n      throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');\n    }\n  }\n\n  // Just add water\n  var container = {\n    strict: function strict(obj, name) {\n      if (!(name in obj)) {\n        throw new _exception2['default']('\"' + name + '\" not defined in ' + obj);\n      }\n      return obj[name];\n    },\n    lookup: function lookup(depths, name) {\n      var len = depths.length;\n      for (var i = 0; i < len; i++) {\n        if (depths[i] && depths[i][name] != null) {\n          return depths[i][name];\n        }\n      }\n    },\n    lambda: function lambda(current, context) {\n      return typeof current === 'function' ? current.call(context) : current;\n    },\n\n    escapeExpression: Utils.escapeExpression,\n    invokePartial: invokePartialWrapper,\n\n    fn: function fn(i) {\n      var ret = templateSpec[i];\n      ret.decorator = templateSpec[i + '_d'];\n      return ret;\n    },\n\n    programs: [],\n    program: function program(i, data, declaredBlockParams, blockParams, depths) {\n      var programWrapper = this.programs[i],\n          fn = this.fn(i);\n      if (data || depths || blockParams || declaredBlockParams) {\n        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);\n      } else if (!programWrapper) {\n        programWrapper = this.programs[i] = wrapProgram(this, i, fn);\n      }\n      return programWrapper;\n    },\n\n    data: function data(value, depth) {\n      while (value && depth--) {\n        value = value._parent;\n      }\n      return value;\n    },\n    merge: function merge(param, common) {\n      var obj = param || common;\n\n      if (param && common && param !== common) {\n        obj = Utils.extend({}, common, param);\n      }\n\n      return obj;\n    },\n\n    noop: env.VM.noop,\n    compilerInfo: templateSpec.compiler\n  };\n\n  function ret(context) {\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    var data = options.data;\n\n    ret._setup(options);\n    if (!options.partial && templateSpec.useData) {\n      data = initData(context, data);\n    }\n    var depths = undefined,\n        blockParams = templateSpec.useBlockParams ? [] : undefined;\n    if (templateSpec.useDepths) {\n      if (options.depths) {\n        depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;\n      } else {\n        depths = [context];\n      }\n    }\n\n    function main(context /*, options*/) {\n      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);\n    }\n    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);\n    return main(context, options);\n  }\n  ret.isTop = true;\n\n  ret._setup = function (options) {\n    if (!options.partial) {\n      container.helpers = container.merge(options.helpers, env.helpers);\n\n      if (templateSpec.usePartial) {\n        container.partials = container.merge(options.partials, env.partials);\n      }\n      if (templateSpec.usePartial || templateSpec.useDecorators) {\n        container.decorators = container.merge(options.decorators, env.decorators);\n      }\n    } else {\n      container.helpers = options.helpers;\n      container.partials = options.partials;\n      container.decorators = options.decorators;\n    }\n  };\n\n  ret._child = function (i, data, blockParams, depths) {\n    if (templateSpec.useBlockParams && !blockParams) {\n      throw new _exception2['default']('must pass block params');\n    }\n    if (templateSpec.useDepths && !depths) {\n      throw new _exception2['default']('must pass parent depths');\n    }\n\n    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);\n  };\n  return ret;\n}\n\nfunction wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {\n  function prog(context) {\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    var currentDepths = depths;\n    if (depths && context != depths[0]) {\n      currentDepths = [context].concat(depths);\n    }\n\n    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);\n  }\n\n  prog = executeDecorators(fn, prog, container, depths, data, blockParams);\n\n  prog.program = i;\n  prog.depth = depths ? depths.length : 0;\n  prog.blockParams = declaredBlockParams || 0;\n  return prog;\n}\n\nfunction resolvePartial(partial, context, options) {\n  if (!partial) {\n    if (options.name === '@partial-block') {\n      var data = options.data;\n      while (data['partial-block'] === noop) {\n        data = data._parent;\n      }\n      partial = data['partial-block'];\n      data['partial-block'] = noop;\n    } else {\n      partial = options.partials[options.name];\n    }\n  } else if (!partial.call && !options.name) {\n    // This is a dynamic partial that returned a string\n    options.name = partial;\n    partial = options.partials[partial];\n  }\n  return partial;\n}\n\nfunction invokePartial(partial, context, options) {\n  options.partial = true;\n  if (options.ids) {\n    options.data.contextPath = options.ids[0] || options.data.contextPath;\n  }\n\n  var partialBlock = undefined;\n  if (options.fn && options.fn !== noop) {\n    options.data = _base.createFrame(options.data);\n    partialBlock = options.data['partial-block'] = options.fn;\n\n    if (partialBlock.partials) {\n      options.partials = Utils.extend({}, options.partials, partialBlock.partials);\n    }\n  }\n\n  if (partial === undefined && partialBlock) {\n    partial = partialBlock;\n  }\n\n  if (partial === undefined) {\n    throw new _exception2['default']('The partial ' + options.name + ' could not be found');\n  } else if (partial instanceof Function) {\n    return partial(context, options);\n  }\n}\n\nfunction noop() {\n  return '';\n}\n\nfunction initData(context, data) {\n  if (!data || !('root' in data)) {\n    data = data ? _base.createFrame(data) : {};\n    data.root = context;\n  }\n  return data;\n}\n\nfunction executeDecorators(fn, prog, container, depths, data, blockParams) {\n  if (fn.decorator) {\n    var props = {};\n    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);\n    Utils.extend(prog, props);\n  }\n  return prog;\n}\n\n\n},{\"./base\":7,\"./exception\":20,\"./utils\":33}],32:[function(require,module,exports){\n// Build out our basic SafeString type\n'use strict';\n\nexports.__esModule = true;\nfunction SafeString(string) {\n  this.string = string;\n}\n\nSafeString.prototype.toString = SafeString.prototype.toHTML = function () {\n  return '' + this.string;\n};\n\nexports['default'] = SafeString;\nmodule.exports = exports['default'];\n\n\n},{}],33:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\nexports.extend = extend;\nexports.indexOf = indexOf;\nexports.escapeExpression = escapeExpression;\nexports.isEmpty = isEmpty;\nexports.createFrame = createFrame;\nexports.blockParams = blockParams;\nexports.appendContextPath = appendContextPath;\nvar escape = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#x27;',\n  '`': '&#x60;',\n  '=': '&#x3D;'\n};\n\nvar badChars = /[&<>\"'`=]/g,\n    possible = /[&<>\"'`=]/;\n\nfunction escapeChar(chr) {\n  return escape[chr];\n}\n\nfunction extend(obj /* , ...source */) {\n  for (var i = 1; i < arguments.length; i++) {\n    for (var key in arguments[i]) {\n      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {\n        obj[key] = arguments[i][key];\n      }\n    }\n  }\n\n  return obj;\n}\n\nvar toString = Object.prototype.toString;\n\nexports.toString = toString;\n// Sourced from lodash\n// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt\n/* eslint-disable func-style */\nvar isFunction = function isFunction(value) {\n  return typeof value === 'function';\n};\n// fallback for older versions of Chrome and Safari\n/* istanbul ignore next */\nif (isFunction(/x/)) {\n  exports.isFunction = isFunction = function (value) {\n    return typeof value === 'function' && toString.call(value) === '[object Function]';\n  };\n}\nexports.isFunction = isFunction;\n\n/* eslint-enable func-style */\n\n/* istanbul ignore next */\nvar isArray = Array.isArray || function (value) {\n  return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;\n};\n\nexports.isArray = isArray;\n// Older IE versions do not directly support indexOf so we must implement our own, sadly.\n\nfunction indexOf(array, value) {\n  for (var i = 0, len = array.length; i < len; i++) {\n    if (array[i] === value) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction escapeExpression(string) {\n  if (typeof string !== 'string') {\n    // don't escape SafeStrings, since they're already safe\n    if (string && string.toHTML) {\n      return string.toHTML();\n    } else if (string == null) {\n      return '';\n    } else if (!string) {\n      return string + '';\n    }\n\n    // Force a string conversion as this will be done by the append regardless and\n    // the regex test will do this transparently behind the scenes, causing issues if\n    // an object's to string has escaped characters in it.\n    string = '' + string;\n  }\n\n  if (!possible.test(string)) {\n    return string;\n  }\n  return string.replace(badChars, escapeChar);\n}\n\nfunction isEmpty(value) {\n  if (!value && value !== 0) {\n    return true;\n  } else if (isArray(value) && value.length === 0) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction createFrame(object) {\n  var frame = extend({}, object);\n  frame._parent = object;\n  return frame;\n}\n\nfunction blockParams(params, ids) {\n  params.path = ids;\n  return params;\n}\n\nfunction appendContextPath(contextPath, id) {\n  return (contextPath ? contextPath + '.' : '') + id;\n}\n\n\n},{}],34:[function(require,module,exports){\n// USAGE:\n// var handlebars = require('handlebars');\n/* eslint-disable no-var */\n\n// var local = handlebars.create();\n\nvar handlebars = require('../dist/cjs/handlebars')['default'];\n\nvar printer = require('../dist/cjs/handlebars/compiler/printer');\nhandlebars.PrintVisitor = printer.PrintVisitor;\nhandlebars.print = printer.print;\n\nmodule.exports = handlebars;\n\n// Publish a Node.js require() handler for .handlebars and .hbs files\nfunction extension(module, filename) {\n  var fs = require('fs');\n  var templateString = fs.readFileSync(filename, 'utf8');\n  module.exports = handlebars.compile(templateString);\n}\n/* istanbul ignore else */\nif (typeof require !== 'undefined' && require.extensions) {\n  require.extensions['.handlebars'] = extension;\n  require.extensions['.hbs'] = extension;\n}\n\n},{\"../dist/cjs/handlebars\":5,\"../dist/cjs/handlebars/compiler/printer\":15,\"fs\":63}],35:[function(require,module,exports){\n// Create a simple path alias to allow browserify to resolve\n// the runtime on a supported path.\nmodule.exports = require('./dist/cjs/handlebars.runtime')['default'];\n\n},{\"./dist/cjs/handlebars.runtime\":6}],36:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nrequire('whatwg-fetch');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nrequire('es6-promise').polyfill(); // needed for fetch\n\nvar Handlebars = require('handlebars');\n/**\n * Makes sure that a path is converted to an array.\n * @param paths\n * @returns {*}\n */\nvar ensurePathArray = function ensurePathArray(paths) {\n    if (!paths) {\n        paths = [];\n    } else if (typeof paths === 'string') {\n        paths = [paths];\n    }\n    return paths;\n};\n\n/**\n The Resource Manager.\n @class ResourceManager\n @description Represents a manager that loads any CSS and Javascript Resources on the fly.\n */\n\nvar ResourceManager = function () {\n\n    /**\n     * Upon initialization.\n     * @memberOf ResourceManager\n     */\n    function ResourceManager() {\n        _classCallCheck(this, ResourceManager);\n\n        this._head = document.getElementsByTagName('head')[0];\n        this._cssPaths = {};\n        this._scriptMaps = {};\n        this._dataPromises = {};\n    }\n\n    /**\n     * Loads a javascript file.\n     * @param {string|Array} paths - The path to the view's js file\n     * @memberOf ResourceManager\n     * @return {Promise} Returns a promise that resolves when all scripts have been loaded\n     */\n\n\n    _createClass(ResourceManager, [{\n        key: 'loadScript',\n        value: function loadScript(paths) {\n            var script,\n                map,\n                loadPromises = [];\n            paths = ensurePathArray(paths);\n            paths.forEach(function (path) {\n                map = this._scriptMaps[path] = this._scriptMaps[path] || {};\n                if (!map.promise) {\n                    map.path = path;\n                    map.promise = new Promise(function (resolve) {\n                        script = this.createScriptElement();\n                        script.setAttribute('type', 'text/javascript');\n                        script.src = path;\n                        script.addEventListener('load', resolve);\n                        this._head.appendChild(script);\n                    }.bind(this));\n                }\n                loadPromises.push(map.promise);\n            }.bind(this));\n            return Promise.all(loadPromises);\n        }\n\n        /**\n         * Removes a script that has the specified path from the head of the document.\n         * @param {string|Array} paths - The paths of the scripts to unload\n         * @memberOf ResourceManager\n         */\n\n    }, {\n        key: 'unloadScript',\n        value: function unloadScript(paths) {\n            var file;\n            return new Promise(function (resolve) {\n                paths = ensurePathArray(paths);\n                paths.forEach(function (path) {\n                    file = this._head.querySelectorAll('script[src=\"' + path + '\"]')[0];\n                    if (file) {\n                        this._head.removeChild(file);\n                        delete this._scriptMaps[path];\n                    }\n                }.bind(this));\n                resolve();\n            }.bind(this));\n        }\n\n        /**\n         * Creates a new script element.\n         * @returns {HTMLElement}\n         */\n\n    }, {\n        key: 'createScriptElement',\n        value: function createScriptElement() {\n            return document.createElement('script');\n        }\n\n        /**\n         * Makes a request to get data and caches it.\n         * @param {string} url - The url to fetch data from\n         * @param [reqOptions] - options to be passed to fetch call\n         * @returns {*}\n         */\n\n    }, {\n        key: 'fetchData',\n        value: function fetchData(url) {\n            var _this = this;\n\n            var reqOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            var cacheId = url + JSON.stringify(reqOptions);\n\n            reqOptions.cache = reqOptions.cache === undefined ? true : reqOptions.cache;\n\n            if (!url) {\n                return Promise.resolve();\n            }\n            if (!this._dataPromises[cacheId] || !reqOptions.cache) {\n                this._dataPromises[cacheId] = fetch(url, reqOptions).catch(function (e) {\n                    // if failure, remove cache so that subsequent\n                    // requests will trigger new ajax call\n                    _this._dataPromises[cacheId] = null;\n                    throw e;\n                });\n            }\n            return this._dataPromises[cacheId];\n        }\n\n        /**\n         * Loads css files.\n         * @param {Array|String} paths - An array of css paths files to load\n         * @memberOf ResourceManager\n         * @return {Promise}\n         */\n\n    }, {\n        key: 'loadCss',\n        value: function loadCss(paths) {\n            return new Promise(function (resolve) {\n                paths = ensurePathArray(paths);\n                paths.forEach(function (path) {\n                    // TODO: figure out a way to find out when css is guaranteed to be loaded,\n                    // and make this return a truely asynchronous promise\n                    if (!this._cssPaths[path]) {\n                        var el = document.createElement('link');\n                        el.setAttribute('rel', 'stylesheet');\n                        el.setAttribute('href', path);\n                        this._head.appendChild(el);\n                        this._cssPaths[path] = el;\n                    }\n                }.bind(this));\n                resolve();\n            }.bind(this));\n        }\n\n        /**\n         * Unloads css paths.\n         * @param {string|Array} paths - The css paths to unload\n         * @memberOf ResourceManager\n         * @return {Promise}\n         */\n\n    }, {\n        key: 'unloadCss',\n        value: function unloadCss(paths) {\n            var el;\n            return new Promise(function (resolve) {\n                paths = ensurePathArray(paths);\n                paths.forEach(function (path) {\n                    el = this._cssPaths[path];\n                    if (el) {\n                        this._head.removeChild(el);\n                        this._cssPaths[path] = null;\n                    }\n                }.bind(this));\n                resolve();\n            }.bind(this));\n        }\n\n        /**\n         * Parses a template into a DOM element, then returns element back to you.\n         * @param {string} path - The path to the template\n         * @param {HTMLElement} [el] - The element to attach template to\n         * @param {Object|Array} [hbsData] - The data to use for the handlebar template (if applicable)\n         * @returns {Promise} Returns a promise that resolves with contents of template file\n         */\n\n    }, {\n        key: 'loadTemplate',\n        value: function loadTemplate(path, el, hbsData) {\n\n            var isHandlebarFile = function isHandlebarFile(filePath) {\n                if (filePath) {\n                    var frags = filePath.split('.');\n                    var ext = frags[frags.length - 1];\n                    return ext === 'hbs';\n                }\n            };\n\n            if (!path) {\n                return Promise.resolve();\n            }\n\n            return fetch(path).then(function (resp) {\n                return resp.text().then(function (contents) {\n                    if (isHandlebarFile(path)) {\n                        contents = Handlebars.compile(contents)(hbsData || {});\n                    }\n                    if (el) {\n                        el.innerHTML = contents;\n                        contents = el;\n                    }\n                    return contents;\n                });\n            });\n        }\n\n        /**\n         * Removes all cached resources.\n         * @memberOf ResourceManager\n         */\n\n    }, {\n        key: 'flush',\n        value: function flush() {\n            this.unloadCss(Object.getOwnPropertyNames(this._cssPaths));\n            this._cssPaths = {};\n            for (var s in this._scriptMaps) {\n                if (this._scriptMaps.hasOwnProperty(s)) {\n                    var map = this._scriptMaps[s];\n                    this.unloadScript(map.path);\n                }\n            }\n            this._scriptMaps = {};\n            this._dataPromises = {};\n        }\n    }]);\n\n    return ResourceManager;\n}();\n\nexports.default = new ResourceManager();\n\n},{\"es6-promise\":4,\"handlebars\":34,\"whatwg-fetch\":57}],37:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _resourceManagerJs = require('resource-manager-js');\n\nvar _resourceManagerJs2 = _interopRequireDefault(_resourceManagerJs);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Promise = require('es6-promise').Promise;\nvar runtime = require('handlebars/runtime');\n\n/**\n * Takes a value and separates the number and unit into a key/value map.\n * @param v - The value\n * @returns {{num: Number, unit: string}} Returns the map\n * @private\n */\nvar getCssPropUnitMap = function getCssPropUnitMap(v) {\n    v.trim();\n    var num = v.match('[0-9\\.]+'),\n        unit = 'ms';\n\n    num = num ? num[0] : '';\n    if (num) {\n        unit = v.split(num)[1];\n        num = Number(num);\n    }\n    return {\n        num: num,\n        unit: unit\n    };\n};\n\n/**\n * Converts a css timing unit value into milliseconds.\n * @param {string} val - The value string\n * @returns {string} Returns the timing unit value in milliseconds\n */\nvar convertCssTimeValueToMilliseconds = function convertCssTimeValueToMilliseconds(val) {\n    var number = getCssPropUnitMap(val).num,\n        unit = val.replace(number, '');\n    if (unit === 's') {\n        val = number * 1000;\n    } else {\n        val = number;\n    }\n    return val + 'ms';\n};\n\n/**\n * Takes a css property name and returns the javascript version of it.\n * @param {string} cssProp - The css property\n * @returns {string} Returns the javascript version\n * @private\n */\nvar getJsPropName = function getJsPropName(cssProp) {\n    // convert to camelCase\n    return cssProp.replace(/-([a-z])/g, function (letter) {\n        return letter[1].toUpperCase();\n    });\n};\n\n/**\n * Bubbles up each parent node of the element, triggering the callback on each element until traversal\n * either runs out of parent nodes, reaches the document element, or if callback returns a falsy value\n * @param {Function} callback - A callback that fires which gets passed the current element\n * @param {HTMLElement} [startEl] - The element where traversal will begin (including the passed element), defaults to current el\n */\nvar traverseEachParent = function traverseEachParent(callback, startEl) {\n    var parentNode = startEl;\n    var predicate = null;\n    // check if the node has classname property, if not, we know we're at the #document element\n    while (parentNode && typeof parentNode.className === 'string') {\n        predicate = callback(parentNode);\n        if (predicate !== undefined && !predicate) {\n            break;\n        }\n        parentNode = parentNode.parentNode;\n    }\n};\n\n/**\n * A function that fires when the module's load() method is called\n * @callback Module~onLoad\n * @return {*} May return a promise when done\n */\n\n/**\n * A function that fires when the module's show() method is called\n * which can be overridden by subclass custom implementations.\n * @callback Module~onShow\n * @return {*} May return a promise when done\n */\n\n/**\n * A function that fires when the module's hide() method is called\n * which can be overridden by subclass custom implementations.\n * @callback Module~onHide\n */\n\n/**\n * A function that fires when the module's enable() method is called\n * @callback Module~onEnable\n */\n\n/**\n * A function that fires when the module's disable() method is called\n * @callback Module~onDisable\n */\n\n/**\n * A function that fires when the error() method is called\n * @callback Module~onError\n * @param {Object} [e] - The error object that was triggered\n */\n\n/**\n * @class Module\n * @description Base class that represents all modules of an App.\n */\n\nvar Module = function () {\n\n    /**\n     * Initialization.\n     * @param {HTMLElement} el - The module element\n     * @param {Object} [options] - An object of options\n     * @param {string} [options.loadedClass] - The class that will be applied to the module element when it is loaded\n     * @param {string} [options.activeClass] - The class that will be applied to the module element when it is shown\n     * @param {string} [options.disabledClass] - The class that will be applied to the module element when disabled\n     * @param {string} [options.errorClass] - The class that will be applied to the module element when it has a load error\n     * @param {Array|string} [options.styles] - Array of stylesheet urls or single url\n     * @param {string|HTMLTemplateElement|HTMLElement} [options.template] - The template to load (can be url to html or handlebars file or html template, just an element, or an html string)\n     * @param {Object|string} [options.data] - The data or url to the module's data\n     * @param {Object} [options.requestOptions] - The request options to use when running the fetch method to get data\n     * @param {Module~onLoad} [options.onLoad] - A function that fires when module's load() method is called\n     * @param {Module~onShow} [options.onShow] - A function that fires when module is shown\n     * @param {Module~onHide} [options.onHide] - A function that fires when module is hidden\n     * @param {Module~onEnable} [options.onEnable] - A function that fires when module is enabled\n     * @param {Module~onDisable} [options.onDisable] - A function that fires when module is disabled\n     * @param {Module~onError} [options.onError] - A function that fires when module goes into error state\n     * @param {Object} [options.helpers] - An object containing a mapping of handlebar helper ids (keys) to their functions (values) to use when handlebar compiling\n     */\n    function Module(el, options) {\n        _classCallCheck(this, Module);\n\n        options = options || {};\n\n        if (!el) {\n            console.error(\"Module error: No element was passed to constructor\");\n        }\n\n        this.el = el;\n\n        var defaultOptions = {\n            loadedClass: 'module-loaded',\n            activeClass: 'module-active',\n            disabledClass: 'module-disabled',\n            errorClass: 'module-error',\n            styles: [],\n            template: \"\",\n            data: null,\n            requestOptions: null,\n            onLoad: function onLoad() {},\n            onShow: function onShow() {},\n            onHide: function onHide() {},\n            onEnable: function onEnable() {},\n            onDisable: function onDisable() {},\n            onError: function onError() {},\n            helpers: {}\n        };\n\n        // we are adding default options to passed custom options\n        // to ensure all expected options exist when instantiating sub classes\n        for (var name in defaultOptions) {\n            if (defaultOptions.hasOwnProperty(name)) {\n                if (!options[name]) {\n                    options[name] = defaultOptions[name];\n                }\n            }\n        }\n\n        this.options = options;\n\n        // setup helpers\n        for (var _name in options.helpers) {\n            if (options.helpers.hasOwnProperty(_name)) {\n                runtime.registerHelper(_name, options.helpers[_name]);\n            }\n        }\n\n        this._handleElementInitialState();\n\n        this.subModules = {};\n        this.active = false;\n        this.loaded = false;\n        this._elChildren = [];\n        this.loadStatus = 'notLoaded';\n    }\n\n    /**\n     * Loads the module's styles, template, and data and applies loaded css classes and state.\n     * @return {Promise}\n     */\n\n\n    _createClass(Module, [{\n        key: 'load',\n        value: function load() {\n            var _this = this;\n\n            if (!this.loaded) {\n                this.loadStatus = 'loading';\n                // load all subModules\n                var loadPromises = [];\n                for (var key in this.subModules) {\n                    if (this.subModules.hasOwnProperty(key)) {\n                        var view = this.subModules[key];\n                        loadPromises.push(view.load());\n                    }\n                }\n                return Promise.all(loadPromises).then(function () {\n                    return _this.getStyles(_this.options.styles).then(function () {\n                        return _this.fetchData(_this.options.data, _this.options.requestOptions).then(function (data) {\n                            return _this.getTemplate(data).then(function (nodes) {\n                                nodes = nodes || [];\n                                var frag = document.createDocumentFragment();\n                                // hold reference to children to remove them later\n                                while (nodes.length) {\n                                    // order matters here so we always start from the first node\n                                    var node = nodes[0];\n                                    _this._elChildren.push(node);\n                                    // appending child changes length of nodes array\n                                    frag.appendChild(node);\n                                }\n                                _this.el.appendChild(frag);\n                                _this.loaded = true;\n                                _this.loadStatus = 'loaded';\n                                if (_this.el) {\n                                    _this.el.classList.add(_this.options.loadedClass);\n                                }\n                                _this.options.onLoad();\n                            });\n                        });\n                    });\n                }).catch(function (e) {\n                    _this.error(e);\n                    // throw error to reject promise\n                    throw e;\n                });\n            } else {\n                return Promise.resolve();\n            }\n        }\n\n        /**\n         * Makes a request to get the data for the module.\n         * @param {string|Object} url - The url to fetch data from or data object\n         * @param [options] - fetch options\n         * @returns {*}\n         */\n\n    }, {\n        key: 'fetchData',\n        value: function fetchData(url, options) {\n            if (typeof url !== 'string') {\n                return Promise.resolve(url);\n            }\n            return _resourceManagerJs2.default.fetchData(url, options);\n        }\n\n        /**\n         * Gets the css files for the module.\n         * @param cssUrl\n         * @return {Promise}\n         */\n\n    }, {\n        key: 'getStyles',\n        value: function getStyles(cssUrl) {\n            return _resourceManagerJs2.default.loadCss(cssUrl);\n        }\n\n        /**\n         * Gets the html template for the module.\n         * @param {Object} [data] - The data to inject (if template is a handlebar file)\n         * @returns {Promise} Returns a document fragment containing the contents of the template with the data injected\n         */\n\n    }, {\n        key: 'getTemplate',\n        value: function getTemplate(data) {\n            var template = this.options.template || '';\n\n            if (!template) {\n                return Promise.resolve();\n            }\n\n            var isHandlebarFile = function isHandlebarFile(filePath) {\n                if (filePath) {\n                    var frags = filePath.split('.');\n                    var ext = frags[frags.length - 1];\n                    return ext === 'hbs';\n                }\n            };\n\n            if (this._isHTMLTemplate(template)) {\n                // template element\n                // TODO: update to accommodate situations where the user wants to adoptNode instead of cloning it\n                var tpl = document.importNode(template.content, true);\n                return Promise.resolve(tpl.childNodes);\n            } else if (template instanceof HTMLElement) {\n                // already an html element\n                var frag = document.createDocumentFragment();\n                frag.appendChild(template);\n                return Promise.resolve(frag.childNodes);\n            } else {\n                var _ret = function () {\n                    // html or handlebar file\n                    var tempDiv = document.createElement('div');\n                    return {\n                        v: _resourceManagerJs2.default.loadTemplate(template, tempDiv, data).then(function (html) {\n                            return tempDiv.childNodes;\n                        })\n                    };\n                }();\n\n                if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n            }\n        }\n\n        /**\n         * Checks if the provided template argument is indeed an html template element.\n         * This is mainly for testing purposes where phantom is not aware of HTMLTemplateElement\n         * @param template\n         * @returns {boolean}\n         * @private\n         */\n\n    }, {\n        key: '_isHTMLTemplate',\n        value: function _isHTMLTemplate(template) {\n            return template instanceof HTMLTemplateElement;\n        }\n\n        /**\n         * Triggers a load error on the module.\n         * @param {Object} [err] - The error object to trigger\n         * @return {Promise} Returns a promise when erroring operation is complete\n         */\n\n    }, {\n        key: 'error',\n        value: function error(err) {\n            var e = err || new Error();\n\n            this.el.classList.add(this.options.errorClass);\n\n            this.errored = true;\n            this.loaded = false;\n            this.loadStatus = 'notLoaded';\n\n            this.options.onError(e);\n            return this.waitForTransition().then(function () {\n                return e;\n            });\n        }\n\n        /**\n         * Enables the module.\n         * @return {Promise}\n         */\n\n    }, {\n        key: 'enable',\n        value: function enable() {\n            var el = this.el;\n            if (el) {\n                el.classList.remove(this.options.disabledClass);\n            }\n            this.disabled = false;\n            this.options.onEnable();\n            return this.waitForTransition();\n        }\n\n        /**\n         * Disables the module.\n         * @return {Promise}\n         */\n\n    }, {\n        key: 'disable',\n        value: function disable() {\n            var el = this.el;\n            if (el) {\n                el.classList.add(this.options.disabledClass);\n            }\n            this.disabled = true;\n\n            this.options.onDisable();\n            return this.waitForTransition();\n        }\n\n        /**\n         * Shows the module.\n         * @return {Promise}\n         */\n\n    }, {\n        key: 'show',\n        value: function show() {\n            var el = this.el;\n            if (el) {\n                el.classList.add(this.options.activeClass);\n            }\n            this.active = true;\n            this.options.onShow();\n            return this.waitForTransition();\n        }\n\n        /**\n         * Hides the module.\n         * @return {Promise}\n         */\n\n    }, {\n        key: 'hide',\n        value: function hide() {\n            var el = this.el;\n            if (el) {\n                el.classList.remove(this.options.activeClass);\n            }\n            this.active = false;\n            this.options.onHide();\n            return this.waitForTransition();\n        }\n\n        /**\n         * Sets up element internally by evaluating its initial state.\n         * @private\n         */\n\n    }, {\n        key: '_handleElementInitialState',\n        value: function _handleElementInitialState() {\n            var el = this.el;\n            if (!el) {\n                return;\n            }\n            if (el.classList.contains(this.options.disabledClass)) {\n                this._origDisabled = true;\n                this.disable();\n            }\n\n            if (el.classList.contains(this.options.errorClass)) {\n                this._origError = true;\n                this.error(new Error());\n            }\n        }\n\n        /**\n         * Restores the elements classes back to the way they were before instantiation.\n         * @private\n         */\n\n    }, {\n        key: '_resetElementInitialState',\n        value: function _resetElementInitialState() {\n            var options = this.options,\n                disabledClass = options.disabledClass,\n                errorClass = options.errorClass;\n\n            if (!this.el) {\n                return;\n            }\n            if (this._origDisabled) {\n                this.el.classList.add(disabledClass);\n            } else {\n                this.el.classList.remove(disabledClass);\n            }\n\n            if (!this._origError) {\n                this.el.classList.remove(errorClass);\n            } else {\n                this.el.classList.add(errorClass);\n            }\n        }\n\n        /**\n         * Builds a transition promise that waits to resolve until the module el's CSS transition is completed (if applicable).\n         * @returns {Promise} Returns a promise that resolves when the element has finished animating\n         */\n\n    }, {\n        key: 'waitForTransition',\n        value: function waitForTransition() {\n            var _this2 = this;\n\n            var duration = this.getTransitionDuration();\n            return new Promise(function (resolve) {\n                if (duration > 0) {\n                    setTimeout(resolve.bind(_this2, _this2.el), duration);\n                } else {\n                    resolve(_this2.el);\n                }\n            });\n        }\n\n        /**\n         * Gets the time is takes for the element to transition to its show state.\n         * @returns {Number} Returns the total CSS transition time in milliseconds\n         */\n\n    }, {\n        key: 'getTransitionDuration',\n        value: function getTransitionDuration() {\n            var delayProp = this.getCssComputedProperty('transition-delay') || '0ms',\n                durationProp = this.getCssComputedProperty('transition-duration') || '0ms',\n                times = Array.isArray(durationProp) ? durationProp : [durationProp],\n                delay = Array.isArray(delayProp) ? delayProp : [delayProp],\n                highest = 0,\n                map;\n\n            times.push.apply(times, delay); // account for delay\n\n            // calculate highest number of time\n            times.forEach(function (value) {\n                value.split(',').forEach(function (v) {\n                    v = convertCssTimeValueToMilliseconds(v);\n                    map = getCssPropUnitMap(v);\n                    if (map.num > highest) {\n                        highest = map.num;\n                    }\n                });\n            });\n\n            return highest;\n        }\n\n        /**\n         * Gets the computed property of the element.\n         * @param {string} prop - The name of the property to get\n         * @returns {string} Returns the value of the property\n         */\n\n    }, {\n        key: 'getCssComputedProperty',\n        value: function getCssComputedProperty(prop) {\n            var style = window.getComputedStyle(this.el);\n            return style.getPropertyValue(prop) || this.el.style[getJsPropName(prop)];\n        }\n\n        /**\n         * Gets the closest ancestor element that has a css class.\n         * @param {string} className - The class name that the ancestor must have to match\n         * @param {Element} startTarget - The element the method should start from\n         */\n\n    }, {\n        key: 'getClosestAncestorElementByClassName',\n        value: function getClosestAncestorElementByClassName(className, startTarget) {\n            var result = null;\n            traverseEachParent(function (parent) {\n                if (parent.classList.contains(className)) {\n                    result = parent;\n                    return false;\n                }\n            }, startTarget || this.el.parentNode || this.el);\n            return result;\n        }\n\n        /**\n         * Destroys all nested views and cleans up.\n         */\n\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            var _this3 = this;\n\n            var subModules = this.subModules;\n\n            for (var key in subModules) {\n                if (subModules.hasOwnProperty(key) && subModules[key]) {\n                    subModules[key].destroy();\n                }\n            }\n            this.subModules = {};\n            this.active = false;\n            this.loaded = false;\n            this.errored = false;\n            this.loadStatus = 'notLoaded';\n\n            this.el.classList.remove(this.options.loadedClass);\n            this.el.classList.remove(this.options.activeClass);\n\n            this._resetElementInitialState();\n\n            this._elChildren.forEach(function (el) {\n                if (_this3.el.contains(el)) {\n                    _this3.el.removeChild(el);\n                }\n            });\n            this._elChildren = [];\n        }\n    }]);\n\n    return Module;\n}();\n\nexports.default = Module;\n\n},{\"es6-promise\":4,\"handlebars/runtime\":35,\"resource-manager-js\":36}],38:[function(require,module,exports){\n'use strict';\n\nmodule.exports = require('./lib')\n\n},{\"./lib\":43}],39:[function(require,module,exports){\n'use strict';\n\nvar asap = require('asap/raw');\n\nfunction noop() {}\n\n// States:\n//\n// 0 - pending\n// 1 - fulfilled with _value\n// 2 - rejected with _value\n// 3 - adopted the state of another promise, _value\n//\n// once the state is no longer pending (0) it is immutable\n\n// All `_` prefixed properties will be reduced to `_{random number}`\n// at build time to obfuscate them and discourage their use.\n// We don't use symbols or Object.defineProperty to fully hide them\n// because the performance isn't good enough.\n\n\n// to avoid using try/catch inside critical functions, we\n// extract them to here.\nvar LAST_ERROR = null;\nvar IS_ERROR = {};\nfunction getThen(obj) {\n  try {\n    return obj.then;\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nfunction tryCallOne(fn, a) {\n  try {\n    return fn(a);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\nfunction tryCallTwo(fn, a, b) {\n  try {\n    fn(a, b);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nmodule.exports = Promise;\n\nfunction Promise(fn) {\n  if (typeof this !== 'object') {\n    throw new TypeError('Promises must be constructed via new');\n  }\n  if (typeof fn !== 'function') {\n    throw new TypeError('not a function');\n  }\n  this._45 = 0;\n  this._81 = 0;\n  this._65 = null;\n  this._54 = null;\n  if (fn === noop) return;\n  doResolve(fn, this);\n}\nPromise._10 = null;\nPromise._97 = null;\nPromise._61 = noop;\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  if (this.constructor !== Promise) {\n    return safeThen(this, onFulfilled, onRejected);\n  }\n  var res = new Promise(noop);\n  handle(this, new Handler(onFulfilled, onRejected, res));\n  return res;\n};\n\nfunction safeThen(self, onFulfilled, onRejected) {\n  return new self.constructor(function (resolve, reject) {\n    var res = new Promise(noop);\n    res.then(resolve, reject);\n    handle(self, new Handler(onFulfilled, onRejected, res));\n  });\n};\nfunction handle(self, deferred) {\n  while (self._81 === 3) {\n    self = self._65;\n  }\n  if (Promise._10) {\n    Promise._10(self);\n  }\n  if (self._81 === 0) {\n    if (self._45 === 0) {\n      self._45 = 1;\n      self._54 = deferred;\n      return;\n    }\n    if (self._45 === 1) {\n      self._45 = 2;\n      self._54 = [self._54, deferred];\n      return;\n    }\n    self._54.push(deferred);\n    return;\n  }\n  handleResolved(self, deferred);\n}\n\nfunction handleResolved(self, deferred) {\n  asap(function() {\n    var cb = self._81 === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      if (self._81 === 1) {\n        resolve(deferred.promise, self._65);\n      } else {\n        reject(deferred.promise, self._65);\n      }\n      return;\n    }\n    var ret = tryCallOne(cb, self._65);\n    if (ret === IS_ERROR) {\n      reject(deferred.promise, LAST_ERROR);\n    } else {\n      resolve(deferred.promise, ret);\n    }\n  });\n}\nfunction resolve(self, newValue) {\n  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n  if (newValue === self) {\n    return reject(\n      self,\n      new TypeError('A promise cannot be resolved with itself.')\n    );\n  }\n  if (\n    newValue &&\n    (typeof newValue === 'object' || typeof newValue === 'function')\n  ) {\n    var then = getThen(newValue);\n    if (then === IS_ERROR) {\n      return reject(self, LAST_ERROR);\n    }\n    if (\n      then === self.then &&\n      newValue instanceof Promise\n    ) {\n      self._81 = 3;\n      self._65 = newValue;\n      finale(self);\n      return;\n    } else if (typeof then === 'function') {\n      doResolve(then.bind(newValue), self);\n      return;\n    }\n  }\n  self._81 = 1;\n  self._65 = newValue;\n  finale(self);\n}\n\nfunction reject(self, newValue) {\n  self._81 = 2;\n  self._65 = newValue;\n  if (Promise._97) {\n    Promise._97(self, newValue);\n  }\n  finale(self);\n}\nfunction finale(self) {\n  if (self._45 === 1) {\n    handle(self, self._54);\n    self._54 = null;\n  }\n  if (self._45 === 2) {\n    for (var i = 0; i < self._54.length; i++) {\n      handle(self, self._54[i]);\n    }\n    self._54 = null;\n  }\n}\n\nfunction Handler(onFulfilled, onRejected, promise){\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, promise) {\n  var done = false;\n  var res = tryCallTwo(fn, function (value) {\n    if (done) return;\n    done = true;\n    resolve(promise, value);\n  }, function (reason) {\n    if (done) return;\n    done = true;\n    reject(promise, reason);\n  })\n  if (!done && res === IS_ERROR) {\n    done = true;\n    reject(promise, LAST_ERROR);\n  }\n}\n\n},{\"asap/raw\":3}],40:[function(require,module,exports){\n'use strict';\n\nvar Promise = require('./core.js');\n\nmodule.exports = Promise;\nPromise.prototype.done = function (onFulfilled, onRejected) {\n  var self = arguments.length ? this.then.apply(this, arguments) : this;\n  self.then(null, function (err) {\n    setTimeout(function () {\n      throw err;\n    }, 0);\n  });\n};\n\n},{\"./core.js\":39}],41:[function(require,module,exports){\n'use strict';\n\n//This file contains the ES6 extensions to the core Promises/A+ API\n\nvar Promise = require('./core.js');\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nvar TRUE = valuePromise(true);\nvar FALSE = valuePromise(false);\nvar NULL = valuePromise(null);\nvar UNDEFINED = valuePromise(undefined);\nvar ZERO = valuePromise(0);\nvar EMPTYSTRING = valuePromise('');\n\nfunction valuePromise(value) {\n  var p = new Promise(Promise._61);\n  p._81 = 1;\n  p._65 = value;\n  return p;\n}\nPromise.resolve = function (value) {\n  if (value instanceof Promise) return value;\n\n  if (value === null) return NULL;\n  if (value === undefined) return UNDEFINED;\n  if (value === true) return TRUE;\n  if (value === false) return FALSE;\n  if (value === 0) return ZERO;\n  if (value === '') return EMPTYSTRING;\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    try {\n      var then = value.then;\n      if (typeof then === 'function') {\n        return new Promise(then.bind(value));\n      }\n    } catch (ex) {\n      return new Promise(function (resolve, reject) {\n        reject(ex);\n      });\n    }\n  }\n  return valuePromise(value);\n};\n\nPromise.all = function (arr) {\n  var args = Array.prototype.slice.call(arr);\n\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n    function res(i, val) {\n      if (val && (typeof val === 'object' || typeof val === 'function')) {\n        if (val instanceof Promise && val.then === Promise.prototype.then) {\n          while (val._81 === 3) {\n            val = val._65;\n          }\n          if (val._81 === 1) return res(i, val._65);\n          if (val._81 === 2) reject(val._65);\n          val.then(function (val) {\n            res(i, val);\n          }, reject);\n          return;\n        } else {\n          var then = val.then;\n          if (typeof then === 'function') {\n            var p = new Promise(then.bind(val));\n            p.then(function (val) {\n              res(i, val);\n            }, reject);\n            return;\n          }\n        }\n      }\n      args[i] = val;\n      if (--remaining === 0) {\n        resolve(args);\n      }\n    }\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) {\n    values.forEach(function(value){\n      Promise.resolve(value).then(resolve, reject);\n    });\n  });\n};\n\n/* Prototype Methods */\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n\n},{\"./core.js\":39}],42:[function(require,module,exports){\n'use strict';\n\nvar Promise = require('./core.js');\n\nmodule.exports = Promise;\nPromise.prototype['finally'] = function (f) {\n  return this.then(function (value) {\n    return Promise.resolve(f()).then(function () {\n      return value;\n    });\n  }, function (err) {\n    return Promise.resolve(f()).then(function () {\n      throw err;\n    });\n  });\n};\n\n},{\"./core.js\":39}],43:[function(require,module,exports){\n'use strict';\n\nmodule.exports = require('./core.js');\nrequire('./done.js');\nrequire('./finally.js');\nrequire('./es6-extensions.js');\nrequire('./node-extensions.js');\nrequire('./synchronous.js');\n\n},{\"./core.js\":39,\"./done.js\":40,\"./es6-extensions.js\":41,\"./finally.js\":42,\"./node-extensions.js\":44,\"./synchronous.js\":45}],44:[function(require,module,exports){\n'use strict';\n\n// This file contains then/promise specific extensions that are only useful\n// for node.js interop\n\nvar Promise = require('./core.js');\nvar asap = require('asap');\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nPromise.denodeify = function (fn, argumentCount) {\n  if (\n    typeof argumentCount === 'number' && argumentCount !== Infinity\n  ) {\n    return denodeifyWithCount(fn, argumentCount);\n  } else {\n    return denodeifyWithoutCount(fn);\n  }\n}\n\nvar callbackFn = (\n  'function (err, res) {' +\n  'if (err) { rj(err); } else { rs(res); }' +\n  '}'\n);\nfunction denodeifyWithCount(fn, argumentCount) {\n  var args = [];\n  for (var i = 0; i < argumentCount; i++) {\n    args.push('a' + i);\n  }\n  var body = [\n    'return function (' + args.join(',') + ') {',\n    'var self = this;',\n    'return new Promise(function (rs, rj) {',\n    'var res = fn.call(',\n    ['self'].concat(args).concat([callbackFn]).join(','),\n    ');',\n    'if (res &&',\n    '(typeof res === \"object\" || typeof res === \"function\") &&',\n    'typeof res.then === \"function\"',\n    ') {rs(res);}',\n    '});',\n    '};'\n  ].join('');\n  return Function(['Promise', 'fn'], body)(Promise, fn);\n}\nfunction denodeifyWithoutCount(fn) {\n  var fnLength = Math.max(fn.length - 1, 3);\n  var args = [];\n  for (var i = 0; i < fnLength; i++) {\n    args.push('a' + i);\n  }\n  var body = [\n    'return function (' + args.join(',') + ') {',\n    'var self = this;',\n    'var args;',\n    'var argLength = arguments.length;',\n    'if (arguments.length > ' + fnLength + ') {',\n    'args = new Array(arguments.length + 1);',\n    'for (var i = 0; i < arguments.length; i++) {',\n    'args[i] = arguments[i];',\n    '}',\n    '}',\n    'return new Promise(function (rs, rj) {',\n    'var cb = ' + callbackFn + ';',\n    'var res;',\n    'switch (argLength) {',\n    args.concat(['extra']).map(function (_, index) {\n      return (\n        'case ' + (index) + ':' +\n        'res = fn.call(' + ['self'].concat(args.slice(0, index)).concat('cb').join(',') + ');' +\n        'break;'\n      );\n    }).join(''),\n    'default:',\n    'args[argLength] = cb;',\n    'res = fn.apply(self, args);',\n    '}',\n    \n    'if (res &&',\n    '(typeof res === \"object\" || typeof res === \"function\") &&',\n    'typeof res.then === \"function\"',\n    ') {rs(res);}',\n    '});',\n    '};'\n  ].join('');\n\n  return Function(\n    ['Promise', 'fn'],\n    body\n  )(Promise, fn);\n}\n\nPromise.nodeify = function (fn) {\n  return function () {\n    var args = Array.prototype.slice.call(arguments);\n    var callback =\n      typeof args[args.length - 1] === 'function' ? args.pop() : null;\n    var ctx = this;\n    try {\n      return fn.apply(this, arguments).nodeify(callback, ctx);\n    } catch (ex) {\n      if (callback === null || typeof callback == 'undefined') {\n        return new Promise(function (resolve, reject) {\n          reject(ex);\n        });\n      } else {\n        asap(function () {\n          callback.call(ctx, ex);\n        })\n      }\n    }\n  }\n}\n\nPromise.prototype.nodeify = function (callback, ctx) {\n  if (typeof callback != 'function') return this;\n\n  this.then(function (value) {\n    asap(function () {\n      callback.call(ctx, null, value);\n    });\n  }, function (err) {\n    asap(function () {\n      callback.call(ctx, err);\n    });\n  });\n}\n\n},{\"./core.js\":39,\"asap\":2}],45:[function(require,module,exports){\n'use strict';\n\nvar Promise = require('./core.js');\n\nmodule.exports = Promise;\nPromise.enableSynchronous = function () {\n  Promise.prototype.isPending = function() {\n    return this.getState() == 0;\n  };\n\n  Promise.prototype.isFulfilled = function() {\n    return this.getState() == 1;\n  };\n\n  Promise.prototype.isRejected = function() {\n    return this.getState() == 2;\n  };\n\n  Promise.prototype.getValue = function () {\n    if (this._81 === 3) {\n      return this._65.getValue();\n    }\n\n    if (!this.isFulfilled()) {\n      throw new Error('Cannot get a value of an unfulfilled promise.');\n    }\n\n    return this._65;\n  };\n\n  Promise.prototype.getReason = function () {\n    if (this._81 === 3) {\n      return this._65.getReason();\n    }\n\n    if (!this.isRejected()) {\n      throw new Error('Cannot get a rejection reason of a non-rejected promise.');\n    }\n\n    return this._65;\n  };\n\n  Promise.prototype.getState = function () {\n    if (this._81 === 3) {\n      return this._65.getState();\n    }\n    if (this._81 === -1 || this._81 === -2) {\n      return 0;\n    }\n\n    return this._81;\n  };\n};\n\nPromise.disableSynchronous = function() {\n  Promise.prototype.isPending = undefined;\n  Promise.prototype.isFulfilled = undefined;\n  Promise.prototype.isRejected = undefined;\n  Promise.prototype.getValue = undefined;\n  Promise.prototype.getReason = undefined;\n  Promise.prototype.getState = undefined;\n};\n\n},{\"./core.js\":39}],46:[function(require,module,exports){\n/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nexports.SourceMapGenerator = require('./source-map/source-map-generator').SourceMapGenerator;\nexports.SourceMapConsumer = require('./source-map/source-map-consumer').SourceMapConsumer;\nexports.SourceNode = require('./source-map/source-node').SourceNode;\n\n},{\"./source-map/source-map-consumer\":53,\"./source-map/source-map-generator\":54,\"./source-map/source-node\":55}],47:[function(require,module,exports){\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n}\ndefine(function (require, exports, module) {\n\n  var util = require('./util');\n\n  /**\n   * A data structure which is a combination of an array and a set. Adding a new\n   * member is O(1), testing for membership is O(1), and finding the index of an\n   * element is O(1). Removing elements from the set is not supported. Only\n   * strings are supported for membership.\n   */\n  function ArraySet() {\n    this._array = [];\n    this._set = {};\n  }\n\n  /**\n   * Static method for creating ArraySet instances from an existing array.\n   */\n  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n    var set = new ArraySet();\n    for (var i = 0, len = aArray.length; i < len; i++) {\n      set.add(aArray[i], aAllowDuplicates);\n    }\n    return set;\n  };\n\n  /**\n   * Return how many unique items are in this ArraySet. If duplicates have been\n   * added, than those do not count towards the size.\n   *\n   * @returns Number\n   */\n  ArraySet.prototype.size = function ArraySet_size() {\n    return Object.getOwnPropertyNames(this._set).length;\n  };\n\n  /**\n   * Add the given string to this set.\n   *\n   * @param String aStr\n   */\n  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n    var isDuplicate = this.has(aStr);\n    var idx = this._array.length;\n    if (!isDuplicate || aAllowDuplicates) {\n      this._array.push(aStr);\n    }\n    if (!isDuplicate) {\n      this._set[util.toSetString(aStr)] = idx;\n    }\n  };\n\n  /**\n   * Is the given string a member of this set?\n   *\n   * @param String aStr\n   */\n  ArraySet.prototype.has = function ArraySet_has(aStr) {\n    return Object.prototype.hasOwnProperty.call(this._set,\n                                                util.toSetString(aStr));\n  };\n\n  /**\n   * What is the index of the given string in the array?\n   *\n   * @param String aStr\n   */\n  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n    if (this.has(aStr)) {\n      return this._set[util.toSetString(aStr)];\n    }\n    throw new Error('\"' + aStr + '\" is not in the set.');\n  };\n\n  /**\n   * What is the element at the given index?\n   *\n   * @param Number aIdx\n   */\n  ArraySet.prototype.at = function ArraySet_at(aIdx) {\n    if (aIdx >= 0 && aIdx < this._array.length) {\n      return this._array[aIdx];\n    }\n    throw new Error('No element indexed by ' + aIdx);\n  };\n\n  /**\n   * Returns the array representation of this set (which has the proper indices\n   * indicated by indexOf). Note that this is a copy of the internal array used\n   * for storing the members so that no one can mess with internal state.\n   */\n  ArraySet.prototype.toArray = function ArraySet_toArray() {\n    return this._array.slice();\n  };\n\n  exports.ArraySet = ArraySet;\n\n});\n\n},{\"./util\":56,\"amdefine\":1}],48:[function(require,module,exports){\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nif (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n}\ndefine(function (require, exports, module) {\n\n  var base64 = require('./base64');\n\n  // A single base 64 digit can contain 6 bits of data. For the base 64 variable\n  // length quantities we use in the source map spec, the first bit is the sign,\n  // the next four bits are the actual value, and the 6th bit is the\n  // continuation bit. The continuation bit tells us whether there are more\n  // digits in this value following this digit.\n  //\n  //   Continuation\n  //   |    Sign\n  //   |    |\n  //   V    V\n  //   101011\n\n  var VLQ_BASE_SHIFT = 5;\n\n  // binary: 100000\n  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n  // binary: 011111\n  var VLQ_BASE_MASK = VLQ_BASE - 1;\n\n  // binary: 100000\n  var VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n  /**\n   * Converts from a two-complement value to a value where the sign bit is\n   * placed in the least significant bit.  For example, as decimals:\n   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n   */\n  function toVLQSigned(aValue) {\n    return aValue < 0\n      ? ((-aValue) << 1) + 1\n      : (aValue << 1) + 0;\n  }\n\n  /**\n   * Converts to a two-complement value from a value where the sign bit is\n   * placed in the least significant bit.  For example, as decimals:\n   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n   */\n  function fromVLQSigned(aValue) {\n    var isNegative = (aValue & 1) === 1;\n    var shifted = aValue >> 1;\n    return isNegative\n      ? -shifted\n      : shifted;\n  }\n\n  /**\n   * Returns the base 64 VLQ encoded value.\n   */\n  exports.encode = function base64VLQ_encode(aValue) {\n    var encoded = \"\";\n    var digit;\n\n    var vlq = toVLQSigned(aValue);\n\n    do {\n      digit = vlq & VLQ_BASE_MASK;\n      vlq >>>= VLQ_BASE_SHIFT;\n      if (vlq > 0) {\n        // There are still more digits in this value, so we must make sure the\n        // continuation bit is marked.\n        digit |= VLQ_CONTINUATION_BIT;\n      }\n      encoded += base64.encode(digit);\n    } while (vlq > 0);\n\n    return encoded;\n  };\n\n  /**\n   * Decodes the next base 64 VLQ value from the given string and returns the\n   * value and the rest of the string via the out parameter.\n   */\n  exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n    var strLen = aStr.length;\n    var result = 0;\n    var shift = 0;\n    var continuation, digit;\n\n    do {\n      if (aIndex >= strLen) {\n        throw new Error(\"Expected more digits in base 64 VLQ value.\");\n      }\n\n      digit = base64.decode(aStr.charCodeAt(aIndex++));\n      if (digit === -1) {\n        throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n      }\n\n      continuation = !!(digit & VLQ_CONTINUATION_BIT);\n      digit &= VLQ_BASE_MASK;\n      result = result + (digit << shift);\n      shift += VLQ_BASE_SHIFT;\n    } while (continuation);\n\n    aOutParam.value = fromVLQSigned(result);\n    aOutParam.rest = aIndex;\n  };\n\n});\n\n},{\"./base64\":49,\"amdefine\":1}],49:[function(require,module,exports){\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n}\ndefine(function (require, exports, module) {\n\n  var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n  /**\n   * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n   */\n  exports.encode = function (number) {\n    if (0 <= number && number < intToCharMap.length) {\n      return intToCharMap[number];\n    }\n    throw new TypeError(\"Must be between 0 and 63: \" + aNumber);\n  };\n\n  /**\n   * Decode a single base 64 character code digit to an integer. Returns -1 on\n   * failure.\n   */\n  exports.decode = function (charCode) {\n    var bigA = 65;     // 'A'\n    var bigZ = 90;     // 'Z'\n\n    var littleA = 97;  // 'a'\n    var littleZ = 122; // 'z'\n\n    var zero = 48;     // '0'\n    var nine = 57;     // '9'\n\n    var plus = 43;     // '+'\n    var slash = 47;    // '/'\n\n    var littleOffset = 26;\n    var numberOffset = 52;\n\n    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n    if (bigA <= charCode && charCode <= bigZ) {\n      return (charCode - bigA);\n    }\n\n    // 26 - 51: abcdefghijklmnopqrstuvwxyz\n    if (littleA <= charCode && charCode <= littleZ) {\n      return (charCode - littleA + littleOffset);\n    }\n\n    // 52 - 61: 0123456789\n    if (zero <= charCode && charCode <= nine) {\n      return (charCode - zero + numberOffset);\n    }\n\n    // 62: +\n    if (charCode == plus) {\n      return 62;\n    }\n\n    // 63: /\n    if (charCode == slash) {\n      return 63;\n    }\n\n    // Invalid base64 digit.\n    return -1;\n  };\n\n});\n\n},{\"amdefine\":1}],50:[function(require,module,exports){\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n}\ndefine(function (require, exports, module) {\n\n  exports.GREATEST_LOWER_BOUND = 1;\n  exports.LEAST_UPPER_BOUND = 2;\n\n  /**\n   * Recursive implementation of binary search.\n   *\n   * @param aLow Indices here and lower do not contain the needle.\n   * @param aHigh Indices here and higher do not contain the needle.\n   * @param aNeedle The element being searched for.\n   * @param aHaystack The non-empty array being searched.\n   * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   */\n  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n    // This function terminates when one of the following is true:\n    //\n    //   1. We find the exact element we are looking for.\n    //\n    //   2. We did not find the exact element, but we can return the index of\n    //      the next-closest element.\n    //\n    //   3. We did not find the exact element, and there is no next-closest\n    //      element than the one we are searching for, so we return -1.\n    var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n    var cmp = aCompare(aNeedle, aHaystack[mid], true);\n    if (cmp === 0) {\n      // Found the element we are looking for.\n      return mid;\n    }\n    else if (cmp > 0) {\n      // Our needle is greater than aHaystack[mid].\n      if (aHigh - mid > 1) {\n        // The element is in the upper half.\n        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n      }\n\n      // The exact needle element was not found in this haystack. Determine if\n      // we are in termination case (3) or (2) and return the appropriate thing.\n      if (aBias == exports.LEAST_UPPER_BOUND) {\n        return aHigh < aHaystack.length ? aHigh : -1;\n      } else {\n        return mid;\n      }\n    }\n    else {\n      // Our needle is less than aHaystack[mid].\n      if (mid - aLow > 1) {\n        // The element is in the lower half.\n        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n      }\n\n      // we are in termination case (3) or (2) and return the appropriate thing.\n      if (aBias == exports.LEAST_UPPER_BOUND) {\n        return mid;\n      } else {\n        return aLow < 0 ? -1 : aLow;\n      }\n    }\n  }\n\n  /**\n   * This is an implementation of binary search which will always try and return\n   * the index of the closest element if there is no exact hit. This is because\n   * mappings between original and generated line/col pairs are single points,\n   * and there is an implicit region between each of them, so a miss just means\n   * that you aren't on the very start of a region.\n   *\n   * @param aNeedle The element you are looking for.\n   * @param aHaystack The array that is being searched.\n   * @param aCompare A function which takes the needle and an element in the\n   *     array and returns -1, 0, or 1 depending on whether the needle is less\n   *     than, equal to, or greater than the element, respectively.\n   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n   */\n  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n    if (aHaystack.length === 0) {\n      return -1;\n    }\n\n    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                                aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n    if (index < 0) {\n      return -1;\n    }\n\n    // We have found either the exact element, or the next-closest element than\n    // the one we are searching for. However, there may be more than one such\n    // element. Make sure we always return the smallest of these.\n    while (index - 1 >= 0) {\n      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n        break;\n      }\n      --index;\n    }\n\n    return index;\n  };\n\n});\n\n},{\"amdefine\":1}],51:[function(require,module,exports){\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n}\ndefine(function (require, exports, module) {\n\n  var util = require('./util');\n\n  /**\n   * Determine whether mappingB is after mappingA with respect to generated\n   * position.\n   */\n  function generatedPositionAfter(mappingA, mappingB) {\n    // Optimized for most common case\n    var lineA = mappingA.generatedLine;\n    var lineB = mappingB.generatedLine;\n    var columnA = mappingA.generatedColumn;\n    var columnB = mappingB.generatedColumn;\n    return lineB > lineA || lineB == lineA && columnB >= columnA ||\n           util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n  }\n\n  /**\n   * A data structure to provide a sorted view of accumulated mappings in a\n   * performance conscious manner. It trades a neglibable overhead in general\n   * case for a large speedup in case of mappings being added in order.\n   */\n  function MappingList() {\n    this._array = [];\n    this._sorted = true;\n    // Serves as infimum\n    this._last = {generatedLine: -1, generatedColumn: 0};\n  }\n\n  /**\n   * Iterate through internal items. This method takes the same arguments that\n   * `Array.prototype.forEach` takes.\n   *\n   * NOTE: The order of the mappings is NOT guaranteed.\n   */\n  MappingList.prototype.unsortedForEach =\n    function MappingList_forEach(aCallback, aThisArg) {\n      this._array.forEach(aCallback, aThisArg);\n    };\n\n  /**\n   * Add the given source mapping.\n   *\n   * @param Object aMapping\n   */\n  MappingList.prototype.add = function MappingList_add(aMapping) {\n    var mapping;\n    if (generatedPositionAfter(this._last, aMapping)) {\n      this._last = aMapping;\n      this._array.push(aMapping);\n    } else {\n      this._sorted = false;\n      this._array.push(aMapping);\n    }\n  };\n\n  /**\n   * Returns the flat, sorted array of mappings. The mappings are sorted by\n   * generated position.\n   *\n   * WARNING: This method returns internal data without copying, for\n   * performance. The return value must NOT be mutated, and should be treated as\n   * an immutable borrow. If you want to take ownership, you must make your own\n   * copy.\n   */\n  MappingList.prototype.toArray = function MappingList_toArray() {\n    if (!this._sorted) {\n      this._array.sort(util.compareByGeneratedPositionsInflated);\n      this._sorted = true;\n    }\n    return this._array;\n  };\n\n  exports.MappingList = MappingList;\n\n});\n\n},{\"./util\":56,\"amdefine\":1}],52:[function(require,module,exports){\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n}\ndefine(function (require, exports, module) {\n\n  // It turns out that some (most?) JavaScript engines don't self-host\n  // `Array.prototype.sort`. This makes sense because C++ will likely remain\n  // faster than JS when doing raw CPU-intensive sorting. However, when using a\n  // custom comparator function, calling back and forth between the VM's C++ and\n  // JIT'd JS is rather slow *and* loses JIT type information, resulting in\n  // worse generated code for the comparator function than would be optimal. In\n  // fact, when sorting with a comparator, these costs outweigh the benefits of\n  // sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n  // a ~3500ms mean speed-up in `bench/bench.html`.\n\n  /**\n   * Swap the elements indexed by `x` and `y` in the array `ary`.\n   *\n   * @param {Array} ary\n   *        The array.\n   * @param {Number} x\n   *        The index of the first item.\n   * @param {Number} y\n   *        The index of the second item.\n   */\n  function swap(ary, x, y) {\n    var temp = ary[x];\n    ary[x] = ary[y];\n    ary[y] = temp;\n  }\n\n  /**\n   * Returns a random integer within the range `low .. high` inclusive.\n   *\n   * @param {Number} low\n   *        The lower bound on the range.\n   * @param {Number} high\n   *        The upper bound on the range.\n   */\n  function randomIntInRange(low, high) {\n    return Math.round(low + (Math.random() * (high - low)));\n  }\n\n  /**\n   * The Quick Sort algorithm.\n   *\n   * @param {Array} ary\n   *        An array to sort.\n   * @param {function} comparator\n   *        Function to use to compare two items.\n   * @param {Number} p\n   *        Start index of the array\n   * @param {Number} r\n   *        End index of the array\n   */\n  function doQuickSort(ary, comparator, p, r) {\n    // If our lower bound is less than our upper bound, we (1) partition the\n    // array into two pieces and (2) recurse on each half. If it is not, this is\n    // the empty array and our base case.\n\n    if (p < r) {\n      // (1) Partitioning.\n      //\n      // The partitioning chooses a pivot between `p` and `r` and moves all\n      // elements that are less than or equal to the pivot to the before it, and\n      // all the elements that are greater than it after it. The effect is that\n      // once partition is done, the pivot is in the exact place it will be when\n      // the array is put in sorted order, and it will not need to be moved\n      // again. This runs in O(n) time.\n\n      // Always choose a random pivot so that an input array which is reverse\n      // sorted does not cause O(n^2) running time.\n      var pivotIndex = randomIntInRange(p, r);\n      var i = p - 1;\n\n      swap(ary, pivotIndex, r);\n      var pivot = ary[r];\n\n      // Immediately after `j` is incremented in this loop, the following hold\n      // true:\n      //\n      //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n      //\n      //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n      for (var j = p; j < r; j++) {\n        if (comparator(ary[j], pivot) <= 0) {\n          i += 1;\n          swap(ary, i, j);\n        }\n      }\n\n      swap(ary, i + 1, j);\n      var q = i + 1;\n\n      // (2) Recurse on each half.\n\n      doQuickSort(ary, comparator, p, q - 1);\n      doQuickSort(ary, comparator, q + 1, r);\n    }\n  }\n\n  /**\n   * Sort the given array in-place with the given comparator function.\n   *\n   * @param {Array} ary\n   *        An array to sort.\n   * @param {function} comparator\n   *        Function to use to compare two items.\n   */\n  exports.quickSort = function (ary, comparator) {\n    doQuickSort(ary, comparator, 0, ary.length - 1);\n  };\n\n});\n\n},{\"amdefine\":1}],53:[function(require,module,exports){\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n}\ndefine(function (require, exports, module) {\n\n  var util = require('./util');\n  var binarySearch = require('./binary-search');\n  var ArraySet = require('./array-set').ArraySet;\n  var base64VLQ = require('./base64-vlq');\n  var quickSort = require('./quick-sort').quickSort;\n\n  function SourceMapConsumer(aSourceMap) {\n    var sourceMap = aSourceMap;\n    if (typeof aSourceMap === 'string') {\n      sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n    }\n\n    return sourceMap.sections != null\n      ? new IndexedSourceMapConsumer(sourceMap)\n      : new BasicSourceMapConsumer(sourceMap);\n  }\n\n  SourceMapConsumer.fromSourceMap = function(aSourceMap) {\n    return BasicSourceMapConsumer.fromSourceMap(aSourceMap);\n  }\n\n  /**\n   * The version of the source mapping spec that we are consuming.\n   */\n  SourceMapConsumer.prototype._version = 3;\n\n  // `__generatedMappings` and `__originalMappings` are arrays that hold the\n  // parsed mapping coordinates from the source map's \"mappings\" attribute. They\n  // are lazily instantiated, accessed via the `_generatedMappings` and\n  // `_originalMappings` getters respectively, and we only parse the mappings\n  // and create these arrays once queried for a source location. We jump through\n  // these hoops because there can be many thousands of mappings, and parsing\n  // them is expensive, so we only want to do it if we must.\n  //\n  // Each object in the arrays is of the form:\n  //\n  //     {\n  //       generatedLine: The line number in the generated code,\n  //       generatedColumn: The column number in the generated code,\n  //       source: The path to the original source file that generated this\n  //               chunk of code,\n  //       originalLine: The line number in the original source that\n  //                     corresponds to this chunk of generated code,\n  //       originalColumn: The column number in the original source that\n  //                       corresponds to this chunk of generated code,\n  //       name: The name of the original symbol which generated this chunk of\n  //             code.\n  //     }\n  //\n  // All properties except for `generatedLine` and `generatedColumn` can be\n  // `null`.\n  //\n  // `_generatedMappings` is ordered by the generated positions.\n  //\n  // `_originalMappings` is ordered by the original positions.\n\n  SourceMapConsumer.prototype.__generatedMappings = null;\n  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n    get: function () {\n      if (!this.__generatedMappings) {\n        this._parseMappings(this._mappings, this.sourceRoot);\n      }\n\n      return this.__generatedMappings;\n    }\n  });\n\n  SourceMapConsumer.prototype.__originalMappings = null;\n  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n    get: function () {\n      if (!this.__originalMappings) {\n        this._parseMappings(this._mappings, this.sourceRoot);\n      }\n\n      return this.__originalMappings;\n    }\n  });\n\n  SourceMapConsumer.prototype._charIsMappingSeparator =\n    function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n      var c = aStr.charAt(index);\n      return c === \";\" || c === \",\";\n    };\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  SourceMapConsumer.prototype._parseMappings =\n    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n      throw new Error(\"Subclasses must implement _parseMappings\");\n    };\n\n  SourceMapConsumer.GENERATED_ORDER = 1;\n  SourceMapConsumer.ORIGINAL_ORDER = 2;\n\n  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;\n  SourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\n  /**\n   * Iterate over each mapping between an original source/line/column and a\n   * generated line/column in this source map.\n   *\n   * @param Function aCallback\n   *        The function that is called with each mapping.\n   * @param Object aContext\n   *        Optional. If specified, this object will be the value of `this` every\n   *        time that `aCallback` is called.\n   * @param aOrder\n   *        Either `SourceMapConsumer.GENERATED_ORDER` or\n   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n   *        iterate over the mappings sorted by the generated file's line/column\n   *        order or the original's source/line/column order, respectively. Defaults to\n   *        `SourceMapConsumer.GENERATED_ORDER`.\n   */\n  SourceMapConsumer.prototype.eachMapping =\n    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n      var context = aContext || null;\n      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n      var mappings;\n      switch (order) {\n      case SourceMapConsumer.GENERATED_ORDER:\n        mappings = this._generatedMappings;\n        break;\n      case SourceMapConsumer.ORIGINAL_ORDER:\n        mappings = this._originalMappings;\n        break;\n      default:\n        throw new Error(\"Unknown order of iteration.\");\n      }\n\n      var sourceRoot = this.sourceRoot;\n      mappings.map(function (mapping) {\n        var source = mapping.source === null ? null : this._sources.at(mapping.source);\n        if (source != null && sourceRoot != null) {\n          source = util.join(sourceRoot, source);\n        }\n        return {\n          source: source,\n          generatedLine: mapping.generatedLine,\n          generatedColumn: mapping.generatedColumn,\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: mapping.name === null ? null : this._names.at(mapping.name)\n        };\n      }, this).forEach(aCallback, context);\n    };\n\n  /**\n   * Returns all generated line and column information for the original source,\n   * line, and column provided. If no column is provided, returns all mappings\n   * corresponding to a either the line we are searching for or the next\n   * closest line that has any mappings. Otherwise, returns all mappings\n   * corresponding to the given line and either the column we are searching for\n   * or the next closest column that has any offsets.\n   *\n   * The only argument is an object with the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.\n   *   - column: Optional. the column number in the original source.\n   *\n   * and an array of objects is returned, each with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.\n   *   - column: The column number in the generated source, or null.\n   */\n  SourceMapConsumer.prototype.allGeneratedPositionsFor =\n    function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n      var line = util.getArg(aArgs, 'line');\n\n      // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n      // returns the index of the closest mapping less than the needle. By\n      // setting needle.originalColumn to 0, we thus find the last mapping for\n      // the given line, provided such a mapping exists.\n      var needle = {\n        source: util.getArg(aArgs, 'source'),\n        originalLine: line,\n        originalColumn: util.getArg(aArgs, 'column', 0)\n      };\n\n      if (this.sourceRoot != null) {\n        needle.source = util.relative(this.sourceRoot, needle.source);\n      }\n      if (!this._sources.has(needle.source)) {\n        return [];\n      }\n      needle.source = this._sources.indexOf(needle.source);\n\n      var mappings = [];\n\n      var index = this._findMapping(needle,\n                                    this._originalMappings,\n                                    \"originalLine\",\n                                    \"originalColumn\",\n                                    util.compareByOriginalPositions,\n                                    binarySearch.LEAST_UPPER_BOUND);\n      if (index >= 0) {\n        var mapping = this._originalMappings[index];\n\n        if (aArgs.column === undefined) {\n          var originalLine = mapping.originalLine;\n\n          // Iterate until either we run out of mappings, or we run into\n          // a mapping for a different line than the one we found. Since\n          // mappings are sorted, this is guaranteed to find all mappings for\n          // the line we found.\n          while (mapping && mapping.originalLine === originalLine) {\n            mappings.push({\n              line: util.getArg(mapping, 'generatedLine', null),\n              column: util.getArg(mapping, 'generatedColumn', null),\n              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n            });\n\n            mapping = this._originalMappings[++index];\n          }\n        } else {\n          var originalColumn = mapping.originalColumn;\n\n          // Iterate until either we run out of mappings, or we run into\n          // a mapping for a different line than the one we were searching for.\n          // Since mappings are sorted, this is guaranteed to find all mappings for\n          // the line we are searching for.\n          while (mapping &&\n                 mapping.originalLine === line &&\n                 mapping.originalColumn == originalColumn) {\n            mappings.push({\n              line: util.getArg(mapping, 'generatedLine', null),\n              column: util.getArg(mapping, 'generatedColumn', null),\n              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n            });\n\n            mapping = this._originalMappings[++index];\n          }\n        }\n      }\n\n      return mappings;\n    };\n\n  exports.SourceMapConsumer = SourceMapConsumer;\n\n  /**\n   * A BasicSourceMapConsumer instance represents a parsed source map which we can\n   * query for information about the original file positions by giving it a file\n   * position in the generated source.\n   *\n   * The only parameter is the raw source map (either as a JSON string, or\n   * already parsed to an object). According to the spec, source maps have the\n   * following attributes:\n   *\n   *   - version: Which version of the source map spec this map is following.\n   *   - sources: An array of URLs to the original source files.\n   *   - names: An array of identifiers which can be referrenced by individual mappings.\n   *   - sourceRoot: Optional. The URL root from which all sources are relative.\n   *   - sourcesContent: Optional. An array of contents of the original source files.\n   *   - mappings: A string of base64 VLQs which contain the actual mappings.\n   *   - file: Optional. The generated file this source map is associated with.\n   *\n   * Here is an example source map, taken from the source map spec[0]:\n   *\n   *     {\n   *       version : 3,\n   *       file: \"out.js\",\n   *       sourceRoot : \"\",\n   *       sources: [\"foo.js\", \"bar.js\"],\n   *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n   *       mappings: \"AA,AB;;ABCDE;\"\n   *     }\n   *\n   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n   */\n  function BasicSourceMapConsumer(aSourceMap) {\n    var sourceMap = aSourceMap;\n    if (typeof aSourceMap === 'string') {\n      sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n    }\n\n    var version = util.getArg(sourceMap, 'version');\n    var sources = util.getArg(sourceMap, 'sources');\n    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n    // requires the array) to play nice here.\n    var names = util.getArg(sourceMap, 'names', []);\n    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n    var mappings = util.getArg(sourceMap, 'mappings');\n    var file = util.getArg(sourceMap, 'file', null);\n\n    // Once again, Sass deviates from the spec and supplies the version as a\n    // string rather than a number, so we use loose equality checking here.\n    if (version != this._version) {\n      throw new Error('Unsupported version: ' + version);\n    }\n\n    // Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    sources = sources.map(util.normalize);\n\n    // Pass `true` below to allow duplicate names and sources. While source maps\n    // are intended to be compressed and deduplicated, the TypeScript compiler\n    // sometimes generates source maps with duplicates in them. See Github issue\n    // #72 and bugzil.la/889492.\n    this._names = ArraySet.fromArray(names, true);\n    this._sources = ArraySet.fromArray(sources, true);\n\n    this.sourceRoot = sourceRoot;\n    this.sourcesContent = sourcesContent;\n    this._mappings = mappings;\n    this.file = file;\n  }\n\n  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\n  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n  /**\n   * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n   *\n   * @param SourceMapGenerator aSourceMap\n   *        The source map that will be consumed.\n   * @returns BasicSourceMapConsumer\n   */\n  BasicSourceMapConsumer.fromSourceMap =\n    function SourceMapConsumer_fromSourceMap(aSourceMap) {\n      var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n      smc.sourceRoot = aSourceMap._sourceRoot;\n      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n                                                              smc.sourceRoot);\n      smc.file = aSourceMap._file;\n\n      // Because we are modifying the entries (by converting string sources and\n      // names to indices into the sources and names ArraySets), we have to make\n      // a copy of the entry or else bad things happen. Shared mutable state\n      // strikes again! See github issue #191.\n\n      var generatedMappings = aSourceMap._mappings.toArray().slice();\n      var destGeneratedMappings = smc.__generatedMappings = [];\n      var destOriginalMappings = smc.__originalMappings = [];\n\n      for (var i = 0, length = generatedMappings.length; i < length; i++) {\n        var srcMapping = generatedMappings[i];\n        var destMapping = new Mapping;\n        destMapping.generatedLine = srcMapping.generatedLine;\n        destMapping.generatedColumn = srcMapping.generatedColumn;\n\n        if (srcMapping.source) {\n          destMapping.source = sources.indexOf(srcMapping.source);\n          destMapping.originalLine = srcMapping.originalLine;\n          destMapping.originalColumn = srcMapping.originalColumn;\n\n          if (srcMapping.name) {\n            destMapping.name = names.indexOf(srcMapping.name);\n          }\n\n          destOriginalMappings.push(destMapping);\n        }\n\n        destGeneratedMappings.push(destMapping);\n      }\n\n      quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\n      return smc;\n    };\n\n  /**\n   * The version of the source mapping spec that we are consuming.\n   */\n  BasicSourceMapConsumer.prototype._version = 3;\n\n  /**\n   * The list of original sources.\n   */\n  Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n    get: function () {\n      return this._sources.toArray().map(function (s) {\n        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;\n      }, this);\n    }\n  });\n\n  /**\n   * Provide the JIT with a nice shape / hidden class.\n   */\n  function Mapping() {\n    this.generatedLine = 0;\n    this.generatedColumn = 0;\n    this.source = null;\n    this.originalLine = null;\n    this.originalColumn = null;\n    this.name = null;\n  }\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  BasicSourceMapConsumer.prototype._parseMappings =\n    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n      var generatedLine = 1;\n      var previousGeneratedColumn = 0;\n      var previousOriginalLine = 0;\n      var previousOriginalColumn = 0;\n      var previousSource = 0;\n      var previousName = 0;\n      var length = aStr.length;\n      var index = 0;\n      var cachedSegments = {};\n      var temp = {};\n      var originalMappings = [];\n      var generatedMappings = [];\n      var mapping, str, segment, end, value;\n\n      while (index < length) {\n        if (aStr.charAt(index) === ';') {\n          generatedLine++;\n          index++;\n          previousGeneratedColumn = 0;\n        }\n        else if (aStr.charAt(index) === ',') {\n          index++;\n        }\n        else {\n          mapping = new Mapping();\n          mapping.generatedLine = generatedLine;\n\n          // Because each offset is encoded relative to the previous one,\n          // many segments often have the same encoding. We can exploit this\n          // fact by caching the parsed variable length fields of each segment,\n          // allowing us to avoid a second parse if we encounter the same\n          // segment again.\n          for (end = index; end < length; end++) {\n            if (this._charIsMappingSeparator(aStr, end)) {\n              break;\n            }\n          }\n          str = aStr.slice(index, end);\n\n          segment = cachedSegments[str];\n          if (segment) {\n            index += str.length;\n          } else {\n            segment = [];\n            while (index < end) {\n              base64VLQ.decode(aStr, index, temp);\n              value = temp.value;\n              index = temp.rest;\n              segment.push(value);\n            }\n\n            if (segment.length === 2) {\n              throw new Error('Found a source, but no line and column');\n            }\n\n            if (segment.length === 3) {\n              throw new Error('Found a source and line, but no column');\n            }\n\n            cachedSegments[str] = segment;\n          }\n\n          // Generated column.\n          mapping.generatedColumn = previousGeneratedColumn + segment[0];\n          previousGeneratedColumn = mapping.generatedColumn;\n\n          if (segment.length > 1) {\n            // Original source.\n            mapping.source = previousSource + segment[1];\n            previousSource += segment[1];\n\n            // Original line.\n            mapping.originalLine = previousOriginalLine + segment[2];\n            previousOriginalLine = mapping.originalLine;\n            // Lines are stored 0-based\n            mapping.originalLine += 1;\n\n            // Original column.\n            mapping.originalColumn = previousOriginalColumn + segment[3];\n            previousOriginalColumn = mapping.originalColumn;\n\n            if (segment.length > 4) {\n              // Original name.\n              mapping.name = previousName + segment[4];\n              previousName += segment[4];\n            }\n          }\n\n          generatedMappings.push(mapping);\n          if (typeof mapping.originalLine === 'number') {\n            originalMappings.push(mapping);\n          }\n        }\n      }\n\n      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n      this.__generatedMappings = generatedMappings;\n\n      quickSort(originalMappings, util.compareByOriginalPositions);\n      this.__originalMappings = originalMappings;\n    };\n\n  /**\n   * Find the mapping that best matches the hypothetical \"needle\" mapping that\n   * we are searching for in the given \"haystack\" of mappings.\n   */\n  BasicSourceMapConsumer.prototype._findMapping =\n    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n                                           aColumnName, aComparator, aBias) {\n      // To return the position we are searching for, we must first find the\n      // mapping for the given position and then return the opposite position it\n      // points to. Because the mappings are sorted, we can use binary search to\n      // find the best mapping.\n\n      if (aNeedle[aLineName] <= 0) {\n        throw new TypeError('Line must be greater than or equal to 1, got '\n                            + aNeedle[aLineName]);\n      }\n      if (aNeedle[aColumnName] < 0) {\n        throw new TypeError('Column must be greater than or equal to 0, got '\n                            + aNeedle[aColumnName]);\n      }\n\n      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n    };\n\n  /**\n   * Compute the last column for each generated mapping. The last column is\n   * inclusive.\n   */\n  BasicSourceMapConsumer.prototype.computeColumnSpans =\n    function SourceMapConsumer_computeColumnSpans() {\n      for (var index = 0; index < this._generatedMappings.length; ++index) {\n        var mapping = this._generatedMappings[index];\n\n        // Mappings do not contain a field for the last generated columnt. We\n        // can come up with an optimistic estimate, however, by assuming that\n        // mappings are contiguous (i.e. given two consecutive mappings, the\n        // first mapping ends where the second one starts).\n        if (index + 1 < this._generatedMappings.length) {\n          var nextMapping = this._generatedMappings[index + 1];\n\n          if (mapping.generatedLine === nextMapping.generatedLine) {\n            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n            continue;\n          }\n        }\n\n        // The last mapping for each line spans the entire line.\n        mapping.lastGeneratedColumn = Infinity;\n      }\n    };\n\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.\n   *   - column: The column number in the generated source.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.\n   *   - column: The column number in the original source, or null.\n   *   - name: The original identifier, or null.\n   */\n  BasicSourceMapConsumer.prototype.originalPositionFor =\n    function SourceMapConsumer_originalPositionFor(aArgs) {\n      var needle = {\n        generatedLine: util.getArg(aArgs, 'line'),\n        generatedColumn: util.getArg(aArgs, 'column')\n      };\n\n      var index = this._findMapping(\n        needle,\n        this._generatedMappings,\n        \"generatedLine\",\n        \"generatedColumn\",\n        util.compareByGeneratedPositionsDeflated,\n        util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n      );\n\n      if (index >= 0) {\n        var mapping = this._generatedMappings[index];\n\n        if (mapping.generatedLine === needle.generatedLine) {\n          var source = util.getArg(mapping, 'source', null);\n          if (source !== null) {\n            source = this._sources.at(source);\n            if (this.sourceRoot != null) {\n              source = util.join(this.sourceRoot, source);\n            }\n          }\n          var name = util.getArg(mapping, 'name', null);\n          if (name !== null) {\n            name = this._names.at(name);\n          }\n          return {\n            source: source,\n            line: util.getArg(mapping, 'originalLine', null),\n            column: util.getArg(mapping, 'originalColumn', null),\n            name: name\n          };\n        }\n      }\n\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    };\n\n  /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */\n  BasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n    function BasicSourceMapConsumer_hasContentsOfAllSources() {\n      if (!this.sourcesContent) {\n        return false;\n      }\n      return this.sourcesContent.length >= this._sources.size() &&\n        !this.sourcesContent.some(function (sc) { return sc == null; });\n    };\n\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * availible.\n   */\n  BasicSourceMapConsumer.prototype.sourceContentFor =\n    function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n      if (!this.sourcesContent) {\n        return null;\n      }\n\n      if (this.sourceRoot != null) {\n        aSource = util.relative(this.sourceRoot, aSource);\n      }\n\n      if (this._sources.has(aSource)) {\n        return this.sourcesContent[this._sources.indexOf(aSource)];\n      }\n\n      var url;\n      if (this.sourceRoot != null\n          && (url = util.urlParse(this.sourceRoot))) {\n        // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n        // many users. We can help them out when they expect file:// URIs to\n        // behave like it would if they were running a local HTTP server. See\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n        var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");\n        if (url.scheme == \"file\"\n            && this._sources.has(fileUriAbsPath)) {\n          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n        }\n\n        if ((!url.path || url.path == \"/\")\n            && this._sources.has(\"/\" + aSource)) {\n          return this.sourcesContent[this._sources.indexOf(\"/\" + aSource)];\n        }\n      }\n\n      // This function is used recursively from\n      // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n      // don't want to throw if we can't find the source - we just want to\n      // return null, so we provide a flag to exit gracefully.\n      if (nullOnMissing) {\n        return null;\n      }\n      else {\n        throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n      }\n    };\n\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.\n   *   - column: The column number in the original source.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.\n   *   - column: The column number in the generated source, or null.\n   */\n  BasicSourceMapConsumer.prototype.generatedPositionFor =\n    function SourceMapConsumer_generatedPositionFor(aArgs) {\n      var source = util.getArg(aArgs, 'source');\n      if (this.sourceRoot != null) {\n        source = util.relative(this.sourceRoot, source);\n      }\n      if (!this._sources.has(source)) {\n        return {\n          line: null,\n          column: null,\n          lastColumn: null\n        };\n      }\n      source = this._sources.indexOf(source);\n\n      var needle = {\n        source: source,\n        originalLine: util.getArg(aArgs, 'line'),\n        originalColumn: util.getArg(aArgs, 'column')\n      };\n\n      var index = this._findMapping(\n        needle,\n        this._originalMappings,\n        \"originalLine\",\n        \"originalColumn\",\n        util.compareByOriginalPositions,\n        util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n      );\n\n      if (index >= 0) {\n        var mapping = this._originalMappings[index];\n\n        if (mapping.source === needle.source) {\n          return {\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          };\n        }\n      }\n\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    };\n\n  exports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n  /**\n   * An IndexedSourceMapConsumer instance represents a parsed source map which\n   * we can query for information. It differs from BasicSourceMapConsumer in\n   * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n   * input.\n   *\n   * The only parameter is a raw source map (either as a JSON string, or already\n   * parsed to an object). According to the spec for indexed source maps, they\n   * have the following attributes:\n   *\n   *   - version: Which version of the source map spec this map is following.\n   *   - file: Optional. The generated file this source map is associated with.\n   *   - sections: A list of section definitions.\n   *\n   * Each value under the \"sections\" field has two fields:\n   *   - offset: The offset into the original specified at which this section\n   *       begins to apply, defined as an object with a \"line\" and \"column\"\n   *       field.\n   *   - map: A source map definition. This source map could also be indexed,\n   *       but doesn't have to be.\n   *\n   * Instead of the \"map\" field, it's also possible to have a \"url\" field\n   * specifying a URL to retrieve a source map from, but that's currently\n   * unsupported.\n   *\n   * Here's an example source map, taken from the source map spec[0], but\n   * modified to omit a section which uses the \"url\" field.\n   *\n   *  {\n   *    version : 3,\n   *    file: \"app.js\",\n   *    sections: [{\n   *      offset: {line:100, column:10},\n   *      map: {\n   *        version : 3,\n   *        file: \"section.js\",\n   *        sources: [\"foo.js\", \"bar.js\"],\n   *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n   *        mappings: \"AAAA,E;;ABCDE;\"\n   *      }\n   *    }],\n   *  }\n   *\n   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n   */\n  function IndexedSourceMapConsumer(aSourceMap) {\n    var sourceMap = aSourceMap;\n    if (typeof aSourceMap === 'string') {\n      sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n    }\n\n    var version = util.getArg(sourceMap, 'version');\n    var sections = util.getArg(sourceMap, 'sections');\n\n    if (version != this._version) {\n      throw new Error('Unsupported version: ' + version);\n    }\n\n    this._sources = new ArraySet();\n    this._names = new ArraySet();\n\n    var lastOffset = {\n      line: -1,\n      column: 0\n    };\n    this._sections = sections.map(function (s) {\n      if (s.url) {\n        // The url field will require support for asynchronicity.\n        // See https://github.com/mozilla/source-map/issues/16\n        throw new Error('Support for url field in sections not implemented.');\n      }\n      var offset = util.getArg(s, 'offset');\n      var offsetLine = util.getArg(offset, 'line');\n      var offsetColumn = util.getArg(offset, 'column');\n\n      if (offsetLine < lastOffset.line ||\n          (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n        throw new Error('Section offsets must be ordered and non-overlapping.');\n      }\n      lastOffset = offset;\n\n      return {\n        generatedOffset: {\n          // The offset fields are 0-based, but we use 1-based indices when\n          // encoding/decoding from VLQ.\n          generatedLine: offsetLine + 1,\n          generatedColumn: offsetColumn + 1\n        },\n        consumer: new SourceMapConsumer(util.getArg(s, 'map'))\n      }\n    });\n  }\n\n  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\n  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n  /**\n   * The version of the source mapping spec that we are consuming.\n   */\n  IndexedSourceMapConsumer.prototype._version = 3;\n\n  /**\n   * The list of original sources.\n   */\n  Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n    get: function () {\n      var sources = [];\n      for (var i = 0; i < this._sections.length; i++) {\n        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n          sources.push(this._sections[i].consumer.sources[j]);\n        }\n      };\n      return sources;\n    }\n  });\n\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.\n   *   - column: The column number in the generated source.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.\n   *   - column: The column number in the original source, or null.\n   *   - name: The original identifier, or null.\n   */\n  IndexedSourceMapConsumer.prototype.originalPositionFor =\n    function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n      var needle = {\n        generatedLine: util.getArg(aArgs, 'line'),\n        generatedColumn: util.getArg(aArgs, 'column')\n      };\n\n      // Find the section containing the generated position we're trying to map\n      // to an original position.\n      var sectionIndex = binarySearch.search(needle, this._sections,\n        function(needle, section) {\n          var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n          if (cmp) {\n            return cmp;\n          }\n\n          return (needle.generatedColumn -\n                  section.generatedOffset.generatedColumn);\n        });\n      var section = this._sections[sectionIndex];\n\n      if (!section) {\n        return {\n          source: null,\n          line: null,\n          column: null,\n          name: null\n        };\n      }\n\n      return section.consumer.originalPositionFor({\n        line: needle.generatedLine -\n          (section.generatedOffset.generatedLine - 1),\n        column: needle.generatedColumn -\n          (section.generatedOffset.generatedLine === needle.generatedLine\n           ? section.generatedOffset.generatedColumn - 1\n           : 0),\n        bias: aArgs.bias\n      });\n    };\n\n  /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */\n  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n    function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n      return this._sections.every(function (s) {\n        return s.consumer.hasContentsOfAllSources();\n      });\n    };\n\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */\n  IndexedSourceMapConsumer.prototype.sourceContentFor =\n    function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n      for (var i = 0; i < this._sections.length; i++) {\n        var section = this._sections[i];\n\n        var content = section.consumer.sourceContentFor(aSource, true);\n        if (content) {\n          return content;\n        }\n      }\n      if (nullOnMissing) {\n        return null;\n      }\n      else {\n        throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n      }\n    };\n\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.\n   *   - column: The column number in the original source.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.\n   *   - column: The column number in the generated source, or null.\n   */\n  IndexedSourceMapConsumer.prototype.generatedPositionFor =\n    function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n      for (var i = 0; i < this._sections.length; i++) {\n        var section = this._sections[i];\n\n        // Only consider this section if the requested source is in the list of\n        // sources of the consumer.\n        if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {\n          continue;\n        }\n        var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n        if (generatedPosition) {\n          var ret = {\n            line: generatedPosition.line +\n              (section.generatedOffset.generatedLine - 1),\n            column: generatedPosition.column +\n              (section.generatedOffset.generatedLine === generatedPosition.line\n               ? section.generatedOffset.generatedColumn - 1\n               : 0)\n          };\n          return ret;\n        }\n      }\n\n      return {\n        line: null,\n        column: null\n      };\n    };\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  IndexedSourceMapConsumer.prototype._parseMappings =\n    function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n      this.__generatedMappings = [];\n      this.__originalMappings = [];\n      for (var i = 0; i < this._sections.length; i++) {\n        var section = this._sections[i];\n        var sectionMappings = section.consumer._generatedMappings;\n        for (var j = 0; j < sectionMappings.length; j++) {\n          var mapping = sectionMappings[i];\n\n          var source = section.consumer._sources.at(mapping.source);\n          if (section.consumer.sourceRoot !== null) {\n            source = util.join(section.consumer.sourceRoot, source);\n          }\n          this._sources.add(source);\n          source = this._sources.indexOf(source);\n\n          var name = section.consumer._names.at(mapping.name);\n          this._names.add(name);\n          name = this._names.indexOf(name);\n\n          // The mappings coming from the consumer for the section have\n          // generated positions relative to the start of the section, so we\n          // need to offset them to be relative to the start of the concatenated\n          // generated file.\n          var adjustedMapping = {\n            source: source,\n            generatedLine: mapping.generatedLine +\n              (section.generatedOffset.generatedLine - 1),\n            generatedColumn: mapping.column +\n              (section.generatedOffset.generatedLine === mapping.generatedLine)\n              ? section.generatedOffset.generatedColumn - 1\n              : 0,\n            originalLine: mapping.originalLine,\n            originalColumn: mapping.originalColumn,\n            name: name\n          };\n\n          this.__generatedMappings.push(adjustedMapping);\n          if (typeof adjustedMapping.originalLine === 'number') {\n            this.__originalMappings.push(adjustedMapping);\n          }\n        };\n      };\n\n      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n      quickSort(this.__originalMappings, util.compareByOriginalPositions);\n    };\n\n  exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n\n});\n\n},{\"./array-set\":47,\"./base64-vlq\":48,\"./binary-search\":50,\"./quick-sort\":52,\"./util\":56,\"amdefine\":1}],54:[function(require,module,exports){\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n}\ndefine(function (require, exports, module) {\n\n  var base64VLQ = require('./base64-vlq');\n  var util = require('./util');\n  var ArraySet = require('./array-set').ArraySet;\n  var MappingList = require('./mapping-list').MappingList;\n\n  /**\n   * An instance of the SourceMapGenerator represents a source map which is\n   * being built incrementally. You may pass an object with the following\n   * properties:\n   *\n   *   - file: The filename of the generated source.\n   *   - sourceRoot: A root for all relative URLs in this source map.\n   */\n  function SourceMapGenerator(aArgs) {\n    if (!aArgs) {\n      aArgs = {};\n    }\n    this._file = util.getArg(aArgs, 'file', null);\n    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n    this._sources = new ArraySet();\n    this._names = new ArraySet();\n    this._mappings = new MappingList();\n    this._sourcesContents = null;\n  }\n\n  SourceMapGenerator.prototype._version = 3;\n\n  /**\n   * Creates a new SourceMapGenerator based on a SourceMapConsumer\n   *\n   * @param aSourceMapConsumer The SourceMap.\n   */\n  SourceMapGenerator.fromSourceMap =\n    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n      var sourceRoot = aSourceMapConsumer.sourceRoot;\n      var generator = new SourceMapGenerator({\n        file: aSourceMapConsumer.file,\n        sourceRoot: sourceRoot\n      });\n      aSourceMapConsumer.eachMapping(function (mapping) {\n        var newMapping = {\n          generated: {\n            line: mapping.generatedLine,\n            column: mapping.generatedColumn\n          }\n        };\n\n        if (mapping.source != null) {\n          newMapping.source = mapping.source;\n          if (sourceRoot != null) {\n            newMapping.source = util.relative(sourceRoot, newMapping.source);\n          }\n\n          newMapping.original = {\n            line: mapping.originalLine,\n            column: mapping.originalColumn\n          };\n\n          if (mapping.name != null) {\n            newMapping.name = mapping.name;\n          }\n        }\n\n        generator.addMapping(newMapping);\n      });\n      aSourceMapConsumer.sources.forEach(function (sourceFile) {\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content != null) {\n          generator.setSourceContent(sourceFile, content);\n        }\n      });\n      return generator;\n    };\n\n  /**\n   * Add a single mapping from original source line and column to the generated\n   * source's line and column for this source map being created. The mapping\n   * object should have the following properties:\n   *\n   *   - generated: An object with the generated line and column positions.\n   *   - original: An object with the original line and column positions.\n   *   - source: The original source file (relative to the sourceRoot).\n   *   - name: An optional original token name for this mapping.\n   */\n  SourceMapGenerator.prototype.addMapping =\n    function SourceMapGenerator_addMapping(aArgs) {\n      var generated = util.getArg(aArgs, 'generated');\n      var original = util.getArg(aArgs, 'original', null);\n      var source = util.getArg(aArgs, 'source', null);\n      var name = util.getArg(aArgs, 'name', null);\n\n      if (!this._skipValidation) {\n        this._validateMapping(generated, original, source, name);\n      }\n\n      if (source != null && !this._sources.has(source)) {\n        this._sources.add(source);\n      }\n\n      if (name != null && !this._names.has(name)) {\n        this._names.add(name);\n      }\n\n      this._mappings.add({\n        generatedLine: generated.line,\n        generatedColumn: generated.column,\n        originalLine: original != null && original.line,\n        originalColumn: original != null && original.column,\n        source: source,\n        name: name\n      });\n    };\n\n  /**\n   * Set the source content for a source file.\n   */\n  SourceMapGenerator.prototype.setSourceContent =\n    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n      var source = aSourceFile;\n      if (this._sourceRoot != null) {\n        source = util.relative(this._sourceRoot, source);\n      }\n\n      if (aSourceContent != null) {\n        // Add the source content to the _sourcesContents map.\n        // Create a new _sourcesContents map if the property is null.\n        if (!this._sourcesContents) {\n          this._sourcesContents = {};\n        }\n        this._sourcesContents[util.toSetString(source)] = aSourceContent;\n      } else if (this._sourcesContents) {\n        // Remove the source file from the _sourcesContents map.\n        // If the _sourcesContents map is empty, set the property to null.\n        delete this._sourcesContents[util.toSetString(source)];\n        if (Object.keys(this._sourcesContents).length === 0) {\n          this._sourcesContents = null;\n        }\n      }\n    };\n\n  /**\n   * Applies the mappings of a sub-source-map for a specific source file to the\n   * source map being generated. Each mapping to the supplied source file is\n   * rewritten using the supplied source map. Note: The resolution for the\n   * resulting mappings is the minimium of this map and the supplied map.\n   *\n   * @param aSourceMapConsumer The source map to be applied.\n   * @param aSourceFile Optional. The filename of the source file.\n   *        If omitted, SourceMapConsumer's file property will be used.\n   * @param aSourceMapPath Optional. The dirname of the path to the source map\n   *        to be applied. If relative, it is relative to the SourceMapConsumer.\n   *        This parameter is needed when the two source maps aren't in the same\n   *        directory, and the source map to be applied contains relative source\n   *        paths. If so, those relative source paths need to be rewritten\n   *        relative to the SourceMapGenerator.\n   */\n  SourceMapGenerator.prototype.applySourceMap =\n    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n      var sourceFile = aSourceFile;\n      // If aSourceFile is omitted, we will use the file property of the SourceMap\n      if (aSourceFile == null) {\n        if (aSourceMapConsumer.file == null) {\n          throw new Error(\n            'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n            'or the source map\\'s \"file\" property. Both were omitted.'\n          );\n        }\n        sourceFile = aSourceMapConsumer.file;\n      }\n      var sourceRoot = this._sourceRoot;\n      // Make \"sourceFile\" relative if an absolute Url is passed.\n      if (sourceRoot != null) {\n        sourceFile = util.relative(sourceRoot, sourceFile);\n      }\n      // Applying the SourceMap can add and remove items from the sources and\n      // the names array.\n      var newSources = new ArraySet();\n      var newNames = new ArraySet();\n\n      // Find mappings for the \"sourceFile\"\n      this._mappings.unsortedForEach(function (mapping) {\n        if (mapping.source === sourceFile && mapping.originalLine != null) {\n          // Check if it can be mapped by the source map, then update the mapping.\n          var original = aSourceMapConsumer.originalPositionFor({\n            line: mapping.originalLine,\n            column: mapping.originalColumn\n          });\n          if (original.source != null) {\n            // Copy mapping\n            mapping.source = original.source;\n            if (aSourceMapPath != null) {\n              mapping.source = util.join(aSourceMapPath, mapping.source)\n            }\n            if (sourceRoot != null) {\n              mapping.source = util.relative(sourceRoot, mapping.source);\n            }\n            mapping.originalLine = original.line;\n            mapping.originalColumn = original.column;\n            if (original.name != null) {\n              mapping.name = original.name;\n            }\n          }\n        }\n\n        var source = mapping.source;\n        if (source != null && !newSources.has(source)) {\n          newSources.add(source);\n        }\n\n        var name = mapping.name;\n        if (name != null && !newNames.has(name)) {\n          newNames.add(name);\n        }\n\n      }, this);\n      this._sources = newSources;\n      this._names = newNames;\n\n      // Copy sourcesContents of applied map.\n      aSourceMapConsumer.sources.forEach(function (sourceFile) {\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content != null) {\n          if (aSourceMapPath != null) {\n            sourceFile = util.join(aSourceMapPath, sourceFile);\n          }\n          if (sourceRoot != null) {\n            sourceFile = util.relative(sourceRoot, sourceFile);\n          }\n          this.setSourceContent(sourceFile, content);\n        }\n      }, this);\n    };\n\n  /**\n   * A mapping can have one of the three levels of data:\n   *\n   *   1. Just the generated position.\n   *   2. The Generated position, original position, and original source.\n   *   3. Generated and original position, original source, as well as a name\n   *      token.\n   *\n   * To maintain consistency, we validate that any new mapping being added falls\n   * in to one of these categories.\n   */\n  SourceMapGenerator.prototype._validateMapping =\n    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n                                                aName) {\n      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n          && aGenerated.line > 0 && aGenerated.column >= 0\n          && !aOriginal && !aSource && !aName) {\n        // Case 1.\n        return;\n      }\n      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n               && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n               && aGenerated.line > 0 && aGenerated.column >= 0\n               && aOriginal.line > 0 && aOriginal.column >= 0\n               && aSource) {\n        // Cases 2 and 3.\n        return;\n      }\n      else {\n        throw new Error('Invalid mapping: ' + JSON.stringify({\n          generated: aGenerated,\n          source: aSource,\n          original: aOriginal,\n          name: aName\n        }));\n      }\n    };\n\n  /**\n   * Serialize the accumulated mappings in to the stream of base 64 VLQs\n   * specified by the source map format.\n   */\n  SourceMapGenerator.prototype._serializeMappings =\n    function SourceMapGenerator_serializeMappings() {\n      var previousGeneratedColumn = 0;\n      var previousGeneratedLine = 1;\n      var previousOriginalColumn = 0;\n      var previousOriginalLine = 0;\n      var previousName = 0;\n      var previousSource = 0;\n      var result = '';\n      var mapping;\n\n      var mappings = this._mappings.toArray();\n      for (var i = 0, len = mappings.length; i < len; i++) {\n        mapping = mappings[i];\n\n        if (mapping.generatedLine !== previousGeneratedLine) {\n          previousGeneratedColumn = 0;\n          while (mapping.generatedLine !== previousGeneratedLine) {\n            result += ';';\n            previousGeneratedLine++;\n          }\n        }\n        else {\n          if (i > 0) {\n            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n              continue;\n            }\n            result += ',';\n          }\n        }\n\n        result += base64VLQ.encode(mapping.generatedColumn\n                                   - previousGeneratedColumn);\n        previousGeneratedColumn = mapping.generatedColumn;\n\n        if (mapping.source != null) {\n          result += base64VLQ.encode(this._sources.indexOf(mapping.source)\n                                     - previousSource);\n          previousSource = this._sources.indexOf(mapping.source);\n\n          // lines are stored 0-based in SourceMap spec version 3\n          result += base64VLQ.encode(mapping.originalLine - 1\n                                     - previousOriginalLine);\n          previousOriginalLine = mapping.originalLine - 1;\n\n          result += base64VLQ.encode(mapping.originalColumn\n                                     - previousOriginalColumn);\n          previousOriginalColumn = mapping.originalColumn;\n\n          if (mapping.name != null) {\n            result += base64VLQ.encode(this._names.indexOf(mapping.name)\n                                       - previousName);\n            previousName = this._names.indexOf(mapping.name);\n          }\n        }\n      }\n\n      return result;\n    };\n\n  SourceMapGenerator.prototype._generateSourcesContent =\n    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n      return aSources.map(function (source) {\n        if (!this._sourcesContents) {\n          return null;\n        }\n        if (aSourceRoot != null) {\n          source = util.relative(aSourceRoot, source);\n        }\n        var key = util.toSetString(source);\n        return Object.prototype.hasOwnProperty.call(this._sourcesContents,\n                                                    key)\n          ? this._sourcesContents[key]\n          : null;\n      }, this);\n    };\n\n  /**\n   * Externalize the source map.\n   */\n  SourceMapGenerator.prototype.toJSON =\n    function SourceMapGenerator_toJSON() {\n      var map = {\n        version: this._version,\n        sources: this._sources.toArray(),\n        names: this._names.toArray(),\n        mappings: this._serializeMappings()\n      };\n      if (this._file != null) {\n        map.file = this._file;\n      }\n      if (this._sourceRoot != null) {\n        map.sourceRoot = this._sourceRoot;\n      }\n      if (this._sourcesContents) {\n        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n      }\n\n      return map;\n    };\n\n  /**\n   * Render the source map being generated to a string.\n   */\n  SourceMapGenerator.prototype.toString =\n    function SourceMapGenerator_toString() {\n      return JSON.stringify(this.toJSON());\n    };\n\n  exports.SourceMapGenerator = SourceMapGenerator;\n\n});\n\n},{\"./array-set\":47,\"./base64-vlq\":48,\"./mapping-list\":51,\"./util\":56,\"amdefine\":1}],55:[function(require,module,exports){\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n}\ndefine(function (require, exports, module) {\n\n  var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\n  var util = require('./util');\n\n  // Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n  // operating systems these days (capturing the result).\n  var REGEX_NEWLINE = /(\\r?\\n)/;\n\n  // Newline character code for charCodeAt() comparisons\n  var NEWLINE_CODE = 10;\n\n  // Private symbol for identifying `SourceNode`s when multiple versions of\n  // the source-map library are loaded. This MUST NOT CHANGE across\n  // versions!\n  var isSourceNode = \"$$$isSourceNode$$$\";\n\n  /**\n   * SourceNodes provide a way to abstract over interpolating/concatenating\n   * snippets of generated JavaScript source code while maintaining the line and\n   * column information associated with the original source code.\n   *\n   * @param aLine The original line number.\n   * @param aColumn The original column number.\n   * @param aSource The original source's filename.\n   * @param aChunks Optional. An array of strings which are snippets of\n   *        generated JS, or other SourceNodes.\n   * @param aName The original identifier.\n   */\n  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n    this.children = [];\n    this.sourceContents = {};\n    this.line = aLine == null ? null : aLine;\n    this.column = aColumn == null ? null : aColumn;\n    this.source = aSource == null ? null : aSource;\n    this.name = aName == null ? null : aName;\n    this[isSourceNode] = true;\n    if (aChunks != null) this.add(aChunks);\n  }\n\n  /**\n   * Creates a SourceNode from generated code and a SourceMapConsumer.\n   *\n   * @param aGeneratedCode The generated code\n   * @param aSourceMapConsumer The SourceMap for the generated code\n   * @param aRelativePath Optional. The path that relative sources in the\n   *        SourceMapConsumer should be relative to.\n   */\n  SourceNode.fromStringWithSourceMap =\n    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n      // The SourceNode we want to fill with the generated code\n      // and the SourceMap\n      var node = new SourceNode();\n\n      // All even indices of this array are one line of the generated code,\n      // while all odd indices are the newlines between two adjacent lines\n      // (since `REGEX_NEWLINE` captures its match).\n      // Processed fragments are removed from this array, by calling `shiftNextLine`.\n      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n      var shiftNextLine = function() {\n        var lineContents = remainingLines.shift();\n        // The last line of a file might not have a newline.\n        var newLine = remainingLines.shift() || \"\";\n        return lineContents + newLine;\n      };\n\n      // We need to remember the position of \"remainingLines\"\n      var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n      // The generate SourceNodes we need a code range.\n      // To extract it current and last mapping is used.\n      // Here we store the last mapping.\n      var lastMapping = null;\n\n      aSourceMapConsumer.eachMapping(function (mapping) {\n        if (lastMapping !== null) {\n          // We add the code from \"lastMapping\" to \"mapping\":\n          // First check if there is a new line in between.\n          if (lastGeneratedLine < mapping.generatedLine) {\n            var code = \"\";\n            // Associate first line with \"lastMapping\"\n            addMappingWithCode(lastMapping, shiftNextLine());\n            lastGeneratedLine++;\n            lastGeneratedColumn = 0;\n            // The remaining code is added without mapping\n          } else {\n            // There is no new line in between.\n            // Associate the code between \"lastGeneratedColumn\" and\n            // \"mapping.generatedColumn\" with \"lastMapping\"\n            var nextLine = remainingLines[0];\n            var code = nextLine.substr(0, mapping.generatedColumn -\n                                          lastGeneratedColumn);\n            remainingLines[0] = nextLine.substr(mapping.generatedColumn -\n                                                lastGeneratedColumn);\n            lastGeneratedColumn = mapping.generatedColumn;\n            addMappingWithCode(lastMapping, code);\n            // No more remaining code, continue\n            lastMapping = mapping;\n            return;\n          }\n        }\n        // We add the generated code until the first mapping\n        // to the SourceNode without any mapping.\n        // Each line is added as separate string.\n        while (lastGeneratedLine < mapping.generatedLine) {\n          node.add(shiftNextLine());\n          lastGeneratedLine++;\n        }\n        if (lastGeneratedColumn < mapping.generatedColumn) {\n          var nextLine = remainingLines[0];\n          node.add(nextLine.substr(0, mapping.generatedColumn));\n          remainingLines[0] = nextLine.substr(mapping.generatedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n        }\n        lastMapping = mapping;\n      }, this);\n      // We have processed all mappings.\n      if (remainingLines.length > 0) {\n        if (lastMapping) {\n          // Associate the remaining code in the current line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n        }\n        // and add the remaining lines without any mapping\n        node.add(remainingLines.join(\"\"));\n      }\n\n      // Copy sourcesContent into SourceNode\n      aSourceMapConsumer.sources.forEach(function (sourceFile) {\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content != null) {\n          if (aRelativePath != null) {\n            sourceFile = util.join(aRelativePath, sourceFile);\n          }\n          node.setSourceContent(sourceFile, content);\n        }\n      });\n\n      return node;\n\n      function addMappingWithCode(mapping, code) {\n        if (mapping === null || mapping.source === undefined) {\n          node.add(code);\n        } else {\n          var source = aRelativePath\n            ? util.join(aRelativePath, mapping.source)\n            : mapping.source;\n          node.add(new SourceNode(mapping.originalLine,\n                                  mapping.originalColumn,\n                                  source,\n                                  code,\n                                  mapping.name));\n        }\n      }\n    };\n\n  /**\n   * Add a chunk of generated JS to this source node.\n   *\n   * @param aChunk A string snippet of generated JS code, another instance of\n   *        SourceNode, or an array where each member is one of those things.\n   */\n  SourceNode.prototype.add = function SourceNode_add(aChunk) {\n    if (Array.isArray(aChunk)) {\n      aChunk.forEach(function (chunk) {\n        this.add(chunk);\n      }, this);\n    }\n    else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n      if (aChunk) {\n        this.children.push(aChunk);\n      }\n    }\n    else {\n      throw new TypeError(\n        \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n      );\n    }\n    return this;\n  };\n\n  /**\n   * Add a chunk of generated JS to the beginning of this source node.\n   *\n   * @param aChunk A string snippet of generated JS code, another instance of\n   *        SourceNode, or an array where each member is one of those things.\n   */\n  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n    if (Array.isArray(aChunk)) {\n      for (var i = aChunk.length-1; i >= 0; i--) {\n        this.prepend(aChunk[i]);\n      }\n    }\n    else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n      this.children.unshift(aChunk);\n    }\n    else {\n      throw new TypeError(\n        \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n      );\n    }\n    return this;\n  };\n\n  /**\n   * Walk over the tree of JS snippets in this node and its children. The\n   * walking function is called once for each snippet of JS and is passed that\n   * snippet and the its original associated source's line/column location.\n   *\n   * @param aFn The traversal function.\n   */\n  SourceNode.prototype.walk = function SourceNode_walk(aFn) {\n    var chunk;\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      chunk = this.children[i];\n      if (chunk[isSourceNode]) {\n        chunk.walk(aFn);\n      }\n      else {\n        if (chunk !== '') {\n          aFn(chunk, { source: this.source,\n                       line: this.line,\n                       column: this.column,\n                       name: this.name });\n        }\n      }\n    }\n  };\n\n  /**\n   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n   * each of `this.children`.\n   *\n   * @param aSep The separator.\n   */\n  SourceNode.prototype.join = function SourceNode_join(aSep) {\n    var newChildren;\n    var i;\n    var len = this.children.length;\n    if (len > 0) {\n      newChildren = [];\n      for (i = 0; i < len-1; i++) {\n        newChildren.push(this.children[i]);\n        newChildren.push(aSep);\n      }\n      newChildren.push(this.children[i]);\n      this.children = newChildren;\n    }\n    return this;\n  };\n\n  /**\n   * Call String.prototype.replace on the very right-most source snippet. Useful\n   * for trimming whitespace from the end of a source node, etc.\n   *\n   * @param aPattern The pattern to replace.\n   * @param aReplacement The thing to replace the pattern with.\n   */\n  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n    var lastChild = this.children[this.children.length - 1];\n    if (lastChild[isSourceNode]) {\n      lastChild.replaceRight(aPattern, aReplacement);\n    }\n    else if (typeof lastChild === 'string') {\n      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n    }\n    else {\n      this.children.push(''.replace(aPattern, aReplacement));\n    }\n    return this;\n  };\n\n  /**\n   * Set the source content for a source file. This will be added to the SourceMapGenerator\n   * in the sourcesContent field.\n   *\n   * @param aSourceFile The filename of the source file\n   * @param aSourceContent The content of the source file\n   */\n  SourceNode.prototype.setSourceContent =\n    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n    };\n\n  /**\n   * Walk over the tree of SourceNodes. The walking function is called for each\n   * source file content and is passed the filename and source content.\n   *\n   * @param aFn The traversal function.\n   */\n  SourceNode.prototype.walkSourceContents =\n    function SourceNode_walkSourceContents(aFn) {\n      for (var i = 0, len = this.children.length; i < len; i++) {\n        if (this.children[i][isSourceNode]) {\n          this.children[i].walkSourceContents(aFn);\n        }\n      }\n\n      var sources = Object.keys(this.sourceContents);\n      for (var i = 0, len = sources.length; i < len; i++) {\n        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n      }\n    };\n\n  /**\n   * Return the string representation of this source node. Walks over the tree\n   * and concatenates all the various snippets together to one string.\n   */\n  SourceNode.prototype.toString = function SourceNode_toString() {\n    var str = \"\";\n    this.walk(function (chunk) {\n      str += chunk;\n    });\n    return str;\n  };\n\n  /**\n   * Returns the string representation of this source node along with a source\n   * map.\n   */\n  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n    var generated = {\n      code: \"\",\n      line: 1,\n      column: 0\n    };\n    var map = new SourceMapGenerator(aArgs);\n    var sourceMappingActive = false;\n    var lastOriginalSource = null;\n    var lastOriginalLine = null;\n    var lastOriginalColumn = null;\n    var lastOriginalName = null;\n    this.walk(function (chunk, original) {\n      generated.code += chunk;\n      if (original.source !== null\n          && original.line !== null\n          && original.column !== null) {\n        if(lastOriginalSource !== original.source\n           || lastOriginalLine !== original.line\n           || lastOriginalColumn !== original.column\n           || lastOriginalName !== original.name) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n        lastOriginalSource = original.source;\n        lastOriginalLine = original.line;\n        lastOriginalColumn = original.column;\n        lastOriginalName = original.name;\n        sourceMappingActive = true;\n      } else if (sourceMappingActive) {\n        map.addMapping({\n          generated: {\n            line: generated.line,\n            column: generated.column\n          }\n        });\n        lastOriginalSource = null;\n        sourceMappingActive = false;\n      }\n      for (var idx = 0, length = chunk.length; idx < length; idx++) {\n        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n          generated.line++;\n          generated.column = 0;\n          // Mappings end at eol\n          if (idx + 1 === length) {\n            lastOriginalSource = null;\n            sourceMappingActive = false;\n          } else if (sourceMappingActive) {\n            map.addMapping({\n              source: original.source,\n              original: {\n                line: original.line,\n                column: original.column\n              },\n              generated: {\n                line: generated.line,\n                column: generated.column\n              },\n              name: original.name\n            });\n          }\n        } else {\n          generated.column++;\n        }\n      }\n    });\n    this.walkSourceContents(function (sourceFile, sourceContent) {\n      map.setSourceContent(sourceFile, sourceContent);\n    });\n\n    return { code: generated.code, map: map };\n  };\n\n  exports.SourceNode = SourceNode;\n\n});\n\n},{\"./source-map-generator\":54,\"./util\":56,\"amdefine\":1}],56:[function(require,module,exports){\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n}\ndefine(function (require, exports, module) {\n\n  /**\n   * This is a helper function for getting values from parameter/options\n   * objects.\n   *\n   * @param args The object we are extracting values from\n   * @param name The name of the property we are getting.\n   * @param defaultValue An optional value to return if the property is missing\n   * from the object. If this is not specified and the property is missing, an\n   * error will be thrown.\n   */\n  function getArg(aArgs, aName, aDefaultValue) {\n    if (aName in aArgs) {\n      return aArgs[aName];\n    } else if (arguments.length === 3) {\n      return aDefaultValue;\n    } else {\n      throw new Error('\"' + aName + '\" is a required argument.');\n    }\n  }\n  exports.getArg = getArg;\n\n  var urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\n  var dataUrlRegexp = /^data:.+\\,.+$/;\n\n  function urlParse(aUrl) {\n    var match = aUrl.match(urlRegexp);\n    if (!match) {\n      return null;\n    }\n    return {\n      scheme: match[1],\n      auth: match[2],\n      host: match[3],\n      port: match[4],\n      path: match[5]\n    };\n  }\n  exports.urlParse = urlParse;\n\n  function urlGenerate(aParsedUrl) {\n    var url = '';\n    if (aParsedUrl.scheme) {\n      url += aParsedUrl.scheme + ':';\n    }\n    url += '//';\n    if (aParsedUrl.auth) {\n      url += aParsedUrl.auth + '@';\n    }\n    if (aParsedUrl.host) {\n      url += aParsedUrl.host;\n    }\n    if (aParsedUrl.port) {\n      url += \":\" + aParsedUrl.port\n    }\n    if (aParsedUrl.path) {\n      url += aParsedUrl.path;\n    }\n    return url;\n  }\n  exports.urlGenerate = urlGenerate;\n\n  /**\n   * Normalizes a path, or the path portion of a URL:\n   *\n   * - Replaces consequtive slashes with one slash.\n   * - Removes unnecessary '.' parts.\n   * - Removes unnecessary '<dir>/..' parts.\n   *\n   * Based on code in the Node.js 'path' core module.\n   *\n   * @param aPath The path or url to normalize.\n   */\n  function normalize(aPath) {\n    var path = aPath;\n    var url = urlParse(aPath);\n    if (url) {\n      if (!url.path) {\n        return aPath;\n      }\n      path = url.path;\n    }\n    var isAbsolute = (path.charAt(0) === '/');\n\n    var parts = path.split(/\\/+/);\n    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n      part = parts[i];\n      if (part === '.') {\n        parts.splice(i, 1);\n      } else if (part === '..') {\n        up++;\n      } else if (up > 0) {\n        if (part === '') {\n          // The first part is blank if the path is absolute. Trying to go\n          // above the root is a no-op. Therefore we can remove all '..' parts\n          // directly after the root.\n          parts.splice(i + 1, up);\n          up = 0;\n        } else {\n          parts.splice(i, 2);\n          up--;\n        }\n      }\n    }\n    path = parts.join('/');\n\n    if (path === '') {\n      path = isAbsolute ? '/' : '.';\n    }\n\n    if (url) {\n      url.path = path;\n      return urlGenerate(url);\n    }\n    return path;\n  }\n  exports.normalize = normalize;\n\n  /**\n   * Joins two paths/URLs.\n   *\n   * @param aRoot The root path or URL.\n   * @param aPath The path or URL to be joined with the root.\n   *\n   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n   *   first.\n   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n   *   is updated with the result and aRoot is returned. Otherwise the result\n   *   is returned.\n   *   - If aPath is absolute, the result is aPath.\n   *   - Otherwise the two paths are joined with a slash.\n   * - Joining for example 'http://' and 'www.example.com' is also supported.\n   */\n  function join(aRoot, aPath) {\n    if (aRoot === \"\") {\n      aRoot = \".\";\n    }\n    if (aPath === \"\") {\n      aPath = \".\";\n    }\n    var aPathUrl = urlParse(aPath);\n    var aRootUrl = urlParse(aRoot);\n    if (aRootUrl) {\n      aRoot = aRootUrl.path || '/';\n    }\n\n    // `join(foo, '//www.example.org')`\n    if (aPathUrl && !aPathUrl.scheme) {\n      if (aRootUrl) {\n        aPathUrl.scheme = aRootUrl.scheme;\n      }\n      return urlGenerate(aPathUrl);\n    }\n\n    if (aPathUrl || aPath.match(dataUrlRegexp)) {\n      return aPath;\n    }\n\n    // `join('http://', 'www.example.com')`\n    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n      aRootUrl.host = aPath;\n      return urlGenerate(aRootUrl);\n    }\n\n    var joined = aPath.charAt(0) === '/'\n      ? aPath\n      : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n    if (aRootUrl) {\n      aRootUrl.path = joined;\n      return urlGenerate(aRootUrl);\n    }\n    return joined;\n  }\n  exports.join = join;\n\n  /**\n   * Make a path relative to a URL or another path.\n   *\n   * @param aRoot The root path or URL.\n   * @param aPath The path or URL to be made relative to aRoot.\n   */\n  function relative(aRoot, aPath) {\n    if (aRoot === \"\") {\n      aRoot = \".\";\n    }\n\n    aRoot = aRoot.replace(/\\/$/, '');\n\n    // It is possible for the path to be above the root. In this case, simply\n    // checking whether the root is a prefix of the path won't work. Instead, we\n    // need to remove components from the root one by one, until either we find\n    // a prefix that fits, or we run out of components to remove.\n    var level = 0;\n    while (aPath.indexOf(aRoot + '/') !== 0) {\n      var index = aRoot.lastIndexOf(\"/\");\n      if (index < 0) {\n        return aPath;\n      }\n\n      // If the only part of the root that is left is the scheme (i.e. http://,\n      // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n      // have exhausted all components, so the path is not relative to the root.\n      aRoot = aRoot.slice(0, index);\n      if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n        return aPath;\n      }\n\n      ++level;\n    }\n\n    // Make sure we add a \"../\" for each component we removed from the root.\n    return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n  }\n  exports.relative = relative;\n\n  /**\n   * Because behavior goes wacky when you set `__proto__` on objects, we\n   * have to prefix all the strings in our set with an arbitrary character.\n   *\n   * See https://github.com/mozilla/source-map/pull/31 and\n   * https://github.com/mozilla/source-map/issues/30\n   *\n   * @param String aStr\n   */\n  function toSetString(aStr) {\n    return '$' + aStr;\n  }\n  exports.toSetString = toSetString;\n\n  function fromSetString(aStr) {\n    return aStr.substr(1);\n  }\n  exports.fromSetString = fromSetString;\n\n  /**\n   * Comparator between two mappings where the original positions are compared.\n   *\n   * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n   * mappings with the same original source/line/column, but different generated\n   * line and column the same. Useful when searching for a mapping with a\n   * stubbed out mapping.\n   */\n  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n    var cmp = mappingA.source - mappingB.source;\n    if (cmp !== 0) {\n      return cmp;\n    }\n\n    cmp = mappingA.originalLine - mappingB.originalLine;\n    if (cmp !== 0) {\n      return cmp;\n    }\n\n    cmp = mappingA.originalColumn - mappingB.originalColumn;\n    if (cmp !== 0 || onlyCompareOriginal) {\n      return cmp;\n    }\n\n    cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n    if (cmp !== 0) {\n      return cmp;\n    }\n\n    cmp = mappingA.generatedLine - mappingB.generatedLine;\n    if (cmp !== 0) {\n      return cmp;\n    }\n\n    return mappingA.name - mappingB.name;\n  };\n  exports.compareByOriginalPositions = compareByOriginalPositions;\n\n  /**\n   * Comparator between two mappings with deflated source and name indices where\n   * the generated positions are compared.\n   *\n   * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n   * mappings with the same generated line and column, but different\n   * source/name/original line and column the same. Useful when searching for a\n   * mapping with a stubbed out mapping.\n   */\n  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n    var cmp = mappingA.generatedLine - mappingB.generatedLine;\n    if (cmp !== 0) {\n      return cmp;\n    }\n\n    cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n    if (cmp !== 0 || onlyCompareGenerated) {\n      return cmp;\n    }\n\n    cmp = mappingA.source - mappingB.source;\n    if (cmp !== 0) {\n      return cmp;\n    }\n\n    cmp = mappingA.originalLine - mappingB.originalLine;\n    if (cmp !== 0) {\n      return cmp;\n    }\n\n    cmp = mappingA.originalColumn - mappingB.originalColumn;\n    if (cmp !== 0) {\n      return cmp;\n    }\n\n    return mappingA.name - mappingB.name;\n  };\n  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\n  function strcmp(aStr1, aStr2) {\n    if (aStr1 === aStr2) {\n      return 0;\n    }\n\n    if (aStr1 > aStr2) {\n      return 1;\n    }\n\n    return -1;\n  }\n\n  /**\n   * Comparator between two mappings with inflated source and name strings where\n   * the generated positions are compared.\n   */\n  function compareByGeneratedPositionsInflated(mappingA, mappingB) {\n    var cmp = mappingA.generatedLine - mappingB.generatedLine;\n    if (cmp !== 0) {\n      return cmp;\n    }\n\n    cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n    if (cmp !== 0) {\n      return cmp;\n    }\n\n    cmp = strcmp(mappingA.source, mappingB.source);\n    if (cmp !== 0) {\n      return cmp;\n    }\n\n    cmp = mappingA.originalLine - mappingB.originalLine;\n    if (cmp !== 0) {\n      return cmp;\n    }\n\n    cmp = mappingA.originalColumn - mappingB.originalColumn;\n    if (cmp !== 0) {\n      return cmp;\n    }\n\n    return strcmp(mappingA.name, mappingB.name);\n  };\n  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n});\n\n},{\"amdefine\":1}],57:[function(require,module,exports){\n(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ]\n\n    var isDataView = function(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj)\n    }\n\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var list = this.map[name]\n    if (!list) {\n      list = []\n      this.map[name] = list\n    }\n    list.push(value)\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    var values = this.map[normalizeName(name)]\n    return values ? values[0] : null\n  }\n\n  Headers.prototype.getAll = function(name) {\n    return this.map[normalizeName(name)] || []\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = [normalizeValue(value)]\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    Object.getOwnPropertyNames(this.map).forEach(function(name) {\n      this.map[name].forEach(function(value) {\n        callback.call(thisArg, value, name, this)\n      }, this)\n    }, this)\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsArrayBuffer(blob)\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsText(blob)\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf)\n    var chars = new Array(view.length)\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i])\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength)\n      view.set(new Uint8Array(buf))\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (!body) {\n        this._bodyText = ''\n      } else if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer)\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer])\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body)\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      }\n    }\n\n    this.text = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n\n    if (typeof input === 'string') {\n      this.url = input\n    } else {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, { body: this._bodyInit })\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers()\n    rawHeaders.split('\\r\\n').forEach(function(line) {\n      var parts = line.split(':')\n      var key = parts.shift().trim()\n      if (key) {\n        var value = parts.join(':').trim()\n        headers.append(key, value)\n      }\n    })\n    return headers\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = 'status' in options ? options.status : 200\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = 'statusText' in options ? options.statusText : 'OK'\n    this.headers = new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init)\n      var xhr = new XMLHttpRequest()\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        }\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n\n},{}],58:[function(require,module,exports){\n'use strict';\n\n/**\n * A callback function that fires after the left arrow is clicked\n * @callback CarouselArrows~onLeftArrowClick\n */\n\n/**\n * A callback function that fires after the right arrow is clicked\n * @callback CarouselArrows~onRightArrowClick\n */\n\n/**\n * Adds functionality for carousel's left and right arrows.\n * @constructor CarouselArrows\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar CarouselArrows = function () {\n\n    /**\n     * When the carousel is instantiated.\n     * @param {object} options - Options passed into instance\n     * @param {HTMLElement} options.leftArrow - The html element to use as the left arrow\n     * @param {HTMLElement} options.rightArrow - The html element to use as the right arrow\n     * @param {HTMLCollection} options.panels - The carousel panel elements that to be associated with the arrows\n     * @param {string} [options.arrowDisabledClass] - The CSS class that gets added to an arrow when it becomes disabled\n     * @param {CarouselArrows~onLeftArrowClick} [options.onLeftArrowClick] - When the left arrow is clicked\n     * @param {CarouselArrows~onRightArrowClick} [options.onRightArrowClick] - When the right arrow is clicked\n     */\n    function CarouselArrows(options) {\n        var _this = this;\n\n        _classCallCheck(this, CarouselArrows);\n\n        options = _extends({\n            leftArrow: null,\n            rightArrow: null,\n            panels: [],\n            arrowDisabledClass: 'carousel-arrow-disabled',\n            onLeftArrowClick: null,\n            onRightArrowClick: null,\n            initialIndex: 0\n        }, options);\n\n        if (!options.leftArrow && !options.rightArrow) {\n            console.error('Carousel Arrows Error: no left and right arrows were passed into constructor');\n        }\n\n        this.options = options;\n\n        this.arrows = [];\n\n        // setup listeners\n        if (options.leftArrow) {\n            this.arrows.push(options.leftArrow);\n            this._leftArrowEventListener = function (e) {\n                return _this.onLeftArrowClick(e);\n            };\n            options.leftArrow.addEventListener('click', this._leftArrowEventListener);\n        }\n\n        if (options.rightArrow) {\n            this.arrows.push(options.rightArrow);\n            this._rightArrowEventListener = function (e) {\n                return _this.onRightArrowClick(e);\n            };\n            options.rightArrow.addEventListener('click', this._rightArrowEventListener);\n        }\n    }\n\n    /**\n     * Updates the arrow based on the supplied panel index.\n     * @param {Number} panelIndex - The new panel index\n     */\n\n\n    _createClass(CarouselArrows, [{\n        key: 'update',\n        value: function update(panelIndex) {\n            var currentItemNum = panelIndex + 1,\n                maxItems = this.options.panels.length,\n                minItems = 1;\n\n            if (currentItemNum < maxItems && currentItemNum > minItems) {\n                // not on first or last item\n                this.enable();\n            } else if (currentItemNum === maxItems && currentItemNum === minItems) {\n                // on the only panel available\n                this.disable();\n            } else if (currentItemNum === maxItems) {\n                // on last item\n                this.disableRightArrow();\n                this.enableLeftArrow();\n            } else if (currentItemNum === minItems) {\n                // on first item\n                this.disableLeftArrow();\n                this.enableRightArrow();\n            }\n        }\n\n        /**\n         * Disables all arrows\n         */\n\n    }, {\n        key: 'disable',\n        value: function disable() {\n            this.disableLeftArrow();\n            this.disableRightArrow();\n        }\n\n        /**\n         * Disables left arrow.\n         */\n\n    }, {\n        key: 'disableLeftArrow',\n        value: function disableLeftArrow() {\n            if (this.options.leftArrow) {\n                this.options.leftArrow.classList.add(this.options.arrowDisabledClass);\n            }\n        }\n\n        /**\n         * Disables right arrow.\n         */\n\n    }, {\n        key: 'disableRightArrow',\n        value: function disableRightArrow() {\n            if (this.options.rightArrow) {\n                this.options.rightArrow.classList.add(this.options.arrowDisabledClass);\n            }\n        }\n\n        /**\n         * Re-enables all arrows.\n         */\n\n    }, {\n        key: 'enable',\n        value: function enable() {\n            this.enableLeftArrow();\n            this.enableRightArrow();\n        }\n\n        /**\n         * Re-enables left arrow.\n         */\n\n    }, {\n        key: 'enableLeftArrow',\n        value: function enableLeftArrow() {\n            if (this.options.leftArrow) {\n                this.options.leftArrow.classList.remove(this.options.arrowDisabledClass);\n            }\n        }\n\n        /**\n         * Re-enables right arrow.\n         */\n\n    }, {\n        key: 'enableRightArrow',\n        value: function enableRightArrow() {\n            if (this.options.rightArrow) {\n                this.options.rightArrow.classList.remove(this.options.arrowDisabledClass);\n            }\n        }\n\n        /**\n         * When the left arrow is clicked.\n         * @param {Event} e\n         */\n\n    }, {\n        key: 'onLeftArrowClick',\n        value: function onLeftArrowClick(e) {\n            var isDisabled = this.options.leftArrow.classList.contains(this.options.arrowDisabledClass);\n            if (this.options.onLeftArrowClick && !isDisabled) {\n                this.options.onLeftArrowClick(e);\n            }\n        }\n\n        /**\n         * When the right arrow is clicked.\n         * @param {Event} e\n         */\n\n    }, {\n        key: 'onRightArrowClick',\n        value: function onRightArrowClick(e) {\n            var isDisabled = this.options.rightArrow.classList.contains(this.options.arrowDisabledClass);\n            if (this.options.onRightArrowClick && !isDisabled) {\n                this.options.onRightArrowClick(e);\n            }\n        }\n\n        /**\n         * Final cleanup of instance.\n         * @memberOf CarouselArrows\n         */\n\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            if (this.options.leftArrow) {\n                this.options.leftArrow.removeEventListener('click', this._leftArrowEventListener);\n            }\n\n            if (this.options.rightArrow) {\n                this.options.rightArrow.removeEventListener('click', this._rightArrowEventListener);\n            }\n        }\n    }]);\n\n    return CarouselArrows;\n}();\n\nexports.default = CarouselArrows;\n\nmodule.exports = exports['default'];\n\n},{}],59:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _promise = require('promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _moduleJs = require('module-js');\n\nvar _moduleJs2 = _interopRequireDefault(_moduleJs);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar CarouselPanel = function (_Module) {\n    _inherits(CarouselPanel, _Module);\n\n    /**\n     * Sets some stuff up.\n     * @param {HTMLElement} el - The element that represents a panel.\n     * @param {Object} options - The options\n     * @param {String} [options.activeClass] - The css class that gets applied when the module is showing\n     * @param {String} [options.assetLoadedClass] - The css class that gets added when the asset has been loaded\n     * @param {String} [options.lazyLoadAttr] - The lazy loading attribute of the panel element containing the src to load\n     */\n    function CarouselPanel(el, options) {\n        _classCallCheck(this, CarouselPanel);\n\n        options = _extends({\n            activeClass: 'carousel-panel-active',\n            lazyLoadAttr: null,\n            loadedClass: 'carousel-panel-loaded',\n            assetLoadedClass: 'carousel-panel-asset-loaded'\n        }, options);\n\n        var _this = _possibleConstructorReturn(this, (CarouselPanel.__proto__ || Object.getPrototypeOf(CarouselPanel)).call(this, el, options));\n\n        _this.options = options;\n        _this.el = el;\n        return _this;\n    }\n\n    /**\n     * Loads all lazy-loadable images within the panel.\n     * @returns {Promise}\n     */\n\n\n    _createClass(CarouselPanel, [{\n        key: 'load',\n        value: function load() {\n            var _this2 = this;\n\n            var loadPromises = [];\n            this._loadableImages().forEach(function (imgEl) {\n                var loadedClass = _this2.options.assetLoadedClass;\n                var promise = _this2._loadImage(imgEl).then(function () {\n                    _this2.el.classList.add(loadedClass);\n                });\n                loadPromises.push(promise);\n            });\n\n            return _get(CarouselPanel.prototype.__proto__ || Object.getPrototypeOf(CarouselPanel.prototype), 'load', this).call(this).then(function () {\n                return _promise2.default.all(loadPromises);\n            });\n        }\n\n        /**\n         * Gets the live set of loadable image elements within the panel (or the panel itself if it is an <img>).\n         * @returns {Array}\n         * @private\n         */\n\n    }, {\n        key: '_loadableImages',\n        value: function _loadableImages() {\n            // if panel has lazy load attribute,  add to loadable assets\n            if (this.el.tagName.toLowerCase() === 'img' && this.el.getAttribute(this.options.lazyLoadAttr)) {\n                return [this.el];\n            } else {\n                return Array.prototype.slice.call(this.el.querySelectorAll('img[' + this.options.lazyLoadAttr + ']'));\n            }\n        }\n\n        /**\n         * Manually lazy loads a resource using an element's data attribute.\n         * @param {HTMLImageElement} img - The image element to load\n         * @private\n         */\n\n    }, {\n        key: '_loadImage',\n        value: function _loadImage(img) {\n            var src = img.getAttribute(this.options.lazyLoadAttr);\n            return new _promise2.default(function (resolve) {\n                img.onload = function () {\n                    resolve(img);\n                };\n                img.onerror = function () {\n                    // IE 9-11 have an issue where it automatically triggers an error on some images,\n                    // and then will immediately trigger onload() causing intermittent errors to appear\n                    // until this is fixed or we have a workaround, we will be resolving\n                    // even if there is an error\n                    resolve(img);\n                };\n                img.src = src;\n            });\n        }\n    }]);\n\n    return CarouselPanel;\n}(_moduleJs2.default);\n\nexports.default = CarouselPanel;\n\nmodule.exports = exports['default'];\n\n},{\"module-js\":37,\"promise\":38}],60:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _promise = require('promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _carouselPanel = require('./carousel-panel');\n\nvar _carouselPanel2 = _interopRequireDefault(_carouselPanel);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * A callback function that fires after a new active panel is set\n * @callback CarouselPanels~onChange\n * @param {Number} index - The index of the new panel\n */\n\n/**\n * Adds functionality for carousel panels. Not really meant to be used own its own, unless you want\n * to customize the the javascript logic for the \"panels\" of the Carousel (assuming that you actually\n * know what you're doing when you do so).\n * @constructor CarouselPanels\n */\nvar CarouselPanels = function () {\n\n    /**\n     * When the carousel is instantiated.\n     * @param {object} options - Options passed into instance\n     * @param {HTMLCollection|NodeList} options.panels - The panels in which to use for the carousel (an array of photos)\n     * @param {string} [options.assetLoadedClass] - The CSS class that gets added to a panel el when it is loaded\n     * @param {string} [options.panelActiveClass] - The CSS class that gets added to an panel when it becomes active\n     * @param {string} [options.panelBackClass] - The CSS class that gets added to all panel elements that appear before the current panel\n     * @param {string} [options.panelForwardClass] - The CSS class that gets added to all panel elements that appear ahead of the current panel\n     * @param {CarouselPanels~onChange} [options.onChange] - When the current panel is changed\n     * @param {string} [options.lazyLoadAttr] - The lazy loading attribute\n     */\n    function CarouselPanels(options) {\n        _classCallCheck(this, CarouselPanels);\n\n        options = _extends({\n            panels: [],\n            assetLoadedClass: 'carousel-asset-loaded',\n            panelActiveClass: 'carousel-panel-active',\n            panelLoadedClass: 'carousel-panel-loaded',\n            onChange: null,\n            lazyLoadAttr: 'data-src',\n            panelBackClass: 'carousel-panel-behind',\n            panelForwardClass: 'carousel-panel-ahead'\n        }, options);\n\n        if (!options.panels.length) {\n            console.error('carousel error: no panels were passed in constructor');\n        } else {\n            this._panelModules = this._setupPanelModules(options);\n        }\n\n        // add forward classes initially\n        this._panelModules.forEach(function (panel) {\n            panel.el.classList.add(options.panelForwardClass);\n        });\n\n        this.options = options;\n    }\n\n    /**\n     * Sets up the panel module instances.\n     * @param {Object} options - The initialization options\n     * @returns {Array} Returns an array of the panel instances\n     * @private\n     */\n\n\n    _createClass(CarouselPanels, [{\n        key: '_setupPanelModules',\n        value: function _setupPanelModules(options) {\n            var modules = [];\n            // panels can be either an array or an HTMLCollection so we\n            // are doing an old-school for loop to satisify both scenarios\n            for (var i = 0; i < options.panels.length; i++) {\n                modules[i] = new _carouselPanel2.default(options.panels[i], {\n                    activeClass: options.panelActiveClass,\n                    lazyLoadAttr: options.lazyLoadAttr,\n                    assetLoadedClass: options.assetLoadedClass,\n                    loadedClass: options.panelLoadedClass\n                });\n            }\n            return modules;\n        }\n\n        /**\n         * Transitions to a panel of an index.\n         * @param {Number} index - The index number to go to\n         * @returns {Promise}\n         */\n\n    }, {\n        key: 'goTo',\n        value: function goTo(index) {\n            var maxIndex = this.options.panels.length - 1,\n                minIndex = 0,\n                prevIndex = this.getCurrentIndex(),\n                errorMsg,\n                promise;\n\n            if (typeof index !== 'number' || index > maxIndex || index < minIndex) {\n                errorMsg = 'carousel panel error: unable to transition to an index of ' + index + 'which does not exist!';\n                console.error(errorMsg);\n                promise = _promise2.default.reject(new Error(errorMsg));\n            } else if (prevIndex === index) {\n                // already at index\n                promise = _promise2.default.resolve();\n            } else {\n                promise = this.load(index);\n                this._updatePanels(index);\n                this._currentIndex = index;\n                if (this.options.onChange) {\n                    this.options.onChange(index);\n                }\n            }\n            return promise;\n        }\n\n        /**\n         * Makes all panels inactive except for the one at the index provided.\n         * @param {Number} toIndex - The new index\n         * @private\n         */\n\n    }, {\n        key: '_updatePanels',\n        value: function _updatePanels(toIndex) {\n            var fromIndex = this.getCurrentIndex();\n            var fromPanel = this._panelModules[fromIndex];\n            var toPanel = this._panelModules[toIndex];\n            var rangePanels = [];\n            var toAdd = '';\n            var toRemove = '';\n\n            if (fromIndex > toIndex) {\n                // include fromIndex but not toIndex\n                rangePanels = this._panelModules.slice(toIndex + 1, fromIndex + 1);\n                toAdd = this.options.panelForwardClass;\n                toRemove = this.options.panelBackClass;\n            } else if (fromIndex < toIndex) {\n                rangePanels = this._panelModules.slice(fromIndex, toIndex);\n                toAdd = this.options.panelBackClass;\n                toRemove = this.options.panelForwardClass;\n            }\n\n            rangePanels.forEach(function (p) {\n                p.el.classList.add(toAdd);\n                p.el.classList.remove(toRemove);\n            });\n\n            if (fromPanel) {\n                fromPanel.hide();\n            }\n            toPanel.el.classList.remove(this.options.panelForwardClass, this.options.panelBackClass);\n            toPanel.show();\n        }\n\n        /**\n         * Gets the current index that is showing.\n         * @returns {Number} Returns the index\n         */\n\n    }, {\n        key: 'getCurrentIndex',\n        value: function getCurrentIndex() {\n            return this._currentIndex;\n        }\n\n        /**\n         * Loads assets for a given panel.\n         * @param {Number} idx - The index of the panel containing the assets to load\n         * @returns {Promise}\n         */\n\n    }, {\n        key: 'load',\n        value: function load(idx) {\n            var panelModule = this._panelModules[idx];\n            if (panelModule.loaded) {\n                return _promise2.default.resolve();\n            }\n            return panelModule.load();\n        }\n\n        /**\n         * Loads assets for a given panel.\n         * @deprecated since 2.1.6\n         * @param {Number} index - The index of the panel containing the assets to load\n         * @returns {Promise}\n         */\n\n    }, {\n        key: 'loadPanelAssets',\n        value: function loadPanelAssets(index) {\n            return this.load(index);\n        }\n\n        /**\n         * Final cleanup of instance.\n         */\n\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            var options = this.options,\n                currentIndex = this.getCurrentIndex();\n\n            if (currentIndex) {\n                options.panels[currentIndex].classList.remove(options.panelActiveClass);\n            }\n            this._currentIndex = undefined;\n\n            this._panelModules.forEach(function (module) {\n                module.el.classList.remove(options.panelForwardClass, options.panelBackClass);\n                module.destroy();\n            });\n        }\n    }]);\n\n    return CarouselPanels;\n}();\n\nexports.default = CarouselPanels;\n\nmodule.exports = exports['default'];\n\n},{\"./carousel-panel\":59,\"promise\":38}],61:[function(require,module,exports){\n'use strict';\n\n/**\n * A callback function that fires after a new active panel is set\n * @callback CarouselThumbs~onChange\n * @param {Number} index - The index of the new panel\n */\n\n/**\n * Adds thumbnails for carousel. Not really meant to be used own its own, unless you\n * want to customize the javascript logic for the \"thumbnails\" of your Carousel instance (assuming that you actually\n * know what you're doing when you do so).\n * @class CarouselThumbs\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar CarouselThumbs = function () {\n\n    /**\n     * When carousel is instantiated.\n     * @param {object} options - Options passed into instance\n     * @param {HTMLCollection} [options.thumbnails] - A collection of elements that are the thumbnails\n     * @param {string} [options.thumbnailActiveClass] - The CSS class that gets added to a thumbnail element when it becomes active\n     * @param {CarouselThumbs~onChange} [options.onChange] - When a new thumbnail becomes active\n     * @memberOf CarouselThumbs\n     */\n    function CarouselThumbs(options) {\n        _classCallCheck(this, CarouselThumbs);\n\n        options = _extends({\n            thumbnails: [],\n            thumbnailActiveTriggerEvent: 'click',\n            thumbnailActiveClass: 'carousel-thumbnail-active',\n            onChange: null\n        }, options);\n\n        this.options = options;\n        this._thumbnailEventListener = this.onThumbnailEvent.bind(this);\n        this.setup();\n    }\n\n    /**\n     * Sets up the carousel instance by adding event listeners to the thumbnails.\n     * @memberOf CarouselThumbs\n     */\n\n\n    _createClass(CarouselThumbs, [{\n        key: 'setup',\n        value: function setup() {\n            var thumbs = this.options.thumbnails;\n            if (thumbs.length) {\n                this.triggerThumbsEventListener('addEventListener');\n            } else {\n                console.error('carousel thumb error: no thumbnails were passed to constructor');\n            }\n        }\n\n        /**\n         * When a thumbnail is clicked.\n         * @param {MouseEvent} e - The click event\n         * @memberOf CarouselThumbs\n         */\n\n    }, {\n        key: 'onThumbnailEvent',\n        value: function onThumbnailEvent(e) {\n            if (!this._thumbnailArr) {\n                // convert thumbnail HTMLCollection to real array so we can perform necessary array methods\n                this._thumbnailArr = Array.prototype.slice.call(this.options.thumbnails);\n            }\n            var index = this._thumbnailArr.indexOf(e.currentTarget);\n            // we are checking that the selected thumbnail is still in the HTMLCollection\n            // because it is live introducing the possibility that the element is no longer in the DOM\n            if (index !== -1 && index !== this.getCurrentIndex()) {\n                this.goTo(index);\n                if (this.options.onChange) {\n                    this.options.onChange(index);\n                }\n            }\n        }\n\n        /**\n         * Checks for errors upon initialize.\n         * @memberOf CarouselThumbs\n         * @private\n         */\n\n    }, {\n        key: '_checkForInitErrors',\n        value: function _checkForInitErrors() {\n            var options = this.options,\n                thumbnailCount = options.thumbnails.length;\n            if (!thumbnailCount) {\n                console.error('carousel error: no thumbnails were passed in constructor');\n            }\n        }\n\n        /**\n         * Makes all thumbnails inactive except for the one at the index provided.\n         * @param {Number} index - The new index\n         * @memberOf CarouselThumbs\n         */\n\n    }, {\n        key: 'goTo',\n        value: function goTo(index) {\n            var thumbs = this.options.thumbnails,\n                prevIndex = this.getCurrentIndex() || 0,\n                activeClass = this.options.thumbnailActiveClass,\n                maxIndex = thumbs.length - 1,\n                minIndex = 0;\n\n            if (index > maxIndex || index < minIndex) {\n                console.error('carousel thumbnail error: unable to transition to a thumbnail with an index of ' + index + ', it does not exist!');\n            }\n\n            thumbs[index].classList.add(activeClass);\n\n            if (prevIndex !== index) {\n                thumbs[prevIndex].classList.remove(activeClass);\n            }\n            this._currentIndex = index;\n        }\n\n        /**\n         * Gets the current thumbnail index that is showing.\n         * @returns {Number} Returns the index\n         * @memberOf CarouselThumbs\n         */\n\n    }, {\n        key: 'getCurrentIndex',\n        value: function getCurrentIndex() {\n            return this._currentIndex;\n        }\n\n        /**\n         * Triggers an event listener method on all thumbnail elements.\n         * @param {string} method - The event listener method to call on each of the elements\n         */\n\n    }, {\n        key: 'triggerThumbsEventListener',\n        value: function triggerThumbsEventListener(method) {\n            var count = this.options.thumbnails.length,\n                i,\n                el;\n            for (i = 0; i < count; i++) {\n                el = this.options.thumbnails[i];\n                el[method](this.options.thumbnailActiveTriggerEvent, this._thumbnailEventListener);\n            }\n        }\n\n        /**\n         * Destroys the instance.\n         * @memberOf CarouselThumbs\n         */\n\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            var thumbs = this.options.thumbnails;\n            this._currentIndex = null;\n            if (thumbs.length) {\n                this.triggerThumbsEventListener('removeEventListener');\n            }\n        }\n    }]);\n\n    return CarouselThumbs;\n}();\n\nexports.default = CarouselThumbs;\n\nmodule.exports = exports['default'];\n\n},{}],62:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _carouselThumbs = require('./carousel-thumbs');\n\nvar _carouselThumbs2 = _interopRequireDefault(_carouselThumbs);\n\nvar _carouselPanels = require('./carousel-panels');\n\nvar _carouselPanels2 = _interopRequireDefault(_carouselPanels);\n\nvar _carouselArrows = require('./carousel-arrows');\n\nvar _carouselArrows2 = _interopRequireDefault(_carouselArrows);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * A callback function that fires after a new active panel is set\n * @callback Carousel~onPanelChange\n * @param {Number} index - The index of the new panel\n */\n\n/**\n * Adds carousel functionality to a set up pre-determined HTML markup.\n * @class Carousel\n * @param {object} options - Options passed into instance\n * @param {HTMLCollection} options.panels - The panels in which to use for the carousel (an array of photos)\n * @param {string} [options.assetLoadingClass] - The CSS class that gets added to an asset when it is loading\n * @param {boolean} [options.autoLoadAssets] - Whether or not to automatically load assets when active\n * @param {string} [options.panelActiveClass] - The CSS class that gets added to an panel when it becomes active\n * @param {string} [options.panelLoadedClass] - The CSS class that gets added to an panel when it is fully loaded\n * @param {string} [options.panelBackClass] - The CSS class that gets added to all panel elements that appear before the current panel\n * @param {string} [options.panelForwardClass] - The CSS class that gets added to all panel elements that appear ahead of the current panel\n * @param {Carousel~onPanelChange} [options.onPanelChange] - When the current panel is changed\n * @param {string} [options.lazyLoadAttr] - The attribute containing the url path to content that is to be lazy loaded\n * @param {HTMLCollection} [options.thumbnails] - A collection of elements that are the thumbnails\n * @param {string} [options.thumbnailActiveClass] - The CSS class that gets added to a thumbnail element when it becomes active\n * @param {Number} [options.initialIndex] - The index of the panel to go to upon instantiation (if not declared, goTo() must be called manually).\n */\n\nvar Carousel = function () {\n\n    /**\n     * Sets up stuff.\n     * @param options\n     */\n    function Carousel(options) {\n        _classCallCheck(this, Carousel);\n\n        options = options || {};\n\n        // if undefined or null is passed in options for panels or thumbnails,\n        // we need to sanitize it to an empty array to prevent a crash\n        if (!options.panels) {\n            options.panels = [];\n        }\n        if (!options.thumbnails) {\n            options.thumbnails = [];\n        }\n\n        options = _extends({\n            panels: [],\n            assetLoadingClass: 'carousel-asset-loading',\n            autoLoadAssets: true,\n            panelActiveClass: 'carousel-panel-active',\n            panelLoadedClass: 'carousel-panel-loaded',\n            panelBackClass: 'carousel-panel-behind',\n            panelForwardClass: 'carousel-panel-ahead',\n            onPanelChange: null,\n            lazyLoadAttr: 'data-src',\n            thumbnails: [],\n            thumbnailActiveTriggerEvent: 'click',\n            thumbnailActiveClass: 'carousel-thumbnail-active',\n            initialIndex: 0,\n            leftArrow: null,\n            rightArrow: null,\n            arrowActiveClass: 'carousel-arrow-active',\n            arrowDisabledClass: 'carousel-arrow-disabled',\n            onLeftArrowClick: null,\n            onRightArrowClick: null\n        }, options);\n\n        this.options = options;\n        this.subModules = {};\n        this._checkForInitErrors();\n        this.setup();\n    }\n\n    /**\n     * Sets up the carousel instance and all controls.\n     */\n\n\n    _createClass(Carousel, [{\n        key: 'setup',\n        value: function setup() {\n\n            if (!this.subModules.panels) {\n                this.subModules.panels = this._setupPanels(this.options);\n            }\n\n            if (this.options.thumbnails.length && !this.subModules.thumbnails) {\n                this.subModules.thumbnails = this._setupThumbs(this.options);\n            }\n\n            if ((this.options.leftArrow || this.options.rightArrow) && !this.subModules.arrows) {\n                this.subModules.arrows = this._setupArrows(this.options);\n            }\n\n            if (typeof this.options.initialIndex === 'number') {\n                this.goTo(this.options.initialIndex);\n            }\n        }\n\n        /**\n         * Sets up the carousel thumbs.\n         * @param {Object} options - The initialize options\n         * @return {CarouselThumbs} Returns thumbnail instance\n         * @private\n         */\n\n    }, {\n        key: '_setupThumbs',\n        value: function _setupThumbs(options) {\n            return new _carouselThumbs2.default(_extends({}, options, {\n                onChange: this.onThumbnailChange.bind(this)\n            }));\n        }\n\n        /**\n         * Sets up the carousel panels.\n         * @param {Object} options - The initialize options\n         * @return {CarouselPanels} Returns panels instance\n         * @private\n         */\n\n    }, {\n        key: '_setupPanels',\n        value: function _setupPanels(options) {\n            if (options.panels.length) {\n                return new _carouselPanels2.default(_extends({}, options, {\n                    onChange: this.onPanelChange.bind(this)\n                }));\n            }\n        }\n\n        /**\n         * Sets up the carousel arrows.\n         * @param {Object} options - The initialize options\n         * @return {CarouselArrows} Returns arrows instance\n         * @private\n         */\n\n    }, {\n        key: '_setupArrows',\n        value: function _setupArrows(options) {\n            var internalOptions;\n            // make clone of original options\n            internalOptions = _extends({}, options);\n\n            internalOptions.onLeftArrowClick = this.onLeftArrowClick.bind(this);\n            internalOptions.onRightArrowClick = this.onRightArrowClick.bind(this);\n            return new _carouselArrows2.default(internalOptions);\n        }\n\n        /**\n         * Checks for errors upon initialize.\n         * @private\n         */\n\n    }, {\n        key: '_checkForInitErrors',\n        value: function _checkForInitErrors() {\n            var options = this.options,\n                panelCount = options.panels.length,\n                thumbnailCount = options.thumbnails.length;\n            if (thumbnailCount && thumbnailCount !== panelCount) {\n                console.warn('carousel warning: number of thumbnails passed in constructor do not equal the number of panels' + '\\n' + 'panels: ' + panelCount + '\\n' + 'thumbnails: ' + thumbnailCount + '\\n');\n            }\n        }\n\n        /**\n         * When a panel index changes.\n         * @param {Number} index - The new index\n         */\n\n    }, {\n        key: 'onPanelChange',\n        value: function onPanelChange(index) {\n            if (this.subModules.thumbnails) {\n                this.subModules.thumbnails.goTo(index);\n            }\n\n            if (this.subModules.arrows) {\n                this.subModules.arrows.update(index);\n            }\n\n            if (this.options.onPanelChange) {\n                this.options.onPanelChange(index);\n            }\n        }\n\n        /**\n         * When the thumbnail index changes.\n         * @param {Number} index - The new index\n         */\n\n    }, {\n        key: 'onThumbnailChange',\n        value: function onThumbnailChange(index) {\n            this.goTo(index);\n        }\n\n        /**\n         * When the right arrow of the carousel is clicked.\n         * @param e\n         */\n\n    }, {\n        key: 'onRightArrowClick',\n        value: function onRightArrowClick(e) {\n            this.goTo(this.subModules.panels.getCurrentIndex() + 1);\n            if (this.options.onRightArrowClick) {\n                this.options.onRightArrowClick(e);\n            }\n        }\n\n        /**\n         * When the left arrow of the carousel is clicked.\n         * @param e\n         */\n\n    }, {\n        key: 'onLeftArrowClick',\n        value: function onLeftArrowClick(e) {\n            this.goTo(this.subModules.panels.getCurrentIndex() - 1);\n            if (this.options.onLeftArrowClick) {\n                this.options.onLeftArrowClick(e);\n            }\n        }\n\n        /**\n         * Transition to a new panel and thumbnail.\n         * @param {Number} index - The index number to go to\n         */\n\n    }, {\n        key: 'goTo',\n        value: function goTo(index) {\n            var options = this.options,\n                maxIndex = options.panels.length - 1,\n                minIndex = 0;\n\n            if (index > maxIndex) {\n                // set to first index if too high\n                index = minIndex;\n            } else if (index < minIndex) {\n                // set to last index if too low\n                index = maxIndex;\n            }\n\n            if (this.subModules.thumbnails) {\n                this.subModules.thumbnails.goTo(index);\n            }\n            if (this.subModules.arrows) {\n                this.subModules.arrows.update(index);\n            }\n\n            if (this.subModules.panels) {\n                return this.subModules.panels.goTo(index);\n            }\n        }\n\n        /**\n         * Gets the current index that is showing.\n         * @returns {Number} Returns the index\n         */\n\n    }, {\n        key: 'getCurrentIndex',\n        value: function getCurrentIndex() {\n            return this.subModules.panels.getCurrentIndex();\n        }\n\n        /**\n         * Moves carousel to next panel.\n         */\n\n    }, {\n        key: 'next',\n        value: function next() {\n            this.goTo(this.getCurrentIndex() + 1);\n        }\n\n        /**\n         * Moves to previous carousel panel.\n         */\n\n    }, {\n        key: 'prev',\n        value: function prev() {\n            this.goTo(this.getCurrentIndex() - 1);\n        }\n\n        /**\n         * Destroys all sub modules.\n         */\n\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            for (var key in this.subModules) {\n                if (this.subModules.hasOwnProperty(key) && this.subModules[key]) {\n                    this.subModules[key].destroy();\n                }\n            }\n        }\n    }]);\n\n    return Carousel;\n}();\n\nexports.default = Carousel;\n\nmodule.exports = exports['default'];\n\n},{\"./carousel-arrows\":58,\"./carousel-panels\":60,\"./carousel-thumbs\":61}],63:[function(require,module,exports){\n\n},{}],64:[function(require,module,exports){\n(function (process){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n}).call(this,require('_process'))\n},{\"_process\":65}],65:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}]},{},[62])(62)\n});","/* global\n    hide\n    toggle\n */\n'use strict';\n\n(function() {\n  /**\n   * Render the FAQ questions from a file located at /faq.js.\n   */\n  window.renderFAQ = () => {\n    /**\n     * Destination of all FAQ items\n     * @type {Element}\n     */\n    const _destination = document.getElementsByClassName('faq-placeholder')[0];\n\n    /**\n     * Template for each wrapper section, including an image.\n     * @type {Element}\n     */\n    const _section = document.getElementsByClassName('template faq-section')[0];\n    bootstrapTemplate(_section);\n\n    /**\n     * Template for each wrapper subsection, including an image.\n     * @type {Element}\n     */\n    const _subsection =\n      document.getElementsByClassName('template faq-subsection')[0];\n    bootstrapTemplate(_subsection);\n\n    /**\n     * Template for each question.\n     * @type {[type]}\n     */\n    const _question = document\n      .getElementsByClassName('template faq-question')[0];\n    bootstrapTemplate(_question);\n\n    for (let sectionTitle in window.faq) {\n      // Since we're working with a global obj, let's make sure we're not\n      // screwed by accidental prototyping.\n      if (!window.faq.hasOwnProperty(sectionTitle)) {\n        continue;\n      }\n\n      /** @type {object} Shortcut  */\n      const section = window.faq[sectionTitle];\n\n      /** @type {Element} The new section where we're putting the FAQ elements */\n      const _thisSection = _section.cloneNode(true);\n\n      // Fill in template data\n      _thisSection.querySelectorAll('h1')[0].innerHTML = sectionTitle;\n      _thisSection.querySelectorAll('img')[0].src = section.image;\n\n      const _thisDestination = _thisSection.querySelectorAll('.faq-content')[0];\n\n      for (let subsectionTitle in section.questions) {\n        if (!section.questions.hasOwnProperty(subsectionTitle)) {\n          continue;\n        }\n\n        /** @type {object,string} The set of either subsections or questions */\n        const subsection = section.questions[subsectionTitle];\n\n        if (typeof subsection === 'string') {\n          // we have a question\n          addQuestion(subsectionTitle, subsection, _thisDestination);\n        } else {\n          // we have a subsection\n          const _thisSubsection = _subsection.cloneNode(true);\n\n          _thisSubsection.querySelectorAll('h2')[0].innerHTML = subsectionTitle;\n\n          for (let question in subsection) {\n            if (!subsection.hasOwnProperty(question)) {\n              continue;\n            }\n\n            addQuestion(question, subsection[question], _thisSubsection);\n          }\n\n          _thisDestination.appendChild(_thisSubsection);\n        }\n      }\n      // Finally, append to the DOM.\n      _destination.appendChild(_thisSection);\n    }\n\n    /**\n     * Bootstrap a template by removing it from the dom and removing the template class.\n     *\n     * @param {Element} domNode The domNode to bootstrap into a template\n     */\n    function bootstrapTemplate(domNode) {\n      // Remove from DOM\n      domNode.parentNode.removeChild(domNode);\n\n      // Remove the template class\n      domNode.className = domNode.className.replace('template', '');\n    }\n\n    /**\n     * Add a question using the global question template to an Element, appendTo.\n     * @param {string} question question\n     * @param {string} answer answer\n     * @param {Element} appendTo Element to append the question to\n     */\n    function addQuestion(question, answer, appendTo) {\n      const _thisQuestion = _question.cloneNode(true);\n\n      _thisQuestion.querySelectorAll('h3')[0].innerHTML = question;\n      _thisQuestion.querySelectorAll('p')[0].innerHTML = answer;\n\n      appendTo.appendChild(_thisQuestion);\n    }\n  };\n\n  /**\n   * Bind click events and hide elements from the FAQ\n   */\n  window.bindFAQ = () => {\n    const select = '.faq-content';\n\n    const allElements = document.querySelectorAll(select);\n    hide(allElements);\n\n    allElements.forEach((e) => {\n      e.style.cursor = 'auto';\n\n      // Prevent the click listener on the parent from affecting this (i.e. re-hiding this element)\n      e.addEventListener('click', function(event) {\n        event.stopPropagation();\n      });\n    });\n\n    const sections = document.querySelectorAll('.faq-section');\n    sections.forEach((e) => {\n      e.style.cursor = 'pointer';\n\n      e.addEventListener('click', function() {\n        this.querySelectorAll(select).forEach(toggle);\n      });\n    });\n  };\n})();\n","/* global\n    Carousel\n */\n'use strict';\n\n(function() {\n  /**\n   * Render the carousel.\n   */\n  window.renderCarousel = () => {\n    new Carousel({\n      panels: document.getElementsByClassName('carousel-panel'),\n      leftArrow: document.getElementsByClassName('carousel-left')[0],\n      rightArrow: document.getElementsByClassName('carousel-right')[0],\n    });\n\n    // setInterval(() => {\n    //   carousel.next();\n    // }, 5000);\n  };\n})();\n","'use strict';\n\n(function() {\n  const MESSAGE_URL = 'http://www.crisistextline.org/trends/data/messages.txt';\n  const messageDiv = document.getElementById('message-count');\n\n  let currentVal = parseInt(messageDiv.innerHTML.replace(/,/g, ''), 10);\n\n  window.getMessageCount = () => {\n    const xhr = new XMLHttpRequest();\n\n    xhr.addEventListener('load', () => {\n      if (xhr.status === 200) {\n        incrementValue(xhr.responseText);\n      } else {\n        fail();\n      }\n    });\n\n    xhr.addEventListener('error', () => {\n      fail();\n    });\n\n    xhr.open('GET', MESSAGE_URL);\n    xhr.send();\n  };\n\n  /**\n   * Failure handler for a failed XHR request. Let's just populate with a sane,\n   * true-enough value.\n   */\n  function fail() {\n    incrementValue('27212575');\n  }\n\n  /**\n   * Increment the current value by the difference from current to desired / 2.\n   *\n   * @param  {integer} intVal Value we're shooting for\n   */\n  function incrementValue(intVal) {\n    intVal = parseInt(intVal, 10);\n\n    const difference = intVal - currentVal;\n\n    currentVal += Math.ceil(difference / 2);\n\n    updateDisplay();\n\n    if (currentVal !== intVal) {\n      setTimeout(() => {\n        incrementValue(intVal);\n      }, 125 - Math.log(difference) * 5);\n    }\n  }\n\n  /**\n   * Update the display to currentValue, formatted in 1,231,131,232 format\n   */\n  function updateDisplay() {\n    // format the string with commas every 3 places\n    messageDiv.innerHTML = currentVal\n      .toString()\n      .replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');\n  }\n})();\n","(function() {\n  const DASHBOARD_URL = 'http://public.tableausoftware.com/views/crisistrends2dec132016/WorkingDashMobile?:embed=y&:showVizHome=no&:host_url=https%3A%2F%2Fpublic.tableausoftware.com%2F&:tabs=no&:toolbar=top&:animate_transition=yes&:display_static_image=no&:display_spinner=yes&:display_overlay=yes&:display_count=yes&:loadOrderID=0';\n\n  let loaded = false;\n\n  window.addEventListener('scroll', loadDashboard);\n  window.addEventListener('resize-complete', reflowDashboard);\n\n  adjustHeight();\n\n  /**\n   * Load the dashboard if it hasn't been loaded yet.\n   *\n   * @param {boolean} reload true if we want to force reloading the dashboard\n   */\n  function loadDashboard(reload) {\n    if (!loaded || reload === true) {\n      document.getElementById('viz').src = DASHBOARD_URL;\n      loaded = true;\n    }\n  }\n\n  /**\n   * Reload the dashboard in response to screen size change.\n   */\n  function reflowDashboard() {\n    loadDashboard(true);\n    adjustHeight();\n  }\n\n  /**\n   * Adjust the height of the data viz.\n   */\n  function adjustHeight() {\n    const viz = document.getElementById('viz');\n\n    if (viz.offsetWidth <= 500) {\n      viz.height = 1950;\n    } else {\n      viz.height = 2600;\n    }\n  }\n})();\n","/* global d3 */\n\n(function() {\n  const wordCloudDiv = document.getElementById('wordcloud');\n  const quoteDiv = document.getElementById('wordcloud-quote');\n  const CLOUD_HEIGHT = 500;\n  const svg = d3.select(wordCloudDiv).append('svg');\n\n  let quotes;\n  let cloudWidth;\n  let cloudHeight = CLOUD_HEIGHT;\n  let vis;\n  let lastWords;\n\n  window.bootstrapWordCloud = () => {\n    getQuotes();\n    initializeD3();\n\n    window.addEventListener('resize-complete', setSVGWidth);\n  };\n\n  function getQuotes() {\n    const xhr = new XMLHttpRequest();\n\n    xhr.addEventListener('load', () => {\n      if (xhr.status === 200) {\n        quotes = JSON.parse(xhr.responseText);\n      }\n    });\n\n    xhr.open('GET', 'data/quotes.json');\n    xhr.send();\n  }\n\n  function initializeD3() {\n    svg.attr('height', cloudHeight);\n    setSVGWidth();\n    wordCloudDiv.style.display = 'none';\n  }\n\n  function setSVGWidth(skipRedraw) {\n    cloudWidth = wordCloudDiv.offsetWidth;\n    svg.attr('width', cloudWidth);\n\n    if (skipRedraw !== true) {\n      doViz();\n    }\n  }\n\n  function doViz(words) {\n    if (words === undefined) {\n      if (lastWords === undefined) {\n        return;\n      }\n\n      words = lastWords;\n    } else {\n      lastWords = words;\n    }\n\n    svg.selectAll('g').remove();\n\n    vis = svg\n      .append('g')\n      .attr('transform', 'translate(' +\n        [cloudWidth >> 1, cloudHeight >> 1] +\n        ')');\n\n    let max = 0;\n    let min = 1000000;\n\n    for (let i in words) {\n      if (words[i].c > max) {\n        max = words[i].c;\n      }\n\n      if (words[i].c < min) {\n        min = words[i].c;\n      }\n    }\n\n    const maxscale = d3.scale.linear().range([50, 120]).domain([10, 960])(cloudWidth);\n    const sizeScale = d3.scale.linear().range([12, maxscale]).domain([min, max]);\n\n    d3.layout.cloud()\n      .size([cloudWidth, cloudHeight])\n      .words(words)\n      .rotate(function() {\n        return 0;\n      })\n      .font('Impact')\n      .fontSize(function(d) {\n        return sizeScale(d.c);\n      })\n      .text(function(d) {\n        return d.w;\n      })\n      .on('end', draw)\n      .start();\n  }\n\n  function draw(words, bounds) {\n    const scale = bounds ? Math.min(\n      cloudWidth / Math.abs(bounds[1].x - cloudWidth / 2),\n      cloudWidth / Math.abs(bounds[0].x - cloudWidth / 2),\n      cloudHeight / Math.abs(bounds[1].y - cloudHeight / 2),\n      cloudHeight / Math.abs(bounds[0].y - cloudHeight / 2)) / 2 : 1;\n\n    vis\n      .selectAll('text')\n      .data(words)\n      .enter().append('text')\n        .attr('text-anchor', 'middle')\n        .style('font-size', function(d) {\n          return d.size + 'px';\n        })\n        .style('font-family', 'Impact')\n        .style('fill', function() {\n          return 'rgba(0,0,0,' + (Math.random() * 0.50 + 0.25) + ')';\n        })\n        .attr('text-anchor', 'middle')\n        .attr('transform', function(d) {\n          return 'translate(' + [d.x, d.y] + ')rotate(' + d.rotate + ')';\n        })\n        .text(function(d) {\n          return d.w;\n        })\n    ;\n\n    vis.attr('transform', 'translate(' + [cloudWidth >> 1, cloudHeight >> 1] + ')scale(' + scale + ')');\n  }\n\n  document.getElementById('wordcloud-select').addEventListener('change', function() {\n    const issue = this.value;\n\n    wordCloudDiv.style.display = 'block';\n    setSVGWidth(true);\n\n    d3.json('data/words/' + issue + '.json', function(error, json) {\n      if (error) {\n        return console.warn(error);\n      }\n\n      if (quotes !== undefined) {\n        quoteDiv.innerHTML = '<p>' + quotes[issue] + '</p>';\n      }\n\n      doViz(json);\n    });\n  });\n})();\n","/* global\n    getMessageCount\n    renderFAQ\n    bindFAQ\n    bootstrapWordCloud\n    toggle\n    hide\n */\n'use strict';\n\n(function() {\n  polyfill();\n  attachHamburger();\n  getMessageCount();\n  renderCarousel();\n  renderFAQ();\n  bindFAQ();\n  bootstrapWordCloud();\n  scrollToTop();\n\n  let resizeTimer;\n  let w = window.outerWidth;\n  window.addEventListener('resize', function(e) {\n    clearTimeout(resizeTimer);\n\n    resizeTimer = setTimeout(() => {\n      if (window.outerWidth === w) {\n        return;\n      }\n\n      w = window.outerWidth;\n      const newEvent = new Event('resize-complete');\n      newEvent.originalEvent = e;\n      window.dispatchEvent(newEvent);\n    }, 500);\n  });\n\n  /**\n   * Attach the hamburger click binders.\n   */\n  function attachHamburger() {\n    document.querySelectorAll('.hamburger')[0].addEventListener('click', () => {\n      toggle(document.querySelectorAll('.hamburger-menu'));\n    });\n\n    document.querySelectorAll('.hamburger-menu a').forEach(function(element) {\n      element.addEventListener('click', function() {\n        hide(document.querySelectorAll('.hamburger-menu'));\n      });\n    });\n  }\n\n  /**\n   * Custom polyfills that aren't included in es5-shim.\n   */\n  function polyfill() {\n    if (NodeList.prototype.forEach === undefined) {\n      NodeList.prototype.forEach = Array.prototype.forEach;\n    }\n  }\n\n  /**\n   * Attach click binder to make #top scroll ALL THE WAY to the top\n   */\n  function scrollToTop() {\n    document.querySelectorAll('a[href=\"#top\"]').forEach(function(element) {\n      element.addEventListener('click', (event) => {\n        window.scrollTo(0, 0);\n        event.preventDefault();\n      });\n    });\n  }\n})();\n"]}